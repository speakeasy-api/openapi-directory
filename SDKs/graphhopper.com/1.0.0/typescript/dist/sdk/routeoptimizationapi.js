"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouteOptimizationAPI = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var shared = __importStar(require("./models/shared"));
/**
 *
 * @remarks
 * ## Quickstart
 *
 * The Route Optimization API can be used to solve [traveling salesman](https://en.wikipedia.org/wiki/Travelling_salesman_problem) or [vehicle routing problems](https://en.wikipedia.org/wiki/Vehicle_routing_problem).
 * Solve your first problem by following these steps. If you already have a GraphHopper account, start with step 2.
 *
 * 1. [Sign up for GraphHopper](https://support.graphhopper.com/a/solutions/articles/44001976025)
 * 2. [Create an API key](https://support.graphhopper.com/a/solutions/articles/44001976027)
 * 3. Download [simple traveling salesman problem](https://gist.github.com/oblonski/fb2f2be534c3ebe7bebaa72151194182) and save it in a local folder
 * 4. Open your command line, go to that local folder and use cURL ([What is cURL?](https://de.wikipedia.org/wiki/CURL)) as follows:
 *
 *    ```
 *    curl -X POST -H "Content-Type: application/json"   "https://graphhopper.com/api/1/vrp?key=YOUR_CREATED_API_KEY" --data "@tsp.json"
 *    ```
 *
 * Alternatively, you can use our Editor to explore that API:
 *
 * 1. Login to your GraphHopper account
 * 2. Go to **Editor**
 * 3. Click the **Optimize** button to solve your first problem
 * 4. Analyze the solution on the **Map** or as raw **JSON Output**
 *
 * If you have successfully solved the first problem, we recommend this tutorial - [Getting Started with the Optimization API](https://www.graphhopper.com/blog/2019/05/17/getting-started-with-the-optimization-api-traveling-salesman-problem/).
 * It shows and describes the essential elements to model your vehicle routing problem.
 *
 * To explore the full specification, we recommend that you either use our [route editor](https://www.graphhopper.com/blog/2015/07/21/graphhoppers-new-route-optimization-editor/),
 * which you can find in our [dashboard](https://graphhopper.com/dashboard/),
 * or use a REST client such as Insomnia or Postman, as described [here](https://docs.graphhopper.com/#section/Explore-our-APIs/Insomnia).
 *
 * ## Tutorials
 *
 * We provide [a number of tutorials](https://www.graphhopper.com/tutorial/) illustrating how to use the Route Optimization API and
 * how to model your vehicle routing problems:
 *
 * - [Getting Start with the Optimization API - Traveling Salesman Problem](https://www.graphhopper.com/blog/2019/05/17/getting-started-with-the-optimization-api-traveling-salesman-problem/)
 * - [How to solve a traveling salesman problem with a week-planning horizon?](https://www.graphhopper.com/blog/2020/07/15/how-to-solve-a-traveling-salesman-problem-with-a-week-planning-horizon-and-driver-shifts/)
 * - [How to schedule technicians with skills and multiple dependencies between tasks?](https://www.graphhopper.com/blog/2016/06/03/how-to-route-technicians-with-skills-and-multiple-dependencies-between-tasks/)
 * - [What is the difference between the min. of completion time and min. transport time?](https://www.graphhopper.com/blog/2016/06/20/what-is-the-difference-between-the-minimization-of-completion-time-and-minimizing-transport-time/)
 * - [How to model multiple delivery routes with a single vehicle?](https://www.graphhopper.com/blog/2016/07/21/how-to-model-multiple-delivery-routes-with-a-single-vehicle/)
 *
 */
var RouteOptimizationAPI = /** @class */ (function () {
    function RouteOptimizationAPI(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * POST route optimization problem (batch mode)
     *
     * @remarks
     *
     * To solve a vehicle routing problem, perform the following steps:
     *
     * 1.) Make a HTTP POST to this URL
     *
     * ```
     * https://graphhopper.com/api/1/vrp/optimize?key=<your_key>
     * ```
     *
     * It returns a job id (job_id).
     *
     * 2.) Take the job id and fetch the solution for the vehicle routing problem from this URL:
     *
     * ```
     * https://graphhopper.com/api/1/vrp/solution/<job_id>?key=<your_key>
     * ```
     *
     * We recommend to query the solution every 500ms until it returns 'status=finished'.
     *
     * **Note**: Since the workflow is a bit more cumbersome and since you lose some time in fetching the solution, you should always prefer
     * the [synchronous endpoint](#operation/solveVRP). You should use the batch mode only for long running problems.
     *
     */
    RouteOptimizationAPI.prototype.asyncVRP = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.Request(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/vrp/optimize";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.AsyncVRPResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.jobId = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.JobId);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.badRequest = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BadRequest);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 500:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.internalErrorMessage = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InternalErrorMessage);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * GET the solution (batch mode)
     *
     * @remarks
     *
     * Take the job id and fetch the solution for the vehicle routing problem from this URL:
     *
     * ```
     * https://graphhopper.com/api/1/vrp/solution/<job_id>?key=<your_key>
     * ```
     *
     * You get the job id by sending a vehicle routing problem to the [batch mode URL](#operation/asyncVRP).
     *
     */
    RouteOptimizationAPI.prototype.getSolution = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetSolutionRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/vrp/solution/{jobId}", req);
        var client = this._securityClient || this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GetSolutionResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.response = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Response);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.badRequest = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BadRequest);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 404:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.getSolution404ApplicationJSONObject = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, operations.GetSolution404ApplicationJSON);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 500:
                    break;
            }
            return res;
        });
    };
    /**
     * POST route optimization problem
     *
     * @remarks
     *
     * To get started with the Route Optimization API, please read the [introduction](#tag/Route-Optimization-API).
     *
     * To solve a new vehicle routing problem, make a HTTP POST to this URL
     *
     * ```
     * https://graphhopper.com/api/1/vrp?key=<your_key>
     * ```
     *
     * It returns the solution to this problem in the JSON response.
     *
     * Please note that this URL is very well suited to solve minor problems.
     * Larger vehicle routing problems, which take longer than 10 seconds to solve, cannot be solved.
     * To solve them, please use the [batch mode URL](#operation/asyncVRP) instead.
     *
     */
    RouteOptimizationAPI.prototype.solveVRP = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new shared.Request(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/vrp";
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "request", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.SolveVRPResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.response = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.Response);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 400:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.badRequest = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.BadRequest);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 500:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.internalErrorMessage = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.InternalErrorMessage);
                    }
                    break;
            }
            return res;
        });
    };
    return RouteOptimizationAPI;
}());
exports.RouteOptimizationAPI = RouteOptimizationAPI;
