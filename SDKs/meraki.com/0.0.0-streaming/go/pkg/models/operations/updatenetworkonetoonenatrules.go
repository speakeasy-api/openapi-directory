// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum - Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
type UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum string

const (
	UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumAny      UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "any"
	UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumIcmpPing UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "icmp-ping"
	UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumTCP      UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "tcp"
	UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnumUDP      UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum = "udp"
)

func (e UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum) ToPointer() *UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum {
	return &e
}

func (e *UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "any":
		fallthrough
	case "icmp-ping":
		fallthrough
	case "tcp":
		fallthrough
	case "udp":
		*e = UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum: %v", v)
	}
}

type UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInbound struct {
	// An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
	AllowedIps []string `json:"allowedIps,omitempty"`
	// An array of ports or port ranges that will be forwarded to the host on the LAN
	DestinationPorts []string `json:"destinationPorts,omitempty"`
	// Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
	Protocol *UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInboundProtocolEnum `json:"protocol,omitempty"`
}

// UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum - The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
type UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum string

const (
	UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnumInternet1 UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum = "internet1"
	UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnumInternet2 UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum = "internet2"
)

func (e UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum) ToPointer() *UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum {
	return &e
}

func (e *UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "internet1":
		fallthrough
	case "internet2":
		*e = UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum: %v", v)
	}
}

type UpdateNetworkOneToOneNatRulesRequestBodyRules struct {
	// The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
	AllowedInbound []UpdateNetworkOneToOneNatRulesRequestBodyRulesAllowedInbound `json:"allowedInbound,omitempty"`
	// The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
	LanIP string `json:"lanIp"`
	// A descriptive name for the rule
	Name *string `json:"name,omitempty"`
	// The IP address that will be used to access the internal resource from the WAN
	PublicIP *string `json:"publicIp,omitempty"`
	// The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
	Uplink *UpdateNetworkOneToOneNatRulesRequestBodyRulesUplinkEnum `json:"uplink,omitempty"`
}

type UpdateNetworkOneToOneNatRulesRequestBody struct {
	// An array of 1:1 nat rules
	Rules []UpdateNetworkOneToOneNatRulesRequestBodyRules `json:"rules"`
}

type UpdateNetworkOneToOneNatRulesRequest struct {
	RequestBody UpdateNetworkOneToOneNatRulesRequestBody `request:"mediaType=application/json"`
	NetworkID   string                                   `pathParam:"style=simple,explode=false,name=networkId"`
}

type UpdateNetworkOneToOneNatRulesResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	UpdateNetworkOneToOneNatRules200ApplicationJSONObject map[string]interface{}
}
