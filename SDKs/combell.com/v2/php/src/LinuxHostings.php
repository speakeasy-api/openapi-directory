<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class LinuxHostings 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Add a scheduled task
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksResponse
     */
	public function addScheduledTasks(
        \OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/scheduledtasks', \OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "scheduledTask", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddScheduledTasksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
        }

        return $response;
    }
	
    /**
     * Add a SSH key
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AddSshKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddSshKeyResponse
     */
	public function addSshKey(
        \OpenAPI\OpenAPI\Models\Operations\AddSshKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddSshKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/ssh/keys', \OpenAPI\OpenAPI\Models\Operations\AddSshKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addSshKeyRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\AddSshKeyRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddSshKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
        }

        return $response;
    }
	
    /**
     * Configure PHP APCu setting
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangeApcuRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangeApcuResponse
     */
	public function changeApcu(
        \OpenAPI\OpenAPI\Models\Operations\ChangeApcuRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangeApcuResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/phpsettings/apcu', \OpenAPI\OpenAPI\Models\Operations\ChangeApcuRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updatePhpAPcuRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ChangeApcuRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangeApcuResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Configure auto redirect
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectResponse
     */
	public function changeAutoRedirect(
        \OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/sslsettings/{hostname}/autoredirect', \OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "autoRedirectConfig", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangeAutoRedirectResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Enable/disable GZIP compression
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionResponse
     */
	public function changeGzipCompression(
        \OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/settings/gzipcompression', \OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "gzipConfig", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangeGzipCompressionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Configure let's encrypt
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptResponse
     */
	public function changeLetsEncrypt(
        \OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/sslsettings/{hostname}/letsencrypt', \OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "letsEncryptConfig", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangeLetsEncryptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Configure PHP memory limit
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitResponse
     */
	public function changePhpMemoryLimit(
        \OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/phpsettings/memorylimit', \OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updatePhpMemoryLimitRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangePhpMemoryLimitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Change the Linux hosting PHP version.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionResponse
     */
	public function changePhpVersion(
        \OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/phpsettings/version', \OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "phpVersion", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangePhpVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Configure FTP
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ConfigureFtpRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ConfigureFtpResponse
     */
	public function configureFtp(
        \OpenAPI\OpenAPI\Models\Operations\ConfigureFtpRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ConfigureFtpResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/ftp/configuration', \OpenAPI\OpenAPI\Models\Operations\ConfigureFtpRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "ftpConfiguration", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ConfigureFtpRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ConfigureFtpResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Configure HTTP/2
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Response
     */
	public function configureHttp2(
        \OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/sites/{siteName}/http2/configuration', \OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "http2Configuration", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Request::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ConfigureHttp2Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Configure a scheduled task
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskResponse
     */
	public function configureScheduledTask(
        \OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/scheduledtasks/{scheduledTaskId}', \OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "scheduledTask", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ConfigureScheduledTaskResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Configure SSH
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ConfigureSshRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ConfigureSshResponse
     */
	public function configureSsh(
        \OpenAPI\OpenAPI\Models\Operations\ConfigureSshRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ConfigureSshResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/ssh/configuration', \OpenAPI\OpenAPI\Models\Operations\ConfigureSshRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "sshConfiguration", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ConfigureSshRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ConfigureSshResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Create a host header
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderResponse
     */
	public function createHostHeader(
        \OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/sites/{siteName}/hostheaders', \OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addHostHeaderRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateHostHeaderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
        }

        return $response;
    }
	
    /**
     * Create a subsite
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateSubsiteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateSubsiteResponse
     */
	public function createSubsite(
        \OpenAPI\OpenAPI\Models\Operations\CreateSubsiteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateSubsiteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/subsites', \OpenAPI\OpenAPI\Models\Operations\CreateSubsiteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addSubsiteRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CreateSubsiteRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateSubsiteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
        }

        return $response;
    }
	
    /**
     * Delete a scheduled task
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskResponse
     */
	public function deleteScheduledTask(
        \OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/scheduledtasks/{scheduledTaskId}', \OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteScheduledTaskResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Delete a SSH key
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyResponse
     */
	public function deleteSshKey(
        \OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/ssh/keys/{fingerprint}', \OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteSshKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Delete a subsite
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteResponse
     */
	public function deleteSubsite(
        \OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/subsites/{siteName}', \OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteSubsiteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Get the available PHP versions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsResponse
     */
	public function getAvailablePhpVersions(
        \OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/phpsettings/availableversions', \OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAvailablePhpVersionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->phpVersions = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\PhpVersion>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Linux hosting detail
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingResponse
     */
	public function getLinuxHosting(
        \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}', \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->linuxHostingDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\LinuxHostingDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Overview of linux hostings
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingsResponse
     */
	public function getLinuxHostings(
        \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLinuxHostingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->linuxHostings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\LinuxHosting>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get scheduled task detail
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskResponse
     */
	public function getScheduledTask(
        \OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/scheduledtasks/{scheduledTaskId}', \OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetScheduledTaskResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->scheduledTask = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ScheduledTask', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Overview of scheduled tasks
     * 
     * Manage scheduled tasks which are also manageable via the control panel.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksResponse
     */
	public function getScheduledTasks(
        \OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/scheduledtasks', \OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetScheduledTasksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->scheduledTasks = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\ScheduledTask>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Overview of SSH keys
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSshKeysRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSshKeysResponse
     */
	public function getSshKeys(
        \OpenAPI\OpenAPI\Models\Operations\GetSshKeysRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSshKeysResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/linuxhostings/{domainName}/ssh/keys', \OpenAPI\OpenAPI\Models\Operations\GetSshKeysRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetSshKeysRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSshKeysResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->sshKeys = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\SshKey>', 'json');
            }
        }

        return $response;
    }
}