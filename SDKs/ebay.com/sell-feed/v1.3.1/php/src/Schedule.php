<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Schedule 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * This method creates a schedule, which is a subscription to the specified schedule template. A schedule periodically generates a report for the <strong>feedType</strong> specified by the template. Specify the same <strong>feedType</strong> as the <strong>feedType</strong> of the associated schedule template. When creating the schedule, if available from the template, you can specify a preferred trigger hour, day of the week, or day of the month. These and other fields are conditionally available as specified by the template.<p> <span class="tablenote"><strong>Note:</strong> Make sure to include all fields required by the schedule template (<strong>scheduleTemplateId</strong>). Call the <strong>getScheduleTemplate</strong> method (or the <strong>getScheduleTemplates</strong> method), to find out which fields are required or optional. If a field is optional and a default value is provided by the template, the default value will be used if omitted from the payload.</span></p>A successful call returns the location response header containing the <strong>getSchedule</strong> call URI to retrieve the schedule you just created. The URL includes the eBay-assigned schedule ID, which you can use to reference the schedule task. <br /><br />To retrieve the details of the create schedule task, use the <strong>getSchedule</strong> method for a single schedule ID or the <strong>getSchedules</strong> method to retrieve all schedule details for the specified <strong>feed_type</strong>. The number of schedules for each feedType is limited. Error code 160031 is returned when you have reached this maximum.<p> <span class="tablenote"><strong>Note:</strong> Except for schedules with a HALF-HOUR frequency, all schedules will ideally run at the start of each hour ('00' minutes). Actual start time may vary time may vary due to load and other factors.</span></p>
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\CreateUserScheduleRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateScheduleSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateScheduleResponse
     */
	public function createSchedule(
        \OpenAPI\OpenAPI\Models\Shared\CreateUserScheduleRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CreateScheduleSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createSchedule201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method deletes an existing schedule. Specify the schedule to delete using the <strong>schedule_id</strong> path parameter.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleResponse
     */
	public function deleteSchedule(
        \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule/{schedule_id}', \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method downloads the latest result file generated by the schedule. The response of this call is a compressed or uncompressed CSV, XML, or JSON file, with the applicable file extension (for example: csv.gz). Specify the <strong>schedule_id</strong> path parameter to download its last generated file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileResponse
     */
	public function getLatestResultFile(
        \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule/{schedule_id}/download_result_file', \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLatestResultFileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/octet-stream')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method retrieves schedule details and status of the specified schedule. Specify the schedule to retrieve using the <strong>schedule_id</strong>. Use the <strong>getSchedules</strong> method to find a schedule if you do not know the <strong>schedule_id</strong>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduleRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduleSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetScheduleResponse
     */
	public function getSchedule(
        \OpenAPI\OpenAPI\Models\Operations\GetScheduleRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetScheduleSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule/{schedule_id}', \OpenAPI\OpenAPI\Models\Operations\GetScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userScheduleResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserScheduleResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method retrieves the details of the specified template. Specify the template to retrieve using the <strong>schedule_template_id</strong> path parameter. Use the <strong>getScheduleTemplates</strong> method to find a schedule template if you do not know the <strong>schedule_template_id</strong>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateResponse
     */
	public function getScheduleTemplate(
        \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule_template/{schedule_template_id}', \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->scheduleTemplateResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ScheduleTemplateResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method retrieves an array containing the details and status of all schedule templates based on the specified <strong>feed_type</strong>. Use this method to find a schedule template if you do not know the <strong>schedule_template_id</strong>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesResponse
     */
	public function getScheduleTemplates(
        \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule_template');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetScheduleTemplatesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->scheduleTemplateCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ScheduleTemplateCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method retrieves an array containing the details and status of all schedules based on the specified <strong>feed_type</strong>. Use this method to find a schedule if you do not know the <strong>schedule_id</strong>.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSchedulesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSchedulesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSchedulesResponse
     */
	public function getSchedules(
        \OpenAPI\OpenAPI\Models\Operations\GetSchedulesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetSchedulesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSchedulesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetSchedulesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSchedulesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userScheduleCollection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserScheduleCollection', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
	
    /**
     * This method updates an existing schedule. Specify the schedule to update using the <strong>schedule_id</strong> path parameter. If the schedule template has changed after the schedule was created or updated, the input will be validated using the changed template.<p> <span class="tablenote"><strong>Note:</strong> Make sure to include all fields required by the schedule template (<strong>scheduleTemplateId</strong>). Call the <strong>getScheduleTemplate</strong> method (or the <strong>getScheduleTemplates</strong> method), to find out which fields are required or optional. If you do not know the <strong>scheduleTemplateId</strong>, call the <strong>getSchedule</strong> method to find out.</span></p>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleResponse
     */
	public function updateSchedule(
        \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/schedule/{schedule_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateUserScheduleRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateScheduleResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 500) {
        }

        return $response;
    }
}