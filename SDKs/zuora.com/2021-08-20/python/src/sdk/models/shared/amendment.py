"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import rateplan as shared_rateplan
from ..shared import rateplanchargedatainrateplandata as shared_rateplanchargedatainrateplandata
from ..shared import subscriptionproductfeaturelist as shared_subscriptionproductfeaturelist
from dataclasses_json import Undefined, dataclass_json
from datetime import date, datetime
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class AmendmentRatePlanData:
    r"""A container for one `RatePlanData`. This field is only required if the `Type` field is set to `NewProduct`, `RemoveProduct`, or `UpdateProduct`."""
    
    rate_plan: shared_rateplan.RatePlan = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RatePlan') }})  
    rate_plan_charge_data: Optional[list[shared_rateplanchargedatainrateplandata.RatePlanChargeDataInRatePlanData]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RatePlanChargeData'), 'exclude': lambda f: f is None }})  
    subscription_product_feature_list: Optional[shared_subscriptionproductfeaturelist.SubscriptionProductFeatureList] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('SubscriptionProductFeatureList'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Amendment:
    
    contract_effective_date: date = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ContractEffectiveDate'), 'encoder': utils.dateisoformat(False), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso') }})
    r"""The date when the amendment's changes become effective for billing purposes."""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name') }})
    r"""The name of the amendment.
    
    
    **Character limit**: 100
    
    **Values**: a string of 100 characters or fewer
    """  
    subscription_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('SubscriptionId') }})
    r"""The ID of the subscription that the amendment changes.
    
    
    **Character limit**: 32
    
    **Values**: a valid subscription ID
    """  
    type: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Type') }})
    r"""The type of amendment.
    
    
    **Character limit**: 18
    
    
    
    **Values**: one of the following:
    
    - Cancellation
    - NewProduct
    - OwnerTransfer (If this value is chosen, the `ContractEffectiveDate`, `ServiceActivationDate`, and `CustomerAcceptanceDate` fields will all be automatically set to today's date, and any values passed from the API are ignored.)
    - RemoveProduct
    - Renewal
    - UpdateProduct
    - TermsAndConditions
    - SuspendSubscription
    - ResumeSubscription
    """  
    auto_renew: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AutoRenew'), 'exclude': lambda f: f is None }})
    r"""Determines whether the subscription is automatically renewed, or whether it expires at the end of the term and needs to be manually renewed. For amendment of type `TermsAndConditions`, this field is only required if you change the automatic renewal status of a subscription.
    
    
    **Values**: true, false
    """  
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""A unique alphanumeric string that identifies the amendment.
    
    
    **Character limit**: 50
    
    **Values**: automatically generated
    """  
    created_by_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreatedById'), 'exclude': lambda f: f is None }})
    r"""The user ID of the person who created the amendment.
    
    
    **Character limit**: 32
    
    **Values**: automatically generated
    """  
    created_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreatedDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the amendment was created.
    
    
    **Values**: automatically generated
    """  
    current_term: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CurrentTerm'), 'exclude': lambda f: f is None }})
    r"""The length of the period for the current subscription term. This field can be updated when Status is `Draft`.
    
    This field is only required if the `Type` field is set to `TermsAndConditions` and `TermType` is set to `TERMED`. This field is not required if `TermType` is set to `EVERGREEN`.
    
    
    **Values**: a valid number
    """  
    current_term_period_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CurrentTermPeriodType'), 'exclude': lambda f: f is None }})
    r"""The period type for the current subscription term. This field is only required if the `Type` field is set to `TermsAndConditions` and `TermType` is set to `TERMED`. This field is not required if `TermType` is set to `EVERGREEN`.
    
    **Values**:
    
    - `Month` (default)
    - `Year`
    - `Day`
    - `Week`
    
    
    **Note**:
    
    - This field can be updated when Status is `Draft`.
    - This field is used with the CurrentTerm field to specify the current subscription term.
    """  
    customer_acceptance_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CustomerAcceptanceDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the customer accepts the amendment's changes to the subscription.
    
    This field is only required if [Zuora is configured to require customer acceptance in Z-Billing](https://knowledgecenter.zuora.com/CB_Billing/W_Billing_and_Payments_Settings/Define_Default_Subscription_Settings) and the subscription is currently in the Pending Acceptance status (the value of the `Status` field is currently `PendingAcceptance`).
    
    Use this field together with the `Status` field. When you set a date in this field as a customer acceptance date, you should also set the `Status` field as `Completed`.
    """  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""A description of the amendment.
    
    
    **Character limit**: 500
    
    **Values**: maximum 500 characters
    """  
    destination_account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DestinationAccountId'), 'exclude': lambda f: f is None }})
    r"""The ID of the subscription owner that the subscription is being transferred to.
    
    
    **Character limit**: 32
    
    **Values**: a valid account ID
    """  
    destination_invoice_owner_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DestinationInvoiceOwnerId'), 'exclude': lambda f: f is None }})
    r"""The ID of the invoice owner that the subscription is being transferred to.
    
    
    **Character limit**: 32
    
    **Values**: a valid invoice ID
    """  
    effective_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EffectiveDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the amendment's changes take effective. This field validates that the amendment's changes are within valid ranges of products and product rate plans.
    This field is only required if the `Type` field is set to `Cancellation`.
    """  
    rate_plan_data: Optional[AmendmentRatePlanData] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RatePlanData'), 'exclude': lambda f: f is None }})
    r"""A container for one `RatePlanData`. This field is only required if the `Type` field is set to `NewProduct`, `RemoveProduct`, or `UpdateProduct`."""  
    renewal_setting: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RenewalSetting'), 'exclude': lambda f: f is None }})
    r"""Specifies whether a termed subscription will remain termed or change to evergreen when it is renewed.
    
    This field is only required if the `TermType` field is set to `Termed`.
    
    
    **Values**: RENEW_WITH_SPECIFIC_TERM (default), RENEW_TO_EVERGREEN
    """  
    renewal_term: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RenewalTerm'), 'exclude': lambda f: f is None }})
    r"""The term of renewal for the amended subscription. This field can be updated when Status is `Draft`.
    This field is only required if the `Type` field is set to `TermsAndConditions`.
    
    
    **Values:** a valid number
    """  
    renewal_term_period_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RenewalTermPeriodType'), 'exclude': lambda f: f is None }})
    r"""The period type for the subscription renewal term. This field can be updated when Status is `Draft`.
    **Required**: Only if the value of the Type field is set to `TermsAndConditions`. This field is used with the RenewalTerm field to specify the subscription renewal term.
    
    
    **Values**:
    
    - `Month` (default)
    - `Year`
    - `Day`
    - `Week`
    """  
    resume_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ResumeDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the subscription resumption takes effect. See [Resume Date](https://knowledgecenter.zuora.com/BC_Subscription_Management/Subscriptions/Resume_a_Subscription#Resume_Date) for more information.
    
    This field is only required if you resume a suspended subscription.
    """  
    service_activation_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ServiceActivationDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when service is activated.
    
    This field is only required if [Zuora is configured to require service activation in Z-Billing](https://knowledgecenter.zuora.com/CB_Billing/W_Billing_and_Payments_Settings/Define_Default_Subscription_Settings) and the subscription is currently in the Pending Activation status (the value of the `Status` field is currently `PendingActivation`).
    
    Use this field together with the `Status` field. When you set a date in this field as a service activation date, you should also set the `Status` field as the expected next phase status: `Completed` or `PendingAcceptance`.
    """  
    specific_update_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('SpecificUpdateDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the UpdateProduct amendment takes effect. This field is only applicable if there is already a future-dated UpdateProduct amendment on the subscription.
    
    
    For the UpdateProduct amendments, this field is only required if there is already a future-dated UpdateProduct amendment on the subscription.
    """  
    status: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Status'), 'exclude': lambda f: f is None }})
    r"""The status of the amendment. Type: string (enum)
    
    
    
    **Values**: one of the following:
    
    - Draft (default, if left null)
    - Pending Activation
    - Pending Acceptance
    - Completed
    """  
    suspend_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('SuspendDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the subscription suspension takes effect. See [Suspend Date](https://knowledgecenter.zuora.com/BC_Subscription_Management/Subscriptions/Suspend_a_Subscription#Suspend_Date) for more information.
    
    This field is only required if you suspend an active subscription.
    """  
    term_start_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TermStartDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the new terms and conditions take effect.
    This field is only required if the `Type` field is set to `TermsAndConditions`.
    """  
    term_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TermType'), 'exclude': lambda f: f is None }})
    r"""Indicates if the subscription isTERMED or EVERGREEN.
    
    - A TERMED subscription has an expiration date, and must be manually renewed.
    - An EVERGREEN subscription doesn't have an expiration date, and must be manually ended.
    
    When as part of an amendment of type `TermsAndConditions`, this field is required to change the term type of a subscription.
    
    
    **Character limit**: 9
    
    **Values**: TERMED, EVERGREEN
    """  
    updated_by_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('UpdatedById'), 'exclude': lambda f: f is None }})
    r"""The ID of the user who last updated the amendment.
    
    
    **Character limit**: 32
    
    **Values**: automatically generated
    """  
    updated_date: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('UpdatedDate'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The date when the amendment was last updated.
    
    
    **Values**: automatically generated
    """  
    