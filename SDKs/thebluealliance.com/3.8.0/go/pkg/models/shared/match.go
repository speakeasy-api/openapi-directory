// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// MatchAlliances - A list of alliances, the teams on the alliances, and their score.
type MatchAlliances struct {
	Blue *MatchAlliance `json:"blue,omitempty"`
	Red  *MatchAlliance `json:"red,omitempty"`
}

// MatchCompLevelEnum - The competition level the match was played at.
type MatchCompLevelEnum string

const (
	MatchCompLevelEnumQm MatchCompLevelEnum = "qm"
	MatchCompLevelEnumEf MatchCompLevelEnum = "ef"
	MatchCompLevelEnumQf MatchCompLevelEnum = "qf"
	MatchCompLevelEnumSf MatchCompLevelEnum = "sf"
	MatchCompLevelEnumF  MatchCompLevelEnum = "f"
)

func (e *MatchCompLevelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "qm":
		fallthrough
	case "ef":
		fallthrough
	case "qf":
		fallthrough
	case "sf":
		fallthrough
	case "f":
		*e = MatchCompLevelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MatchCompLevelEnum: %s", s)
	}
}

type MatchVideos struct {
	// Unique key representing this video
	Key *string `json:"key,omitempty"`
	// Can be one of 'youtube' or 'tba'
	Type *string `json:"type,omitempty"`
}

// MatchWinningAllianceEnum - The color (red/blue) of the winning alliance. Will contain an empty string in the event of no winner, or a tie.
type MatchWinningAllianceEnum string

const (
	MatchWinningAllianceEnumRed     MatchWinningAllianceEnum = "red"
	MatchWinningAllianceEnumBlue    MatchWinningAllianceEnum = "blue"
	MatchWinningAllianceEnumUnknown MatchWinningAllianceEnum = ""
)

func (e *MatchWinningAllianceEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "red":
		fallthrough
	case "blue":
		fallthrough
	case "":
		*e = MatchWinningAllianceEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MatchWinningAllianceEnum: %s", s)
	}
}

// Match - Successful response
type Match struct {
	// UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of actual match start time.
	ActualTime *int64 `json:"actual_time,omitempty"`
	// A list of alliances, the teams on the alliances, and their score.
	Alliances *MatchAlliances `json:"alliances,omitempty"`
	// The competition level the match was played at.
	CompLevel MatchCompLevelEnum `json:"comp_level"`
	// Event key of the event the match was played at.
	EventKey string `json:"event_key"`
	// TBA match key with the format `yyyy[EVENT_CODE]_[COMP_LEVEL]m[MATCH_NUMBER]`, where `yyyy` is the year, and `EVENT_CODE` is the event code of the event, `COMP_LEVEL` is (qm, ef, qf, sf, f), and `MATCH_NUMBER` is the match number in the competition level. A set number may be appended to the competition level if more than one match in required per set.
	Key string `json:"key"`
	// The match number of the match in the competition level.
	MatchNumber int64 `json:"match_number"`
	// UNIX timestamp (seconds since 1-Jan-1970 00:00:00) when the match result was posted.
	PostResultTime *int64 `json:"post_result_time,omitempty"`
	// UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the TBA predicted match start time.
	PredictedTime *int64 `json:"predicted_time,omitempty"`
	// Score breakdown for auto, teleop, etc. points. Varies from year to year. May be null.
	ScoreBreakdown map[string]interface{} `json:"score_breakdown,omitempty"`
	// The set number in a series of matches where more than one match is required in the match series.
	SetNumber int64 `json:"set_number"`
	// UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the scheduled match time, as taken from the published schedule.
	Time *int64 `json:"time,omitempty"`
	// Array of video objects associated with this match.
	Videos []MatchVideos `json:"videos,omitempty"`
	// The color (red/blue) of the winning alliance. Will contain an empty string in the event of no winner, or a tie.
	WinningAlliance *MatchWinningAllianceEnum `json:"winning_alliance,omitempty"`
}
