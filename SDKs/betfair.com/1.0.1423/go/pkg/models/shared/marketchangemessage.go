// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// MarketChangeMessageCtEnum - Change Type - set to indicate the type of change - if null this is a delta)
type MarketChangeMessageCtEnum string

const (
	MarketChangeMessageCtEnumSubImage   MarketChangeMessageCtEnum = "SUB_IMAGE"
	MarketChangeMessageCtEnumResubDelta MarketChangeMessageCtEnum = "RESUB_DELTA"
	MarketChangeMessageCtEnumHeartbeat  MarketChangeMessageCtEnum = "HEARTBEAT"
)

func (e *MarketChangeMessageCtEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SUB_IMAGE":
		fallthrough
	case "RESUB_DELTA":
		fallthrough
	case "HEARTBEAT":
		*e = MarketChangeMessageCtEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MarketChangeMessageCtEnum: %s", s)
	}
}

// MarketChangeMessageSegmentTypeEnum - Segment Type - if the change is split into multiple segments, this denotes the beginning and end of a change, and segments in between. Will be null if data is not segmented
type MarketChangeMessageSegmentTypeEnum string

const (
	MarketChangeMessageSegmentTypeEnumSegStart MarketChangeMessageSegmentTypeEnum = "SEG_START"
	MarketChangeMessageSegmentTypeEnumSeg      MarketChangeMessageSegmentTypeEnum = "SEG"
	MarketChangeMessageSegmentTypeEnumSegEnd   MarketChangeMessageSegmentTypeEnum = "SEG_END"
)

func (e *MarketChangeMessageSegmentTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SEG_START":
		fallthrough
	case "SEG":
		fallthrough
	case "SEG_END":
		*e = MarketChangeMessageSegmentTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for MarketChangeMessageSegmentTypeEnum: %s", s)
	}
}

type MarketChangeMessage struct {
	// Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)
	Clk *string `json:"clk,omitempty"`
	// Conflate Milliseconds - the conflation rate (may differ from that requested if subscription is delayed)
	ConflateMs *int64 `json:"conflateMs,omitempty"`
	// Change Type - set to indicate the type of change - if null this is a delta)
	Ct *MarketChangeMessageCtEnum `json:"ct,omitempty"`
	// Heartbeat Milliseconds - the heartbeat rate (may differ from requested: bounds are 500 to 30000)
	HeartbeatMs *int64 `json:"heartbeatMs,omitempty"`
	// Client generated unique id to link request with response (like json rpc)
	ID *int `json:"id,omitempty"`
	// Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)
	InitialClk *string `json:"initialClk,omitempty"`
	// MarketChanges - the modifications to markets (will be null on a heartbeat
	Mc []MarketChange `json:"mc,omitempty"`
	// The operation type
	Op *string `json:"op,omitempty"`
	// Publish Time (in millis since epoch) that the changes were generated
	Pt *int64 `json:"pt,omitempty"`
	// Segment Type - if the change is split into multiple segments, this denotes the beginning and end of a change, and segments in between. Will be null if data is not segmented
	SegmentType *MarketChangeMessageSegmentTypeEnum `json:"segmentType,omitempty"`
	// Stream status: set to null if the exchange stream data is up to date and 503 if the downstream services are experiencing latencies
	Status *int `json:"status,omitempty"`
}
