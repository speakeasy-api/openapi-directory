/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://taskrouter.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  createActivity(
    req: operations.CreateActivityRequest,
    security: operations.CreateActivitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateActivityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateActivityRequest(req);
    }

    let baseURL: string = operations.CreateActivityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Activities",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateActivitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateActivityResponse =
        new operations.CreateActivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceActivity = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceActivity
            );
          }
          break;
      }

      return res;
    });
  }

  createTask(
    req: operations.CreateTaskRequest,
    security: operations.CreateTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTaskRequest(req);
    }

    let baseURL: string = operations.CreateTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTaskResponse =
        new operations.CreateTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTask = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTask
            );
          }
          break;
      }

      return res;
    });
  }

  createTaskChannel(
    req: operations.CreateTaskChannelRequest,
    security: operations.CreateTaskChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTaskChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTaskChannelRequest(req);
    }

    let baseURL: string = operations.CreateTaskChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskChannels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTaskChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTaskChannelResponse =
        new operations.CreateTaskChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskChannel = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskChannel
            );
          }
          break;
      }

      return res;
    });
  }

  createTaskQueue(
    req: operations.CreateTaskQueueRequest,
    security: operations.CreateTaskQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTaskQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTaskQueueRequest(req);
    }

    let baseURL: string = operations.CreateTaskQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTaskQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTaskQueueResponse =
        new operations.CreateTaskQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskQueue = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskQueue
            );
          }
          break;
      }

      return res;
    });
  }

  createWorker(
    req: operations.CreateWorkerRequest,
    security: operations.CreateWorkerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWorkerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWorkerRequest(req);
    }

    let baseURL: string = operations.CreateWorkerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWorkerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWorkerResponse =
        new operations.CreateWorkerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorker = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorker
            );
          }
          break;
      }

      return res;
    });
  }

  createWorkflow(
    req: operations.CreateWorkflowRequest,
    security: operations.CreateWorkflowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWorkflowRequest(req);
    }

    let baseURL: string = operations.CreateWorkflowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWorkflowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWorkflowResponse =
        new operations.CreateWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkflow = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorkflow
            );
          }
          break;
      }

      return res;
    });
  }

  createWorkspace(
    req: operations.CreateWorkspaceCreateWorkspaceRequest,
    security: operations.CreateWorkspaceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWorkspaceCreateWorkspaceRequest(req);
    }

    let baseURL: string = operations.CreateWorkspaceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Workspaces";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWorkspaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWorkspaceResponse =
        new operations.CreateWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1Workspace = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1Workspace
            );
          }
          break;
      }

      return res;
    });
  }

  deleteActivity(
    req: operations.DeleteActivityRequest,
    security: operations.DeleteActivitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteActivityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteActivityRequest(req);
    }

    let baseURL: string = operations.DeleteActivityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteActivitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteActivityResponse =
        new operations.DeleteActivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteTask(
    req: operations.DeleteTaskRequest,
    security: operations.DeleteTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTaskRequest(req);
    }

    let baseURL: string = operations.DeleteTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTaskResponse =
        new operations.DeleteTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteTaskChannel(
    req: operations.DeleteTaskChannelRequest,
    security: operations.DeleteTaskChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTaskChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTaskChannelRequest(req);
    }

    let baseURL: string = operations.DeleteTaskChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTaskChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTaskChannelResponse =
        new operations.DeleteTaskChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteTaskQueue(
    req: operations.DeleteTaskQueueRequest,
    security: operations.DeleteTaskQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTaskQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTaskQueueRequest(req);
    }

    let baseURL: string = operations.DeleteTaskQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTaskQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTaskQueueResponse =
        new operations.DeleteTaskQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteWorker(
    req: operations.DeleteWorkerRequest,
    security: operations.DeleteWorkerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWorkerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWorkerRequest(req);
    }

    let baseURL: string = operations.DeleteWorkerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWorkerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWorkerResponse =
        new operations.DeleteWorkerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteWorkflow(
    req: operations.DeleteWorkflowRequest,
    security: operations.DeleteWorkflowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWorkflowRequest(req);
    }

    let baseURL: string = operations.DeleteWorkflowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWorkflowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWorkflowResponse =
        new operations.DeleteWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteWorkspace(
    req: operations.DeleteWorkspaceRequest,
    security: operations.DeleteWorkspaceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWorkspaceRequest(req);
    }

    let baseURL: string = operations.DeleteWorkspaceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Workspaces/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWorkspaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWorkspaceResponse =
        new operations.DeleteWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  fetchActivity(
    req: operations.FetchActivityRequest,
    security: operations.FetchActivitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchActivityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchActivityRequest(req);
    }

    let baseURL: string = operations.FetchActivityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchActivitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchActivityResponse =
        new operations.FetchActivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceActivity = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceActivity
            );
          }
          break;
      }

      return res;
    });
  }

  fetchEvent(
    req: operations.FetchEventRequest,
    security: operations.FetchEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEventRequest(req);
    }

    let baseURL: string = operations.FetchEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Events/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEventResponse =
        new operations.FetchEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceEvent = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceEvent
            );
          }
          break;
      }

      return res;
    });
  }

  fetchTask(
    req: operations.FetchTaskRequest,
    security: operations.FetchTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskRequest(req);
    }

    let baseURL: string = operations.FetchTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskResponse =
        new operations.FetchTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTask = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTask
            );
          }
          break;
      }

      return res;
    });
  }

  fetchTaskChannel(
    req: operations.FetchTaskChannelRequest,
    security: operations.FetchTaskChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskChannelRequest(req);
    }

    let baseURL: string = operations.FetchTaskChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskChannelResponse =
        new operations.FetchTaskChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskChannel = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskChannel
            );
          }
          break;
      }

      return res;
    });
  }

  fetchTaskQueue(
    req: operations.FetchTaskQueueRequest,
    security: operations.FetchTaskQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskQueueRequest(req);
    }

    let baseURL: string = operations.FetchTaskQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskQueueResponse =
        new operations.FetchTaskQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskQueue = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskQueue
            );
          }
          break;
      }

      return res;
    });
  }

  fetchTaskQueueCumulativeStatistics(
    req: operations.FetchTaskQueueCumulativeStatisticsRequest,
    security: operations.FetchTaskQueueCumulativeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskQueueCumulativeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskQueueCumulativeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchTaskQueueCumulativeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/CumulativeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskQueueCumulativeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskQueueCumulativeStatisticsResponse =
        new operations.FetchTaskQueueCumulativeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchTaskQueueRealTimeStatistics(
    req: operations.FetchTaskQueueRealTimeStatisticsRequest,
    security: operations.FetchTaskQueueRealTimeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskQueueRealTimeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskQueueRealTimeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchTaskQueueRealTimeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/RealTimeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskQueueRealTimeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskQueueRealTimeStatisticsResponse =
        new operations.FetchTaskQueueRealTimeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchTaskQueueStatistics(
    req: operations.FetchTaskQueueStatisticsRequest,
    security: operations.FetchTaskQueueStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskQueueStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskQueueStatisticsRequest(req);
    }

    let baseURL: string = operations.FetchTaskQueueStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskQueueStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskQueueStatisticsResponse =
        new operations.FetchTaskQueueStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskQueueTaskQueueStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchTaskReservation(
    req: operations.FetchTaskReservationRequest,
    security: operations.FetchTaskReservationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTaskReservationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTaskReservationRequest(req);
    }

    let baseURL: string = operations.FetchTaskReservationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTaskReservationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTaskReservationResponse =
        new operations.FetchTaskReservationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskTaskReservation = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskTaskReservation
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWorker(
    req: operations.FetchWorkerRequest,
    security: operations.FetchWorkerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkerRequest(req);
    }

    let baseURL: string = operations.FetchWorkerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkerResponse =
        new operations.FetchWorkerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorker = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorker
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkerChannel(
    req: operations.FetchWorkerChannelRequest,
    security: operations.FetchWorkerChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkerChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkerChannelRequest(req);
    }

    let baseURL: string = operations.FetchWorkerChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkerChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkerChannelResponse =
        new operations.FetchWorkerChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkerChannel = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorkerWorkerChannel
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkerInstanceStatistics(
    req: operations.FetchWorkerInstanceStatisticsRequest,
    security: operations.FetchWorkerInstanceStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkerInstanceStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkerInstanceStatisticsRequest(req);
    }

    let baseURL: string = operations.FetchWorkerInstanceStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkerInstanceStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkerInstanceStatisticsResponse =
        new operations.FetchWorkerInstanceStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkerInstanceStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkerReservation(
    req: operations.FetchWorkerReservationRequest,
    security: operations.FetchWorkerReservationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkerReservationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkerReservationRequest(req);
    }

    let baseURL: string = operations.FetchWorkerReservationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkerReservationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkerReservationResponse =
        new operations.FetchWorkerReservationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkerReservation =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkerWorkerReservation
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkerStatistics(
    req: operations.FetchWorkerStatisticsRequest,
    security: operations.FetchWorkerStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkerStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkerStatisticsRequest(req);
    }

    let baseURL: string = operations.FetchWorkerStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkerStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkerStatisticsResponse =
        new operations.FetchWorkerStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkerStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkerWorkerStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkersCumulativeStatistics(
    req: operations.FetchWorkersCumulativeStatisticsRequest,
    security: operations.FetchWorkersCumulativeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkersCumulativeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkersCumulativeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchWorkersCumulativeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/CumulativeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkersCumulativeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkersCumulativeStatisticsResponse =
        new operations.FetchWorkersCumulativeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkersCumulativeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkersRealTimeStatistics(
    req: operations.FetchWorkersRealTimeStatisticsRequest,
    security: operations.FetchWorkersRealTimeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkersRealTimeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkersRealTimeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchWorkersRealTimeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/RealTimeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkersRealTimeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkersRealTimeStatisticsResponse =
        new operations.FetchWorkersRealTimeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkersRealTimeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkflow(
    req: operations.FetchWorkflowRequest,
    security: operations.FetchWorkflowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkflowRequest(req);
    }

    let baseURL: string = operations.FetchWorkflowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkflowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkflowResponse =
        new operations.FetchWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkflow = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorkflow
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkflowCumulativeStatistics(
    req: operations.FetchWorkflowCumulativeStatisticsRequest,
    security: operations.FetchWorkflowCumulativeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkflowCumulativeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkflowCumulativeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchWorkflowCumulativeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/CumulativeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkflowCumulativeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkflowCumulativeStatisticsResponse =
        new operations.FetchWorkflowCumulativeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkflowRealTimeStatistics(
    req: operations.FetchWorkflowRealTimeStatisticsRequest,
    security: operations.FetchWorkflowRealTimeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkflowRealTimeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkflowRealTimeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchWorkflowRealTimeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/RealTimeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkflowRealTimeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkflowRealTimeStatisticsResponse =
        new operations.FetchWorkflowRealTimeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkflowStatistics(
    req: operations.FetchWorkflowStatisticsRequest,
    security: operations.FetchWorkflowStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkflowStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkflowStatisticsRequest(req);
    }

    let baseURL: string = operations.FetchWorkflowStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkflowStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkflowStatisticsResponse =
        new operations.FetchWorkflowStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkflowWorkflowStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkflowWorkflowStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkspace(
    req: operations.FetchWorkspaceRequest,
    security: operations.FetchWorkspaceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkspaceRequest(req);
    }

    let baseURL: string = operations.FetchWorkspaceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Workspaces/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkspaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkspaceResponse =
        new operations.FetchWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1Workspace = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1Workspace
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkspaceCumulativeStatistics(
    req: operations.FetchWorkspaceCumulativeStatisticsRequest,
    security: operations.FetchWorkspaceCumulativeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkspaceCumulativeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkspaceCumulativeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchWorkspaceCumulativeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/CumulativeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkspaceCumulativeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkspaceCumulativeStatisticsResponse =
        new operations.FetchWorkspaceCumulativeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkspaceCumulativeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkspaceCumulativeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkspaceRealTimeStatistics(
    req: operations.FetchWorkspaceRealTimeStatisticsRequest,
    security: operations.FetchWorkspaceRealTimeStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkspaceRealTimeStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkspaceRealTimeStatisticsRequest(req);
    }

    let baseURL: string =
      operations.FetchWorkspaceRealTimeStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/RealTimeStatistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkspaceRealTimeStatisticsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkspaceRealTimeStatisticsResponse =
        new operations.FetchWorkspaceRealTimeStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkspaceRealTimeStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkspaceRealTimeStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWorkspaceStatistics(
    req: operations.FetchWorkspaceStatisticsRequest,
    security: operations.FetchWorkspaceStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWorkspaceStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWorkspaceStatisticsRequest(req);
    }

    let baseURL: string = operations.FetchWorkspaceStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWorkspaceStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWorkspaceStatisticsResponse =
        new operations.FetchWorkspaceStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkspaceStatistics = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorkspaceStatistics
            );
          }
          break;
      }

      return res;
    });
  }

  listActivity(
    req: operations.ListActivityRequest,
    security: operations.ListActivitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListActivityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListActivityRequest(req);
    }

    let baseURL: string = operations.ListActivityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Activities",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListActivitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListActivityResponse =
        new operations.ListActivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listActivityResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListActivityListActivityResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listEvent(
    req: operations.ListEventRequest,
    security: operations.ListEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEventRequest(req);
    }

    let baseURL: string = operations.ListEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Events",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEventResponse =
        new operations.ListEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEventResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEventListEventResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listTask(
    req: operations.ListTaskRequest,
    security: operations.ListTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTaskRequest(req);
    }

    let baseURL: string = operations.ListTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTaskResponse = new operations.ListTaskResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTaskResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTaskListTaskResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listTaskChannel(
    req: operations.ListTaskChannelRequest,
    security: operations.ListTaskChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTaskChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTaskChannelRequest(req);
    }

    let baseURL: string = operations.ListTaskChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskChannels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTaskChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTaskChannelResponse =
        new operations.ListTaskChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTaskChannelResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTaskChannelListTaskChannelResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listTaskQueue(
    req: operations.ListTaskQueueRequest,
    security: operations.ListTaskQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTaskQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTaskQueueRequest(req);
    }

    let baseURL: string = operations.ListTaskQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTaskQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTaskQueueResponse =
        new operations.ListTaskQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTaskQueueResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTaskQueueListTaskQueueResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listTaskQueuesStatistics(
    req: operations.ListTaskQueuesStatisticsRequest,
    security: operations.ListTaskQueuesStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTaskQueuesStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTaskQueuesStatisticsRequest(req);
    }

    let baseURL: string = operations.ListTaskQueuesStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTaskQueuesStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTaskQueuesStatisticsResponse =
        new operations.ListTaskQueuesStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTaskQueuesStatisticsResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTaskQueuesStatisticsListTaskQueuesStatisticsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listTaskReservation(
    req: operations.ListTaskReservationRequest,
    security: operations.ListTaskReservationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTaskReservationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTaskReservationRequest(req);
    }

    let baseURL: string = operations.ListTaskReservationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTaskReservationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTaskReservationResponse =
        new operations.ListTaskReservationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTaskReservationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTaskReservationListTaskReservationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWorker(
    req: operations.ListWorkerRequest,
    security: operations.ListWorkerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkerRequest(req);
    }

    let baseURL: string = operations.ListWorkerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWorkerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkerResponse =
        new operations.ListWorkerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkerResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWorkerListWorkerResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWorkerChannel(
    req: operations.ListWorkerChannelRequest,
    security: operations.ListWorkerChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkerChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkerChannelRequest(req);
    }

    let baseURL: string = operations.ListWorkerChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWorkerChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkerChannelResponse =
        new operations.ListWorkerChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkerChannelResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWorkerChannelListWorkerChannelResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWorkerReservation(
    req: operations.ListWorkerReservationRequest,
    security: operations.ListWorkerReservationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkerReservationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkerReservationRequest(req);
    }

    let baseURL: string = operations.ListWorkerReservationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWorkerReservationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkerReservationResponse =
        new operations.ListWorkerReservationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkerReservationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWorkerReservationListWorkerReservationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWorkflow(
    req: operations.ListWorkflowRequest,
    security: operations.ListWorkflowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkflowRequest(req);
    }

    let baseURL: string = operations.ListWorkflowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWorkflowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkflowResponse =
        new operations.ListWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkflowResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWorkflowListWorkflowResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWorkspace(
    req: operations.ListWorkspaceRequest,
    security: operations.ListWorkspaceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkspaceRequest(req);
    }

    let baseURL: string = operations.ListWorkspaceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Workspaces";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWorkspaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkspaceResponse =
        new operations.ListWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkspaceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWorkspaceListWorkspaceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  updateActivity(
    req: operations.UpdateActivityRequest,
    security: operations.UpdateActivitySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateActivityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateActivityRequest(req);
    }

    let baseURL: string = operations.UpdateActivityServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Activities/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateActivitySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateActivityResponse =
        new operations.UpdateActivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceActivity = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceActivity
            );
          }
          break;
      }

      return res;
    });
  }

  updateTask(
    req: operations.UpdateTaskRequest,
    security: operations.UpdateTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTaskRequest(req);
    }

    let baseURL: string = operations.UpdateTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTaskResponse =
        new operations.UpdateTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTask = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTask
            );
          }
          break;
      }

      return res;
    });
  }

  updateTaskChannel(
    req: operations.UpdateTaskChannelRequest,
    security: operations.UpdateTaskChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTaskChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTaskChannelRequest(req);
    }

    let baseURL: string = operations.UpdateTaskChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTaskChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTaskChannelResponse =
        new operations.UpdateTaskChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskChannel = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskChannel
            );
          }
          break;
      }

      return res;
    });
  }

  updateTaskQueue(
    req: operations.UpdateTaskQueueRequest,
    security: operations.UpdateTaskQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTaskQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTaskQueueRequest(req);
    }

    let baseURL: string = operations.UpdateTaskQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTaskQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTaskQueueResponse =
        new operations.UpdateTaskQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskQueue = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskQueue
            );
          }
          break;
      }

      return res;
    });
  }

  updateTaskReservation(
    req: operations.UpdateTaskReservationRequest,
    security: operations.UpdateTaskReservationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTaskReservationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTaskReservationRequest(req);
    }

    let baseURL: string = operations.UpdateTaskReservationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateTaskReservationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTaskReservationResponse =
        new operations.UpdateTaskReservationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceTaskTaskReservation = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceTaskTaskReservation
            );
          }
          break;
      }

      return res;
    });
  }

  updateWorker(
    req: operations.UpdateWorkerRequest,
    security: operations.UpdateWorkerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkerRequest(req);
    }

    let baseURL: string = operations.UpdateWorkerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWorkerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkerResponse =
        new operations.UpdateWorkerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorker = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorker
            );
          }
          break;
      }

      return res;
    });
  }

  updateWorkerChannel(
    req: operations.UpdateWorkerChannelRequest,
    security: operations.UpdateWorkerChannelSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkerChannelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkerChannelRequest(req);
    }

    let baseURL: string = operations.UpdateWorkerChannelServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWorkerChannelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkerChannelResponse =
        new operations.UpdateWorkerChannelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkerChannel = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorkerWorkerChannel
            );
          }
          break;
      }

      return res;
    });
  }

  updateWorkerReservation(
    req: operations.UpdateWorkerReservationRequest,
    security: operations.UpdateWorkerReservationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkerReservationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkerReservationRequest(req);
    }

    let baseURL: string = operations.UpdateWorkerReservationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWorkerReservationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkerReservationResponse =
        new operations.UpdateWorkerReservationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkerWorkerReservation =
              utils.objectToClass(
                httpRes?.data,
                shared.TaskrouterV1WorkspaceWorkerWorkerReservation
              );
          }
          break;
      }

      return res;
    });
  }

  updateWorkflow(
    req: operations.UpdateWorkflowRequest,
    security: operations.UpdateWorkflowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkflowRequest(req);
    }

    let baseURL: string = operations.UpdateWorkflowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWorkflowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkflowResponse =
        new operations.UpdateWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1WorkspaceWorkflow = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1WorkspaceWorkflow
            );
          }
          break;
      }

      return res;
    });
  }

  updateWorkspace(
    req: operations.UpdateWorkspaceRequest,
    security: operations.UpdateWorkspaceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkspaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkspaceRequest(req);
    }

    let baseURL: string = operations.UpdateWorkspaceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Workspaces/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWorkspaceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkspaceResponse =
        new operations.UpdateWorkspaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.taskrouterV1Workspace = utils.objectToClass(
              httpRes?.data,
              shared.TaskrouterV1Workspace
            );
          }
          break;
      }

      return res;
    });
  }
}
