/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://api.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Create a new Twilio Subaccount from the account making the request
   */
  createAccount(
    req: operations.CreateAccountCreateAccountRequest,
    security: operations.CreateAccountSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAccountCreateAccountRequest(req);
    }

    let baseURL: string = operations.CreateAccountServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/2010-04-01/Accounts.json";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAccountResponse =
        new operations.CreateAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010Account = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010Account
            );
          }
          break;
      }

      return res;
    });
  }

  createAddress(
    req: operations.CreateAddressRequest,
    security: operations.CreateAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAddressRequest(req);
    }

    let baseURL: string = operations.CreateAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Addresses.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAddressResponse =
        new operations.CreateAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountAddress = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountAddress
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new application within your account
   */
  createApplication(
    req: operations.CreateApplicationRequest,
    security: operations.CreateApplicationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateApplicationRequest(req);
    }

    let baseURL: string = operations.CreateApplicationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Applications.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateApplicationResponse =
        new operations.CreateApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountApplication = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountApplication
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new outgoing call to phones, SIP-enabled endpoints or Twilio Client connections
   */
  createCall(
    req: operations.CreateCallRequest,
    security: operations.CreateCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCallRequest(req);
    }

    let baseURL: string = operations.CreateCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCallResponse =
        new operations.CreateCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCall = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCall
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a FeedbackSummary resource for a call
   */
  createCallFeedbackSummary(
    req: operations.CreateCallFeedbackSummaryRequest,
    security: operations.CreateCallFeedbackSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCallFeedbackSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCallFeedbackSummaryRequest(req);
    }

    let baseURL: string = operations.CreateCallFeedbackSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCallFeedbackSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCallFeedbackSummaryResponse =
        new operations.CreateCallFeedbackSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallFeedbackSummary = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallFeedbackSummary
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a recording for the call
   */
  createCallRecording(
    req: operations.CreateCallRecordingRequest,
    security: operations.CreateCallRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCallRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCallRecordingRequest(req);
    }

    let baseURL: string = operations.CreateCallRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateCallRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCallRecordingResponse =
        new operations.CreateCallRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallRecording = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallRecording
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Purchase a phone-number for the account.
   */
  createIncomingPhoneNumber(
    req: operations.CreateIncomingPhoneNumberRequest,
    security: operations.CreateIncomingPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIncomingPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIncomingPhoneNumberRequest(req);
    }

    let baseURL: string = operations.CreateIncomingPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIncomingPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIncomingPhoneNumberResponse =
        new operations.CreateIncomingPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumber = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountIncomingPhoneNumber
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Assign an Add-on installation to the Number specified.
   */
  createIncomingPhoneNumberAssignedAddOn(
    req: operations.CreateIncomingPhoneNumberAssignedAddOnRequest,
    security: operations.CreateIncomingPhoneNumberAssignedAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIncomingPhoneNumberAssignedAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIncomingPhoneNumberAssignedAddOnRequest(req);
    }

    let baseURL: string =
      operations.CreateIncomingPhoneNumberAssignedAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIncomingPhoneNumberAssignedAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIncomingPhoneNumberAssignedAddOnResponse =
        new operations.CreateIncomingPhoneNumberAssignedAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
              );
          }
          break;
      }

      return res;
    });
  }

  createIncomingPhoneNumberLocal(
    req: operations.CreateIncomingPhoneNumberLocalRequest,
    security: operations.CreateIncomingPhoneNumberLocalSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIncomingPhoneNumberLocalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIncomingPhoneNumberLocalRequest(req);
    }

    let baseURL: string =
      operations.CreateIncomingPhoneNumberLocalServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIncomingPhoneNumberLocalSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIncomingPhoneNumberLocalResponse =
        new operations.CreateIncomingPhoneNumberLocalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal
              );
          }
          break;
      }

      return res;
    });
  }

  createIncomingPhoneNumberMobile(
    req: operations.CreateIncomingPhoneNumberMobileRequest,
    security: operations.CreateIncomingPhoneNumberMobileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIncomingPhoneNumberMobileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIncomingPhoneNumberMobileRequest(req);
    }

    let baseURL: string =
      operations.CreateIncomingPhoneNumberMobileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIncomingPhoneNumberMobileSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIncomingPhoneNumberMobileResponse =
        new operations.CreateIncomingPhoneNumberMobileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile
              );
          }
          break;
      }

      return res;
    });
  }

  createIncomingPhoneNumberTollFree(
    req: operations.CreateIncomingPhoneNumberTollFreeRequest,
    security: operations.CreateIncomingPhoneNumberTollFreeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIncomingPhoneNumberTollFreeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIncomingPhoneNumberTollFreeRequest(req);
    }

    let baseURL: string =
      operations.CreateIncomingPhoneNumberTollFreeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIncomingPhoneNumberTollFreeSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIncomingPhoneNumberTollFreeResponse =
        new operations.CreateIncomingPhoneNumberTollFreeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Send a message from the account used to make the request
   */
  createMessage(
    req: operations.CreateMessageRequest,
    security: operations.CreateMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateMessageRequest(req);
    }

    let baseURL: string = operations.CreateMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateMessageResponse =
        new operations.CreateMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountMessage = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountMessage
            );
          }
          break;
      }

      return res;
    });
  }

  createMessageFeedback(
    req: operations.CreateMessageFeedbackRequest,
    security: operations.CreateMessageFeedbackSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateMessageFeedbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateMessageFeedbackRequest(req);
    }

    let baseURL: string = operations.CreateMessageFeedbackServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateMessageFeedbackSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateMessageFeedbackResponse =
        new operations.CreateMessageFeedbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountMessageMessageFeedback = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountMessageMessageFeedback
            );
          }
          break;
      }

      return res;
    });
  }

  createNewKey(
    req: operations.CreateNewKeyRequest,
    security: operations.CreateNewKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNewKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNewKeyRequest(req);
    }

    let baseURL: string = operations.CreateNewKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Keys.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateNewKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNewKeyResponse =
        new operations.CreateNewKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountNewKey = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountNewKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Signing Key for the account making the request.
   */
  createNewSigningKey(
    req: operations.CreateNewSigningKeyRequest,
    security: operations.CreateNewSigningKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNewSigningKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNewSigningKeyRequest(req);
    }

    let baseURL: string = operations.CreateNewSigningKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SigningKeys.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateNewSigningKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNewSigningKeyResponse =
        new operations.CreateNewSigningKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountNewSigningKey = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountNewSigningKey
            );
          }
          break;
      }

      return res;
    });
  }

  createParticipant(
    req: operations.CreateParticipantRequest,
    security: operations.CreateParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateParticipantRequest(req);
    }

    let baseURL: string = operations.CreateParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateParticipantResponse =
        new operations.CreateParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConferenceParticipant = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConferenceParticipant
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * create an instance of payments. This will start a new payments session
   */
  createPayments(
    req: operations.CreatePaymentsRequest,
    security: operations.CreatePaymentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePaymentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePaymentsRequest(req);
    }

    let baseURL: string = operations.CreatePaymentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreatePaymentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePaymentsResponse =
        new operations.CreatePaymentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallPayments = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallPayments
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a queue
   */
  createQueue(
    req: operations.CreateQueueRequest,
    security: operations.CreateQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateQueueRequest(req);
    }

    let baseURL: string = operations.CreateQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateQueueResponse =
        new operations.CreateQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountQueue = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountQueue
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new credential list mapping resource
   */
  createSipAuthCallsCredentialListMapping(
    req: operations.CreateSipAuthCallsCredentialListMappingRequest,
    security: operations.CreateSipAuthCallsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipAuthCallsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipAuthCallsCredentialListMappingRequest(req);
    }

    let baseURL: string =
      operations.CreateSipAuthCallsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipAuthCallsCredentialListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipAuthCallsCredentialListMappingResponse =
        new operations.CreateSipAuthCallsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new IP Access Control List mapping
   */
  createSipAuthCallsIpAccessControlListMapping(
    req: operations.CreateSipAuthCallsIpAccessControlListMappingRequest,
    security: operations.CreateSipAuthCallsIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipAuthCallsIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipAuthCallsIpAccessControlListMappingRequest(
        req
      );
    }

    let baseURL: string =
      operations.CreateSipAuthCallsIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CreateSipAuthCallsIpAccessControlListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipAuthCallsIpAccessControlListMappingResponse =
        new operations.CreateSipAuthCallsIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new credential list mapping resource
   */
  createSipAuthRegistrationsCredentialListMapping(
    req: operations.CreateSipAuthRegistrationsCredentialListMappingRequest,
    security: operations.CreateSipAuthRegistrationsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipAuthRegistrationsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateSipAuthRegistrationsCredentialListMappingRequest(
          req
        );
    }

    let baseURL: string =
      operations.CreateSipAuthRegistrationsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CreateSipAuthRegistrationsCredentialListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipAuthRegistrationsCredentialListMappingResponse =
        new operations.CreateSipAuthRegistrationsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new credential resource.
   */
  createSipCredential(
    req: operations.CreateSipCredentialRequest,
    security: operations.CreateSipCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipCredentialRequest(req);
    }

    let baseURL: string = operations.CreateSipCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipCredentialResponse =
        new operations.CreateSipCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipCredentialListSipCredential =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipCredentialListSipCredential
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Credential List
   */
  createSipCredentialList(
    req: operations.CreateSipCredentialListRequest,
    security: operations.CreateSipCredentialListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipCredentialListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipCredentialListRequest(req);
    }

    let baseURL: string = operations.CreateSipCredentialListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipCredentialListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipCredentialListResponse =
        new operations.CreateSipCredentialListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipCredentialList = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipCredentialList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a CredentialListMapping resource for an account.
   */
  createSipCredentialListMapping(
    req: operations.CreateSipCredentialListMappingRequest,
    security: operations.CreateSipCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipCredentialListMappingRequest(req);
    }

    let baseURL: string =
      operations.CreateSipCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipCredentialListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipCredentialListMappingResponse =
        new operations.CreateSipCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipCredentialListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipCredentialListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Domain
   */
  createSipDomain(
    req: operations.CreateSipDomainRequest,
    security: operations.CreateSipDomainSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipDomainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipDomainRequest(req);
    }

    let baseURL: string = operations.CreateSipDomainServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipDomainSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipDomainResponse =
        new operations.CreateSipDomainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomain = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipDomain
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new IpAccessControlList resource
   */
  createSipIpAccessControlList(
    req: operations.CreateSipIpAccessControlListRequest,
    security: operations.CreateSipIpAccessControlListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipIpAccessControlListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipIpAccessControlListRequest(req);
    }

    let baseURL: string = operations.CreateSipIpAccessControlListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipIpAccessControlListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipIpAccessControlListResponse =
        new operations.CreateSipIpAccessControlListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipIpAccessControlList = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipIpAccessControlList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new IpAccessControlListMapping resource.
   */
  createSipIpAccessControlListMapping(
    req: operations.CreateSipIpAccessControlListMappingRequest,
    security: operations.CreateSipIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipIpAccessControlListMappingRequest(req);
    }

    let baseURL: string =
      operations.CreateSipIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipIpAccessControlListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipIpAccessControlListMappingResponse =
        new operations.CreateSipIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipIpAccessControlListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new IpAddress resource.
   */
  createSipIpAddress(
    req: operations.CreateSipIpAddressRequest,
    security: operations.CreateSipIpAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSipIpAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSipIpAddressRequest(req);
    }

    let baseURL: string = operations.CreateSipIpAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSipIpAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSipIpAddressResponse =
        new operations.CreateSipIpAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipIpAccessControlListSipIpAddress =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipIpAccessControlListSipIpAddress
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Siprec
   */
  createSiprec(
    req: operations.CreateSiprecRequest,
    security: operations.CreateSiprecSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSiprecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSiprecRequest(req);
    }

    let baseURL: string = operations.CreateSiprecServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSiprecSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSiprecResponse =
        new operations.CreateSiprecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallSiprec = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallSiprec
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Stream
   */
  createStream(
    req: operations.CreateStreamRequest,
    security: operations.CreateStreamSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateStreamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateStreamRequest(req);
    }

    let baseURL: string = operations.CreateStreamServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateStreamSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateStreamResponse =
        new operations.CreateStreamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallStream = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallStream
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new token for ICE servers
   */
  createToken(
    req: operations.CreateTokenRequest,
    security: operations.CreateTokenSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTokenRequest(req);
    }

    let baseURL: string = operations.CreateTokenServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Tokens.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateTokenSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTokenResponse =
        new operations.CreateTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountToken = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountToken
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new UsageTrigger
   */
  createUsageTrigger(
    req: operations.CreateUsageTriggerRequest,
    security: operations.CreateUsageTriggerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUsageTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUsageTriggerRequest(req);
    }

    let baseURL: string = operations.CreateUsageTriggerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUsageTriggerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUsageTriggerResponse =
        new operations.CreateUsageTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountUsageUsageTrigger = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountUsageUsageTrigger
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new User Defined Message for the given Call SID.
   */
  createUserDefinedMessage(
    req: operations.CreateUserDefinedMessageRequest,
    security: operations.CreateUserDefinedMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUserDefinedMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUserDefinedMessageRequest(req);
    }

    let baseURL: string = operations.CreateUserDefinedMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/UserDefinedMessages.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUserDefinedMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUserDefinedMessageResponse =
        new operations.CreateUserDefinedMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallUserDefinedMessage = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallUserDefinedMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Subscribe to User Defined Messages for a given Call SID.
   */
  createUserDefinedMessageSubscription(
    req: operations.CreateUserDefinedMessageSubscriptionRequest,
    security: operations.CreateUserDefinedMessageSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUserDefinedMessageSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUserDefinedMessageSubscriptionRequest(req);
    }

    let baseURL: string =
      operations.CreateUserDefinedMessageSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/UserDefinedMessageSubscriptions.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUserDefinedMessageSubscriptionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUserDefinedMessageSubscriptionResponse =
        new operations.CreateUserDefinedMessageSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallUserDefinedMessageSubscription =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountCallUserDefinedMessageSubscription
              );
          }
          break;
      }

      return res;
    });
  }

  createValidationRequest(
    req: operations.CreateValidationRequestRequest,
    security: operations.CreateValidationRequestSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateValidationRequestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateValidationRequestRequest(req);
    }

    let baseURL: string = operations.CreateValidationRequestServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateValidationRequestSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateValidationRequestResponse =
        new operations.CreateValidationRequestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountValidationRequest = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountValidationRequest
            );
          }
          break;
      }

      return res;
    });
  }

  deleteAddress(
    req: operations.DeleteAddressRequest,
    security: operations.DeleteAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAddressRequest(req);
    }

    let baseURL: string = operations.DeleteAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAddressResponse =
        new operations.DeleteAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete the application by the specified application sid
   */
  deleteApplication(
    req: operations.DeleteApplicationRequest,
    security: operations.DeleteApplicationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApplicationRequest(req);
    }

    let baseURL: string = operations.DeleteApplicationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApplicationResponse =
        new operations.DeleteApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Call record from your account. Once the record is deleted, it will no longer appear in the API and Account Portal logs.
   */
  deleteCall(
    req: operations.DeleteCallRequest,
    security: operations.DeleteCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCallRequest(req);
    }

    let baseURL: string = operations.DeleteCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCallResponse =
        new operations.DeleteCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a FeedbackSummary resource from a call
   */
  deleteCallFeedbackSummary(
    req: operations.DeleteCallFeedbackSummaryRequest,
    security: operations.DeleteCallFeedbackSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCallFeedbackSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCallFeedbackSummaryRequest(req);
    }

    let baseURL: string = operations.DeleteCallFeedbackSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCallFeedbackSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCallFeedbackSummaryResponse =
        new operations.DeleteCallFeedbackSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a recording from your account
   */
  deleteCallRecording(
    req: operations.DeleteCallRecordingRequest,
    security: operations.DeleteCallRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCallRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCallRecordingRequest(req);
    }

    let baseURL: string = operations.DeleteCallRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCallRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCallRecordingResponse =
        new operations.DeleteCallRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a recording from your account
   */
  deleteConferenceRecording(
    req: operations.DeleteConferenceRecordingRequest,
    security: operations.DeleteConferenceRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConferenceRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConferenceRecordingRequest(req);
    }

    let baseURL: string = operations.DeleteConferenceRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConferenceRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConferenceRecordingResponse =
        new operations.DeleteConferenceRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an instance of a connect-app
   */
  deleteConnectApp(
    req: operations.DeleteConnectAppRequest,
    security: operations.DeleteConnectAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConnectAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConnectAppRequest(req);
    }

    let baseURL: string = operations.DeleteConnectAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConnectAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConnectAppResponse =
        new operations.DeleteConnectAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a phone-numbers belonging to the account used to make the request.
   */
  deleteIncomingPhoneNumber(
    req: operations.DeleteIncomingPhoneNumberRequest,
    security: operations.DeleteIncomingPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteIncomingPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteIncomingPhoneNumberRequest(req);
    }

    let baseURL: string = operations.DeleteIncomingPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteIncomingPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteIncomingPhoneNumberResponse =
        new operations.DeleteIncomingPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove the assignment of an Add-on installation from the Number specified.
   */
  deleteIncomingPhoneNumberAssignedAddOn(
    req: operations.DeleteIncomingPhoneNumberAssignedAddOnRequest,
    security: operations.DeleteIncomingPhoneNumberAssignedAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteIncomingPhoneNumberAssignedAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteIncomingPhoneNumberAssignedAddOnRequest(req);
    }

    let baseURL: string =
      operations.DeleteIncomingPhoneNumberAssignedAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteIncomingPhoneNumberAssignedAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteIncomingPhoneNumberAssignedAddOnResponse =
        new operations.DeleteIncomingPhoneNumberAssignedAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteKey(
    req: operations.DeleteKeyRequest,
    security: operations.DeleteKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteKeyRequest(req);
    }

    let baseURL: string = operations.DeleteKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteKeyResponse =
        new operations.DeleteKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete media from your account. Once delete, you will no longer be billed
   */
  deleteMedia(
    req: operations.DeleteMediaRequest,
    security: operations.DeleteMediaSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteMediaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteMediaRequest(req);
    }

    let baseURL: string = operations.DeleteMediaServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteMediaSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteMediaResponse =
        new operations.DeleteMediaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a message record from your account
   */
  deleteMessage(
    req: operations.DeleteMessageRequest,
    security: operations.DeleteMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteMessageRequest(req);
    }

    let baseURL: string = operations.DeleteMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteMessageResponse =
        new operations.DeleteMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete the caller-id specified from the account
   */
  deleteOutgoingCallerId(
    req: operations.DeleteOutgoingCallerIdRequest,
    security: operations.DeleteOutgoingCallerIdSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteOutgoingCallerIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteOutgoingCallerIdRequest(req);
    }

    let baseURL: string = operations.DeleteOutgoingCallerIdServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteOutgoingCallerIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteOutgoingCallerIdResponse =
        new operations.DeleteOutgoingCallerIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Kick a participant from a given conference
   */
  deleteParticipant(
    req: operations.DeleteParticipantRequest,
    security: operations.DeleteParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteParticipantRequest(req);
    }

    let baseURL: string = operations.DeleteParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteParticipantResponse =
        new operations.DeleteParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an empty queue
   */
  deleteQueue(
    req: operations.DeleteQueueRequest,
    security: operations.DeleteQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteQueueRequest(req);
    }

    let baseURL: string = operations.DeleteQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteQueueResponse =
        new operations.DeleteQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a recording from your account
   */
  deleteRecording(
    req: operations.DeleteRecordingRequest,
    security: operations.DeleteRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRecordingRequest(req);
    }

    let baseURL: string = operations.DeleteRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRecordingResponse =
        new operations.DeleteRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a result and purge all associated Payloads
   */
  deleteRecordingAddOnResult(
    req: operations.DeleteRecordingAddOnResultRequest,
    security: operations.DeleteRecordingAddOnResultSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRecordingAddOnResultResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRecordingAddOnResultRequest(req);
    }

    let baseURL: string = operations.DeleteRecordingAddOnResultServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteRecordingAddOnResultSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRecordingAddOnResultResponse =
        new operations.DeleteRecordingAddOnResultResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a payload from the result along with all associated Data
   */
  deleteRecordingAddOnResultPayload(
    req: operations.DeleteRecordingAddOnResultPayloadRequest,
    security: operations.DeleteRecordingAddOnResultPayloadSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRecordingAddOnResultPayloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRecordingAddOnResultPayloadRequest(req);
    }

    let baseURL: string =
      operations.DeleteRecordingAddOnResultPayloadServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteRecordingAddOnResultPayloadSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRecordingAddOnResultPayloadResponse =
        new operations.DeleteRecordingAddOnResultPayloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteRecordingTranscription(
    req: operations.DeleteRecordingTranscriptionRequest,
    security: operations.DeleteRecordingTranscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRecordingTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRecordingTranscriptionRequest(req);
    }

    let baseURL: string = operations.DeleteRecordingTranscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteRecordingTranscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRecordingTranscriptionResponse =
        new operations.DeleteRecordingTranscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSigningKey(
    req: operations.DeleteSigningKeyRequest,
    security: operations.DeleteSigningKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSigningKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSigningKeyRequest(req);
    }

    let baseURL: string = operations.DeleteSigningKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSigningKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSigningKeyResponse =
        new operations.DeleteSigningKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a credential list mapping from the requested domain
   */
  deleteSipAuthCallsCredentialListMapping(
    req: operations.DeleteSipAuthCallsCredentialListMappingRequest,
    security: operations.DeleteSipAuthCallsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipAuthCallsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipAuthCallsCredentialListMappingRequest(req);
    }

    let baseURL: string =
      operations.DeleteSipAuthCallsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipAuthCallsCredentialListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipAuthCallsCredentialListMappingResponse =
        new operations.DeleteSipAuthCallsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an IP Access Control List mapping from the requested domain
   */
  deleteSipAuthCallsIpAccessControlListMapping(
    req: operations.DeleteSipAuthCallsIpAccessControlListMappingRequest,
    security: operations.DeleteSipAuthCallsIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipAuthCallsIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipAuthCallsIpAccessControlListMappingRequest(
        req
      );
    }

    let baseURL: string =
      operations.DeleteSipAuthCallsIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteSipAuthCallsIpAccessControlListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipAuthCallsIpAccessControlListMappingResponse =
        new operations.DeleteSipAuthCallsIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a credential list mapping from the requested domain
   */
  deleteSipAuthRegistrationsCredentialListMapping(
    req: operations.DeleteSipAuthRegistrationsCredentialListMappingRequest,
    security: operations.DeleteSipAuthRegistrationsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipAuthRegistrationsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSipAuthRegistrationsCredentialListMappingRequest(
          req
        );
    }

    let baseURL: string =
      operations.DeleteSipAuthRegistrationsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteSipAuthRegistrationsCredentialListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipAuthRegistrationsCredentialListMappingResponse =
        new operations.DeleteSipAuthRegistrationsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a credential resource.
   */
  deleteSipCredential(
    req: operations.DeleteSipCredentialRequest,
    security: operations.DeleteSipCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipCredentialRequest(req);
    }

    let baseURL: string = operations.DeleteSipCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipCredentialResponse =
        new operations.DeleteSipCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Credential List
   */
  deleteSipCredentialList(
    req: operations.DeleteSipCredentialListRequest,
    security: operations.DeleteSipCredentialListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipCredentialListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipCredentialListRequest(req);
    }

    let baseURL: string = operations.DeleteSipCredentialListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipCredentialListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipCredentialListResponse =
        new operations.DeleteSipCredentialListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a CredentialListMapping resource from an account.
   */
  deleteSipCredentialListMapping(
    req: operations.DeleteSipCredentialListMappingRequest,
    security: operations.DeleteSipCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipCredentialListMappingRequest(req);
    }

    let baseURL: string =
      operations.DeleteSipCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipCredentialListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipCredentialListMappingResponse =
        new operations.DeleteSipCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an instance of a Domain
   */
  deleteSipDomain(
    req: operations.DeleteSipDomainRequest,
    security: operations.DeleteSipDomainSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipDomainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipDomainRequest(req);
    }

    let baseURL: string = operations.DeleteSipDomainServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipDomainSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipDomainResponse =
        new operations.DeleteSipDomainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an IpAccessControlList from the requested account
   */
  deleteSipIpAccessControlList(
    req: operations.DeleteSipIpAccessControlListRequest,
    security: operations.DeleteSipIpAccessControlListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipIpAccessControlListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipIpAccessControlListRequest(req);
    }

    let baseURL: string = operations.DeleteSipIpAccessControlListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipIpAccessControlListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipIpAccessControlListResponse =
        new operations.DeleteSipIpAccessControlListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an IpAccessControlListMapping resource.
   */
  deleteSipIpAccessControlListMapping(
    req: operations.DeleteSipIpAccessControlListMappingRequest,
    security: operations.DeleteSipIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipIpAccessControlListMappingRequest(req);
    }

    let baseURL: string =
      operations.DeleteSipIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipIpAccessControlListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipIpAccessControlListMappingResponse =
        new operations.DeleteSipIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an IpAddress resource.
   */
  deleteSipIpAddress(
    req: operations.DeleteSipIpAddressRequest,
    security: operations.DeleteSipIpAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSipIpAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSipIpAddressRequest(req);
    }

    let baseURL: string = operations.DeleteSipIpAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSipIpAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSipIpAddressResponse =
        new operations.DeleteSipIpAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a transcription from the account used to make the request
   */
  deleteTranscription(
    req: operations.DeleteTranscriptionRequest,
    security: operations.DeleteTranscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTranscriptionRequest(req);
    }

    let baseURL: string = operations.DeleteTranscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTranscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTranscriptionResponse =
        new operations.DeleteTranscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUsageTrigger(
    req: operations.DeleteUsageTriggerRequest,
    security: operations.DeleteUsageTriggerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUsageTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUsageTriggerRequest(req);
    }

    let baseURL: string = operations.DeleteUsageTriggerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUsageTriggerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUsageTriggerResponse =
        new operations.DeleteUsageTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific User Defined Message Subscription.
   */
  deleteUserDefinedMessageSubscription(
    req: operations.DeleteUserDefinedMessageSubscriptionRequest,
    security: operations.DeleteUserDefinedMessageSubscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUserDefinedMessageSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUserDefinedMessageSubscriptionRequest(req);
    }

    let baseURL: string =
      operations.DeleteUserDefinedMessageSubscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/UserDefinedMessageSubscriptions/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUserDefinedMessageSubscriptionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUserDefinedMessageSubscriptionResponse =
        new operations.DeleteUserDefinedMessageSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the account specified by the provided Account Sid
   */
  fetchAccount(
    req: operations.FetchAccountRequest,
    security: operations.FetchAccountSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAccountRequest(req);
    }

    let baseURL: string = operations.FetchAccountServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAccountResponse =
        new operations.FetchAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010Account = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010Account
            );
          }
          break;
      }

      return res;
    });
  }

  fetchAddress(
    req: operations.FetchAddressRequest,
    security: operations.FetchAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAddressRequest(req);
    }

    let baseURL: string = operations.FetchAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAddressResponse =
        new operations.FetchAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountAddress = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountAddress
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the application specified by the provided sid
   */
  fetchApplication(
    req: operations.FetchApplicationRequest,
    security: operations.FetchApplicationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchApplicationRequest(req);
    }

    let baseURL: string = operations.FetchApplicationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchApplicationResponse =
        new operations.FetchApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountApplication = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountApplication
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an authorized-connect-app
   */
  fetchAuthorizedConnectApp(
    req: operations.FetchAuthorizedConnectAppRequest,
    security: operations.FetchAuthorizedConnectAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAuthorizedConnectAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAuthorizedConnectAppRequest(req);
    }

    let baseURL: string = operations.FetchAuthorizedConnectAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAuthorizedConnectAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAuthorizedConnectAppResponse =
        new operations.FetchAuthorizedConnectAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountAuthorizedConnectApp = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountAuthorizedConnectApp
            );
          }
          break;
      }

      return res;
    });
  }

  fetchAvailablePhoneNumberCountry(
    req: operations.FetchAvailablePhoneNumberCountryRequest,
    security: operations.FetchAvailablePhoneNumberCountrySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchAvailablePhoneNumberCountryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchAvailablePhoneNumberCountryRequest(req);
    }

    let baseURL: string =
      operations.FetchAvailablePhoneNumberCountryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchAvailablePhoneNumberCountrySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchAvailablePhoneNumberCountryResponse =
        new operations.FetchAvailablePhoneNumberCountryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountAvailablePhoneNumberCountry =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountAvailablePhoneNumberCountry
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the balance for an Account based on Account Sid. Balance changes may not be reflected immediately. Child accounts do not contain balance information
   */
  fetchBalance(
    req: operations.FetchBalanceRequest,
    security: operations.FetchBalanceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchBalanceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchBalanceRequest(req);
    }

    let baseURL: string = operations.FetchBalanceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Balance.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchBalanceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchBalanceResponse =
        new operations.FetchBalanceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountBalance = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountBalance
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the call specified by the provided Call SID
   */
  fetchCall(
    req: operations.FetchCallRequest,
    security: operations.FetchCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCallRequest(req);
    }

    let baseURL: string = operations.FetchCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCallResponse =
        new operations.FetchCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCall = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCall
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a Feedback resource from a call
   */
  fetchCallFeedback(
    req: operations.FetchCallFeedbackRequest,
    security: operations.FetchCallFeedbackSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCallFeedbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCallFeedbackRequest(req);
    }

    let baseURL: string = operations.FetchCallFeedbackServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCallFeedbackSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCallFeedbackResponse =
        new operations.FetchCallFeedbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallFeedback = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallFeedback
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a FeedbackSummary resource from a call
   */
  fetchCallFeedbackSummary(
    req: operations.FetchCallFeedbackSummaryRequest,
    security: operations.FetchCallFeedbackSummarySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCallFeedbackSummaryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCallFeedbackSummaryRequest(req);
    }

    let baseURL: string = operations.FetchCallFeedbackSummaryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCallFeedbackSummarySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCallFeedbackSummaryResponse =
        new operations.FetchCallFeedbackSummaryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallFeedbackSummary = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallFeedbackSummary
            );
          }
          break;
      }

      return res;
    });
  }

  fetchCallNotification(
    req: operations.FetchCallNotificationRequest,
    security: operations.FetchCallNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCallNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCallNotificationRequest(req);
    }

    let baseURL: string = operations.FetchCallNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCallNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCallNotificationResponse =
        new operations.FetchCallNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallNotificationInstance =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountCallCallNotificationInstance
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a recording for a call
   */
  fetchCallRecording(
    req: operations.FetchCallRecordingRequest,
    security: operations.FetchCallRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchCallRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchCallRecordingRequest(req);
    }

    let baseURL: string = operations.FetchCallRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchCallRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchCallRecordingResponse =
        new operations.FetchCallRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallRecording = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallRecording
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a conference
   */
  fetchConference(
    req: operations.FetchConferenceRequest,
    security: operations.FetchConferenceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConferenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConferenceRequest(req);
    }

    let baseURL: string = operations.FetchConferenceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConferenceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConferenceResponse =
        new operations.FetchConferenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConference = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConference
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a recording for a call
   */
  fetchConferenceRecording(
    req: operations.FetchConferenceRecordingRequest,
    security: operations.FetchConferenceRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConferenceRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConferenceRecordingRequest(req);
    }

    let baseURL: string = operations.FetchConferenceRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConferenceRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConferenceRecordingResponse =
        new operations.FetchConferenceRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConferenceConferenceRecording =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountConferenceConferenceRecording
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a connect-app
   */
  fetchConnectApp(
    req: operations.FetchConnectAppRequest,
    security: operations.FetchConnectAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConnectAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConnectAppRequest(req);
    }

    let baseURL: string = operations.FetchConnectAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConnectAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConnectAppResponse =
        new operations.FetchConnectAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConnectApp = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConnectApp
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an incoming-phone-number belonging to the account used to make the request.
   */
  fetchIncomingPhoneNumber(
    req: operations.FetchIncomingPhoneNumberRequest,
    security: operations.FetchIncomingPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchIncomingPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchIncomingPhoneNumberRequest(req);
    }

    let baseURL: string = operations.FetchIncomingPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchIncomingPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchIncomingPhoneNumberResponse =
        new operations.FetchIncomingPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumber = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountIncomingPhoneNumber
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an Add-on installation currently assigned to this Number.
   */
  fetchIncomingPhoneNumberAssignedAddOn(
    req: operations.FetchIncomingPhoneNumberAssignedAddOnRequest,
    security: operations.FetchIncomingPhoneNumberAssignedAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchIncomingPhoneNumberAssignedAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchIncomingPhoneNumberAssignedAddOnRequest(req);
    }

    let baseURL: string =
      operations.FetchIncomingPhoneNumberAssignedAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchIncomingPhoneNumberAssignedAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchIncomingPhoneNumberAssignedAddOnResponse =
        new operations.FetchIncomingPhoneNumberAssignedAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an Extension for the Assigned Add-on.
   */
  fetchIncomingPhoneNumberAssignedAddOnExtension(
    req: operations.FetchIncomingPhoneNumberAssignedAddOnExtensionRequest,
    security: operations.FetchIncomingPhoneNumberAssignedAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchIncomingPhoneNumberAssignedAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.FetchIncomingPhoneNumberAssignedAddOnExtensionRequest(
          req
        );
    }

    let baseURL: string =
      operations.FetchIncomingPhoneNumberAssignedAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.FetchIncomingPhoneNumberAssignedAddOnExtensionSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchIncomingPhoneNumberAssignedAddOnExtensionResponse =
        new operations.FetchIncomingPhoneNumberAssignedAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension
              );
          }
          break;
      }

      return res;
    });
  }

  fetchKey(
    req: operations.FetchKeyRequest,
    security: operations.FetchKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchKeyRequest(req);
    }

    let baseURL: string = operations.FetchKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchKeyResponse = new operations.FetchKeyResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountKey = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a single media instance belonging to the account used to make the request
   */
  fetchMedia(
    req: operations.FetchMediaRequest,
    security: operations.FetchMediaSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMediaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMediaRequest(req);
    }

    let baseURL: string = operations.FetchMediaServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMediaSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMediaResponse =
        new operations.FetchMediaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountMessageMedia = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountMessageMedia
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific member from the queue
   */
  fetchMember(
    req: operations.FetchMemberRequest,
    security: operations.FetchMemberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMemberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMemberRequest(req);
    }

    let baseURL: string = operations.FetchMemberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMemberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMemberResponse =
        new operations.FetchMemberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountQueueMember = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountQueueMember
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a message belonging to the account used to make the request
   */
  fetchMessage(
    req: operations.FetchMessageRequest,
    security: operations.FetchMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMessageRequest(req);
    }

    let baseURL: string = operations.FetchMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMessageResponse =
        new operations.FetchMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountMessage = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a notification belonging to the account used to make the request
   */
  fetchNotification(
    req: operations.FetchNotificationRequest,
    security: operations.FetchNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchNotificationRequest(req);
    }

    let baseURL: string = operations.FetchNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchNotificationResponse =
        new operations.FetchNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountNotificationInstance = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountNotificationInstance
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an outgoing-caller-id belonging to the account used to make the request
   */
  fetchOutgoingCallerId(
    req: operations.FetchOutgoingCallerIdRequest,
    security: operations.FetchOutgoingCallerIdSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchOutgoingCallerIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchOutgoingCallerIdRequest(req);
    }

    let baseURL: string = operations.FetchOutgoingCallerIdServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchOutgoingCallerIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchOutgoingCallerIdResponse =
        new operations.FetchOutgoingCallerIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountOutgoingCallerId = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountOutgoingCallerId
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a participant
   */
  fetchParticipant(
    req: operations.FetchParticipantRequest,
    security: operations.FetchParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchParticipantRequest(req);
    }

    let baseURL: string = operations.FetchParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchParticipantResponse =
        new operations.FetchParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConferenceParticipant = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConferenceParticipant
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a queue identified by the QueueSid
   */
  fetchQueue(
    req: operations.FetchQueueRequest,
    security: operations.FetchQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchQueueRequest(req);
    }

    let baseURL: string = operations.FetchQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchQueueResponse =
        new operations.FetchQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountQueue = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountQueue
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a recording
   */
  fetchRecording(
    req: operations.FetchRecordingRequest,
    security: operations.FetchRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRecordingRequest(req);
    }

    let baseURL: string = operations.FetchRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRecordingResponse =
        new operations.FetchRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountRecording = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountRecording
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an AddOnResult
   */
  fetchRecordingAddOnResult(
    req: operations.FetchRecordingAddOnResultRequest,
    security: operations.FetchRecordingAddOnResultSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRecordingAddOnResultResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRecordingAddOnResultRequest(req);
    }

    let baseURL: string = operations.FetchRecordingAddOnResultServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRecordingAddOnResultSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRecordingAddOnResultResponse =
        new operations.FetchRecordingAddOnResultResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountRecordingRecordingAddOnResult =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountRecordingRecordingAddOnResult
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a result payload
   */
  fetchRecordingAddOnResultPayload(
    req: operations.FetchRecordingAddOnResultPayloadRequest,
    security: operations.FetchRecordingAddOnResultPayloadSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRecordingAddOnResultPayloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRecordingAddOnResultPayloadRequest(req);
    }

    let baseURL: string =
      operations.FetchRecordingAddOnResultPayloadServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRecordingAddOnResultPayloadSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRecordingAddOnResultPayloadResponse =
        new operations.FetchRecordingAddOnResultPayloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload
              );
          }
          break;
      }

      return res;
    });
  }

  fetchRecordingTranscription(
    req: operations.FetchRecordingTranscriptionRequest,
    security: operations.FetchRecordingTranscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchRecordingTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchRecordingTranscriptionRequest(req);
    }

    let baseURL: string = operations.FetchRecordingTranscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchRecordingTranscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchRecordingTranscriptionResponse =
        new operations.FetchRecordingTranscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountRecordingRecordingTranscription =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountRecordingRecordingTranscription
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a short code
   */
  fetchShortCode(
    req: operations.FetchShortCodeRequest,
    security: operations.FetchShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchShortCodeRequest(req);
    }

    let baseURL: string = operations.FetchShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchShortCodeResponse =
        new operations.FetchShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountShortCode = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountShortCode
            );
          }
          break;
      }

      return res;
    });
  }

  fetchSigningKey(
    req: operations.FetchSigningKeyRequest,
    security: operations.FetchSigningKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSigningKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSigningKeyRequest(req);
    }

    let baseURL: string = operations.FetchSigningKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSigningKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSigningKeyResponse =
        new operations.FetchSigningKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSigningKey = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSigningKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific instance of a credential list mapping
   */
  fetchSipAuthCallsCredentialListMapping(
    req: operations.FetchSipAuthCallsCredentialListMappingRequest,
    security: operations.FetchSipAuthCallsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipAuthCallsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipAuthCallsCredentialListMappingRequest(req);
    }

    let baseURL: string =
      operations.FetchSipAuthCallsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipAuthCallsCredentialListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipAuthCallsCredentialListMappingResponse =
        new operations.FetchSipAuthCallsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific instance of an IP Access Control List mapping
   */
  fetchSipAuthCallsIpAccessControlListMapping(
    req: operations.FetchSipAuthCallsIpAccessControlListMappingRequest,
    security: operations.FetchSipAuthCallsIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipAuthCallsIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipAuthCallsIpAccessControlListMappingRequest(
        req
      );
    }

    let baseURL: string =
      operations.FetchSipAuthCallsIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.FetchSipAuthCallsIpAccessControlListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipAuthCallsIpAccessControlListMappingResponse =
        new operations.FetchSipAuthCallsIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific instance of a credential list mapping
   */
  fetchSipAuthRegistrationsCredentialListMapping(
    req: operations.FetchSipAuthRegistrationsCredentialListMappingRequest,
    security: operations.FetchSipAuthRegistrationsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipAuthRegistrationsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.FetchSipAuthRegistrationsCredentialListMappingRequest(
          req
        );
    }

    let baseURL: string =
      operations.FetchSipAuthRegistrationsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.FetchSipAuthRegistrationsCredentialListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipAuthRegistrationsCredentialListMappingResponse =
        new operations.FetchSipAuthRegistrationsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a single credential.
   */
  fetchSipCredential(
    req: operations.FetchSipCredentialRequest,
    security: operations.FetchSipCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipCredentialRequest(req);
    }

    let baseURL: string = operations.FetchSipCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipCredentialResponse =
        new operations.FetchSipCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipCredentialListSipCredential =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipCredentialListSipCredential
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a Credential List
   */
  fetchSipCredentialList(
    req: operations.FetchSipCredentialListRequest,
    security: operations.FetchSipCredentialListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipCredentialListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipCredentialListRequest(req);
    }

    let baseURL: string = operations.FetchSipCredentialListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipCredentialListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipCredentialListResponse =
        new operations.FetchSipCredentialListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipCredentialList = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipCredentialList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a single CredentialListMapping resource from an account.
   */
  fetchSipCredentialListMapping(
    req: operations.FetchSipCredentialListMappingRequest,
    security: operations.FetchSipCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipCredentialListMappingRequest(req);
    }

    let baseURL: string = operations.FetchSipCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipCredentialListMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipCredentialListMappingResponse =
        new operations.FetchSipCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipCredentialListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipCredentialListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a Domain
   */
  fetchSipDomain(
    req: operations.FetchSipDomainRequest,
    security: operations.FetchSipDomainSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipDomainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipDomainRequest(req);
    }

    let baseURL: string = operations.FetchSipDomainServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipDomainSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipDomainResponse =
        new operations.FetchSipDomainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomain = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipDomain
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific instance of an IpAccessControlList
   */
  fetchSipIpAccessControlList(
    req: operations.FetchSipIpAccessControlListRequest,
    security: operations.FetchSipIpAccessControlListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipIpAccessControlListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipIpAccessControlListRequest(req);
    }

    let baseURL: string = operations.FetchSipIpAccessControlListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipIpAccessControlListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipIpAccessControlListResponse =
        new operations.FetchSipIpAccessControlListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipIpAccessControlList = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipIpAccessControlList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an IpAccessControlListMapping resource.
   */
  fetchSipIpAccessControlListMapping(
    req: operations.FetchSipIpAccessControlListMappingRequest,
    security: operations.FetchSipIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipIpAccessControlListMappingRequest(req);
    }

    let baseURL: string =
      operations.FetchSipIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipIpAccessControlListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipIpAccessControlListMappingResponse =
        new operations.FetchSipIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomainSipIpAccessControlListMapping =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Read one IpAddress resource.
   */
  fetchSipIpAddress(
    req: operations.FetchSipIpAddressRequest,
    security: operations.FetchSipIpAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSipIpAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSipIpAddressRequest(req);
    }

    let baseURL: string = operations.FetchSipIpAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSipIpAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSipIpAddressResponse =
        new operations.FetchSipIpAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipIpAccessControlListSipIpAddress =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipIpAccessControlListSipIpAddress
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of a Transcription
   */
  fetchTranscription(
    req: operations.FetchTranscriptionRequest,
    security: operations.FetchTranscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchTranscriptionRequest(req);
    }

    let baseURL: string = operations.FetchTranscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchTranscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchTranscriptionResponse =
        new operations.FetchTranscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountTranscription = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountTranscription
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch and instance of a usage-trigger
   */
  fetchUsageTrigger(
    req: operations.FetchUsageTriggerRequest,
    security: operations.FetchUsageTriggerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUsageTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUsageTriggerRequest(req);
    }

    let baseURL: string = operations.FetchUsageTriggerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUsageTriggerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUsageTriggerResponse =
        new operations.FetchUsageTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountUsageUsageTrigger = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountUsageUsageTrigger
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a collection of Accounts belonging to the account used to make the request
   */
  listAccount(
    req: operations.ListAccountRequest,
    security: operations.ListAccountSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountRequest(req);
    }

    let baseURL: string = operations.ListAccountServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/2010-04-01/Accounts.json";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountResponse =
        new operations.ListAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAccountResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAccountListAccountResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAddress(
    req: operations.ListAddressRequest,
    security: operations.ListAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAddressRequest(req);
    }

    let baseURL: string = operations.ListAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Addresses.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAddressResponse =
        new operations.ListAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAddressResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAddressListAddressResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of applications representing an application within the requesting account
   */
  listApplication(
    req: operations.ListApplicationRequest,
    security: operations.ListApplicationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListApplicationRequest(req);
    }

    let baseURL: string = operations.ListApplicationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Applications.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListApplicationResponse =
        new operations.ListApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApplicationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListApplicationListApplicationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of authorized-connect-apps belonging to the account used to make the request
   */
  listAuthorizedConnectApp(
    req: operations.ListAuthorizedConnectAppRequest,
    security: operations.ListAuthorizedConnectAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAuthorizedConnectAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAuthorizedConnectAppRequest(req);
    }

    let baseURL: string = operations.ListAuthorizedConnectAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAuthorizedConnectAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAuthorizedConnectAppResponse =
        new operations.ListAuthorizedConnectAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAuthorizedConnectAppResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAuthorizedConnectAppListAuthorizedConnectAppResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberCountry(
    req: operations.ListAvailablePhoneNumberCountryRequest,
    security: operations.ListAvailablePhoneNumberCountrySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberCountryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberCountryRequest(req);
    }

    let baseURL: string =
      operations.ListAvailablePhoneNumberCountryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberCountrySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberCountryResponse =
        new operations.ListAvailablePhoneNumberCountryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberCountryResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAvailablePhoneNumberCountryListAvailablePhoneNumberCountryResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberLocal(
    req: operations.ListAvailablePhoneNumberLocalRequest,
    security: operations.ListAvailablePhoneNumberLocalSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberLocalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberLocalRequest(req);
    }

    let baseURL: string = operations.ListAvailablePhoneNumberLocalServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberLocalSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberLocalResponse =
        new operations.ListAvailablePhoneNumberLocalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberLocalResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAvailablePhoneNumberLocalListAvailablePhoneNumberLocalResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberMachineToMachine(
    req: operations.ListAvailablePhoneNumberMachineToMachineRequest,
    security: operations.ListAvailablePhoneNumberMachineToMachineSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberMachineToMachineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberMachineToMachineRequest(req);
    }

    let baseURL: string =
      operations.ListAvailablePhoneNumberMachineToMachineServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListAvailablePhoneNumberMachineToMachineSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberMachineToMachineResponse =
        new operations.ListAvailablePhoneNumberMachineToMachineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberMachineToMachineResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListAvailablePhoneNumberMachineToMachineListAvailablePhoneNumberMachineToMachineResponse
              );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberMobile(
    req: operations.ListAvailablePhoneNumberMobileRequest,
    security: operations.ListAvailablePhoneNumberMobileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberMobileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberMobileRequest(req);
    }

    let baseURL: string =
      operations.ListAvailablePhoneNumberMobileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberMobileSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberMobileResponse =
        new operations.ListAvailablePhoneNumberMobileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberMobileResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAvailablePhoneNumberMobileListAvailablePhoneNumberMobileResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberNational(
    req: operations.ListAvailablePhoneNumberNationalRequest,
    security: operations.ListAvailablePhoneNumberNationalSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberNationalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberNationalRequest(req);
    }

    let baseURL: string =
      operations.ListAvailablePhoneNumberNationalServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberNationalSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberNationalResponse =
        new operations.ListAvailablePhoneNumberNationalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberNationalResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAvailablePhoneNumberNationalListAvailablePhoneNumberNationalResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberSharedCost(
    req: operations.ListAvailablePhoneNumberSharedCostRequest,
    security: operations.ListAvailablePhoneNumberSharedCostSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberSharedCostResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberSharedCostRequest(req);
    }

    let baseURL: string =
      operations.ListAvailablePhoneNumberSharedCostServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberSharedCostSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberSharedCostResponse =
        new operations.ListAvailablePhoneNumberSharedCostResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberSharedCostResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListAvailablePhoneNumberSharedCostListAvailablePhoneNumberSharedCostResponse
              );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberTollFree(
    req: operations.ListAvailablePhoneNumberTollFreeRequest,
    security: operations.ListAvailablePhoneNumberTollFreeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberTollFreeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberTollFreeRequest(req);
    }

    let baseURL: string =
      operations.ListAvailablePhoneNumberTollFreeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberTollFreeSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberTollFreeResponse =
        new operations.ListAvailablePhoneNumberTollFreeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberTollFreeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAvailablePhoneNumberTollFreeListAvailablePhoneNumberTollFreeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listAvailablePhoneNumberVoip(
    req: operations.ListAvailablePhoneNumberVoipRequest,
    security: operations.ListAvailablePhoneNumberVoipSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAvailablePhoneNumberVoipResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAvailablePhoneNumberVoipRequest(req);
    }

    let baseURL: string = operations.ListAvailablePhoneNumberVoipServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAvailablePhoneNumberVoipSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAvailablePhoneNumberVoipResponse =
        new operations.ListAvailablePhoneNumberVoipResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAvailablePhoneNumberVoipResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListAvailablePhoneNumberVoipListAvailablePhoneNumberVoipResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a collection of calls made to and from your account
   */
  listCall(
    req: operations.ListCallRequest,
    security: operations.ListCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCallRequest(req);
    }

    let baseURL: string = operations.ListCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCallResponse = new operations.ListCallResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCallResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCallListCallResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all events for a call.
   */
  listCallEvent(
    req: operations.ListCallEventRequest,
    security: operations.ListCallEventSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCallEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCallEventRequest(req);
    }

    let baseURL: string = operations.ListCallEventServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCallEventSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCallEventResponse =
        new operations.ListCallEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCallEventResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCallEventListCallEventResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listCallNotification(
    req: operations.ListCallNotificationRequest,
    security: operations.ListCallNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCallNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCallNotificationRequest(req);
    }

    let baseURL: string = operations.ListCallNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCallNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCallNotificationResponse =
        new operations.ListCallNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCallNotificationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCallNotificationListCallNotificationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of recordings belonging to the call used to make the request
   */
  listCallRecording(
    req: operations.ListCallRecordingRequest,
    security: operations.ListCallRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCallRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCallRecordingRequest(req);
    }

    let baseURL: string = operations.ListCallRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListCallRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCallRecordingResponse =
        new operations.ListCallRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCallRecordingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListCallRecordingListCallRecordingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of conferences belonging to the account used to make the request
   */
  listConference(
    req: operations.ListConferenceRequest,
    security: operations.ListConferenceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConferenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConferenceRequest(req);
    }

    let baseURL: string = operations.ListConferenceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConferenceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConferenceResponse =
        new operations.ListConferenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConferenceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConferenceListConferenceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of recordings belonging to the call used to make the request
   */
  listConferenceRecording(
    req: operations.ListConferenceRecordingRequest,
    security: operations.ListConferenceRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConferenceRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConferenceRecordingRequest(req);
    }

    let baseURL: string = operations.ListConferenceRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConferenceRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConferenceRecordingResponse =
        new operations.ListConferenceRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConferenceRecordingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConferenceRecordingListConferenceRecordingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of connect-apps belonging to the account used to make the request
   */
  listConnectApp(
    req: operations.ListConnectAppRequest,
    security: operations.ListConnectAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConnectAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConnectAppRequest(req);
    }

    let baseURL: string = operations.ListConnectAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/ConnectApps.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConnectAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConnectAppResponse =
        new operations.ListConnectAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConnectAppResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConnectAppListConnectAppResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listDependentPhoneNumber(
    req: operations.ListDependentPhoneNumberRequest,
    security: operations.ListDependentPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDependentPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDependentPhoneNumberRequest(req);
    }

    let baseURL: string = operations.ListDependentPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDependentPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDependentPhoneNumberResponse =
        new operations.ListDependentPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDependentPhoneNumberResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDependentPhoneNumberListDependentPhoneNumberResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of incoming-phone-numbers belonging to the account used to make the request.
   */
  listIncomingPhoneNumber(
    req: operations.ListIncomingPhoneNumberRequest,
    security: operations.ListIncomingPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIncomingPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIncomingPhoneNumberRequest(req);
    }

    let baseURL: string = operations.ListIncomingPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIncomingPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIncomingPhoneNumberResponse =
        new operations.ListIncomingPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIncomingPhoneNumberResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListIncomingPhoneNumberListIncomingPhoneNumberResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Add-on installations currently assigned to this Number.
   */
  listIncomingPhoneNumberAssignedAddOn(
    req: operations.ListIncomingPhoneNumberAssignedAddOnRequest,
    security: operations.ListIncomingPhoneNumberAssignedAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIncomingPhoneNumberAssignedAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIncomingPhoneNumberAssignedAddOnRequest(req);
    }

    let baseURL: string =
      operations.ListIncomingPhoneNumberAssignedAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIncomingPhoneNumberAssignedAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIncomingPhoneNumberAssignedAddOnResponse =
        new operations.ListIncomingPhoneNumberAssignedAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIncomingPhoneNumberAssignedAddOnResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListIncomingPhoneNumberAssignedAddOnListIncomingPhoneNumberAssignedAddOnResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Extensions for the Assigned Add-on.
   */
  listIncomingPhoneNumberAssignedAddOnExtension(
    req: operations.ListIncomingPhoneNumberAssignedAddOnExtensionRequest,
    security: operations.ListIncomingPhoneNumberAssignedAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIncomingPhoneNumberAssignedAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIncomingPhoneNumberAssignedAddOnExtensionRequest(
        req
      );
    }

    let baseURL: string =
      operations.ListIncomingPhoneNumberAssignedAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListIncomingPhoneNumberAssignedAddOnExtensionSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIncomingPhoneNumberAssignedAddOnExtensionResponse =
        new operations.ListIncomingPhoneNumberAssignedAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIncomingPhoneNumberAssignedAddOnExtensionResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListIncomingPhoneNumberAssignedAddOnExtensionListIncomingPhoneNumberAssignedAddOnExtensionResponse
              );
          }
          break;
      }

      return res;
    });
  }

  listIncomingPhoneNumberLocal(
    req: operations.ListIncomingPhoneNumberLocalRequest,
    security: operations.ListIncomingPhoneNumberLocalSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIncomingPhoneNumberLocalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIncomingPhoneNumberLocalRequest(req);
    }

    let baseURL: string = operations.ListIncomingPhoneNumberLocalServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIncomingPhoneNumberLocalSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIncomingPhoneNumberLocalResponse =
        new operations.ListIncomingPhoneNumberLocalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIncomingPhoneNumberLocalResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListIncomingPhoneNumberLocalListIncomingPhoneNumberLocalResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listIncomingPhoneNumberMobile(
    req: operations.ListIncomingPhoneNumberMobileRequest,
    security: operations.ListIncomingPhoneNumberMobileSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIncomingPhoneNumberMobileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIncomingPhoneNumberMobileRequest(req);
    }

    let baseURL: string = operations.ListIncomingPhoneNumberMobileServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIncomingPhoneNumberMobileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIncomingPhoneNumberMobileResponse =
        new operations.ListIncomingPhoneNumberMobileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIncomingPhoneNumberMobileResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListIncomingPhoneNumberMobileListIncomingPhoneNumberMobileResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listIncomingPhoneNumberTollFree(
    req: operations.ListIncomingPhoneNumberTollFreeRequest,
    security: operations.ListIncomingPhoneNumberTollFreeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIncomingPhoneNumberTollFreeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIncomingPhoneNumberTollFreeRequest(req);
    }

    let baseURL: string =
      operations.ListIncomingPhoneNumberTollFreeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIncomingPhoneNumberTollFreeSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIncomingPhoneNumberTollFreeResponse =
        new operations.ListIncomingPhoneNumberTollFreeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIncomingPhoneNumberTollFreeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListIncomingPhoneNumberTollFreeListIncomingPhoneNumberTollFreeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listKey(
    req: operations.ListKeyRequest,
    security: operations.ListKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListKeyRequest(req);
    }

    let baseURL: string = operations.ListKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Keys.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListKeyResponse = new operations.ListKeyResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listKeyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListKeyListKeyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Media resources belonging to the account used to make the request
   */
  listMedia(
    req: operations.ListMediaRequest,
    security: operations.ListMediaSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMediaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMediaRequest(req);
    }

    let baseURL: string = operations.ListMediaServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMediaSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMediaResponse =
        new operations.ListMediaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMediaResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMediaListMediaResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the members of the queue
   */
  listMember(
    req: operations.ListMemberRequest,
    security: operations.ListMemberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMemberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMemberRequest(req);
    }

    let baseURL: string = operations.ListMemberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMemberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMemberResponse =
        new operations.ListMemberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMemberResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMemberListMemberResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of messages belonging to the account used to make the request
   */
  listMessage(
    req: operations.ListMessageRequest,
    security: operations.ListMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMessageRequest(req);
    }

    let baseURL: string = operations.ListMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMessageResponse =
        new operations.ListMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMessageResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMessageListMessageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of notifications belonging to the account used to make the request
   */
  listNotification(
    req: operations.ListNotificationRequest,
    security: operations.ListNotificationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListNotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListNotificationRequest(req);
    }

    let baseURL: string = operations.ListNotificationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Notifications.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListNotificationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListNotificationResponse =
        new operations.ListNotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNotificationResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListNotificationListNotificationResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of outgoing-caller-ids belonging to the account used to make the request
   */
  listOutgoingCallerId(
    req: operations.ListOutgoingCallerIdRequest,
    security: operations.ListOutgoingCallerIdSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListOutgoingCallerIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListOutgoingCallerIdRequest(req);
    }

    let baseURL: string = operations.ListOutgoingCallerIdServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListOutgoingCallerIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListOutgoingCallerIdResponse =
        new operations.ListOutgoingCallerIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listOutgoingCallerIdResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListOutgoingCallerIdListOutgoingCallerIdResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of participants belonging to the account used to make the request
   */
  listParticipant(
    req: operations.ListParticipantRequest,
    security: operations.ListParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListParticipantRequest(req);
    }

    let baseURL: string = operations.ListParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListParticipantResponse =
        new operations.ListParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listParticipantResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListParticipantListParticipantResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of queues belonging to the account used to make the request
   */
  listQueue(
    req: operations.ListQueueRequest,
    security: operations.ListQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListQueueRequest(req);
    }

    let baseURL: string = operations.ListQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListQueueResponse =
        new operations.ListQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listQueueResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListQueueListQueueResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of recordings belonging to the account used to make the request
   */
  listRecording(
    req: operations.ListRecordingRequest,
    security: operations.ListRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRecordingRequest(req);
    }

    let baseURL: string = operations.ListRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRecordingResponse =
        new operations.ListRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRecordingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRecordingListRecordingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of results belonging to the recording
   */
  listRecordingAddOnResult(
    req: operations.ListRecordingAddOnResultRequest,
    security: operations.ListRecordingAddOnResultSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRecordingAddOnResultResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRecordingAddOnResultRequest(req);
    }

    let baseURL: string = operations.ListRecordingAddOnResultServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRecordingAddOnResultSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRecordingAddOnResultResponse =
        new operations.ListRecordingAddOnResultResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRecordingAddOnResultResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRecordingAddOnResultListRecordingAddOnResultResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of payloads belonging to the AddOnResult
   */
  listRecordingAddOnResultPayload(
    req: operations.ListRecordingAddOnResultPayloadRequest,
    security: operations.ListRecordingAddOnResultPayloadSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRecordingAddOnResultPayloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRecordingAddOnResultPayloadRequest(req);
    }

    let baseURL: string =
      operations.ListRecordingAddOnResultPayloadServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRecordingAddOnResultPayloadSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRecordingAddOnResultPayloadResponse =
        new operations.ListRecordingAddOnResultPayloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRecordingAddOnResultPayloadResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRecordingAddOnResultPayloadListRecordingAddOnResultPayloadResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listRecordingTranscription(
    req: operations.ListRecordingTranscriptionRequest,
    security: operations.ListRecordingTranscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRecordingTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRecordingTranscriptionRequest(req);
    }

    let baseURL: string = operations.ListRecordingTranscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListRecordingTranscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRecordingTranscriptionResponse =
        new operations.ListRecordingTranscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRecordingTranscriptionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListRecordingTranscriptionListRecordingTranscriptionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of short-codes belonging to the account used to make the request
   */
  listShortCode(
    req: operations.ListShortCodeRequest,
    security: operations.ListShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListShortCodeRequest(req);
    }

    let baseURL: string = operations.ListShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListShortCodeResponse =
        new operations.ListShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listShortCodeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListShortCodeListShortCodeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSigningKey(
    req: operations.ListSigningKeyRequest,
    security: operations.ListSigningKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSigningKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSigningKeyRequest(req);
    }

    let baseURL: string = operations.ListSigningKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SigningKeys.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSigningKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSigningKeyResponse =
        new operations.ListSigningKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSigningKeyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSigningKeyListSigningKeyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of credential list mappings belonging to the domain used in the request
   */
  listSipAuthCallsCredentialListMapping(
    req: operations.ListSipAuthCallsCredentialListMappingRequest,
    security: operations.ListSipAuthCallsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipAuthCallsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipAuthCallsCredentialListMappingRequest(req);
    }

    let baseURL: string =
      operations.ListSipAuthCallsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipAuthCallsCredentialListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipAuthCallsCredentialListMappingResponse =
        new operations.ListSipAuthCallsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipAuthCallsCredentialListMappingResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListSipAuthCallsCredentialListMappingListSipAuthCallsCredentialListMappingResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of IP Access Control List mappings belonging to the domain used in the request
   */
  listSipAuthCallsIpAccessControlListMapping(
    req: operations.ListSipAuthCallsIpAccessControlListMappingRequest,
    security: operations.ListSipAuthCallsIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipAuthCallsIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipAuthCallsIpAccessControlListMappingRequest(
        req
      );
    }

    let baseURL: string =
      operations.ListSipAuthCallsIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListSipAuthCallsIpAccessControlListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipAuthCallsIpAccessControlListMappingResponse =
        new operations.ListSipAuthCallsIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipAuthCallsIpAccessControlListMappingResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListSipAuthCallsIpAccessControlListMappingListSipAuthCallsIpAccessControlListMappingResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of credential list mappings belonging to the domain used in the request
   */
  listSipAuthRegistrationsCredentialListMapping(
    req: operations.ListSipAuthRegistrationsCredentialListMappingRequest,
    security: operations.ListSipAuthRegistrationsCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipAuthRegistrationsCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipAuthRegistrationsCredentialListMappingRequest(
        req
      );
    }

    let baseURL: string =
      operations.ListSipAuthRegistrationsCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListSipAuthRegistrationsCredentialListMappingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipAuthRegistrationsCredentialListMappingResponse =
        new operations.ListSipAuthRegistrationsCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipAuthRegistrationsCredentialListMappingResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListSipAuthRegistrationsCredentialListMappingListSipAuthRegistrationsCredentialListMappingResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of credentials.
   */
  listSipCredential(
    req: operations.ListSipCredentialRequest,
    security: operations.ListSipCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipCredentialRequest(req);
    }

    let baseURL: string = operations.ListSipCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipCredentialResponse =
        new operations.ListSipCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipCredentialResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipCredentialListSipCredentialResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get All Credential Lists
   */
  listSipCredentialList(
    req: operations.ListSipCredentialListRequest,
    security: operations.ListSipCredentialListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipCredentialListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipCredentialListRequest(req);
    }

    let baseURL: string = operations.ListSipCredentialListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipCredentialListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipCredentialListResponse =
        new operations.ListSipCredentialListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipCredentialListResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipCredentialListListSipCredentialListResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Read multiple CredentialListMapping resources from an account.
   */
  listSipCredentialListMapping(
    req: operations.ListSipCredentialListMappingRequest,
    security: operations.ListSipCredentialListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipCredentialListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipCredentialListMappingRequest(req);
    }

    let baseURL: string = operations.ListSipCredentialListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipCredentialListMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipCredentialListMappingResponse =
        new operations.ListSipCredentialListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipCredentialListMappingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipCredentialListMappingListSipCredentialListMappingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of domains belonging to the account used to make the request
   */
  listSipDomain(
    req: operations.ListSipDomainRequest,
    security: operations.ListSipDomainSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipDomainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipDomainRequest(req);
    }

    let baseURL: string = operations.ListSipDomainServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipDomainSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipDomainResponse =
        new operations.ListSipDomainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipDomainResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipDomainListSipDomainResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of IpAccessControlLists that belong to the account used to make the request
   */
  listSipIpAccessControlList(
    req: operations.ListSipIpAccessControlListRequest,
    security: operations.ListSipIpAccessControlListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipIpAccessControlListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipIpAccessControlListRequest(req);
    }

    let baseURL: string = operations.ListSipIpAccessControlListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipIpAccessControlListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipIpAccessControlListResponse =
        new operations.ListSipIpAccessControlListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipIpAccessControlListResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipIpAccessControlListListSipIpAccessControlListResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of IpAccessControlListMapping resources.
   */
  listSipIpAccessControlListMapping(
    req: operations.ListSipIpAccessControlListMappingRequest,
    security: operations.ListSipIpAccessControlListMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipIpAccessControlListMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipIpAccessControlListMappingRequest(req);
    }

    let baseURL: string =
      operations.ListSipIpAccessControlListMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipIpAccessControlListMappingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipIpAccessControlListMappingResponse =
        new operations.ListSipIpAccessControlListMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipIpAccessControlListMappingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipIpAccessControlListMappingListSipIpAccessControlListMappingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Read multiple IpAddress resources.
   */
  listSipIpAddress(
    req: operations.ListSipIpAddressRequest,
    security: operations.ListSipIpAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSipIpAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSipIpAddressRequest(req);
    }

    let baseURL: string = operations.ListSipIpAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSipIpAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSipIpAddressResponse =
        new operations.ListSipIpAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSipIpAddressResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSipIpAddressListSipIpAddressResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of transcriptions belonging to the account used to make the request
   */
  listTranscription(
    req: operations.ListTranscriptionRequest,
    security: operations.ListTranscriptionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTranscriptionRequest(req);
    }

    let baseURL: string = operations.ListTranscriptionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Transcriptions.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTranscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTranscriptionResponse =
        new operations.ListTranscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTranscriptionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListTranscriptionListTranscriptionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of usage-records belonging to the account used to make the request
   */
  listUsageRecord(
    req: operations.ListUsageRecordRequest,
    security: operations.ListUsageRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordResponse =
        new operations.ListUsageRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordListUsageRecordResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordAllTime(
    req: operations.ListUsageRecordAllTimeRequest,
    security: operations.ListUsageRecordAllTimeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordAllTimeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordAllTimeRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordAllTimeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordAllTimeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordAllTimeResponse =
        new operations.ListUsageRecordAllTimeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordAllTimeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordAllTimeListUsageRecordAllTimeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordDaily(
    req: operations.ListUsageRecordDailyRequest,
    security: operations.ListUsageRecordDailySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordDailyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordDailyRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordDailyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordDailySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordDailyResponse =
        new operations.ListUsageRecordDailyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordDailyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordDailyListUsageRecordDailyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordLastMonth(
    req: operations.ListUsageRecordLastMonthRequest,
    security: operations.ListUsageRecordLastMonthSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordLastMonthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordLastMonthRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordLastMonthServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordLastMonthSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordLastMonthResponse =
        new operations.ListUsageRecordLastMonthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordLastMonthResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordLastMonthListUsageRecordLastMonthResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordMonthly(
    req: operations.ListUsageRecordMonthlyRequest,
    security: operations.ListUsageRecordMonthlySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordMonthlyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordMonthlyRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordMonthlyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordMonthlySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordMonthlyResponse =
        new operations.ListUsageRecordMonthlyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordMonthlyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordMonthlyListUsageRecordMonthlyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordThisMonth(
    req: operations.ListUsageRecordThisMonthRequest,
    security: operations.ListUsageRecordThisMonthSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordThisMonthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordThisMonthRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordThisMonthServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordThisMonthSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordThisMonthResponse =
        new operations.ListUsageRecordThisMonthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordThisMonthResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordThisMonthListUsageRecordThisMonthResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordToday(
    req: operations.ListUsageRecordTodayRequest,
    security: operations.ListUsageRecordTodaySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordTodayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordTodayRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordTodayServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordTodaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordTodayResponse =
        new operations.ListUsageRecordTodayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordTodayResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordTodayListUsageRecordTodayResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordYearly(
    req: operations.ListUsageRecordYearlyRequest,
    security: operations.ListUsageRecordYearlySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordYearlyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordYearlyRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordYearlyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordYearlySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordYearlyResponse =
        new operations.ListUsageRecordYearlyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordYearlyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordYearlyListUsageRecordYearlyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUsageRecordYesterday(
    req: operations.ListUsageRecordYesterdayRequest,
    security: operations.ListUsageRecordYesterdaySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageRecordYesterdayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageRecordYesterdayRequest(req);
    }

    let baseURL: string = operations.ListUsageRecordYesterdayServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageRecordYesterdaySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageRecordYesterdayResponse =
        new operations.ListUsageRecordYesterdayResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageRecordYesterdayResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageRecordYesterdayListUsageRecordYesterdayResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of usage-triggers belonging to the account used to make the request
   */
  listUsageTrigger(
    req: operations.ListUsageTriggerRequest,
    security: operations.ListUsageTriggerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUsageTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUsageTriggerRequest(req);
    }

    let baseURL: string = operations.ListUsageTriggerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUsageTriggerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUsageTriggerResponse =
        new operations.ListUsageTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsageTriggerResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUsageTriggerListUsageTriggerResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modify the properties of a given Account
   */
  updateAccount(
    req: operations.UpdateAccountRequest,
    security: operations.UpdateAccountSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAccountRequest(req);
    }

    let baseURL: string = operations.UpdateAccountServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAccountSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAccountResponse =
        new operations.UpdateAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010Account = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010Account
            );
          }
          break;
      }

      return res;
    });
  }

  updateAddress(
    req: operations.UpdateAddressRequest,
    security: operations.UpdateAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAddressRequest(req);
    }

    let baseURL: string = operations.UpdateAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAddressResponse =
        new operations.UpdateAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountAddress = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountAddress
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the application's properties
   */
  updateApplication(
    req: operations.UpdateApplicationRequest,
    security: operations.UpdateApplicationSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateApplicationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateApplicationRequest(req);
    }

    let baseURL: string = operations.UpdateApplicationServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateApplicationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateApplicationResponse =
        new operations.UpdateApplicationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountApplication = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountApplication
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Initiates a call redirect or terminates a call
   */
  updateCall(
    req: operations.UpdateCallRequest,
    security: operations.UpdateCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCallRequest(req);
    }

    let baseURL: string = operations.UpdateCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCallResponse =
        new operations.UpdateCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCall = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCall
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Feedback resource for a call
   */
  updateCallFeedback(
    req: operations.UpdateCallFeedbackRequest,
    security: operations.UpdateCallFeedbackSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCallFeedbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCallFeedbackRequest(req);
    }

    let baseURL: string = operations.UpdateCallFeedbackServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCallFeedbackSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCallFeedbackResponse =
        new operations.UpdateCallFeedbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallFeedback = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallFeedback
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes the status of the recording to paused, stopped, or in-progress. Note: Pass `Twilio.CURRENT` instead of recording sid to reference current active recording.
   */
  updateCallRecording(
    req: operations.UpdateCallRecordingRequest,
    security: operations.UpdateCallRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCallRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCallRecordingRequest(req);
    }

    let baseURL: string = operations.UpdateCallRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCallRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCallRecordingResponse =
        new operations.UpdateCallRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallCallRecording = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallCallRecording
            );
          }
          break;
      }

      return res;
    });
  }

  updateConference(
    req: operations.UpdateConferenceRequest,
    security: operations.UpdateConferenceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConferenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConferenceRequest(req);
    }

    let baseURL: string = operations.UpdateConferenceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConferenceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConferenceResponse =
        new operations.UpdateConferenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConference = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConference
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes the status of the recording to paused, stopped, or in-progress. Note: To use `Twilio.CURRENT`, pass it as recording sid.
   */
  updateConferenceRecording(
    req: operations.UpdateConferenceRecordingRequest,
    security: operations.UpdateConferenceRecordingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConferenceRecordingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConferenceRecordingRequest(req);
    }

    let baseURL: string = operations.UpdateConferenceRecordingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConferenceRecordingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConferenceRecordingResponse =
        new operations.UpdateConferenceRecordingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConferenceConferenceRecording =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountConferenceConferenceRecording
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a connect-app with the specified parameters
   */
  updateConnectApp(
    req: operations.UpdateConnectAppRequest,
    security: operations.UpdateConnectAppSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConnectAppResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConnectAppRequest(req);
    }

    let baseURL: string = operations.UpdateConnectAppServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConnectAppSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConnectAppResponse =
        new operations.UpdateConnectAppResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConnectApp = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConnectApp
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an incoming-phone-number instance.
   */
  updateIncomingPhoneNumber(
    req: operations.UpdateIncomingPhoneNumberRequest,
    security: operations.UpdateIncomingPhoneNumberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateIncomingPhoneNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateIncomingPhoneNumberRequest(req);
    }

    let baseURL: string = operations.UpdateIncomingPhoneNumberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateIncomingPhoneNumberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateIncomingPhoneNumberResponse =
        new operations.UpdateIncomingPhoneNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountIncomingPhoneNumber = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountIncomingPhoneNumber
            );
          }
          break;
      }

      return res;
    });
  }

  updateKey(
    req: operations.UpdateKeyRequest,
    security: operations.UpdateKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateKeyRequest(req);
    }

    let baseURL: string = operations.UpdateKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateKeyResponse =
        new operations.UpdateKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountKey = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Dequeue a member from a queue and have the member's call begin executing the TwiML document at that URL
   */
  updateMember(
    req: operations.UpdateMemberRequest,
    security: operations.UpdateMemberSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateMemberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateMemberRequest(req);
    }

    let baseURL: string = operations.UpdateMemberServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateMemberSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateMemberResponse =
        new operations.UpdateMemberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountQueueMember = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountQueueMember
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * To redact a message-body from a post-flight message record, post to the message instance resource with an empty body
   */
  updateMessage(
    req: operations.UpdateMessageRequest,
    security: operations.UpdateMessageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateMessageRequest(req);
    }

    let baseURL: string = operations.UpdateMessageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateMessageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateMessageResponse =
        new operations.UpdateMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountMessage = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountMessage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the caller-id
   */
  updateOutgoingCallerId(
    req: operations.UpdateOutgoingCallerIdRequest,
    security: operations.UpdateOutgoingCallerIdSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOutgoingCallerIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateOutgoingCallerIdRequest(req);
    }

    let baseURL: string = operations.UpdateOutgoingCallerIdServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateOutgoingCallerIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOutgoingCallerIdResponse =
        new operations.UpdateOutgoingCallerIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountOutgoingCallerId = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountOutgoingCallerId
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the properties of the participant
   */
  updateParticipant(
    req: operations.UpdateParticipantRequest,
    security: operations.UpdateParticipantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateParticipantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateParticipantRequest(req);
    }

    let baseURL: string = operations.UpdateParticipantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateParticipantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateParticipantResponse =
        new operations.UpdateParticipantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountConferenceParticipant = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountConferenceParticipant
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * update an instance of payments with different phases of payment flows.
   */
  updatePayments(
    req: operations.UpdatePaymentsRequest,
    security: operations.UpdatePaymentsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePaymentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePaymentsRequest(req);
    }

    let baseURL: string = operations.UpdatePaymentsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdatePaymentsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePaymentsResponse =
        new operations.UpdatePaymentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallPayments = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallPayments
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the queue with the new parameters
   */
  updateQueue(
    req: operations.UpdateQueueRequest,
    security: operations.UpdateQueueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateQueueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateQueueRequest(req);
    }

    let baseURL: string = operations.UpdateQueueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateQueueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateQueueResponse =
        new operations.UpdateQueueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountQueue = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountQueue
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a short code with the following parameters
   */
  updateShortCode(
    req: operations.UpdateShortCodeRequest,
    security: operations.UpdateShortCodeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateShortCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateShortCodeRequest(req);
    }

    let baseURL: string = operations.UpdateShortCodeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateShortCodeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateShortCodeResponse =
        new operations.UpdateShortCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountShortCode = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountShortCode
            );
          }
          break;
      }

      return res;
    });
  }

  updateSigningKey(
    req: operations.UpdateSigningKeyRequest,
    security: operations.UpdateSigningKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSigningKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSigningKeyRequest(req);
    }

    let baseURL: string = operations.UpdateSigningKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSigningKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSigningKeyResponse =
        new operations.UpdateSigningKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSigningKey = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSigningKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a credential resource.
   */
  updateSipCredential(
    req: operations.UpdateSipCredentialRequest,
    security: operations.UpdateSipCredentialSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSipCredentialResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSipCredentialRequest(req);
    }

    let baseURL: string = operations.UpdateSipCredentialServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSipCredentialSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSipCredentialResponse =
        new operations.UpdateSipCredentialResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipCredentialListSipCredential =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipCredentialListSipCredential
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Credential List
   */
  updateSipCredentialList(
    req: operations.UpdateSipCredentialListRequest,
    security: operations.UpdateSipCredentialListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSipCredentialListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSipCredentialListRequest(req);
    }

    let baseURL: string = operations.UpdateSipCredentialListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSipCredentialListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSipCredentialListResponse =
        new operations.UpdateSipCredentialListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipCredentialList = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipCredentialList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the attributes of a domain
   */
  updateSipDomain(
    req: operations.UpdateSipDomainRequest,
    security: operations.UpdateSipDomainSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSipDomainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSipDomainRequest(req);
    }

    let baseURL: string = operations.UpdateSipDomainServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSipDomainSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSipDomainResponse =
        new operations.UpdateSipDomainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipDomain = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipDomain
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rename an IpAccessControlList
   */
  updateSipIpAccessControlList(
    req: operations.UpdateSipIpAccessControlListRequest,
    security: operations.UpdateSipIpAccessControlListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSipIpAccessControlListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSipIpAccessControlListRequest(req);
    }

    let baseURL: string = operations.UpdateSipIpAccessControlListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSipIpAccessControlListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSipIpAccessControlListResponse =
        new operations.UpdateSipIpAccessControlListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipIpAccessControlList = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountSipSipIpAccessControlList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an IpAddress resource.
   */
  updateSipIpAddress(
    req: operations.UpdateSipIpAddressRequest,
    security: operations.UpdateSipIpAddressSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSipIpAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSipIpAddressRequest(req);
    }

    let baseURL: string = operations.UpdateSipIpAddressServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSipIpAddressSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSipIpAddressResponse =
        new operations.UpdateSipIpAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountSipSipIpAccessControlListSipIpAddress =
              utils.objectToClass(
                httpRes?.data,
                shared.ApiV2010AccountSipSipIpAccessControlListSipIpAddress
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop a Siprec using either the SID of the Siprec resource or the `name` used when creating the resource
   */
  updateSiprec(
    req: operations.UpdateSiprecRequest,
    security: operations.UpdateSiprecSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSiprecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSiprecRequest(req);
    }

    let baseURL: string = operations.UpdateSiprecServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSiprecSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSiprecResponse =
        new operations.UpdateSiprecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallSiprec = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallSiprec
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop a Stream using either the SID of the Stream resource or the `name` used when creating the resource
   */
  updateStream(
    req: operations.UpdateStreamRequest,
    security: operations.UpdateStreamSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateStreamResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateStreamRequest(req);
    }

    let baseURL: string = operations.UpdateStreamServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateStreamSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateStreamResponse =
        new operations.UpdateStreamResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountCallStream = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountCallStream
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an instance of a usage trigger
   */
  updateUsageTrigger(
    req: operations.UpdateUsageTriggerRequest,
    security: operations.UpdateUsageTriggerSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUsageTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUsageTriggerRequest(req);
    }

    let baseURL: string = operations.UpdateUsageTriggerServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUsageTriggerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUsageTriggerResponse =
        new operations.UpdateUsageTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiV2010AccountUsageUsageTrigger = utils.objectToClass(
              httpRes?.data,
              shared.ApiV2010AccountUsageUsageTrigger
            );
          }
          break;
      }

      return res;
    });
  }
}
