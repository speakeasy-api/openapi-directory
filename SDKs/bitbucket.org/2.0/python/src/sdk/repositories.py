"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Repositories:
    r"""A Git repository is a virtual storage of your project. It
    allows you to save versions of your code, which you can access
    when needed. The repo resource allows you to access public repos,
    or repos that belong to a specific workspace.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_repositories_workspace_repo_slug_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugResponse:
        r"""Delete a repository
        Deletes the repository. This is an irreversible operation.
        
        This does not affect its forks.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}', request)
        
        query_params = utils.get_query_params(operations.DeleteRepositoriesWorkspaceRepoSlugRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_hooks_uid_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDResponse:
        r"""Delete a webhook for a repository
        Deletes the specified webhook subscription from the given
        repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/hooks/{uid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugHooksUIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_permissions_config_groups_group_slug_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugResponse:
        r"""Delete an explicit group permission for a repository
        Deletes the repository group permission between the requested repository and group, if one exists.
        
        Only users with admin permission for the repository may access this resource.
        
        Example:
        
        $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial
        /geordi/permissions-config/groups/developers
        
        
        HTTP/1.1 204
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_permissions_config_users_selected_user_id_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDResponse:
        r"""Delete an explicit user permission for a repository
        Deletes the repository user permission between the requested repository and user, if one exists.
        
        Only users with admin permission for the repository may access this resource.
        
        The only authentication method for this endpoint is via app passwords.
        
        ```
        $ curl -X DELETE https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
        permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a
        
        
        HTTP/1.1 204
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories(self, request: operations.GetRepositoriesRequest, security: operations.GetRepositoriesSecurity) -> operations.GetRepositoriesResponse:
        r"""List public repositories
        Returns a paginated list of all public repositories.
        
        This endpoint also supports filtering and sorting of the results. See
        [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/repositories'
        
        query_params = utils.get_query_params(operations.GetRepositoriesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRepositories])
                res.paginated_repositories = out

        return res

    def get_repositories_workspace_(self, request: operations.GetRepositoriesWorkspaceRequest, security: operations.GetRepositoriesWorkspaceSecurity) -> operations.GetRepositoriesWorkspaceResponse:
        r"""List repositories in a workspace
        Returns a paginated list of all repositories owned by the specified
        workspace.
        
        The result can be narrowed down based on the authenticated user's role.
        
        E.g. with `?role=contributor`, only those repositories that the
        authenticated user has write access to are returned (this includes any
        repo the user is an admin on, as that implies write access).
        
        This endpoint also supports filtering and sorting of the results. See
        [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRequest, base_url, '/repositories/{workspace}', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRepositories])
                res.paginated_repositories = out
        elif http_res.status_code in [404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_(self, request: operations.GetRepositoriesWorkspaceRepoSlugRequest, security: operations.GetRepositoriesWorkspaceRepoSlugSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugResponse:
        r"""Get a repository
        Returns the object describing this repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_filehistory_commit_path_(self, request: operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathRequest, security: operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathResponse:
        r"""List commits that modified a file
        Returns a paginated list of commits that modified the specified file.
        
        Commits are returned in reverse chronological order. This is roughly
        equivalent to the following commands:
        
            $ git log --follow --date-order <sha> <path>
        
        By default, Bitbucket will follow renames and the path name in the
        returned entries reflects that. This can be turned off using the
        `?renames=false` query parameter.
        
        Results are returned in descending chronological order by default, and
        like most endpoints you can
        [filter and sort](/cloud/bitbucket/rest/intro/#filtering) the response to
        only provide exactly the data you want.
        
        For example, if you wanted to find commits made before 2011-05-18
        against a file named `README.rst`, but you only wanted the path and
        date, your query would look like this:
        
        ```
        $ curl 'https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/filehistory/master/README.rst'\
          '?fields=values.next,values.path,values.commit.date&q=commit.date<=2011-05-18'
        {
          \"values\": [
            {
              \"commit\": {
                \"date\": \"2011-05-17T07:32:09+00:00\"
              },
              \"path\": \"README.rst\"
            },
            {
              \"commit\": {
                \"date\": \"2011-05-16T06:33:28+00:00\"
              },
              \"path\": \"README.txt\"
            },
            {
              \"commit\": {
                \"date\": \"2011-05-16T06:15:39+00:00\"
              },
              \"path\": \"README.txt\"
            }
          ]
        }
        ```
        
        In the response you can see that the file was renamed to `README.rst`
        by the commit made on 2011-05-16, and was previously named `README.txt`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathRequest, base_url, '/repositories/{workspace}/{repo_slug}/filehistory/{commit}/{path}', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugFilehistoryCommitPathResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedFiles])
                res.paginated_files = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_forks(self, request: operations.GetRepositoriesWorkspaceRepoSlugForksRequest, security: operations.GetRepositoriesWorkspaceRepoSlugForksSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugForksResponse:
        r"""List repository forks
        Returns a paginated list of all the forks of the specified
        repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugForksRequest, base_url, '/repositories/{workspace}/{repo_slug}/forks', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugForksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugForksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRepositories])
                res.paginated_repositories = out

        return res

    def get_repositories_workspace_repo_slug_hooks(self, request: operations.GetRepositoriesWorkspaceRepoSlugHooksRequest, security: operations.GetRepositoriesWorkspaceRepoSlugHooksSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugHooksResponse:
        r"""List webhooks for a repository
        Returns a paginated list of webhooks installed on this repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugHooksRequest, base_url, '/repositories/{workspace}/{repo_slug}/hooks', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugHooksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedWebhookSubscriptions])
                res.paginated_webhook_subscriptions = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_hooks_uid_(self, request: operations.GetRepositoriesWorkspaceRepoSlugHooksUIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugHooksUIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugHooksUIDResponse:
        r"""Get a webhook for a repository
        Returns the webhook with the specified id installed on the specified
        repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugHooksUIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/hooks/{uid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugHooksUIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.webhook_subscription = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_override_settings(self, request: operations.GetRepositoriesWorkspaceRepoSlugOverrideSettingsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugOverrideSettingsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugOverrideSettingsResponse:
        r"""Retrieve the inheritance state for repository settings"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugOverrideSettingsRequest, base_url, '/repositories/{workspace}/{repo_slug}/override-settings', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugOverrideSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository_inheritance_state = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_permissions_config_groups(self, request: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsResponse:
        r"""List explicit group permissions for a repository
        Returns a paginated list of explicit group permissions for the given repository.
        This endpoint does not support BBQL features.
        
        Example:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups
        
        HTTP/1.1 200
        Location: https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups
        
        {
          \"pagelen\": 10,
          \"values\": [
            {
              \"type\": \"repository_group_permission\",
              \"group\": {
                \"type\": \"group\",
                \"name\": \"Administrators\",
                \"slug\": \"administrators\"
              },
              \"permission\": \"admin\",
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/
                           geordi/permissions-config/groups/administrators\"
                }
              }
            },
            {
              \"type\": \"repository_group_permission\",
              \"group\": {
                \"type\": \"group\",
                \"name\": \"Developers\",
                \"slug\": \"developers\"
              },
              \"permission\": \"read\",
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/
                           geordi/permissions-config/groups/developers\"
                }
              }
            }
          ],
          \"page\": 1,
          \"size\": 2
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/groups', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRepositoryGroupPermissions])
                res.paginated_repository_group_permissions = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_permissions_config_groups_group_slug_(self, request: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugRequest, security: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugResponse:
        r"""Get an explicit group permission for a repository
        Returns the group permission for a given group slug and repository
        
        Only users with admin permission for the repository may access this resource.
        
        Permissions can be:
        
        * `admin`
        * `write`
        * `read`
        * `none`
        
        Example:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers
        
        HTTP/1.1 200
        Location:
        https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers
        
        {
            \"type\": \"repository_group_permission\",
            \"group\": {
                \"type\": \"group\",
                \"name\": \"Developers\",
                \"slug\": \"developers\"
            },
            \"repository\": {
                \"type\": \"repository\",
                \"name\": \"geordi\",
                \"full_name\": \"atlassian_tutorial/geordi\",
                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"
            },
            \"permission\": \"read\",
            \"links\": {
              \"self\": {
                \"href\":
                \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\"
              }
            }
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository_group_permission = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_permissions_config_users(self, request: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersRequest, security: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersResponse:
        r"""List explicit user permissions for a repository
        Returns a paginated list of explicit user permissions for the given repository.
        This endpoint does not support BBQL features.
        
        Example:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/users
        
        {
          \"pagelen\": 10,
          \"values\": [
            {
                \"type\": \"repository_user_permission\",
                \"user\": {
                    \"type\": \"user\",
                    \"display_name\": \"Colin Cameron\",
                    \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",
                    \"account_id\": \"557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\"
                },
                \"permission\": \"admin\",
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
                             permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\"
                  }
                }
            },
            {
              \"type\": \"repository_user_permission\",
              \"user\": {
                \"type\": \"user\",
                \"display_name\": \"Sean Conaty\",
                \"uuid\": \"{504c3b62-8120-4f0c-a7bc-87800b9d6f70}\",
                \"account_id\": \"557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\"
              },
              \"permission\": \"write\",
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0//repositories/atlassian_tutorial/geordi/
                           permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324c\"
                }
              }
            }
          ],
          \"page\": 1,
          \"size\": 2
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/users', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRepositoryUserPermissions])
                res.paginated_repository_user_permissions = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_permissions_config_users_selected_user_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDResponse:
        r"""Get an explicit user permission for a repository
        Returns the explicit user permission for a given user and repository.
        
        Only users with admin permission for the repository may access this resource.
        
        Permissions can be:
        
        * `admin`
        * `write`
        * `read`
        * `none`
        
        Example:
        
        ```
        $ curl 'https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
                permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a'
        
        HTTP/1.1 200
        Location: 'https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
                   permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a'
        
        {
            \"type\": \"repository_user_permission\",
            \"user\": {
                \"type\": \"user\",
                \"display_name\": \"Colin Cameron\",
                \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",
                \"account_id\": \"557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\"
            },
            \"repository\": {
                \"type\": \"repository\",
                \"name\": \"geordi\",
                \"full_name\": \"atlassian_tutorial/geordi\",
                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"
            },
            \"permission\": \"admin\",
            \"links\": {
                \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
                             permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\"
                }
            }
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository_user_permission = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_src(self, request: operations.GetRepositoriesWorkspaceRepoSlugSrcRequest, security: operations.GetRepositoriesWorkspaceRepoSlugSrcSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugSrcResponse:
        r"""Get the root directory of the main branch
        This endpoint redirects the client to the directory listing of the
        root directory on the main branch.
        
        This is equivalent to directly hitting
        [/2.0/repositories/{username}/{repo_slug}/src/{commit}/{path}](src/%7Bcommit%7D/%7Bpath%7D)
        without having to know the name or SHA1 of the repo's main branch.
        
        To create new commits, [POST to this endpoint](#post)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugSrcRequest, base_url, '/repositories/{workspace}/{repo_slug}/src', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugSrcRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugSrcResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedTreeentries])
                res.paginated_treeentries = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_src_commit_path_(self, request: operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathRequest, security: operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathResponse:
        r"""Get file or directory contents
        This endpoints is used to retrieve the contents of a single file,
        or the contents of a directory at a specified revision.
        
        #### Raw file contents
        
        When `path` points to a file, this endpoint returns the raw contents.
        The response's Content-Type is derived from the filename
        extension (not from the contents). The file contents are not processed
        and no character encoding/recoding is performed and as a result no
        character encoding is included as part of the Content-Type.
        
        The `Content-Disposition` header will be \"attachment\" to prevent
        browsers from running executable files.
        
        If the file is managed by LFS, then a 301 redirect pointing to
        Atlassian's media services platform is returned.
        
        The response includes an ETag that is based on the contents of the file
        and its attributes. This means that an empty `__init__.py` always
        returns the same ETag, regardless on the directory it lives in, or the
        commit it is on.
        
        #### File meta data
        
        When the request for a file path includes the query parameter
        `?format=meta`, instead of returning the file's raw contents, Bitbucket
        instead returns the JSON object describing the file's properties:
        
        ```javascript
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests/__init__.py?format=meta
        {
          \"links\": {
            \"self\": {
              \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"
            },
            \"meta\": {
              \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"
            }
          },
          \"path\": \"tests/__init__.py\",
          \"commit\": {
            \"type\": \"commit\",
            \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",
            \"links\": {
              \"self\": {
                \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"
              },
              \"html\": {
                \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"
              }
            }
          },
          \"attributes\": [],
          \"type\": \"commit_file\",
          \"size\": 0
        }
        ```
        
        File objects contain an `attributes` element that contains a list of
        possible modifiers. Currently defined values are:
        
        * `link` -- indicates that the entry is a symbolic link. The contents
            of the file represent the path the link points to.
        * `executable` -- indicates that the file has the executable bit set.
        * `subrepository` -- indicates that the entry points to a submodule or
            subrepo. The contents of the file is the SHA1 of the repository
            pointed to.
        * `binary` -- indicates whether Bitbucket thinks the file is binary.
        
        This endpoint can provide an alternative to how a HEAD request can be
        used to check for the existence of a file, or a file's size without
        incurring the overhead of receiving its full contents.
        
        
        #### Directory listings
        
        When `path` points to a directory instead of a file, the response is a
        paginated list of directory and file objects in the same order as the
        underlying SCM system would return them.
        
        For example:
        
        ```javascript
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef/tests
        {
          \"pagelen\": 10,
          \"values\": [
            {
              \"path\": \"tests/test_project\",
              \"type\": \"commit_directory\",
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"
                },
                \"meta\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"
                }
              },
              \"commit\": {
                \"type\": \"commit\",
                \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"
                  },
                  \"html\": {
                    \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"
                  }
                }
              }
            },
            {
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py\"
                },
                \"meta\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/__init__.py?format=meta\"
                }
              },
              \"path\": \"tests/__init__.py\",
              \"commit\": {
                \"type\": \"commit\",
                \"hash\": \"eefd5ef5d3df01aed629f650959d6706d54cd335\",
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/commit/eefd5ef5d3df01aed629f650959d6706d54cd335\"
                  },
                  \"html\": {
                    \"href\": \"https://bitbucket.org/atlassian/bbql/commits/eefd5ef5d3df01aed629f650959d6706d54cd335\"
                  }
                }
              },
              \"attributes\": [],
              \"type\": \"commit_file\",
              \"size\": 0
            }
          ],
          \"page\": 1,
          \"size\": 2
        }
        ```
        
        When listing the contents of the repo's root directory, the use of a
        trailing slash at the end of the URL is required.
        
        The response by default is not recursive, meaning that only the direct contents of
        a path are returned. The response does not recurse down into
        subdirectories. In order to \"walk\" the entire directory tree, the
        client can either parse each response and follow the `self` links of each
        `commit_directory` object, or can specify a `max_depth` to recurse to.
        
        The max_depth parameter will do a breadth-first search to return the contents of the subdirectories
        up to the depth specified. Breadth-first search was chosen as it leads to the least amount of
        file system operations for git. If the `max_depth` parameter is specified to be too
        large, the call will time out and return a 555.
        
        Each returned object is either a `commit_file`, or a `commit_directory`,
        both of which contain a `path` element. This path is the absolute path
        from the root of the repository. Each object also contains a `commit`
        object which embeds the commit the file is on. Note that this is merely
        the commit that was used in the URL. It is *not* the commit that last
        modified the file.
        
        Directory objects have 2 representations. Their `self` link returns the
        paginated contents of the directory. The `meta` link on the other hand
        returns the actual `directory` object itself, e.g.:
        
        ```javascript
        {
          \"path\": \"tests/test_project\",
          \"type\": \"commit_directory\",
          \"links\": {
            \"self\": {
              \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/\"
            },
            \"meta\": {
              \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src/eefd5ef5d3df01aed629f650959d6706d54cd335/tests/test_project/?format=meta\"
            }
          },
          \"commit\": { ... }
        }
        ```
        
        #### Querying, filtering and sorting
        
        Like most API endpoints, this API supports the Bitbucket
        querying/filtering syntax and so you could filter a directory listing
        to only include entries that match certain criteria. For instance, to
        list all binary files over 1kb use the expression:
        
        `size > 1024 and attributes = \"binary\"`
        
        which after urlencoding yields the query string:
        
        `?q=size%3E1024+and+attributes%3D%22binary%22`
        
        To change the ordering of the response, use the `?sort` parameter:
        
        `.../src/eefd5ef/?sort=-size`
        
        See [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more
        details.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathRequest, base_url, '/repositories/{workspace}/{repo_slug}/src/{commit}/{path}', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugSrcCommitPathResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedTreeentries])
                res.paginated_treeentries = out
        elif http_res.status_code in [404, 555]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_watchers(self, request: operations.GetRepositoriesWorkspaceRepoSlugWatchersRequest, security: operations.GetRepositoriesWorkspaceRepoSlugWatchersSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugWatchersResponse:
        r"""List repositories watchers
        Returns a paginated list of all the watchers on the specified
        repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugWatchersRequest, base_url, '/repositories/{workspace}/{repo_slug}/watchers', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugWatchersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedAccounts])
                res.paginated_accounts = out

        return res

    def get_user_permissions_repositories(self, request: operations.GetUserPermissionsRepositoriesRequest, security: operations.GetUserPermissionsRepositoriesSecurity) -> operations.GetUserPermissionsRepositoriesResponse:
        r"""List repository permissions for a user
        Returns an object for each repository the caller has explicit access
        to and their effective permission â€” the highest level of permission the
        caller has. This does not return public repositories that the user was
        not granted any specific permission in, and does not distinguish between
        explicit and implicit privileges.
        
        Permissions can be:
        
        * `admin`
        * `write`
        * `read`
        
        Example:
        
        ```
        $ curl https://api.bitbucket.org/2.0/user/permissions/repositories
        
        {
          \"pagelen\": 10,
          \"values\": [
            {
              \"type\": \"repository_permission\",
              \"user\": {
                \"type\": \"user\",
                \"nickname\": \"evzijst\",
                \"display_name\": \"Erik van Zijst\",
                \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\"
              },
              \"repository\": {
                \"type\": \"repository\",
                \"name\": \"geordi\",
                \"full_name\": \"bitbucket/geordi\",
                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"
              },
              \"permission\": \"admin\"
            }
          ],
          \"page\": 1,
          \"size\": 1
        }
        ```
        
        Results may be further [filtered or sorted](/cloud/bitbucket/rest/intro/#filtering) by
        repository or permission by adding the following query string
        parameters:
        
        * `q=repository.name=\"geordi\"` or `q=permission>\"read\"`
        * `sort=repository.name`
        
        Note that the query parameter values need to be URL escaped so that `=`
        would become `%3D`.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/user/permissions/repositories'
        
        query_params = utils.get_query_params(operations.GetUserPermissionsRepositoriesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUserPermissionsRepositoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedRepositoryPermissions])
                res.paginated_repository_permissions = out

        return res

    def post_repositories_workspace_repo_slug_(self, request: operations.PostRepositoriesWorkspaceRepoSlugRequest, security: operations.PostRepositoriesWorkspaceRepoSlugSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugResponse:
        r"""Create a repository
        Creates a new repository.
        
        Note: In order to set the project for the newly created repository,
        pass in either the project key or the project UUID as part of the
        request body as shown in the examples below:
        
        ```
        $ curl -X POST -H \"Content-Type: application/json\" -d '{
            \"scm\": \"git\",
            \"project\": {
                \"key\": \"MARS\"
            }
        }' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding
        ```
        
        or
        
        ```
        $ curl -X POST -H \"Content-Type: application/json\" -d '{
            \"scm\": \"git\",
            \"project\": {
                \"key\": \"{ba516952-992a-4c2d-acbd-17d502922f96}\"
            }
        }' https://api.bitbucket.org/2.0/repositories/teamsinspace/hablanding
        ```
        
        The project must be assigned for all repositories. If the project is not provided,
        the repository is automatically assigned to the oldest project in the workspace.
        
        Note: In the examples above, the workspace ID `teamsinspace`,
        and/or the repository name `hablanding` can be replaced by UUIDs.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository = out
        elif http_res.status_code in [400, 401]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_forks(self, request: operations.PostRepositoriesWorkspaceRepoSlugForksRequest, security: operations.PostRepositoriesWorkspaceRepoSlugForksSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugForksResponse:
        r"""Fork a repository
        Creates a new fork of the specified repository.
        
        #### Forking a repository
        
        To create a fork, specify the workspace explicitly as part of the
        request body:
        
        ```
        $ curl -X POST -u jdoe https://api.bitbucket.org/2.0/repositories/atlassian/bbql/forks \
          -H 'Content-Type: application/json' -d '{
            \"name\": \"bbql_fork\",
            \"workspace\": {
              \"slug\": \"atlassian\"
            }
        }'
        ```
        
        To fork a repository into the same workspace, also specify a new `name`.
        
        When you specify a value for `name`, it will also affect the `slug`.
        The `slug` is reflected in the repository URL of the new fork. It is
        derived from `name` by substituting non-ASCII characters, removes
        whitespace, and changes characters to lower case. For example,
        `My repo` would turn into `my_repo`.
        
        You need contributor access to create new forks within a workspace.
        
        
        #### Change the properties of a new fork
        
        By default the fork inherits most of its properties from the parent.
        However, since the optional POST body document follows the normal
        `repository` JSON schema and you can override the new fork's
        properties.
        
        Properties that can be overridden include:
        
        * description
        * fork_policy
        * language
        * mainbranch
        * is_private (note that a private repo's fork_policy might prohibit
          the creation of public forks, in which `is_private=False` would fail)
        * has_issues (to initialize or disable the new repo's issue tracker --
          note that the actual contents of the parent repository's issue
          tracker are not copied during forking)
        * has_wiki (to initialize or disable the new repo's wiki --
          note that the actual contents of the parent repository's wiki are not
          copied during forking)
        * project (when forking into a private project, the fork's `is_private`
          must be `true`)
        
        Properties that cannot be modified include:
        
        * scm
        * parent
        * full_name
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugForksRequest, base_url, '/repositories/{workspace}/{repo_slug}/forks', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugForksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository = out

        return res

    def post_repositories_workspace_repo_slug_hooks(self, request: operations.PostRepositoriesWorkspaceRepoSlugHooksRequest, security: operations.PostRepositoriesWorkspaceRepoSlugHooksSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugHooksResponse:
        r"""Create a webhook for a repository
        Creates a new webhook on the specified repository.
        
        Example:
        
        ```
        $ curl -X POST -u credentials -H 'Content-Type: application/json'
          https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks
          -d '
            {
              \"description\": \"Webhook Description\",
              \"url\": \"https://example.com/\",
              \"active\": true,
              \"events\": [
                \"repo:push\",
                \"issue:created\",
                \"issue:updated\"
              ]
            }'
        ```
        
        Note that this call requires the webhook scope, as well as any scope
        that applies to the events that the webhook subscribes to. In the
        example above that means: `webhook`, `repository` and `issue`.
        
        Also note that the `url` must properly resolve and cannot be an
        internal, non-routed address.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugHooksRequest, base_url, '/repositories/{workspace}/{repo_slug}/hooks', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugHooksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.webhook_subscription = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_src(self, request: operations.PostRepositoriesWorkspaceRepoSlugSrcRequest, security: operations.PostRepositoriesWorkspaceRepoSlugSrcSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugSrcResponse:
        r"""Create a commit by uploading a file
        This endpoint is used to create new commits in the repository by
        uploading files.
        
        To add a new file to a repository:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \
          -F /repo/path/to/image.png=@image.png
        ```
        
        This will create a new commit on top of the main branch, inheriting the
        contents of the main branch, but adding (or overwriting) the
        `image.png` file to the repository in the `/repo/path/to` directory.
        
        To create a commit that deletes files, use the `files` parameter:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/username/slug/src \
          -F files=/file/to/delete/1.txt \
          -F files=/file/to/delete/2.txt
        ```
        
        You can add/modify/delete multiple files in a request. Rename/move a
        file by deleting the old path and adding the content at the new path.
        
        This endpoint accepts `multipart/form-data` (as in the examples above),
        as well as `application/x-www-form-urlencoded`.
        
        #### multipart/form-data
        
        A `multipart/form-data` post contains a series of \"form fields\" that
        identify both the individual files that are being uploaded, as well as
        additional, optional meta data.
        
        Files are uploaded in file form fields (those that have a
        `Content-Disposition` parameter) whose field names point to the remote
        path in the repository where the file should be stored. Path field
        names are always interpreted to be absolute from the root of the
        repository, regardless whether the client uses a leading slash (as the
        above `curl` example did).
        
        File contents are treated as bytes and are not decoded as text.
        
        The commit message, as well as other non-file meta data for the
        request, is sent along as normal form field elements. Meta data fields
        share the same namespace as the file objects. For `multipart/form-data`
        bodies that should not lead to any ambiguity, as the
        `Content-Disposition` header will contain the `filename` parameter to
        distinguish between a file named \"message\" and the commit message field.
        
        #### application/x-www-form-urlencoded
        
        It is also possible to upload new files using a simple
        `application/x-www-form-urlencoded` POST. This can be convenient when
        uploading pure text files:
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/bbql/src \
          --data-urlencode \"/path/to/me.txt=Lorem ipsum.\" \
          --data-urlencode \"message=Initial commit\" \
          --data-urlencode \"author=Erik van Zijst <erik.van.zijst@gmail.com>\"
        ```
        
        There could be a field name clash if a client were to upload a file
        named \"message\", as this filename clashes with the meta data property
        for the commit message. To avoid this and to upload files whose names
        clash with the meta data properties, use a leading slash for the files,
        e.g. `curl --data-urlencode \"/message=file contents\"`.
        
        When an explicit slash is omitted for a file whose path matches that of
        a meta data parameter, then it is interpreted as meta data, not as a
        file.
        
        #### Executables and links
        
        While this API aims to facilitate the most common use cases, it is
        possible to perform some more advanced operations like creating a new
        symlink in the repository, or creating an executable file.
        
        Files can be supplied with a `x-attributes` value in the
        `Content-Disposition` header. For example, to upload an executable
        file, as well as create a symlink from `README.txt` to `README`:
        
        ```
        --===============1438169132528273974==
        Content-Type: text/plain; charset=\"us-ascii\"
        MIME-Version: 1.0
        Content-Transfer-Encoding: 7bit
        Content-ID: \"bin/shutdown.sh\"
        Content-Disposition: attachment; filename=\"shutdown.sh\"; x-attributes:\"executable\"
        
        #!/bin/sh
        halt
        
        --===============1438169132528273974==
        Content-Type: text/plain; charset=\"us-ascii\"
        MIME-Version: 1.0
        Content-Transfer-Encoding: 7bit
        Content-ID: \"/README.txt\"
        Content-Disposition: attachment; filename=\"README.txt\"; x-attributes:\"link\"
        
        README
        --===============1438169132528273974==--
        ```
        
        Links are files that contain the target path and have
        `x-attributes:\"link\"` set.
        
        When overwriting links with files, or vice versa, the newly uploaded
        file determines both the new contents, as well as the attributes. That
        means uploading a file without specifying `x-attributes=\"link\"` will
        create a regular file, even if the parent commit hosted a symlink at
        the same path.
        
        The same applies to executables. When modifying an existing executable
        file, the form-data file element must include
        `x-attributes=\"executable\"` in order to preserve the executable status
        of the file.
        
        Note that this API does not support the creation or manipulation of
        subrepos / submodules.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugSrcRequest, base_url, '/repositories/{workspace}/{repo_slug}/src', request)
        
        query_params = utils.get_query_params(operations.PostRepositoriesWorkspaceRepoSlugSrcRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugSrcResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            pass
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_(self, request: operations.PutRepositoriesWorkspaceRepoSlugRequest, security: operations.PutRepositoriesWorkspaceRepoSlugSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugResponse:
        r"""Update a repository
        Since this endpoint can be used to both update and to create a
        repository, the request body depends on the intent.
        
        #### Creation
        
        See the POST documentation for the repository endpoint for an example
        of the request body.
        
        #### Update
        
        Note: Changing the `name` of the repository will cause the location to
        be changed. This is because the URL of the repo is derived from the
        name (a process called slugification). In such a scenario, it is
        possible for the request to fail if the newly created slug conflicts
        with an existing repository's slug. But if there is no conflict,
        the new location will be returned in the `Location` header of the
        response.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 201]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository = out
        elif http_res.status_code in [400, 401]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_hooks_uid_(self, request: operations.PutRepositoriesWorkspaceRepoSlugHooksUIDRequest, security: operations.PutRepositoriesWorkspaceRepoSlugHooksUIDSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugHooksUIDResponse:
        r"""Update a webhook for a repository
        Updates the specified webhook subscription.
        
        The following properties can be mutated:
        
        * `description`
        * `url`
        * `active`
        * `events`
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugHooksUIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/hooks/{uid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugHooksUIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.webhook_subscription = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_override_settings(self, request: operations.PutRepositoriesWorkspaceRepoSlugOverrideSettingsRequest, security: operations.PutRepositoriesWorkspaceRepoSlugOverrideSettingsSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugOverrideSettingsResponse:
        r"""Set the inheritance state for repository settings"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugOverrideSettingsRequest, base_url, '/repositories/{workspace}/{repo_slug}/override-settings', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugOverrideSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_permissions_config_groups_group_slug_(self, request: operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugRequest, security: operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugResponse:
        r"""Update an explicit group permission for a repository
        Updates the group permission if it exists.
        
        Only users with admin permission for the repository may access this resource.
        
        The only authentication method supported for this endpoint is via app passwords.
        
        Permissions can be:
        
        * `admin`
        * `write`
        * `read`
        
        Example:
        ```
        $ curl -X PUT -H \"Content-Type: application/json\"
        https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers
        -d
        '{
            \"permission\": \"write\"
        }'
        
        HTTP/1.1 200
        Location:
        https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers
        
        {
            \"type\": \"repository_group_permission\",
            \"group\": {
                \"type\": \"group\",
                \"name\": \"Developers\",
                \"slug\": \"developers\"
            },
            \"repository\": {
                \"type\": \"repository\",
                \"name\": \"geordi\",
                \"full_name\": \"atlassian_tutorial/geordi\",
                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"
            },
            \"permission\": \"write\",
            \"links\": {
              \"self\": {
                \"href\":
                \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/permissions-config/groups/developers\"
              }
            }
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/groups/{group_slug}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigGroupsGroupSlugResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository_group_permission = out
        elif http_res.status_code in [400, 401, 402, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_permissions_config_users_selected_user_id_(self, request: operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDRequest, security: operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDResponse:
        r"""Update an explicit user permission for a repository
        Updates the explicit user permission for a given user and repository. The selected user must be a member of
        the workspace, and cannot be the workspace owner.
        Only users with admin permission for the repository may access this resource.
        
        The only authentication method for this endpoint is via app passwords.
        
        Permissions can be:
        
        * `admin`
        * `write`
        * `read`
        
        Example:
        
        ```
        $ curl -X PUT -H \"Content-Type: application/json\" 'https://api.bitbucket.org/2.0/repositories/
        atlassian_tutorial/geordi/permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a'
        -d         '{
            \"permission\": \"write\"
        }'
        
        HTTP/1.1 200
        Location: 'https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
        permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a'
        
        
        {
            \"type\": \"repository_user_permission\",
            \"user\": {
                \"type\": \"user\",
                \"display_name\": \"Colin Cameron\",
                \"uuid\": \"{d301aafa-d676-4ee0-88be-962be7417567}\",
                \"account_id\": \"557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\"
            },
            \"repository\": {
                \"type\": \"repository\",
                \"name\": \"geordi\",
                \"full_name\": \"atlassian_tutorial/geordi\",
                \"uuid\": \"{85d08b4e-571d-44e9-a507-fa476535aa98}\"
            },
            \"permission\": \"write\",
            \"links\": {
                \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/atlassian_tutorial/geordi/
                             permissions-config/users/557058:ba8948b2-49da-43a9-9e8b-e7249b8e324a\"
                }
            }
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/permissions-config/users/{selected_user_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugPermissionsConfigUsersSelectedUserIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.repository_user_permission = out
        elif http_res.status_code in [400, 401, 402, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    