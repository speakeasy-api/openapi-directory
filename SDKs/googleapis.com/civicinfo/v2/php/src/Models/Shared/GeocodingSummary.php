<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI\Models\Shared;


/**
 * GeocodingSummary - Detailed summary of the result from geocoding an address
 * 
 * @package OpenAPI\OpenAPI\Models\Shared
 * @access public
 */
class GeocodingSummary
{
    /**
     * Represents the best estimate of whether or not the input address was fully understood and the address is correctly componentized. Mirrors the same-name field in geostore.staging.AddressLinkupScoringProto.
     * 
     * @var ?bool $addressUnderstood
     */
	#[\JMS\Serializer\Annotation\SerializedName('addressUnderstood')]
    #[\JMS\Serializer\Annotation\Type('bool')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?bool $addressUnderstood = null;
    
    /**
     * A globally unique identifier associated with each feature. We use 128-bit identifiers so that we have lots of bits available to distinguish between features. The feature id currently consists of a 64-bit "cell id" that **sometimes** corresponds to the approximate centroid of the feature, plus a 64-bit fingerprint of other identifying information. See more on each respective field in its comments. Feature ids are first assigned when the data is created in MapFacts. After initial creation of the feature, they are immutable. This means that the only properties that you should rely on are that they are unique, and that cell_ids often - but not always - preserve spatial locality. The degree of locality varies as the feature undergoes geometry changes, and should not in general be considered a firm guarantee of the location of any particular feature. In fact, some locationless features have randomized cell IDs! Consumers of FeatureProtos from Mapfacts are guaranteed that fprints in the id field of features will be globally unique. Using the fprint allows consumers who don't need the spatial benefit of cell ids to uniquely identify features in a 64-bit address space. This property is not guaranteed for other sources of FeatureProtos.
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Shared\FeatureIdProto $featureId
     */
	#[\JMS\Serializer\Annotation\SerializedName('featureId')]
    #[\JMS\Serializer\Annotation\Type('OpenAPI\OpenAPI\Models\Shared\FeatureIdProto')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?FeatureIdProto $featureId = null;
    
    /**
     * The feature type for the FeatureProto returned by the geocoder
     * 
     * @var ?\OpenAPI\OpenAPI\Models\Shared\GeocodingSummaryFeatureTypeEnum $featureType
     */
	#[\JMS\Serializer\Annotation\SerializedName('featureType')]
    #[\JMS\Serializer\Annotation\Type('enum<OpenAPI\OpenAPI\Models\Shared\GeocodingSummaryFeatureTypeEnum>')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?GeocodingSummaryFeatureTypeEnum $featureType = null;
    
    /**
     * Precision of the center point (lat/long) of the geocoded FeatureProto
     * 
     * @var ?float $positionPrecisionMeters
     */
	#[\JMS\Serializer\Annotation\SerializedName('positionPrecisionMeters')]
    #[\JMS\Serializer\Annotation\Type('float')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?float $positionPrecisionMeters = null;
    
    /**
     * The query sent to the geocoder
     * 
     * @var ?string $queryString
     */
	#[\JMS\Serializer\Annotation\SerializedName('queryString')]
    #[\JMS\Serializer\Annotation\Type('string')]
    #[\JMS\Serializer\Annotation\SkipWhenEmpty]
    public ?string $queryString = null;
    
	public function __construct()
	{
		$this->addressUnderstood = null;
		$this->featureId = null;
		$this->featureType = null;
		$this->positionPrecisionMeters = null;
		$this->queryString = null;
	}
}
