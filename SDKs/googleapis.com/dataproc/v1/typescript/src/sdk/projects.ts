/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a batch workload that executes asynchronously.
   */
  dataprocProjectsLocationsBatchesCreate(
    req: operations.DataprocProjectsLocationsBatchesCreateRequest,
    security: operations.DataprocProjectsLocationsBatchesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsLocationsBatchesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsLocationsBatchesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/batches", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsLocationsBatchesCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsLocationsBatchesCreateResponse =
        new operations.DataprocProjectsLocationsBatchesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists batch workloads.
   */
  dataprocProjectsLocationsBatchesList(
    req: operations.DataprocProjectsLocationsBatchesListRequest,
    security: operations.DataprocProjectsLocationsBatchesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsLocationsBatchesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsLocationsBatchesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/batches", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsLocationsBatchesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsLocationsBatchesListResponse =
        new operations.DataprocProjectsLocationsBatchesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBatchesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBatchesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates new autoscaling policy.
   */
  dataprocProjectsRegionsAutoscalingPoliciesCreate(
    req: operations.DataprocProjectsRegionsAutoscalingPoliciesCreateRequest,
    security: operations.DataprocProjectsRegionsAutoscalingPoliciesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsAutoscalingPoliciesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsAutoscalingPoliciesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/autoscalingPolicies",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "autoscalingPolicyInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsAutoscalingPoliciesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsAutoscalingPoliciesCreateResponse =
        new operations.DataprocProjectsRegionsAutoscalingPoliciesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.autoscalingPolicy = utils.objectToClass(
              httpRes?.data,
              shared.AutoscalingPolicy
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists autoscaling policies in the project.
   */
  dataprocProjectsRegionsAutoscalingPoliciesList(
    req: operations.DataprocProjectsRegionsAutoscalingPoliciesListRequest,
    security: operations.DataprocProjectsRegionsAutoscalingPoliciesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsAutoscalingPoliciesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsAutoscalingPoliciesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/autoscalingPolicies",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsAutoscalingPoliciesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsAutoscalingPoliciesListResponse =
        new operations.DataprocProjectsRegionsAutoscalingPoliciesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAutoscalingPoliciesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAutoscalingPoliciesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a cluster in a project. The returned Operation.metadata will be ClusterOperationMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#clusteroperationmetadata).
   */
  dataprocProjectsRegionsClustersCreate(
    req: operations.DataprocProjectsRegionsClustersCreateRequest,
    security: operations.DataprocProjectsRegionsClustersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "clusterInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersCreateResponse =
        new operations.DataprocProjectsRegionsClustersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a cluster in a project. The returned Operation.metadata will be ClusterOperationMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#clusteroperationmetadata).
   */
  dataprocProjectsRegionsClustersDelete(
    req: operations.DataprocProjectsRegionsClustersDeleteRequest,
    security: operations.DataprocProjectsRegionsClustersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersDeleteResponse =
        new operations.DataprocProjectsRegionsClustersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets cluster diagnostic information. The returned Operation.metadata will be ClusterOperationMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#clusteroperationmetadata). After the operation completes, Operation.response contains DiagnoseClusterResults (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#diagnoseclusterresults).
   */
  dataprocProjectsRegionsClustersDiagnose(
    req: operations.DataprocProjectsRegionsClustersDiagnoseRequest,
    security: operations.DataprocProjectsRegionsClustersDiagnoseSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersDiagnoseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersDiagnoseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}:diagnose",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "diagnoseClusterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersDiagnoseSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersDiagnoseResponse =
        new operations.DataprocProjectsRegionsClustersDiagnoseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the resource representation for a cluster in a project.
   */
  dataprocProjectsRegionsClustersGet(
    req: operations.DataprocProjectsRegionsClustersGetRequest,
    security: operations.DataprocProjectsRegionsClustersGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersGetResponse =
        new operations.DataprocProjectsRegionsClustersGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cluster = utils.objectToClass(httpRes?.data, shared.Cluster);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Inject encrypted credentials into all of the VMs in a cluster.The target cluster must be a personal auth cluster assigned to the user who is issuing the RPC.
   */
  dataprocProjectsRegionsClustersInjectCredentials(
    req: operations.DataprocProjectsRegionsClustersInjectCredentialsRequest,
    security: operations.DataprocProjectsRegionsClustersInjectCredentialsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersInjectCredentialsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsClustersInjectCredentialsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{project}/{region}/{cluster}:injectCredentials",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "injectCredentialsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsClustersInjectCredentialsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersInjectCredentialsResponse =
        new operations.DataprocProjectsRegionsClustersInjectCredentialsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all regions/{region}/clusters in a project alphabetically.
   */
  dataprocProjectsRegionsClustersList(
    req: operations.DataprocProjectsRegionsClustersListRequest,
    security: operations.DataprocProjectsRegionsClustersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersListResponse =
        new operations.DataprocProjectsRegionsClustersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listClustersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListClustersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a node group in a cluster. The returned Operation.metadata is NodeGroupOperationMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#nodegroupoperationmetadata).
   */
  dataprocProjectsRegionsClustersNodeGroupsCreate(
    req: operations.DataprocProjectsRegionsClustersNodeGroupsCreateRequest,
    security: operations.DataprocProjectsRegionsClustersNodeGroupsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersNodeGroupsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsClustersNodeGroupsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/nodeGroups",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "nodeGroupInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsClustersNodeGroupsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersNodeGroupsCreateResponse =
        new operations.DataprocProjectsRegionsClustersNodeGroupsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Resizes a node group in a cluster. The returned Operation.metadata is NodeGroupOperationMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#nodegroupoperationmetadata).
   */
  dataprocProjectsRegionsClustersNodeGroupsResize(
    req: operations.DataprocProjectsRegionsClustersNodeGroupsResizeRequest,
    security: operations.DataprocProjectsRegionsClustersNodeGroupsResizeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersNodeGroupsResizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsClustersNodeGroupsResizeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:resize", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resizeNodeGroupRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsClustersNodeGroupsResizeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersNodeGroupsResizeResponse =
        new operations.DataprocProjectsRegionsClustersNodeGroupsResizeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a cluster in a project. The returned Operation.metadata will be ClusterOperationMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#clusteroperationmetadata). The cluster must be in a RUNNING state or an error is returned.
   */
  dataprocProjectsRegionsClustersPatch(
    req: operations.DataprocProjectsRegionsClustersPatchRequest,
    security: operations.DataprocProjectsRegionsClustersPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "clusterInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersPatchResponse =
        new operations.DataprocProjectsRegionsClustersPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Repairs a cluster.
   */
  dataprocProjectsRegionsClustersRepair(
    req: operations.DataprocProjectsRegionsClustersRepairRequest,
    security: operations.DataprocProjectsRegionsClustersRepairSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersRepairResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersRepairRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}:repair",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "repairClusterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersRepairSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersRepairResponse =
        new operations.DataprocProjectsRegionsClustersRepairResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a cluster in a project.
   */
  dataprocProjectsRegionsClustersStart(
    req: operations.DataprocProjectsRegionsClustersStartRequest,
    security: operations.DataprocProjectsRegionsClustersStartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersStartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersStartRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}:start",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startClusterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersStartSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersStartResponse =
        new operations.DataprocProjectsRegionsClustersStartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stops a cluster in a project.
   */
  dataprocProjectsRegionsClustersStop(
    req: operations.DataprocProjectsRegionsClustersStopRequest,
    security: operations.DataprocProjectsRegionsClustersStopSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsClustersStopResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsClustersStopRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/clusters/{clusterName}:stop",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stopClusterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsClustersStopSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsClustersStopResponse =
        new operations.DataprocProjectsRegionsClustersStopResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a job cancellation request. To access the job resource after cancellation, call regions/{region}/jobs.list (https://cloud.google.com/dataproc/docs/reference/rest/v1/projects.regions.jobs/list) or regions/{region}/jobs.get (https://cloud.google.com/dataproc/docs/reference/rest/v1/projects.regions.jobs/get).
   */
  dataprocProjectsRegionsJobsCancel(
    req: operations.DataprocProjectsRegionsJobsCancelRequest,
    security: operations.DataprocProjectsRegionsJobsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsCancelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs/{jobId}:cancel",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsJobsCancelSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsCancelResponse =
        new operations.DataprocProjectsRegionsJobsCancelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.job = utils.objectToClass(httpRes?.data, shared.Job);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the job from the project. If the job is active, the delete fails, and the response returns FAILED_PRECONDITION.
   */
  dataprocProjectsRegionsJobsDelete(
    req: operations.DataprocProjectsRegionsJobsDeleteRequest,
    security: operations.DataprocProjectsRegionsJobsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs/{jobId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsJobsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsDeleteResponse =
        new operations.DataprocProjectsRegionsJobsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the resource representation for a job in a project.
   */
  dataprocProjectsRegionsJobsGet(
    req: operations.DataprocProjectsRegionsJobsGetRequest,
    security: operations.DataprocProjectsRegionsJobsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs/{jobId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsJobsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsGetResponse =
        new operations.DataprocProjectsRegionsJobsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.job = utils.objectToClass(httpRes?.data, shared.Job);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists regions/{region}/jobs in a project.
   */
  dataprocProjectsRegionsJobsList(
    req: operations.DataprocProjectsRegionsJobsListRequest,
    security: operations.DataprocProjectsRegionsJobsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsJobsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsListResponse =
        new operations.DataprocProjectsRegionsJobsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listJobsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListJobsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a job in a project.
   */
  dataprocProjectsRegionsJobsPatch(
    req: operations.DataprocProjectsRegionsJobsPatchRequest,
    security: operations.DataprocProjectsRegionsJobsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs/{jobId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "jobInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsJobsPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsPatchResponse =
        new operations.DataprocProjectsRegionsJobsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.job = utils.objectToClass(httpRes?.data, shared.Job);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Submits a job to a cluster.
   */
  dataprocProjectsRegionsJobsSubmit(
    req: operations.DataprocProjectsRegionsJobsSubmitRequest,
    security: operations.DataprocProjectsRegionsJobsSubmitSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsSubmitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsSubmitRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs:submit",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "submitJobRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsJobsSubmitSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsSubmitResponse =
        new operations.DataprocProjectsRegionsJobsSubmitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.job = utils.objectToClass(httpRes?.data, shared.Job);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Submits job to a cluster.
   */
  dataprocProjectsRegionsJobsSubmitAsOperation(
    req: operations.DataprocProjectsRegionsJobsSubmitAsOperationRequest,
    security: operations.DataprocProjectsRegionsJobsSubmitAsOperationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsJobsSubmitAsOperationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsJobsSubmitAsOperationRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{projectId}/regions/{region}/jobs:submitAsOperation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "submitJobRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsJobsSubmitAsOperationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsJobsSubmitAsOperationResponse =
        new operations.DataprocProjectsRegionsJobsSubmitAsOperationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns google.rpc.Code.UNIMPLEMENTED. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to Code.CANCELLED.
   */
  dataprocProjectsRegionsOperationsCancel(
    req: operations.DataprocProjectsRegionsOperationsCancelRequest,
    security: operations.DataprocProjectsRegionsOperationsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsOperationsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsOperationsCancelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:cancel", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DataprocProjectsRegionsOperationsCancelSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsOperationsCancelResponse =
        new operations.DataprocProjectsRegionsOperationsCancelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates new workflow template.
   */
  dataprocProjectsRegionsWorkflowTemplatesCreate(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesCreateRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/workflowTemplates",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "workflowTemplateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesCreateResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.workflowTemplate = utils.objectToClass(
              httpRes?.data,
              shared.WorkflowTemplate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a workflow template. It does not cancel in-progress workflows.
   */
  dataprocProjectsRegionsWorkflowTemplatesDelete(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesDeleteRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesDeleteResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the latest workflow template.Can retrieve previously instantiated template by specifying optional version parameter.
   */
  dataprocProjectsRegionsWorkflowTemplatesGet(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesGetRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsWorkflowTemplatesGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesGetResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.workflowTemplate = utils.objectToClass(
              httpRes?.data,
              shared.WorkflowTemplate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
   */
  dataprocProjectsRegionsWorkflowTemplatesGetIamPolicy(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicyRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:getIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getIamPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicyResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesGetIamPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Instantiates a template and begins execution.The returned Operation can be used to track execution of workflow by polling operations.get. The Operation will complete when entire workflow is finished.The running workflow can be aborted via operations.cancel. This will cause any inflight jobs to be cancelled and workflow-owned clusters to be deleted.The Operation.metadata will be WorkflowMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#workflowmetadata). Also see Using WorkflowMetadata (https://cloud.google.com/dataproc/docs/concepts/workflows/debugging#using_workflowmetadata).On successful completion, Operation.response will be Empty.
   */
  dataprocProjectsRegionsWorkflowTemplatesInstantiate(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:instantiate",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "instantiateWorkflowTemplateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Instantiates a template and begins execution.This method is equivalent to executing the sequence CreateWorkflowTemplate, InstantiateWorkflowTemplate, DeleteWorkflowTemplate.The returned Operation can be used to track execution of workflow by polling operations.get. The Operation will complete when entire workflow is finished.The running workflow can be aborted via operations.cancel. This will cause any inflight jobs to be cancelled and workflow-owned clusters to be deleted.The Operation.metadata will be WorkflowMetadata (https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#workflowmetadata). Also see Using WorkflowMetadata (https://cloud.google.com/dataproc/docs/concepts/workflows/debugging#using_workflowmetadata).On successful completion, Operation.response will be Empty.
   */
  dataprocProjectsRegionsWorkflowTemplatesInstantiateInline(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/workflowTemplates:instantiateInline",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "workflowTemplateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesInstantiateInlineResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists workflows that match the specified filter in the request.
   */
  dataprocProjectsRegionsWorkflowTemplatesList(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesListRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DataprocProjectsRegionsWorkflowTemplatesListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/workflowTemplates",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesListResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkflowTemplatesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListWorkflowTemplatesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any existing policy.Can return NOT_FOUND, INVALID_ARGUMENT, and PERMISSION_DENIED errors.
   */
  dataprocProjectsRegionsWorkflowTemplatesSetIamPolicy(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicyRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:setIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setIamPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicyResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesSetIamPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a NOT_FOUND error.Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
   */
  dataprocProjectsRegionsWorkflowTemplatesTestIamPermissions(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:testIamPermissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testIamPermissionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesTestIamPermissionsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testIamPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestIamPermissionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates (replaces) workflow template. The updated template must contain version that matches the current server version.
   */
  dataprocProjectsRegionsWorkflowTemplatesUpdate(
    req: operations.DataprocProjectsRegionsWorkflowTemplatesUpdateRequest,
    security: operations.DataprocProjectsRegionsWorkflowTemplatesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DataprocProjectsRegionsWorkflowTemplatesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DataprocProjectsRegionsWorkflowTemplatesUpdateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "workflowTemplateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DataprocProjectsRegionsWorkflowTemplatesUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DataprocProjectsRegionsWorkflowTemplatesUpdateResponse =
        new operations.DataprocProjectsRegionsWorkflowTemplatesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.workflowTemplate = utils.objectToClass(
              httpRes?.data,
              shared.WorkflowTemplate
            );
          }
          break;
      }

      return res;
    });
  }
}
