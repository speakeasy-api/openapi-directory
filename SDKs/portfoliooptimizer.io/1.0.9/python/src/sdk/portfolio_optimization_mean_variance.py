"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Optional

class PortfolioOptimizationMeanVariance:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def post_portfolio_optimization_maximum_return(self, request: operations.PostPortfolioOptimizationMaximumReturnRequestBody) -> operations.PostPortfolioOptimizationMaximumReturnResponse:
        r"""Maximum Return Portfolio
        Compute the asset weights of the maximum return portfolio, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/maximum-return'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMaximumReturnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMaximumReturn200ApplicationJSON])
                res.post_portfolio_optimization_maximum_return_200_application_json_object = out

        return res

    def post_portfolio_optimization_maximum_return_diversified(self, request: operations.PostPortfolioOptimizationMaximumReturnDiversifiedRequestBody) -> operations.PostPortfolioOptimizationMaximumReturnDiversifiedResponse:
        r"""Diversified Maximum Return Portfolio
        Compute the asset weights of the diversified maximum return portfolio, as defined in the first reference, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
        
        References
         * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
         * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/maximum-return/diversified'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMaximumReturnDiversifiedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMaximumReturnDiversified200ApplicationJSON])
                res.post_portfolio_optimization_maximum_return_diversified_200_application_json_object = out

        return res

    def post_portfolio_optimization_maximum_return_subset_resampling_based(self, request: operations.PostPortfolioOptimizationMaximumReturnSubsetResamplingBasedRequestBody) -> operations.PostPortfolioOptimizationMaximumReturnSubsetResamplingBasedResponse:
        r"""Subset Resampling-Based Maximum Return Portfolio
        Compute the asset weights of the subset resampling-based maximum return portfolio, following the methodology described in the first and the second references, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
         * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/maximum-return/subset-resampling-based'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMaximumReturnSubsetResamplingBasedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMaximumReturnSubsetResamplingBased200ApplicationJSON])
                res.post_portfolio_optimization_maximum_return_subset_resampling_based_200_application_json_object = out

        return res

    def post_portfolio_optimization_maximum_sharpe_ratio(self, request: operations.PostPortfolioOptimizationMaximumSharpeRatioRequestBody) -> operations.PostPortfolioOptimizationMaximumSharpeRatioResponse:
        r"""Maximum Sharpe Ratio Portfolio
        Compute the asset weights of the maximum Sharpe ratio portfolio, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/maximum-sharpe-ratio'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMaximumSharpeRatioResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMaximumSharpeRatio200ApplicationJSON])
                res.post_portfolio_optimization_maximum_sharpe_ratio_200_application_json_object = out

        return res

    def post_portfolio_optimization_maximum_sharpe_ratio_diversified(self, request: operations.PostPortfolioOptimizationMaximumSharpeRatioDiversifiedRequestBody) -> operations.PostPortfolioOptimizationMaximumSharpeRatioDiversifiedResponse:
        r"""Diversified Maximum Sharpe Ratio Portfolio
        Compute the asset weights of the diversified maximum Sharpe ratio portfolio, as defined in the first reference, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
        
        References
         * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
         * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/maximum-sharpe-ratio/diversified'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMaximumSharpeRatioDiversifiedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMaximumSharpeRatioDiversified200ApplicationJSON])
                res.post_portfolio_optimization_maximum_sharpe_ratio_diversified_200_application_json_object = out

        return res

    def post_portfolio_optimization_maximum_sharpe_ratio_subset_resampling_based(self, request: operations.PostPortfolioOptimizationMaximumSharpeRatioSubsetResamplingBasedRequestBody) -> operations.PostPortfolioOptimizationMaximumSharpeRatioSubsetResamplingBasedResponse:
        r"""Subset Resampling-Based Maximum Sharpe Ratio Portfolio
        Compute the asset weights of the susbet resampling-based maximum Sharpe ratio portfolio, following the methodology described in the first and the second references, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
         * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/maximum-sharpe-ratio/subset-resampling-based'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMaximumSharpeRatioSubsetResamplingBasedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMaximumSharpeRatioSubsetResamplingBased200ApplicationJSON])
                res.post_portfolio_optimization_maximum_sharpe_ratio_subset_resampling_based_200_application_json_object = out

        return res

    def post_portfolio_optimization_mean_variance_efficient(self, request: operations.PostPortfolioOptimizationMeanVarianceEfficientRequestBody) -> operations.PostPortfolioOptimizationMeanVarianceEfficientResponse:
        r"""Mean-Variance Efficient Portfolio
        Compute the asset weights of a mean-variance efficient portfolio, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        > A mean-variance efficient portfolio is a portfolio belonging to [the mean-variance efficient frontier](#post-/portfolio/analysis/mean-variance/efficient-frontier).
        
        References
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/mean-variance-efficient'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMeanVarianceEfficientResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMeanVarianceEfficient200ApplicationJSON])
                res.post_portfolio_optimization_mean_variance_efficient_200_application_json_object = out

        return res

    def post_portfolio_optimization_mean_variance_efficient_diversified(self, request: operations.PostPortfolioOptimizationMeanVarianceEfficientDiversifiedRequestBody) -> operations.PostPortfolioOptimizationMeanVarianceEfficientDiversifiedResponse:
        r"""Diversified Mean-Variance Efficient Portfolio
        Compute the asset weights of a diversified mean-variance efficient portfolio, as defined in the first reference, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
        
        > A diversified mean-variance efficient portfolio does NOT belong to [the mean-variance efficient frontier](#post-/portfolio/analysis/mean-variance/efficient-frontier), but is close to this frontier.
        
        References
         * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
         * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/mean-variance-efficient/diversified'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMeanVarianceEfficientDiversifiedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMeanVarianceEfficientDiversified200ApplicationJSON])
                res.post_portfolio_optimization_mean_variance_efficient_diversified_200_application_json_object = out

        return res

    def post_portfolio_optimization_mean_variance_efficient_subset_resampling_based(self, request: operations.PostPortfolioOptimizationMeanVarianceEfficientSubsetResamplingBasedRequestBody) -> operations.PostPortfolioOptimizationMeanVarianceEfficientSubsetResamplingBasedResponse:
        r"""Subset Resampling-Based Mean-Variance Efficient Portfolio
        Compute the asset weights of a subset resampling-based  mean-variance efficient portfolio, following the methodology described in the first and the second references, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
         * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/mean-variance-efficient/subset-resampling-based'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMeanVarianceEfficientSubsetResamplingBasedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMeanVarianceEfficientSubsetResamplingBased200ApplicationJSON])
                res.post_portfolio_optimization_mean_variance_efficient_subset_resampling_based_200_application_json_object = out

        return res

    def post_portfolio_optimization_minimum_variance(self, request: operations.PostPortfolioOptimizationMinimumVarianceRequestBody) -> operations.PostPortfolioOptimizationMinimumVarianceResponse:
        r"""Minimum Variance Portfolio
        Compute the asset weights of the minimum variance portfolio, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/minimum-variance'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMinimumVarianceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMinimumVariance200ApplicationJSON])
                res.post_portfolio_optimization_minimum_variance_200_application_json_object = out

        return res

    def post_portfolio_optimization_minimum_variance_diversified(self, request: operations.PostPortfolioOptimizationMinimumVarianceDiversifiedRequestBody) -> operations.PostPortfolioOptimizationMinimumVarianceDiversifiedResponse:
        r"""Diversified Minimum Variance Portfolio
        Compute the asset weights of the diversified minimum variance portfolio, as defined in the first reference, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        The diversification measure used in the optimization procedure is the [Herfindahl-Hirschman Index](https://en.wikipedia.org/wiki/Herfindahl%E2%80%93Hirschman_index) of the assets weights.
        
        References
         * [Alejandro Corvalan, 2005. Well Diversified Efficient Portfolios, Working Papers Central Bank of Chile 336, Central Bank of Chile](https://ideas.repec.org/p/chb/bcchwp/336.html)
         * [Bouchaud, Jean-Philippe and Potters, Marc and Aguilar, Jean-Pierre, Missing Information and Asset Allocation, arXiv, 1997](https://arxiv.org/abs/cond-mat/9707042)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/minimum-variance/diversified'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMinimumVarianceDiversifiedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMinimumVarianceDiversified200ApplicationJSON])
                res.post_portfolio_optimization_minimum_variance_diversified_200_application_json_object = out

        return res

    def post_portfolio_optimization_minimum_variance_subset_resampling_based(self, request: operations.PostPortfolioOptimizationMinimumVarianceSubsetResamplingBasedRequestBody) -> operations.PostPortfolioOptimizationMinimumVarianceSubsetResamplingBasedResponse:
        r"""Subset Resampling-Based Minimum Variance Portfolio
        Compute the asset weights of the subset resampling-based minimum variance portfolio, following the methodology described in the first and the second references, optionally subject to:  
        * Minimum and maximum weights constraints
        * Maximum group weights constraints
        * Minimum and maximum portfolio exposure constraints
        
        References
         * [CSSA, Random Subspace Optimization (RSO)](https://cssanalytics.wordpress.com/2013/10/06/random-subspace-optimization-rso/)
         * [Subset Optimization for Asset Allocation,Benjamin J. Gillen](https://www.bengillen.com/uploads/1/2/3/8/123891022/subsets.pdf)
         * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/portfolio/optimization/minimum-variance/subset-resampling-based'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPortfolioOptimizationMinimumVarianceSubsetResamplingBasedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PostPortfolioOptimizationMinimumVarianceSubsetResamplingBased200ApplicationJSON])
                res.post_portfolio_optimization_minimum_variance_subset_resampling_based_200_application_json_object = out

        return res

    