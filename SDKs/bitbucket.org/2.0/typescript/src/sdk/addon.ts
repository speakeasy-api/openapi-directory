/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * The addon resource is intended to use used by Bitbucket Cloud Connect
 *
 * @remarks
 * Apps, and only supports JWT authentication.
 *
 */
export class Addon {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete an app
   *
   * @remarks
   * Deletes the application for the user.
   *
   * This endpoint is intended to be used by Bitbucket Connect apps
   * and only supports JWT authentication -- that is how Bitbucket
   * identifies the particular installation of the app. Developers
   * with applications registered in the "Develop Apps" section
   * of Bitbucket Marketplace need not use this endpoint as
   * updates for those applications can be sent out via the
   * UI of that section.
   *
   * ```
   * $ curl -X DELETE https://api.bitbucket.org/2.0/addon \
   *   -H "Authorization: JWT <JWT Token>"
   * ```
   */
  deleteAddon(
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAddonResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/addon";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAddonResponse =
        new operations.DeleteAddonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete all linker values
   *
   * @remarks
   * Delete all [linker](/cloud/bitbucket/modules/linker/) values for the
   * specified linker of the authenticated application.
   */
  deleteAddonLinkersLinkerKeyValues(
    req: operations.DeleteAddonLinkersLinkerKeyValuesRequest,
    security: operations.DeleteAddonLinkersLinkerKeyValuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAddonLinkersLinkerKeyValuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAddonLinkersLinkerKeyValuesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}/values",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteAddonLinkersLinkerKeyValuesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAddonLinkersLinkerKeyValuesResponse =
        new operations.DeleteAddonLinkersLinkerKeyValuesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a linker value
   *
   * @remarks
   * Delete a single [linker](/cloud/bitbucket/modules/linker/) value
   * of the authenticated application.
   */
  deleteAddonLinkersLinkerKeyValuesValueId(
    req: operations.DeleteAddonLinkersLinkerKeyValuesValueIdRequest,
    security: operations.DeleteAddonLinkersLinkerKeyValuesValueIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAddonLinkersLinkerKeyValuesValueIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAddonLinkersLinkerKeyValuesValueIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}/values/{value_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteAddonLinkersLinkerKeyValuesValueIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAddonLinkersLinkerKeyValuesValueIdResponse =
        new operations.DeleteAddonLinkersLinkerKeyValuesValueIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List linkers for an app
   *
   * @remarks
   * Gets a list of all [linkers](/cloud/bitbucket/modules/linker/)
   * for the authenticated application.
   */
  getAddonLinkers(
    config?: AxiosRequestConfig
  ): Promise<operations.GetAddonLinkersResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/addon/linkers";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAddonLinkersResponse =
        new operations.GetAddonLinkersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a linker for an app
   *
   * @remarks
   * Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key`
   * for the authenticated application.
   */
  getAddonLinkersLinkerKey(
    req: operations.GetAddonLinkersLinkerKeyRequest,
    security: operations.GetAddonLinkersLinkerKeySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAddonLinkersLinkerKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAddonLinkersLinkerKeyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAddonLinkersLinkerKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAddonLinkersLinkerKeyResponse =
        new operations.GetAddonLinkersLinkerKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List linker values for a linker
   *
   * @remarks
   * Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the
   * specified linker of the authenticated application.
   *
   * A linker value lets applications supply values to modify its regular expression.
   *
   * The base regular expression must use a Bitbucket-specific match group `(?K)`
   * which will be translated to `([\w\-]+)`. A value must match this pattern.
   *
   * [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
   */
  getAddonLinkersLinkerKeyValues(
    req: operations.GetAddonLinkersLinkerKeyValuesRequest,
    security: operations.GetAddonLinkersLinkerKeyValuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAddonLinkersLinkerKeyValuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAddonLinkersLinkerKeyValuesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}/values",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAddonLinkersLinkerKeyValuesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAddonLinkersLinkerKeyValuesResponse =
        new operations.GetAddonLinkersLinkerKeyValuesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a linker value
   *
   * @remarks
   * Get a single [linker](/cloud/bitbucket/modules/linker/) value
   * of the authenticated application.
   */
  getAddonLinkersLinkerKeyValuesValueId(
    req: operations.GetAddonLinkersLinkerKeyValuesValueIdRequest,
    security: operations.GetAddonLinkersLinkerKeyValuesValueIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAddonLinkersLinkerKeyValuesValueIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAddonLinkersLinkerKeyValuesValueIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}/values/{value_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetAddonLinkersLinkerKeyValuesValueIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAddonLinkersLinkerKeyValuesValueIdResponse =
        new operations.GetAddonLinkersLinkerKeyValuesValueIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a linker value
   *
   * @remarks
   * Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified
   * linker of authenticated application.
   *
   * A linker value lets applications supply values to modify its regular expression.
   *
   * The base regular expression must use a Bitbucket-specific match group `(?K)`
   * which will be translated to `([\w\-]+)`. A value must match this pattern.
   *
   * [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
   */
  postAddonLinkersLinkerKeyValues(
    req: operations.PostAddonLinkersLinkerKeyValuesRequest,
    security: operations.PostAddonLinkersLinkerKeyValuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostAddonLinkersLinkerKeyValuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostAddonLinkersLinkerKeyValuesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}/values",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostAddonLinkersLinkerKeyValuesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostAddonLinkersLinkerKeyValuesResponse =
        new operations.PostAddonLinkersLinkerKeyValuesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
        case [401, 404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an installed app
   *
   * @remarks
   * Updates the application installation for the user.
   *
   * This endpoint is intended to be used by Bitbucket Connect apps
   * and only supports JWT authentication -- that is how Bitbucket
   * identifies the particular installation of the app. Developers
   * with applications registered in the "Develop Apps" section
   * of Bitbucket need not use this endpoint as updates for those
   * applications can be sent out via the UI of that section.
   *
   * Passing an empty body will update the installation using the
   * existing descriptor URL.
   *
   * ```
   * $ curl -X PUT https://api.bitbucket.org/2.0/addon \
   *   -H "Authorization: JWT <JWT Token>" \
   *   --header "Content-Type: application/json" \
   *   --data '{}'
   * ```
   *
   * The new `descriptor` for the installation can be also provided
   * in the body directly.
   *
   * ```
   * $ curl -X PUT https://api.bitbucket.org/2.0/addon \
   *   -H "Authorization: JWT <JWT Token>" \
   *   --header "Content-Type: application/json" \
   *   --data '{"descriptor": $NEW_DESCRIPTOR}'
   * ```
   *
   * In both these modes the URL of the descriptor cannot be changed. To
   * change the descriptor location and upgrade an installation
   * the request must be made exclusively with a `descriptor_url`.
   *
   *  ```
   * $ curl -X PUT https://api.bitbucket.org/2.0/addon \
   *   -H "Authorization: JWT <JWT Token>" \
   *   --header "Content-Type: application/json" \
   *   --data '{"descriptor_url": $NEW_URL}'
   * ```
   *
   * The `descriptor_url` must exactly match the marketplace registration
   * that Atlassian has for the application. Contact your Atlassian
   * developer advocate to update this registration. Once the registration
   * has been updated you may call this resource for each installation.
   *
   * Note that the scopes of the application cannot be increased
   * in the new descriptor nor reduced to none.
   */
  putAddon(config?: AxiosRequestConfig): Promise<operations.PutAddonResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/addon";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutAddonResponse = new operations.PutAddonResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a linker value
   *
   * @remarks
   * Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified
   * linker of the authenticated application.
   *
   * A linker value lets applications supply values to modify its regular expression.
   *
   * The base regular expression must use a Bitbucket-specific match group `(?K)`
   * which will be translated to `([\w\-]+)`. A value must match this pattern.
   *
   * [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
   */
  putAddonLinkersLinkerKeyValues(
    req: operations.PutAddonLinkersLinkerKeyValuesRequest,
    security: operations.PutAddonLinkersLinkerKeyValuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutAddonLinkersLinkerKeyValuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutAddonLinkersLinkerKeyValuesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/addon/linkers/{linker_key}/values",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutAddonLinkersLinkerKeyValuesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutAddonLinkersLinkerKeyValuesResponse =
        new operations.PutAddonLinkersLinkerKeyValuesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }
}
