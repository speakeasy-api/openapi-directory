// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
)

type SearchResponseResultsType string

const (
	SearchResponseResultsTypeEpisodeSearchResult     SearchResponseResultsType = "EpisodeSearchResult"
	SearchResponseResultsTypePodcastSearchResult     SearchResponseResultsType = "PodcastSearchResult"
	SearchResponseResultsTypeCuratedListSearchResult SearchResponseResultsType = "CuratedListSearchResult"
)

type SearchResponseResults struct {
	EpisodeSearchResult     *EpisodeSearchResult
	PodcastSearchResult     *PodcastSearchResult
	CuratedListSearchResult *CuratedListSearchResult

	Type SearchResponseResultsType
}

func CreateSearchResponseResultsEpisodeSearchResult(episodeSearchResult EpisodeSearchResult) SearchResponseResults {
	typ := SearchResponseResultsTypeEpisodeSearchResult

	return SearchResponseResults{
		EpisodeSearchResult: &episodeSearchResult,
		Type:                typ,
	}
}

func CreateSearchResponseResultsPodcastSearchResult(podcastSearchResult PodcastSearchResult) SearchResponseResults {
	typ := SearchResponseResultsTypePodcastSearchResult

	return SearchResponseResults{
		PodcastSearchResult: &podcastSearchResult,
		Type:                typ,
	}
}

func CreateSearchResponseResultsCuratedListSearchResult(curatedListSearchResult CuratedListSearchResult) SearchResponseResults {
	typ := SearchResponseResultsTypeCuratedListSearchResult

	return SearchResponseResults{
		CuratedListSearchResult: &curatedListSearchResult,
		Type:                    typ,
	}
}

func (u *SearchResponseResults) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	episodeSearchResult := new(EpisodeSearchResult)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&episodeSearchResult); err == nil {
		u.EpisodeSearchResult = episodeSearchResult
		u.Type = SearchResponseResultsTypeEpisodeSearchResult
		return nil
	}

	podcastSearchResult := new(PodcastSearchResult)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&podcastSearchResult); err == nil {
		u.PodcastSearchResult = podcastSearchResult
		u.Type = SearchResponseResultsTypePodcastSearchResult
		return nil
	}

	curatedListSearchResult := new(CuratedListSearchResult)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&curatedListSearchResult); err == nil {
		u.CuratedListSearchResult = curatedListSearchResult
		u.Type = SearchResponseResultsTypeCuratedListSearchResult
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SearchResponseResults) MarshalJSON() ([]byte, error) {
	if u.EpisodeSearchResult != nil {
		return json.Marshal(u.EpisodeSearchResult)
	}

	if u.PodcastSearchResult != nil {
		return json.Marshal(u.PodcastSearchResult)
	}

	if u.CuratedListSearchResult != nil {
		return json.Marshal(u.CuratedListSearchResult)
	}

	return nil, nil
}

// SearchResponse - OK
type SearchResponse struct {
	// The number of search results in this page.
	Count *int64 `json:"count,omitempty"`
	// Pass this value to the **offset** parameter to do pagination of search results.
	NextOffset *int64 `json:"next_offset,omitempty"`
	// A list of search results.
	Results []SearchResponseResults `json:"results,omitempty"`
	// The time it took to fetch these search results. In seconds.
	Took *float64 `json:"took,omitempty"`
	// The total number of search results.
	Total *int64 `json:"total,omitempty"`
}
