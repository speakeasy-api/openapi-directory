/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Expose, Type } from "class-transformer";

/**
 * How the subscription is managed in the downstream.
 */
export enum WebhookSupportManagedViaEnum {
  Manual = "manual",
  Api = "api",
}

/**
 * Mode of the webhook support.
 */
export enum WebhookSupportModeEnum {
  Native = "native",
  Virtual = "virtual",
  None = "none",
}

/**
 * Received events are scoped to connection or across integration.
 */
export enum WebhookSupportSubscriptionLevelEnum {
  Connection = "connection",
  Integration = "integration",
}

/**
 * The window unit for the rate.
 */
export enum WebhookSupportVirtualWebhooksRequestRateUnitEnum {
  Second = "second",
  Minute = "minute",
  Hour = "hour",
  Day = "day",
}

/**
 * The rate at which requests for resources will be made to downstream.
 */
export class WebhookSupportVirtualWebhooksRequestRate extends SpeakeasyBase {
  /**
   * The number of requests per window unit.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "rate" })
  rate: number;

  /**
   * Size of request window.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "size" })
  size: number;

  /**
   * The window unit for the rate.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "unit" })
  unit: WebhookSupportVirtualWebhooksRequestRateUnitEnum;
}

/**
 * Virtual webhook config for the connector.
 */
export class WebhookSupportVirtualWebhooks extends SpeakeasyBase {
  /**
   * The rate at which requests for resources will be made to downstream.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "request_rate" })
  @Type(() => WebhookSupportVirtualWebhooksRequestRate)
  requestRate: WebhookSupportVirtualWebhooksRequestRate;

  /**
   * The resources that will be requested from downstream.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "resources" })
  resources?: Record<string, any>;
}

/**
 * How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling.
 */
export class WebhookSupport extends SpeakeasyBase {
  /**
   * How the subscription is managed in the downstream.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "managed_via" })
  managedVia?: WebhookSupportManagedViaEnum;

  /**
   * Mode of the webhook support.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "mode" })
  mode?: WebhookSupportModeEnum;

  /**
   * Received events are scoped to connection or across integration.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "subscription_level" })
  subscriptionLevel?: WebhookSupportSubscriptionLevelEnum;

  /**
   * Virtual webhook config for the connector.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "virtual_webhooks" })
  @Type(() => WebhookSupportVirtualWebhooks)
  virtualWebhooks?: WebhookSupportVirtualWebhooks;
}
