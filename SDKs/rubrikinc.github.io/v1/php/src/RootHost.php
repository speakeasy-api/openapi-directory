<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootHost 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Register hosts
     * 
     * Register multiple hosts and perform discovery for databases and Microsoft SQL Server instances. When called, this API returns a success message, but completes the host registration in the background. Monitor the status of the background host discovery with the "status" field in GET API on /hosts. The POST API on /hosts can take longer for discovery, depending on the number of hosts on the system. POST on this API can be used instead to perform the discovery in the background and quickly register the host. Doing this requires that you install RBS for Linux and Windows hosts, similar to regular register using POST on /hosts.
     * 
     * @param array<\OpenAPI\OpenAPI\Models\Shared\HostRegister> $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BulkRegisterHostAsyncResponse
     */
	public function bulkRegisterHostAsync(
        array $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BulkRegisterHostAsyncResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/bulk_background');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BulkRegisterHostAsyncResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetails = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\HostDetail>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a registered host
     * 
     * Delete host by specifying the host ID.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteHostResponse
     */
	public function deleteHost(
        \OpenAPI\OpenAPI\Models\Operations\DeleteHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Discover and return all shares on a NAS host
     * 
     * Discover and return all shares on the identified NAS host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DiscoverNasSharesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DiscoverNasSharesResponse
     */
	public function discoverNasShares(
        \OpenAPI\OpenAPI\Models\Operations\DiscoverNasSharesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DiscoverNasSharesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}/nas_share_discover', \OpenAPI\OpenAPI\Models\Operations\DiscoverNasSharesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DiscoverNasSharesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->discoveredNasShares = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\DiscoveredNasShare>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for a host
     * 
     * Retrieve summary information for a registered host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetHostResponse
     */
	public function getHost(
        \OpenAPI\OpenAPI\Models\Operations\GetHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}', \OpenAPI\OpenAPI\Models\Operations\GetHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the Rubrik Backup Service details for a host
     * 
     * Get the details of the Rubrik Backup Service (RBS) installed on a specific host. Specify the details of the host to check whether RBS is installed on the host or not. If RBS is installed, the response will include the RBS details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRbsHostInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRbsHostInfoResponse
     */
	public function getRbsHostInfo(
        \OpenAPI\OpenAPI\Models\Operations\GetRbsHostInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRbsHostInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/rbs');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRbsHostInfoRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRbsHostInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rbsHostSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RbsHostSummary', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 422) {
        }

        return $response;
    }
	
    /**
     * Make this cluster the primary for agents on a set of hosts
     * 
     * Migrate the primary cluster with which the agent is able to perform regular operations (backup, restore etc). This can be done on a specified set of hosts or for all hosts that currently have a specified primary cluster for disaster recovery. Specify exactly one of `ids` or `oldPrimaryClusterUuid`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\HostMakePrimaryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HostMakePrimaryResponse
     */
	public function hostMakePrimary(
        \OpenAPI\OpenAPI\Models\Shared\HostMakePrimaryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HostMakePrimaryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/make_primary');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HostMakePrimaryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for hosts
     * 
     * Retrieve summary information for all hosts that are registered with a Rubrik cluster.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryHostResponse
     */
	public function queryHost(
        \OpenAPI\OpenAPI\Models\Operations\QueryHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryHostRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of Volume Group volumes
     * 
     * Retrieve summary information for each volume on a specified Volume Group host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryHostVolumeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryHostVolumeResponse
     */
	public function queryHostVolume(
        \OpenAPI\OpenAPI\Models\Operations\QueryHostVolumeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryHostVolumeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}/volume', \OpenAPI\OpenAPI\Models\Operations\QueryHostVolumeRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryHostVolumeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostVolumeSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostVolumeSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Install Rubrik Backup Service on a host
     * 
     * Install Rubrik Backup Service on a host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\RbsHostOperationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RbsInstallResponse
     */
	public function rbsInstall(
        \OpenAPI\OpenAPI\Models\Shared\RbsHostOperationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RbsInstallResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/rbs/install');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RbsInstallResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rbsHostOperationResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RbsHostOperationResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 408 or $httpResponse->getStatusCode() === 422) {
        }

        return $response;
    }
	
    /**
     * Uninstall Rubrik Backup Service from a host
     * 
     * Uninstall Rubrik Backup Service from a host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\RbsHostOperationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RbsUninstallResponse
     */
	public function rbsUninstall(
        \OpenAPI\OpenAPI\Models\Shared\RbsHostOperationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RbsUninstallResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/rbs/uninstall');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RbsUninstallResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rbsHostOperationResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RbsHostOperationResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 408 or $httpResponse->getStatusCode() === 422) {
        }

        return $response;
    }
	
    /**
     * Upgrade Rubrik Backup Service on a host
     * 
     * Upgrade Rubrik Backup Service on a host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\RbsHostOperationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RbsUpgradeResponse
     */
	public function rbsUpgrade(
        \OpenAPI\OpenAPI\Models\Shared\RbsHostOperationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RbsUpgradeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/rbs/upgrade');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RbsUpgradeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rbsHostOperationResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RbsHostOperationResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 408 or $httpResponse->getStatusCode() === 422) {
        }

        return $response;
    }
	
    /**
     * Refresh a host
     * 
     * Refresh the properties of a host object when changes on the host are not seen in the Rubrik web UI.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RefreshHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RefreshHostResponse
     */
	public function refreshHost(
        \OpenAPI\OpenAPI\Models\Operations\RefreshHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RefreshHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}/refresh', \OpenAPI\OpenAPI\Models\Operations\RefreshHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RefreshHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Register a host
     * 
     * Register a host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\HostRegister $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegisterHostResponse
     */
	public function registerHost(
        \OpenAPI\OpenAPI\Models\Shared\HostRegister $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegisterHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegisterHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Register a host
     * 
     * Register a host and perform discovery for databases and Microsoft SQL Server instances. When called, this API returns a success message, but completes the host registration in the background. Monitor the status of the background host discovery with the "status" field in GET API on /hosts. The POST API on /hosts can take longer for discovery, depending on the number of hosts on the system. POST on this API can be used instead to perform the discovery in the background and quickly register the host. Doing this requires that you install RBS for Linux and Windows hosts, similar to regular register using POST on /hosts.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\HostRegister $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RegisterHostAsyncResponse
     */
	public function registerHostAsync(
        \OpenAPI\OpenAPI\Models\Shared\HostRegister $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RegisterHostAsyncResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/background');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RegisterHostAsyncResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Search for a file within the host
     * 
     * Search for a file within the host. Search via full path prefix or filename prefix.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchHostResponse
     */
	public function searchHost(
        \OpenAPI\OpenAPI\Models\Operations\SearchHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}/search', \OpenAPI\OpenAPI\Models\Operations\SearchHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SearchHostRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->searchResponseListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\SearchResponseListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update certificate
     * 
     * Provide an updated certificate for a specified host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateCertificateHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateCertificateHostResponse
     */
	public function updateCertificateHost(
        \OpenAPI\OpenAPI\Models\Operations\UpdateCertificateHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateCertificateHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/certificate/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateCertificateHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateCertificateHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modify information for a registered host
     * 
     * Change the FQDN and IPv4 address that is assigned to a host object. Enable or disable pre-transfer data compression. Enable or disable change block tracking (CBT) for backups of SQL Server databases on Windows hosts. Enable or disable volume filter driver (VFD) for volume backups on Windows hosts. Set an Oracle user with sysdba privileges to permit Oracle discovery queries.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateHostRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateHostResponse
     */
	public function updateHost(
        \OpenAPI\OpenAPI\Models\Operations\UpdateHostRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateHostResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/host/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateHostRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "hostUpdate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateHostResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->hostDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\HostDetail', 'json');
            }
        }

        return $response;
    }
}