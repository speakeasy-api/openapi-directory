"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Dcim:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def dcim_choices_list(self) -> operations.DcimChoicesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/_choices/'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimChoicesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_choices_read(self, request: operations.DcimChoicesReadRequest) -> operations.DcimChoicesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimChoicesReadRequest, base_url, '/dcim/_choices/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimChoicesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_connected_device_list(self, request: operations.DcimConnectedDeviceListRequest) -> operations.DcimConnectedDeviceListResponse:
        r"""This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer
        interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors
        via a protocol such as LLDP. Two query parameters must be included in the request:
        
        * `peer_device`: The name of the peer device
        * `peer_interface`: The name of the peer interface
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/connected-device/'
        
        query_params = utils.get_query_params(operations.DcimConnectedDeviceListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConnectedDeviceListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out

        return res

    def dcim_console_connections_list(self, request: operations.DcimConsoleConnectionsListRequest) -> operations.DcimConsoleConnectionsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-connections/'
        
        query_params = utils.get_query_params(operations.DcimConsoleConnectionsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleConnectionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimConsoleConnectionsList200ApplicationJSON])
                res.dcim_console_connections_list_200_application_json_object = out

        return res

    def dcim_console_port_templates_create(self, request: shared.WritableConsolePortTemplateInput) -> operations.DcimConsolePortTemplatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-port-templates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortTemplatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePortTemplate])
                res.console_port_template = out

        return res

    def dcim_console_port_templates_delete(self, request: operations.DcimConsolePortTemplatesDeleteRequest) -> operations.DcimConsolePortTemplatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortTemplatesDeleteRequest, base_url, '/dcim/console-port-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortTemplatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_console_port_templates_list(self, request: operations.DcimConsolePortTemplatesListRequest) -> operations.DcimConsolePortTemplatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-port-templates/'
        
        query_params = utils.get_query_params(operations.DcimConsolePortTemplatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortTemplatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimConsolePortTemplatesList200ApplicationJSON])
                res.dcim_console_port_templates_list_200_application_json_object = out

        return res

    def dcim_console_port_templates_partial_update(self, request: operations.DcimConsolePortTemplatesPartialUpdateRequest) -> operations.DcimConsolePortTemplatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortTemplatesPartialUpdateRequest, base_url, '/dcim/console-port-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_port_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortTemplatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePortTemplate])
                res.console_port_template = out

        return res

    def dcim_console_port_templates_read(self, request: operations.DcimConsolePortTemplatesReadRequest) -> operations.DcimConsolePortTemplatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortTemplatesReadRequest, base_url, '/dcim/console-port-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortTemplatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePortTemplate])
                res.console_port_template = out

        return res

    def dcim_console_port_templates_update(self, request: operations.DcimConsolePortTemplatesUpdateRequest) -> operations.DcimConsolePortTemplatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortTemplatesUpdateRequest, base_url, '/dcim/console-port-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_port_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortTemplatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePortTemplate])
                res.console_port_template = out

        return res

    def dcim_console_ports_create(self, request: shared.WritableConsolePortInput) -> operations.DcimConsolePortsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-ports/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePort])
                res.console_port = out

        return res

    def dcim_console_ports_delete(self, request: operations.DcimConsolePortsDeleteRequest) -> operations.DcimConsolePortsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortsDeleteRequest, base_url, '/dcim/console-ports/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_console_ports_list(self, request: operations.DcimConsolePortsListRequest) -> operations.DcimConsolePortsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-ports/'
        
        query_params = utils.get_query_params(operations.DcimConsolePortsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimConsolePortsList200ApplicationJSON])
                res.dcim_console_ports_list_200_application_json_object = out

        return res

    def dcim_console_ports_partial_update(self, request: operations.DcimConsolePortsPartialUpdateRequest) -> operations.DcimConsolePortsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortsPartialUpdateRequest, base_url, '/dcim/console-ports/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_port_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePort])
                res.console_port = out

        return res

    def dcim_console_ports_read(self, request: operations.DcimConsolePortsReadRequest) -> operations.DcimConsolePortsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortsReadRequest, base_url, '/dcim/console-ports/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePort])
                res.console_port = out

        return res

    def dcim_console_ports_update(self, request: operations.DcimConsolePortsUpdateRequest) -> operations.DcimConsolePortsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsolePortsUpdateRequest, base_url, '/dcim/console-ports/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_port_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsolePortsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsolePort])
                res.console_port = out

        return res

    def dcim_console_server_port_templates_create(self, request: shared.WritableConsoleServerPortTemplateInput) -> operations.DcimConsoleServerPortTemplatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-server-port-templates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortTemplatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPortTemplate])
                res.console_server_port_template = out

        return res

    def dcim_console_server_port_templates_delete(self, request: operations.DcimConsoleServerPortTemplatesDeleteRequest) -> operations.DcimConsoleServerPortTemplatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortTemplatesDeleteRequest, base_url, '/dcim/console-server-port-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortTemplatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_console_server_port_templates_list(self, request: operations.DcimConsoleServerPortTemplatesListRequest) -> operations.DcimConsoleServerPortTemplatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-server-port-templates/'
        
        query_params = utils.get_query_params(operations.DcimConsoleServerPortTemplatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortTemplatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimConsoleServerPortTemplatesList200ApplicationJSON])
                res.dcim_console_server_port_templates_list_200_application_json_object = out

        return res

    def dcim_console_server_port_templates_partial_update(self, request: operations.DcimConsoleServerPortTemplatesPartialUpdateRequest) -> operations.DcimConsoleServerPortTemplatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortTemplatesPartialUpdateRequest, base_url, '/dcim/console-server-port-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_server_port_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortTemplatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPortTemplate])
                res.console_server_port_template = out

        return res

    def dcim_console_server_port_templates_read(self, request: operations.DcimConsoleServerPortTemplatesReadRequest) -> operations.DcimConsoleServerPortTemplatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortTemplatesReadRequest, base_url, '/dcim/console-server-port-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortTemplatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPortTemplate])
                res.console_server_port_template = out

        return res

    def dcim_console_server_port_templates_update(self, request: operations.DcimConsoleServerPortTemplatesUpdateRequest) -> operations.DcimConsoleServerPortTemplatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortTemplatesUpdateRequest, base_url, '/dcim/console-server-port-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_server_port_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortTemplatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPortTemplate])
                res.console_server_port_template = out

        return res

    def dcim_console_server_ports_create(self, request: shared.WritableConsoleServerPortInput) -> operations.DcimConsoleServerPortsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-server-ports/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPort])
                res.console_server_port = out

        return res

    def dcim_console_server_ports_delete(self, request: operations.DcimConsoleServerPortsDeleteRequest) -> operations.DcimConsoleServerPortsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortsDeleteRequest, base_url, '/dcim/console-server-ports/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_console_server_ports_list(self, request: operations.DcimConsoleServerPortsListRequest) -> operations.DcimConsoleServerPortsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/console-server-ports/'
        
        query_params = utils.get_query_params(operations.DcimConsoleServerPortsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimConsoleServerPortsList200ApplicationJSON])
                res.dcim_console_server_ports_list_200_application_json_object = out

        return res

    def dcim_console_server_ports_partial_update(self, request: operations.DcimConsoleServerPortsPartialUpdateRequest) -> operations.DcimConsoleServerPortsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortsPartialUpdateRequest, base_url, '/dcim/console-server-ports/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_server_port_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPort])
                res.console_server_port = out

        return res

    def dcim_console_server_ports_read(self, request: operations.DcimConsoleServerPortsReadRequest) -> operations.DcimConsoleServerPortsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortsReadRequest, base_url, '/dcim/console-server-ports/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPort])
                res.console_server_port = out

        return res

    def dcim_console_server_ports_update(self, request: operations.DcimConsoleServerPortsUpdateRequest) -> operations.DcimConsoleServerPortsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimConsoleServerPortsUpdateRequest, base_url, '/dcim/console-server-ports/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_console_server_port_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimConsoleServerPortsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConsoleServerPort])
                res.console_server_port = out

        return res

    def dcim_device_bay_templates_create(self, request: shared.WritableDeviceBayTemplateInput) -> operations.DcimDeviceBayTemplatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-bay-templates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBayTemplatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBayTemplate])
                res.device_bay_template = out

        return res

    def dcim_device_bay_templates_delete(self, request: operations.DcimDeviceBayTemplatesDeleteRequest) -> operations.DcimDeviceBayTemplatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBayTemplatesDeleteRequest, base_url, '/dcim/device-bay-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBayTemplatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_device_bay_templates_list(self, request: operations.DcimDeviceBayTemplatesListRequest) -> operations.DcimDeviceBayTemplatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-bay-templates/'
        
        query_params = utils.get_query_params(operations.DcimDeviceBayTemplatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBayTemplatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimDeviceBayTemplatesList200ApplicationJSON])
                res.dcim_device_bay_templates_list_200_application_json_object = out

        return res

    def dcim_device_bay_templates_partial_update(self, request: operations.DcimDeviceBayTemplatesPartialUpdateRequest) -> operations.DcimDeviceBayTemplatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBayTemplatesPartialUpdateRequest, base_url, '/dcim/device-bay-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_bay_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBayTemplatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBayTemplate])
                res.device_bay_template = out

        return res

    def dcim_device_bay_templates_read(self, request: operations.DcimDeviceBayTemplatesReadRequest) -> operations.DcimDeviceBayTemplatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBayTemplatesReadRequest, base_url, '/dcim/device-bay-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBayTemplatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBayTemplate])
                res.device_bay_template = out

        return res

    def dcim_device_bay_templates_update(self, request: operations.DcimDeviceBayTemplatesUpdateRequest) -> operations.DcimDeviceBayTemplatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBayTemplatesUpdateRequest, base_url, '/dcim/device-bay-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_bay_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBayTemplatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBayTemplate])
                res.device_bay_template = out

        return res

    def dcim_device_bays_create(self, request: shared.WritableDeviceBayInput) -> operations.DcimDeviceBaysCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-bays/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBaysCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBay])
                res.device_bay = out

        return res

    def dcim_device_bays_delete(self, request: operations.DcimDeviceBaysDeleteRequest) -> operations.DcimDeviceBaysDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBaysDeleteRequest, base_url, '/dcim/device-bays/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBaysDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_device_bays_list(self, request: operations.DcimDeviceBaysListRequest) -> operations.DcimDeviceBaysListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-bays/'
        
        query_params = utils.get_query_params(operations.DcimDeviceBaysListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBaysListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimDeviceBaysList200ApplicationJSON])
                res.dcim_device_bays_list_200_application_json_object = out

        return res

    def dcim_device_bays_partial_update(self, request: operations.DcimDeviceBaysPartialUpdateRequest) -> operations.DcimDeviceBaysPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBaysPartialUpdateRequest, base_url, '/dcim/device-bays/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_bay_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBaysPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBay])
                res.device_bay = out

        return res

    def dcim_device_bays_read(self, request: operations.DcimDeviceBaysReadRequest) -> operations.DcimDeviceBaysReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBaysReadRequest, base_url, '/dcim/device-bays/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBaysReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBay])
                res.device_bay = out

        return res

    def dcim_device_bays_update(self, request: operations.DcimDeviceBaysUpdateRequest) -> operations.DcimDeviceBaysUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceBaysUpdateRequest, base_url, '/dcim/device-bays/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_bay_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceBaysUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceBay])
                res.device_bay = out

        return res

    def dcim_device_roles_create(self, request: shared.DeviceRoleInput) -> operations.DcimDeviceRolesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-roles/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceRolesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceRole])
                res.device_role = out

        return res

    def dcim_device_roles_delete(self, request: operations.DcimDeviceRolesDeleteRequest) -> operations.DcimDeviceRolesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceRolesDeleteRequest, base_url, '/dcim/device-roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceRolesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_device_roles_list(self, request: operations.DcimDeviceRolesListRequest) -> operations.DcimDeviceRolesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-roles/'
        
        query_params = utils.get_query_params(operations.DcimDeviceRolesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceRolesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimDeviceRolesList200ApplicationJSON])
                res.dcim_device_roles_list_200_application_json_object = out

        return res

    def dcim_device_roles_partial_update(self, request: operations.DcimDeviceRolesPartialUpdateRequest) -> operations.DcimDeviceRolesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceRolesPartialUpdateRequest, base_url, '/dcim/device-roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "device_role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceRolesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceRole])
                res.device_role = out

        return res

    def dcim_device_roles_read(self, request: operations.DcimDeviceRolesReadRequest) -> operations.DcimDeviceRolesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceRolesReadRequest, base_url, '/dcim/device-roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceRolesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceRole])
                res.device_role = out

        return res

    def dcim_device_roles_update(self, request: operations.DcimDeviceRolesUpdateRequest) -> operations.DcimDeviceRolesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceRolesUpdateRequest, base_url, '/dcim/device-roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "device_role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceRolesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceRole])
                res.device_role = out

        return res

    def dcim_device_types_create(self, request: shared.WritableDeviceTypeInput) -> operations.DcimDeviceTypesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-types/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceTypesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceType])
                res.device_type = out

        return res

    def dcim_device_types_delete(self, request: operations.DcimDeviceTypesDeleteRequest) -> operations.DcimDeviceTypesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceTypesDeleteRequest, base_url, '/dcim/device-types/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceTypesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_device_types_list(self, request: operations.DcimDeviceTypesListRequest) -> operations.DcimDeviceTypesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/device-types/'
        
        query_params = utils.get_query_params(operations.DcimDeviceTypesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceTypesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimDeviceTypesList200ApplicationJSON])
                res.dcim_device_types_list_200_application_json_object = out

        return res

    def dcim_device_types_partial_update(self, request: operations.DcimDeviceTypesPartialUpdateRequest) -> operations.DcimDeviceTypesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceTypesPartialUpdateRequest, base_url, '/dcim/device-types/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_type_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceTypesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceType])
                res.device_type = out

        return res

    def dcim_device_types_read(self, request: operations.DcimDeviceTypesReadRequest) -> operations.DcimDeviceTypesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceTypesReadRequest, base_url, '/dcim/device-types/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceTypesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceType])
                res.device_type = out

        return res

    def dcim_device_types_update(self, request: operations.DcimDeviceTypesUpdateRequest) -> operations.DcimDeviceTypesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDeviceTypesUpdateRequest, base_url, '/dcim/device-types/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_type_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDeviceTypesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceType])
                res.device_type = out

        return res

    def dcim_devices_create(self, request: shared.WritableDeviceInput) -> operations.DcimDevicesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/devices/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out

        return res

    def dcim_devices_delete(self, request: operations.DcimDevicesDeleteRequest) -> operations.DcimDevicesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDevicesDeleteRequest, base_url, '/dcim/devices/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_devices_list(self, request: operations.DcimDevicesListRequest) -> operations.DcimDevicesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/devices/'
        
        query_params = utils.get_query_params(operations.DcimDevicesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimDevicesList200ApplicationJSON])
                res.dcim_devices_list_200_application_json_object = out

        return res

    def dcim_devices_napalm(self, request: operations.DcimDevicesNapalmRequest) -> operations.DcimDevicesNapalmResponse:
        r"""Execute a NAPALM method on a Device"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDevicesNapalmRequest, base_url, '/dcim/devices/{id}/napalm/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesNapalmResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out

        return res

    def dcim_devices_partial_update(self, request: operations.DcimDevicesPartialUpdateRequest) -> operations.DcimDevicesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDevicesPartialUpdateRequest, base_url, '/dcim/devices/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out

        return res

    def dcim_devices_read(self, request: operations.DcimDevicesReadRequest) -> operations.DcimDevicesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDevicesReadRequest, base_url, '/dcim/devices/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeviceWithConfigContext])
                res.device_with_config_context = out

        return res

    def dcim_devices_update(self, request: operations.DcimDevicesUpdateRequest) -> operations.DcimDevicesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimDevicesUpdateRequest, base_url, '/dcim/devices/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_device_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimDevicesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Device])
                res.device = out

        return res

    def dcim_interface_connections_create(self, request: shared.WritableInterfaceConnectionInput) -> operations.DcimInterfaceConnectionsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/interface-connections/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceConnectionsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceConnection])
                res.interface_connection = out

        return res

    def dcim_interface_connections_delete(self, request: operations.DcimInterfaceConnectionsDeleteRequest) -> operations.DcimInterfaceConnectionsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceConnectionsDeleteRequest, base_url, '/dcim/interface-connections/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceConnectionsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_interface_connections_list(self, request: operations.DcimInterfaceConnectionsListRequest) -> operations.DcimInterfaceConnectionsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/interface-connections/'
        
        query_params = utils.get_query_params(operations.DcimInterfaceConnectionsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceConnectionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimInterfaceConnectionsList200ApplicationJSON])
                res.dcim_interface_connections_list_200_application_json_object = out

        return res

    def dcim_interface_connections_partial_update(self, request: operations.DcimInterfaceConnectionsPartialUpdateRequest) -> operations.DcimInterfaceConnectionsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceConnectionsPartialUpdateRequest, base_url, '/dcim/interface-connections/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_interface_connection_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceConnectionsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceConnection])
                res.interface_connection = out

        return res

    def dcim_interface_connections_read(self, request: operations.DcimInterfaceConnectionsReadRequest) -> operations.DcimInterfaceConnectionsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceConnectionsReadRequest, base_url, '/dcim/interface-connections/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceConnectionsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceConnection])
                res.interface_connection = out

        return res

    def dcim_interface_connections_update(self, request: operations.DcimInterfaceConnectionsUpdateRequest) -> operations.DcimInterfaceConnectionsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceConnectionsUpdateRequest, base_url, '/dcim/interface-connections/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_interface_connection_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceConnectionsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceConnection])
                res.interface_connection = out

        return res

    def dcim_interface_templates_create(self, request: shared.WritableInterfaceTemplateInput) -> operations.DcimInterfaceTemplatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/interface-templates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceTemplatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceTemplate])
                res.interface_template = out

        return res

    def dcim_interface_templates_delete(self, request: operations.DcimInterfaceTemplatesDeleteRequest) -> operations.DcimInterfaceTemplatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceTemplatesDeleteRequest, base_url, '/dcim/interface-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceTemplatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_interface_templates_list(self, request: operations.DcimInterfaceTemplatesListRequest) -> operations.DcimInterfaceTemplatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/interface-templates/'
        
        query_params = utils.get_query_params(operations.DcimInterfaceTemplatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceTemplatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimInterfaceTemplatesList200ApplicationJSON])
                res.dcim_interface_templates_list_200_application_json_object = out

        return res

    def dcim_interface_templates_partial_update(self, request: operations.DcimInterfaceTemplatesPartialUpdateRequest) -> operations.DcimInterfaceTemplatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceTemplatesPartialUpdateRequest, base_url, '/dcim/interface-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_interface_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceTemplatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceTemplate])
                res.interface_template = out

        return res

    def dcim_interface_templates_read(self, request: operations.DcimInterfaceTemplatesReadRequest) -> operations.DcimInterfaceTemplatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceTemplatesReadRequest, base_url, '/dcim/interface-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceTemplatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceTemplate])
                res.interface_template = out

        return res

    def dcim_interface_templates_update(self, request: operations.DcimInterfaceTemplatesUpdateRequest) -> operations.DcimInterfaceTemplatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfaceTemplatesUpdateRequest, base_url, '/dcim/interface-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_interface_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfaceTemplatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InterfaceTemplate])
                res.interface_template = out

        return res

    def dcim_interfaces_create(self, request: shared.WritableInterfaceInput) -> operations.DcimInterfacesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/interfaces/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Interface])
                res.interface = out

        return res

    def dcim_interfaces_delete(self, request: operations.DcimInterfacesDeleteRequest) -> operations.DcimInterfacesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfacesDeleteRequest, base_url, '/dcim/interfaces/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_interfaces_graphs(self, request: operations.DcimInterfacesGraphsRequest) -> operations.DcimInterfacesGraphsResponse:
        r"""A convenience method for rendering graphs for a particular interface."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfacesGraphsRequest, base_url, '/dcim/interfaces/{id}/graphs/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesGraphsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Interface])
                res.interface = out

        return res

    def dcim_interfaces_list(self, request: operations.DcimInterfacesListRequest) -> operations.DcimInterfacesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/interfaces/'
        
        query_params = utils.get_query_params(operations.DcimInterfacesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimInterfacesList200ApplicationJSON])
                res.dcim_interfaces_list_200_application_json_object = out

        return res

    def dcim_interfaces_partial_update(self, request: operations.DcimInterfacesPartialUpdateRequest) -> operations.DcimInterfacesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfacesPartialUpdateRequest, base_url, '/dcim/interfaces/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_interface_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Interface])
                res.interface = out

        return res

    def dcim_interfaces_read(self, request: operations.DcimInterfacesReadRequest) -> operations.DcimInterfacesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfacesReadRequest, base_url, '/dcim/interfaces/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Interface])
                res.interface = out

        return res

    def dcim_interfaces_update(self, request: operations.DcimInterfacesUpdateRequest) -> operations.DcimInterfacesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInterfacesUpdateRequest, base_url, '/dcim/interfaces/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_interface_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInterfacesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Interface])
                res.interface = out

        return res

    def dcim_inventory_items_create(self, request: shared.WritableInventoryItemInput) -> operations.DcimInventoryItemsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/inventory-items/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInventoryItemsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InventoryItem])
                res.inventory_item = out

        return res

    def dcim_inventory_items_delete(self, request: operations.DcimInventoryItemsDeleteRequest) -> operations.DcimInventoryItemsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInventoryItemsDeleteRequest, base_url, '/dcim/inventory-items/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInventoryItemsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_inventory_items_list(self, request: operations.DcimInventoryItemsListRequest) -> operations.DcimInventoryItemsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/inventory-items/'
        
        query_params = utils.get_query_params(operations.DcimInventoryItemsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInventoryItemsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimInventoryItemsList200ApplicationJSON])
                res.dcim_inventory_items_list_200_application_json_object = out

        return res

    def dcim_inventory_items_partial_update(self, request: operations.DcimInventoryItemsPartialUpdateRequest) -> operations.DcimInventoryItemsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInventoryItemsPartialUpdateRequest, base_url, '/dcim/inventory-items/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_inventory_item_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInventoryItemsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InventoryItem])
                res.inventory_item = out

        return res

    def dcim_inventory_items_read(self, request: operations.DcimInventoryItemsReadRequest) -> operations.DcimInventoryItemsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInventoryItemsReadRequest, base_url, '/dcim/inventory-items/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInventoryItemsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InventoryItem])
                res.inventory_item = out

        return res

    def dcim_inventory_items_update(self, request: operations.DcimInventoryItemsUpdateRequest) -> operations.DcimInventoryItemsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimInventoryItemsUpdateRequest, base_url, '/dcim/inventory-items/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_inventory_item_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimInventoryItemsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InventoryItem])
                res.inventory_item = out

        return res

    def dcim_manufacturers_create(self, request: shared.ManufacturerInput) -> operations.DcimManufacturersCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/manufacturers/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimManufacturersCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Manufacturer])
                res.manufacturer = out

        return res

    def dcim_manufacturers_delete(self, request: operations.DcimManufacturersDeleteRequest) -> operations.DcimManufacturersDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimManufacturersDeleteRequest, base_url, '/dcim/manufacturers/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimManufacturersDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_manufacturers_list(self, request: operations.DcimManufacturersListRequest) -> operations.DcimManufacturersListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/manufacturers/'
        
        query_params = utils.get_query_params(operations.DcimManufacturersListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimManufacturersListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimManufacturersList200ApplicationJSON])
                res.dcim_manufacturers_list_200_application_json_object = out

        return res

    def dcim_manufacturers_partial_update(self, request: operations.DcimManufacturersPartialUpdateRequest) -> operations.DcimManufacturersPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimManufacturersPartialUpdateRequest, base_url, '/dcim/manufacturers/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "manufacturer_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimManufacturersPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Manufacturer])
                res.manufacturer = out

        return res

    def dcim_manufacturers_read(self, request: operations.DcimManufacturersReadRequest) -> operations.DcimManufacturersReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimManufacturersReadRequest, base_url, '/dcim/manufacturers/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimManufacturersReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Manufacturer])
                res.manufacturer = out

        return res

    def dcim_manufacturers_update(self, request: operations.DcimManufacturersUpdateRequest) -> operations.DcimManufacturersUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimManufacturersUpdateRequest, base_url, '/dcim/manufacturers/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "manufacturer_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimManufacturersUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Manufacturer])
                res.manufacturer = out

        return res

    def dcim_platforms_create(self, request: shared.WritablePlatformInput) -> operations.DcimPlatformsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/platforms/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPlatformsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Platform])
                res.platform = out

        return res

    def dcim_platforms_delete(self, request: operations.DcimPlatformsDeleteRequest) -> operations.DcimPlatformsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPlatformsDeleteRequest, base_url, '/dcim/platforms/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPlatformsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_platforms_list(self, request: operations.DcimPlatformsListRequest) -> operations.DcimPlatformsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/platforms/'
        
        query_params = utils.get_query_params(operations.DcimPlatformsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPlatformsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimPlatformsList200ApplicationJSON])
                res.dcim_platforms_list_200_application_json_object = out

        return res

    def dcim_platforms_partial_update(self, request: operations.DcimPlatformsPartialUpdateRequest) -> operations.DcimPlatformsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPlatformsPartialUpdateRequest, base_url, '/dcim/platforms/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_platform_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPlatformsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Platform])
                res.platform = out

        return res

    def dcim_platforms_read(self, request: operations.DcimPlatformsReadRequest) -> operations.DcimPlatformsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPlatformsReadRequest, base_url, '/dcim/platforms/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPlatformsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Platform])
                res.platform = out

        return res

    def dcim_platforms_update(self, request: operations.DcimPlatformsUpdateRequest) -> operations.DcimPlatformsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPlatformsUpdateRequest, base_url, '/dcim/platforms/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_platform_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPlatformsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Platform])
                res.platform = out

        return res

    def dcim_power_connections_list(self, request: operations.DcimPowerConnectionsListRequest) -> operations.DcimPowerConnectionsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-connections/'
        
        query_params = utils.get_query_params(operations.DcimPowerConnectionsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerConnectionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimPowerConnectionsList200ApplicationJSON])
                res.dcim_power_connections_list_200_application_json_object = out

        return res

    def dcim_power_outlet_templates_create(self, request: shared.WritablePowerOutletTemplateInput) -> operations.DcimPowerOutletTemplatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-outlet-templates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletTemplatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutletTemplate])
                res.power_outlet_template = out

        return res

    def dcim_power_outlet_templates_delete(self, request: operations.DcimPowerOutletTemplatesDeleteRequest) -> operations.DcimPowerOutletTemplatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletTemplatesDeleteRequest, base_url, '/dcim/power-outlet-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletTemplatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_power_outlet_templates_list(self, request: operations.DcimPowerOutletTemplatesListRequest) -> operations.DcimPowerOutletTemplatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-outlet-templates/'
        
        query_params = utils.get_query_params(operations.DcimPowerOutletTemplatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletTemplatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimPowerOutletTemplatesList200ApplicationJSON])
                res.dcim_power_outlet_templates_list_200_application_json_object = out

        return res

    def dcim_power_outlet_templates_partial_update(self, request: operations.DcimPowerOutletTemplatesPartialUpdateRequest) -> operations.DcimPowerOutletTemplatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletTemplatesPartialUpdateRequest, base_url, '/dcim/power-outlet-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_outlet_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletTemplatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutletTemplate])
                res.power_outlet_template = out

        return res

    def dcim_power_outlet_templates_read(self, request: operations.DcimPowerOutletTemplatesReadRequest) -> operations.DcimPowerOutletTemplatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletTemplatesReadRequest, base_url, '/dcim/power-outlet-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletTemplatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutletTemplate])
                res.power_outlet_template = out

        return res

    def dcim_power_outlet_templates_update(self, request: operations.DcimPowerOutletTemplatesUpdateRequest) -> operations.DcimPowerOutletTemplatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletTemplatesUpdateRequest, base_url, '/dcim/power-outlet-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_outlet_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletTemplatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutletTemplate])
                res.power_outlet_template = out

        return res

    def dcim_power_outlets_create(self, request: shared.WritablePowerOutletInput) -> operations.DcimPowerOutletsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-outlets/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutlet])
                res.power_outlet = out

        return res

    def dcim_power_outlets_delete(self, request: operations.DcimPowerOutletsDeleteRequest) -> operations.DcimPowerOutletsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletsDeleteRequest, base_url, '/dcim/power-outlets/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_power_outlets_list(self, request: operations.DcimPowerOutletsListRequest) -> operations.DcimPowerOutletsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-outlets/'
        
        query_params = utils.get_query_params(operations.DcimPowerOutletsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimPowerOutletsList200ApplicationJSON])
                res.dcim_power_outlets_list_200_application_json_object = out

        return res

    def dcim_power_outlets_partial_update(self, request: operations.DcimPowerOutletsPartialUpdateRequest) -> operations.DcimPowerOutletsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletsPartialUpdateRequest, base_url, '/dcim/power-outlets/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_outlet_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutlet])
                res.power_outlet = out

        return res

    def dcim_power_outlets_read(self, request: operations.DcimPowerOutletsReadRequest) -> operations.DcimPowerOutletsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletsReadRequest, base_url, '/dcim/power-outlets/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutlet])
                res.power_outlet = out

        return res

    def dcim_power_outlets_update(self, request: operations.DcimPowerOutletsUpdateRequest) -> operations.DcimPowerOutletsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerOutletsUpdateRequest, base_url, '/dcim/power-outlets/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_outlet_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerOutletsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerOutlet])
                res.power_outlet = out

        return res

    def dcim_power_port_templates_create(self, request: shared.WritablePowerPortTemplateInput) -> operations.DcimPowerPortTemplatesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-port-templates/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortTemplatesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPortTemplate])
                res.power_port_template = out

        return res

    def dcim_power_port_templates_delete(self, request: operations.DcimPowerPortTemplatesDeleteRequest) -> operations.DcimPowerPortTemplatesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortTemplatesDeleteRequest, base_url, '/dcim/power-port-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortTemplatesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_power_port_templates_list(self, request: operations.DcimPowerPortTemplatesListRequest) -> operations.DcimPowerPortTemplatesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-port-templates/'
        
        query_params = utils.get_query_params(operations.DcimPowerPortTemplatesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortTemplatesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimPowerPortTemplatesList200ApplicationJSON])
                res.dcim_power_port_templates_list_200_application_json_object = out

        return res

    def dcim_power_port_templates_partial_update(self, request: operations.DcimPowerPortTemplatesPartialUpdateRequest) -> operations.DcimPowerPortTemplatesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortTemplatesPartialUpdateRequest, base_url, '/dcim/power-port-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_port_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortTemplatesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPortTemplate])
                res.power_port_template = out

        return res

    def dcim_power_port_templates_read(self, request: operations.DcimPowerPortTemplatesReadRequest) -> operations.DcimPowerPortTemplatesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortTemplatesReadRequest, base_url, '/dcim/power-port-templates/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortTemplatesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPortTemplate])
                res.power_port_template = out

        return res

    def dcim_power_port_templates_update(self, request: operations.DcimPowerPortTemplatesUpdateRequest) -> operations.DcimPowerPortTemplatesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortTemplatesUpdateRequest, base_url, '/dcim/power-port-templates/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_port_template_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortTemplatesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPortTemplate])
                res.power_port_template = out

        return res

    def dcim_power_ports_create(self, request: shared.WritablePowerPortInput) -> operations.DcimPowerPortsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-ports/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPort])
                res.power_port = out

        return res

    def dcim_power_ports_delete(self, request: operations.DcimPowerPortsDeleteRequest) -> operations.DcimPowerPortsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortsDeleteRequest, base_url, '/dcim/power-ports/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_power_ports_list(self, request: operations.DcimPowerPortsListRequest) -> operations.DcimPowerPortsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/power-ports/'
        
        query_params = utils.get_query_params(operations.DcimPowerPortsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimPowerPortsList200ApplicationJSON])
                res.dcim_power_ports_list_200_application_json_object = out

        return res

    def dcim_power_ports_partial_update(self, request: operations.DcimPowerPortsPartialUpdateRequest) -> operations.DcimPowerPortsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortsPartialUpdateRequest, base_url, '/dcim/power-ports/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_port_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPort])
                res.power_port = out

        return res

    def dcim_power_ports_read(self, request: operations.DcimPowerPortsReadRequest) -> operations.DcimPowerPortsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortsReadRequest, base_url, '/dcim/power-ports/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPort])
                res.power_port = out

        return res

    def dcim_power_ports_update(self, request: operations.DcimPowerPortsUpdateRequest) -> operations.DcimPowerPortsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimPowerPortsUpdateRequest, base_url, '/dcim/power-ports/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_power_port_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimPowerPortsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PowerPort])
                res.power_port = out

        return res

    def dcim_rack_groups_create(self, request: shared.WritableRackGroupInput) -> operations.DcimRackGroupsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/rack-groups/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackGroupsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackGroup])
                res.rack_group = out

        return res

    def dcim_rack_groups_delete(self, request: operations.DcimRackGroupsDeleteRequest) -> operations.DcimRackGroupsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackGroupsDeleteRequest, base_url, '/dcim/rack-groups/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackGroupsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_rack_groups_list(self, request: operations.DcimRackGroupsListRequest) -> operations.DcimRackGroupsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/rack-groups/'
        
        query_params = utils.get_query_params(operations.DcimRackGroupsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackGroupsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimRackGroupsList200ApplicationJSON])
                res.dcim_rack_groups_list_200_application_json_object = out

        return res

    def dcim_rack_groups_partial_update(self, request: operations.DcimRackGroupsPartialUpdateRequest) -> operations.DcimRackGroupsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackGroupsPartialUpdateRequest, base_url, '/dcim/rack-groups/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_rack_group_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackGroupsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackGroup])
                res.rack_group = out

        return res

    def dcim_rack_groups_read(self, request: operations.DcimRackGroupsReadRequest) -> operations.DcimRackGroupsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackGroupsReadRequest, base_url, '/dcim/rack-groups/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackGroupsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackGroup])
                res.rack_group = out

        return res

    def dcim_rack_groups_update(self, request: operations.DcimRackGroupsUpdateRequest) -> operations.DcimRackGroupsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackGroupsUpdateRequest, base_url, '/dcim/rack-groups/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_rack_group_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackGroupsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackGroup])
                res.rack_group = out

        return res

    def dcim_rack_reservations_create(self, request: shared.WritableRackReservationInput) -> operations.DcimRackReservationsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/rack-reservations/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackReservationsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackReservation])
                res.rack_reservation = out

        return res

    def dcim_rack_reservations_delete(self, request: operations.DcimRackReservationsDeleteRequest) -> operations.DcimRackReservationsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackReservationsDeleteRequest, base_url, '/dcim/rack-reservations/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackReservationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_rack_reservations_list(self, request: operations.DcimRackReservationsListRequest) -> operations.DcimRackReservationsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/rack-reservations/'
        
        query_params = utils.get_query_params(operations.DcimRackReservationsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackReservationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimRackReservationsList200ApplicationJSON])
                res.dcim_rack_reservations_list_200_application_json_object = out

        return res

    def dcim_rack_reservations_partial_update(self, request: operations.DcimRackReservationsPartialUpdateRequest) -> operations.DcimRackReservationsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackReservationsPartialUpdateRequest, base_url, '/dcim/rack-reservations/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_rack_reservation_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackReservationsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackReservation])
                res.rack_reservation = out

        return res

    def dcim_rack_reservations_read(self, request: operations.DcimRackReservationsReadRequest) -> operations.DcimRackReservationsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackReservationsReadRequest, base_url, '/dcim/rack-reservations/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackReservationsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackReservation])
                res.rack_reservation = out

        return res

    def dcim_rack_reservations_update(self, request: operations.DcimRackReservationsUpdateRequest) -> operations.DcimRackReservationsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackReservationsUpdateRequest, base_url, '/dcim/rack-reservations/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_rack_reservation_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackReservationsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackReservation])
                res.rack_reservation = out

        return res

    def dcim_rack_roles_create(self, request: shared.RackRoleInput) -> operations.DcimRackRolesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/rack-roles/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackRolesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackRole])
                res.rack_role = out

        return res

    def dcim_rack_roles_delete(self, request: operations.DcimRackRolesDeleteRequest) -> operations.DcimRackRolesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackRolesDeleteRequest, base_url, '/dcim/rack-roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackRolesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_rack_roles_list(self, request: operations.DcimRackRolesListRequest) -> operations.DcimRackRolesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/rack-roles/'
        
        query_params = utils.get_query_params(operations.DcimRackRolesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackRolesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimRackRolesList200ApplicationJSON])
                res.dcim_rack_roles_list_200_application_json_object = out

        return res

    def dcim_rack_roles_partial_update(self, request: operations.DcimRackRolesPartialUpdateRequest) -> operations.DcimRackRolesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackRolesPartialUpdateRequest, base_url, '/dcim/rack-roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rack_role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackRolesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackRole])
                res.rack_role = out

        return res

    def dcim_rack_roles_read(self, request: operations.DcimRackRolesReadRequest) -> operations.DcimRackRolesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackRolesReadRequest, base_url, '/dcim/rack-roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackRolesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackRole])
                res.rack_role = out

        return res

    def dcim_rack_roles_update(self, request: operations.DcimRackRolesUpdateRequest) -> operations.DcimRackRolesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRackRolesUpdateRequest, base_url, '/dcim/rack-roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "rack_role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRackRolesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RackRole])
                res.rack_role = out

        return res

    def dcim_racks_create(self, request: shared.WritableRackInput) -> operations.DcimRacksCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/racks/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rack])
                res.rack = out

        return res

    def dcim_racks_delete(self, request: operations.DcimRacksDeleteRequest) -> operations.DcimRacksDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRacksDeleteRequest, base_url, '/dcim/racks/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_racks_list(self, request: operations.DcimRacksListRequest) -> operations.DcimRacksListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/racks/'
        
        query_params = utils.get_query_params(operations.DcimRacksListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimRacksList200ApplicationJSON])
                res.dcim_racks_list_200_application_json_object = out

        return res

    def dcim_racks_partial_update(self, request: operations.DcimRacksPartialUpdateRequest) -> operations.DcimRacksPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRacksPartialUpdateRequest, base_url, '/dcim/racks/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_rack_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rack])
                res.rack = out

        return res

    def dcim_racks_read(self, request: operations.DcimRacksReadRequest) -> operations.DcimRacksReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRacksReadRequest, base_url, '/dcim/racks/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rack])
                res.rack = out

        return res

    def dcim_racks_units(self, request: operations.DcimRacksUnitsRequest) -> operations.DcimRacksUnitsResponse:
        r"""List rack units (by rack)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRacksUnitsRequest, base_url, '/dcim/racks/{id}/units/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksUnitsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rack])
                res.rack = out

        return res

    def dcim_racks_update(self, request: operations.DcimRacksUpdateRequest) -> operations.DcimRacksUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRacksUpdateRequest, base_url, '/dcim/racks/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_rack_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRacksUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Rack])
                res.rack = out

        return res

    def dcim_regions_create(self, request: shared.WritableRegionInput) -> operations.DcimRegionsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/regions/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRegionsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Region])
                res.region = out

        return res

    def dcim_regions_delete(self, request: operations.DcimRegionsDeleteRequest) -> operations.DcimRegionsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRegionsDeleteRequest, base_url, '/dcim/regions/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRegionsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_regions_list(self, request: operations.DcimRegionsListRequest) -> operations.DcimRegionsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/regions/'
        
        query_params = utils.get_query_params(operations.DcimRegionsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRegionsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimRegionsList200ApplicationJSON])
                res.dcim_regions_list_200_application_json_object = out

        return res

    def dcim_regions_partial_update(self, request: operations.DcimRegionsPartialUpdateRequest) -> operations.DcimRegionsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRegionsPartialUpdateRequest, base_url, '/dcim/regions/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_region_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRegionsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Region])
                res.region = out

        return res

    def dcim_regions_read(self, request: operations.DcimRegionsReadRequest) -> operations.DcimRegionsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRegionsReadRequest, base_url, '/dcim/regions/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRegionsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Region])
                res.region = out

        return res

    def dcim_regions_update(self, request: operations.DcimRegionsUpdateRequest) -> operations.DcimRegionsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimRegionsUpdateRequest, base_url, '/dcim/regions/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_region_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimRegionsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Region])
                res.region = out

        return res

    def dcim_sites_create(self, request: shared.WritableSiteInput) -> operations.DcimSitesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/sites/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Site])
                res.site = out

        return res

    def dcim_sites_delete(self, request: operations.DcimSitesDeleteRequest) -> operations.DcimSitesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimSitesDeleteRequest, base_url, '/dcim/sites/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_sites_graphs(self, request: operations.DcimSitesGraphsRequest) -> operations.DcimSitesGraphsResponse:
        r"""A convenience method for rendering graphs for a particular site."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimSitesGraphsRequest, base_url, '/dcim/sites/{id}/graphs/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesGraphsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Site])
                res.site = out

        return res

    def dcim_sites_list(self, request: operations.DcimSitesListRequest) -> operations.DcimSitesListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/sites/'
        
        query_params = utils.get_query_params(operations.DcimSitesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimSitesList200ApplicationJSON])
                res.dcim_sites_list_200_application_json_object = out

        return res

    def dcim_sites_partial_update(self, request: operations.DcimSitesPartialUpdateRequest) -> operations.DcimSitesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimSitesPartialUpdateRequest, base_url, '/dcim/sites/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_site_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Site])
                res.site = out

        return res

    def dcim_sites_read(self, request: operations.DcimSitesReadRequest) -> operations.DcimSitesReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimSitesReadRequest, base_url, '/dcim/sites/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Site])
                res.site = out

        return res

    def dcim_sites_update(self, request: operations.DcimSitesUpdateRequest) -> operations.DcimSitesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimSitesUpdateRequest, base_url, '/dcim/sites/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_site_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimSitesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Site])
                res.site = out

        return res

    def dcim_virtual_chassis_create(self, request: shared.WritableVirtualChassisInput) -> operations.DcimVirtualChassisCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/virtual-chassis/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimVirtualChassisCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VirtualChassis])
                res.virtual_chassis = out

        return res

    def dcim_virtual_chassis_delete(self, request: operations.DcimVirtualChassisDeleteRequest) -> operations.DcimVirtualChassisDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimVirtualChassisDeleteRequest, base_url, '/dcim/virtual-chassis/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimVirtualChassisDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def dcim_virtual_chassis_list(self, request: operations.DcimVirtualChassisListRequest) -> operations.DcimVirtualChassisListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/dcim/virtual-chassis/'
        
        query_params = utils.get_query_params(operations.DcimVirtualChassisListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimVirtualChassisListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DcimVirtualChassisList200ApplicationJSON])
                res.dcim_virtual_chassis_list_200_application_json_object = out

        return res

    def dcim_virtual_chassis_partial_update(self, request: operations.DcimVirtualChassisPartialUpdateRequest) -> operations.DcimVirtualChassisPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimVirtualChassisPartialUpdateRequest, base_url, '/dcim/virtual-chassis/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_virtual_chassis_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimVirtualChassisPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VirtualChassis])
                res.virtual_chassis = out

        return res

    def dcim_virtual_chassis_read(self, request: operations.DcimVirtualChassisReadRequest) -> operations.DcimVirtualChassisReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimVirtualChassisReadRequest, base_url, '/dcim/virtual-chassis/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimVirtualChassisReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VirtualChassis])
                res.virtual_chassis = out

        return res

    def dcim_virtual_chassis_update(self, request: operations.DcimVirtualChassisUpdateRequest) -> operations.DcimVirtualChassisUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DcimVirtualChassisUpdateRequest, base_url, '/dcim/virtual-chassis/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_virtual_chassis_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DcimVirtualChassisUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.VirtualChassis])
                res.virtual_chassis = out

        return res

    