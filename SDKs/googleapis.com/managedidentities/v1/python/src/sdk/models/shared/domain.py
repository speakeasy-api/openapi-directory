"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import trust as shared_trust
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class DomainStateEnum(str, Enum):
    r"""Output only. The current state of this domain."""
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    CREATING = 'CREATING'
    READY = 'READY'
    UPDATING = 'UPDATING'
    DELETING = 'DELETING'
    REPAIRING = 'REPAIRING'
    PERFORMING_MAINTENANCE = 'PERFORMING_MAINTENANCE'
    UNAVAILABLE = 'UNAVAILABLE'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Domain:
    r"""Represents a managed Microsoft Active Directory domain. If the domain is being changed, it will be placed into the UPDATING state, which indicates that the resource is being reconciled. At this point, Get will reflect an intermediate state."""
    
    admin: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('admin'), 'exclude': lambda f: f is None }})
    r"""Optional. The name of delegated administrator account used to perform Active Directory operations. If not specified, `setupadmin` will be used."""  
    audit_logs_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auditLogsEnabled'), 'exclude': lambda f: f is None }})
    r"""Optional. Configuration for audit logs. True if audit logs are enabled, else false. Default is audit logs disabled."""  
    authorized_networks: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authorizedNetworks'), 'exclude': lambda f: f is None }})
    r"""Optional. The full names of the Google Compute Engine [networks](/compute/docs/networks-and-firewalls#networks) the domain instance is connected to. Networks can be added using UpdateDomain. The domain is only available on networks listed in `authorized_networks`. If CIDR subnets overlap between networks, domain creation will fail."""  
    create_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createTime'), 'exclude': lambda f: f is None }})
    r"""Output only. The time the instance was created."""  
    fqdn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fqdn'), 'exclude': lambda f: f is None }})
    r"""Output only. The fully-qualified domain name of the exposed domain used by clients to connect to the service. Similar to what would be chosen for an Active Directory set up on an internal network."""  
    labels: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""Optional. Resource labels that can contain user-provided metadata."""  
    locations: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locations'), 'exclude': lambda f: f is None }})
    r"""Required. Locations where domain needs to be provisioned. regions e.g. us-west1 or us-east4 Service supports up to 4 locations at once. Each location will use a /26 block."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Required. The unique name of the domain using the form: `projects/{project_id}/locations/global/domains/{domain_name}`."""  
    reserved_ip_range: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reservedIpRange'), 'exclude': lambda f: f is None }})
    r"""Required. The CIDR range of internal addresses that are reserved for this domain. Reserved networks must be /24 or larger. Ranges must be unique and non-overlapping with existing subnets in [Domain].[authorized_networks]."""  
    state: Optional[DomainStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('state'), 'exclude': lambda f: f is None }})
    r"""Output only. The current state of this domain."""  
    status_message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('statusMessage'), 'exclude': lambda f: f is None }})
    r"""Output only. Additional information about the current status of this domain, if available."""  
    trusts: Optional[list[shared_trust.Trust]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trusts'), 'exclude': lambda f: f is None }})
    r"""Output only. The current trusts associated with the domain."""  
    update_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updateTime'), 'exclude': lambda f: f is None }})
    r"""Output only. The last update time."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DomainInput:
    r"""Represents a managed Microsoft Active Directory domain. If the domain is being changed, it will be placed into the UPDATING state, which indicates that the resource is being reconciled. At this point, Get will reflect an intermediate state."""
    
    admin: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('admin'), 'exclude': lambda f: f is None }})
    r"""Optional. The name of delegated administrator account used to perform Active Directory operations. If not specified, `setupadmin` will be used."""  
    audit_logs_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auditLogsEnabled'), 'exclude': lambda f: f is None }})
    r"""Optional. Configuration for audit logs. True if audit logs are enabled, else false. Default is audit logs disabled."""  
    authorized_networks: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authorizedNetworks'), 'exclude': lambda f: f is None }})
    r"""Optional. The full names of the Google Compute Engine [networks](/compute/docs/networks-and-firewalls#networks) the domain instance is connected to. Networks can be added using UpdateDomain. The domain is only available on networks listed in `authorized_networks`. If CIDR subnets overlap between networks, domain creation will fail."""  
    labels: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""Optional. Resource labels that can contain user-provided metadata."""  
    locations: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locations'), 'exclude': lambda f: f is None }})
    r"""Required. Locations where domain needs to be provisioned. regions e.g. us-west1 or us-east4 Service supports up to 4 locations at once. Each location will use a /26 block."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Required. The unique name of the domain using the form: `projects/{project_id}/locations/global/domains/{domain_name}`."""  
    reserved_ip_range: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reservedIpRange'), 'exclude': lambda f: f is None }})
    r"""Required. The CIDR range of internal addresses that are reserved for this domain. Reserved networks must be /24 or larger. Ranges must be unique and non-overlapping with existing subnets in [Domain].[authorized_networks]."""  
    