// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum string

const (
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumSeasonalPeriodTypeUnspecified ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "SEASONAL_PERIOD_TYPE_UNSPECIFIED"
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumNoSeasonality                 ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "NO_SEASONALITY"
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumDaily                         ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "DAILY"
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumWeekly                        ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "WEEKLY"
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumMonthly                       ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "MONTHLY"
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumQuarterly                     ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "QUARTERLY"
	ArimaSingleModelForecastingMetricsSeasonalPeriodsEnumYearly                        ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum = "YEARLY"
)

func (e ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum) ToPointer() *ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum {
	return &e
}

func (e *ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SEASONAL_PERIOD_TYPE_UNSPECIFIED":
		fallthrough
	case "NO_SEASONALITY":
		fallthrough
	case "DAILY":
		fallthrough
	case "WEEKLY":
		fallthrough
	case "MONTHLY":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "YEARLY":
		*e = ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum: %v", v)
	}
}

// ArimaSingleModelForecastingMetrics - Model evaluation metrics for a single ARIMA forecasting model.
type ArimaSingleModelForecastingMetrics struct {
	// ARIMA model fitting metrics.
	ArimaFittingMetrics *ArimaFittingMetrics `json:"arimaFittingMetrics,omitempty"`
	// Is arima model fitted with drift or not. It is always false when d is not 1.
	HasDrift *bool `json:"hasDrift,omitempty"`
	// If true, holiday_effect is a part of time series decomposition result.
	HasHolidayEffect *bool `json:"hasHolidayEffect,omitempty"`
	// If true, spikes_and_dips is a part of time series decomposition result.
	HasSpikesAndDips *bool `json:"hasSpikesAndDips,omitempty"`
	// If true, step_changes is a part of time series decomposition result.
	HasStepChanges *bool `json:"hasStepChanges,omitempty"`
	// Arima order, can be used for both non-seasonal and seasonal parts.
	NonSeasonalOrder *ArimaOrder `json:"nonSeasonalOrder,omitempty"`
	// Seasonal periods. Repeated because multiple periods are supported for one time series.
	SeasonalPeriods []ArimaSingleModelForecastingMetricsSeasonalPeriodsEnum `json:"seasonalPeriods,omitempty"`
	// The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
	TimeSeriesID *string `json:"timeSeriesId,omitempty"`
	// The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
	TimeSeriesIds []string `json:"timeSeriesIds,omitempty"`
}
