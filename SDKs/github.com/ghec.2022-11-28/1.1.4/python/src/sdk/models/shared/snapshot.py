"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import manifest as shared_manifest
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from marshmallow import fields
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SnapshotDetector:
    r"""A description of the detector used."""
    
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""The name of the detector used."""  
    url: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url') }})
    r"""The url of the detector used."""  
    version: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('version') }})
    r"""The version of the detector used."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SnapshotJob:
    
    correlator: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('correlator') }})
    r"""Correlator provides a key that is used to group snapshots submitted over time. Only the \\"latest\\" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository's current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given \\"wave\\" of CI workflow you run. If you're using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you're using a build matrix, then you'll also need to add additional key(s) to distinguish between each submission inside a matrix variation."""  
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""The external ID of the job."""  
    html_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('html_url'), 'exclude': lambda f: f is None }})
    r"""The url for the job."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Snapshot:
    r"""Create a new snapshot of a repository's dependencies."""
    
    detector: SnapshotDetector = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('detector') }})
    r"""A description of the detector used."""  
    job: SnapshotJob = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('job') }})  
    ref: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ref') }})
    r"""The repository branch that triggered this snapshot."""  
    scanned: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scanned'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})
    r"""The time at which the snapshot was scanned."""  
    sha: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sha') }})
    r"""The commit SHA associated with this dependency snapshot. Maximum length: 40 characters."""  
    version: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('version') }})
    r"""The version of the repository snapshot submission."""  
    manifests: Optional[dict[str, shared_manifest.Manifest]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('manifests'), 'exclude': lambda f: f is None }})
    r"""A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies."""  
    metadata: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metadata'), 'exclude': lambda f: f is None }})
    r"""User-defined metadata to store domain-specific information limited to 8 keys with scalar values."""  
    