/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Tagging {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete CIS instruction tag
   *
   * @remarks
   * Deletes a tag from the CIS instruction
   */
  deleteCisInstructionTag(
    req: operations.DeleteCisInstructionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCisInstructionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCisInstructionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisInstruction/{CisInstructionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCisInstructionTagResponse =
        new operations.DeleteCisInstructionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete CIS line tag
   *
   * @remarks
   * Deletes a tag from the CIS line
   */
  deleteCisLineTag(
    req: operations.DeleteCisLineTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCisLineTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCisLineTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisLine/{CisLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCisLineTagResponse =
        new operations.DeleteCisLineTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete CIS line type tag
   *
   * @remarks
   * Deletes a tag from the CIS line type
   */
  deleteCisLineTypeTag(
    req: operations.DeleteCisLineTypeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCisLineTypeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCisLineTypeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/CisLineType/{CisLineTypeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCisLineTypeTagResponse =
        new operations.DeleteCisLineTypeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete employee tag
   *
   * @remarks
   * Deletes a tag from the employee
   */
  deleteEmployeeTag(
    req: operations.DeleteEmployeeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEmployeeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEmployeeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEmployeeTagResponse =
        new operations.DeleteEmployeeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete employer tag
   *
   * @remarks
   * Deletes a tag from the employer
   */
  deleteEmployerTag(
    req: operations.DeleteEmployerTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEmployerTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEmployerTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEmployerTagResponse =
        new operations.DeleteEmployerTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete holiday scheme tag
   *
   * @remarks
   * Deletes a tag from the holiday scheme
   */
  deleteHolidaySchemeTag(
    req: operations.DeleteHolidaySchemeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteHolidaySchemeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteHolidaySchemeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidayScheme/{HolidaySchemeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteHolidaySchemeTagResponse =
        new operations.DeleteHolidaySchemeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete journal line tag
   *
   * @remarks
   * Deletes a tag from the journal line
   */
  deleteJournalLineTag(
    req: operations.DeleteJournalLineTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteJournalLineTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteJournalLineTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/JournalLine/{JournalLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteJournalLineTagResponse =
        new operations.DeleteJournalLineTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete pay code tag
   *
   * @remarks
   * Deletes a tag from the pay code
   */
  deletePayCodeTag(
    req: operations.DeletePayCodeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayCodeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayCodeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PayCode/{PayCodeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayCodeTagResponse =
        new operations.DeletePayCodeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete pay instruction tag
   *
   * @remarks
   * Deletes a tag from the pay instruction
   */
  deletePayInstructionTag(
    req: operations.DeletePayInstructionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayInstructionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayInstructionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayInstruction/{PayInstructionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayInstructionTagResponse =
        new operations.DeletePayInstructionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete pay line tag
   *
   * @remarks
   * Deletes a tag from the pay line
   */
  deletePayLineTag(
    req: operations.DeletePayLineTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayLineTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayLineTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayLine/{PayLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayLineTagResponse =
        new operations.DeletePayLineTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete pay run tag
   *
   * @remarks
   * Deletes a tag from the pay run
   */
  deletePayRunTag(
    req: operations.DeletePayRunTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayRunTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayRunTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRun/{PayRunId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayRunTagResponse =
        new operations.DeletePayRunTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete pay schedule tag
   *
   * @remarks
   * Deletes a tag from the pay schedule
   */
  deletePayScheduleTag(
    req: operations.DeletePayScheduleTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePayScheduleTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePayScheduleTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePayScheduleTagResponse =
        new operations.DeletePayScheduleTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete Permission tag
   *
   * @remarks
   * Deletes a tag from the Permission
   */
  deletePermissionTag(
    req: operations.DeletePermissionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePermissionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePermissionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Permission/{PermissionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePermissionTagResponse =
        new operations.DeletePermissionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete RTI transaction tag
   *
   * @remarks
   * Deletes a tag from the RTI transaction
   */
  deleteRtiTransactionTag(
    req: operations.DeleteRtiTransactionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRtiTransactionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRtiTransactionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/RtiTransaction/{RtiTransactionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRtiTransactionTagResponse =
        new operations.DeleteRtiTransactionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete sub contractor tag
   *
   * @remarks
   * Deletes a tag from the sub contractor
   */
  deleteSubContractorTag(
    req: operations.DeleteSubContractorTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSubContractorTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSubContractorTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSubContractorTagResponse =
        new operations.DeleteSubContractorTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete third party transaction tag
   *
   * @remarks
   * Deletes a tag from the third party transaction
   */
  deleteThirdPartyTransactionTag(
    req: operations.DeleteThirdPartyTransactionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteThirdPartyTransactionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteThirdPartyTransactionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/ThirdPartyTransaction/{ThirdPartyTransactionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteThirdPartyTransactionTagResponse =
        new operations.DeleteThirdPartyTransactionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete user tag
   *
   * @remarks
   * Deletes a tag from the user
   */
  deleteUserTag(
    req: operations.DeleteUserTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUserTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUserTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/User/{UserId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUserTagResponse =
        new operations.DeleteUserTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all CIS instruction tags
   *
   * @remarks
   * Gets all the CIS instruction tags
   */
  getAllCisInstructionTags(
    req: operations.GetAllCisInstructionTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllCisInstructionTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllCisInstructionTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisInstructions/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllCisInstructionTagsResponse =
        new operations.GetAllCisInstructionTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all CIS line tags
   *
   * @remarks
   * Gets all the CIS line tags
   */
  getAllCisLineTags(
    req: operations.GetAllCisLineTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllCisLineTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllCisLineTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisLines/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllCisLineTagsResponse =
        new operations.GetAllCisLineTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all CIS line type tags
   *
   * @remarks
   * Gets all the CIS line type tags
   */
  getAllCisLineTypeTags(
    req: operations.GetAllCisLineTypeTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllCisLineTypeTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllCisLineTypeTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/CisLineTypes/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllCisLineTypeTagsResponse =
        new operations.GetAllCisLineTypeTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee tags
   *
   * @remarks
   * Gets all the employee tags
   */
  getAllEmployeeTags(
    req: operations.GetAllEmployeeTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllEmployeeTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllEmployeeTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllEmployeeTagsResponse =
        new operations.GetAllEmployeeTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employer tags
   *
   * @remarks
   * Gets all the employer tags
   */
  getAllEmployerTags(
    req: operations.GetAllEmployerTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllEmployerTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllEmployerTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Employers/Tags";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllEmployerTagsResponse =
        new operations.GetAllEmployerTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all holiday scheme tags
   *
   * @remarks
   * Gets all the holiday scheme tags
   */
  getAllHolidaySchemeTags(
    req: operations.GetAllHolidaySchemeTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllHolidaySchemeTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllHolidaySchemeTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidaySchemes/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllHolidaySchemeTagsResponse =
        new operations.GetAllHolidaySchemeTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all journal line tags
   *
   * @remarks
   * Gets all the journal line tags
   */
  getAllJournalLineTags(
    req: operations.GetAllJournalLineTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllJournalLineTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllJournalLineTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/JournalLines/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllJournalLineTagsResponse =
        new operations.GetAllJournalLineTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get links to tagged journal lines
   *
   * @remarks
   * Gets the journal lines with the specified tag
   */
  getAllJournalLinesWithTag(
    req: operations.GetAllJournalLinesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllJournalLinesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllJournalLinesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/JournalLines/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllJournalLinesWithTagResponse =
        new operations.GetAllJournalLinesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay code tags
   *
   * @remarks
   * Gets all the pay code tags
   */
  getAllPayCodeTags(
    req: operations.GetAllPayCodeTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPayCodeTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPayCodeTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PayCodes/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPayCodeTagsResponse =
        new operations.GetAllPayCodeTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay instruction tags
   *
   * @remarks
   * Gets all the pay instruction tags
   */
  getAllPayInstructionTags(
    req: operations.GetAllPayInstructionTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPayInstructionTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPayInstructionTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayInstructions/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPayInstructionTagsResponse =
        new operations.GetAllPayInstructionTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay line tags
   *
   * @remarks
   * Gets all the pay line tags
   */
  getAllPayLineTags(
    req: operations.GetAllPayLineTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPayLineTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPayLineTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayLines/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPayLineTagsResponse =
        new operations.GetAllPayLineTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay run tags
   *
   * @remarks
   * Gets all the pay run tags
   */
  getAllPayRunTags(
    req: operations.GetAllPayRunTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPayRunTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPayRunTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRuns/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPayRunTagsResponse =
        new operations.GetAllPayRunTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay schedule tags
   *
   * @remarks
   * Gets all the pay schedule tags
   */
  getAllPayScheduleTags(
    req: operations.GetAllPayScheduleTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPayScheduleTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPayScheduleTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedules/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPayScheduleTagsResponse =
        new operations.GetAllPayScheduleTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all Permission tags
   *
   * @remarks
   * Get all tags from all Permissions
   */
  getAllPermissionTags(
    req: operations.GetAllPermissionTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPermissionTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPermissionTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Permissions/Tags";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPermissionTagsResponse =
        new operations.GetAllPermissionTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get links to tagged Permissions
   *
   * @remarks
   * Gets the Permissions with the specified tag
   */
  getAllPermissionsWithTag(
    req: operations.GetAllPermissionsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllPermissionsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllPermissionsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Permissions/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllPermissionsWithTagResponse =
        new operations.GetAllPermissionsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all RTI transaction tags
   *
   * @remarks
   * Gets all the RTI transaction tags
   */
  getAllRtiTransactionTags(
    req: operations.GetAllRtiTransactionTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllRtiTransactionTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllRtiTransactionTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/RtiTransactions/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllRtiTransactionTagsResponse =
        new operations.GetAllRtiTransactionTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all sub contractor tags
   *
   * @remarks
   * Gets all the sub contractor tags
   */
  getAllSubContractorTags(
    req: operations.GetAllSubContractorTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllSubContractorTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllSubContractorTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractors/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllSubContractorTagsResponse =
        new operations.GetAllSubContractorTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all third party transaction tags
   *
   * @remarks
   * Gets all the third party transaction tags
   */
  getAllThirdPartyTransactionTags(
    req: operations.GetAllThirdPartyTransactionTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllThirdPartyTransactionTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllThirdPartyTransactionTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/ThirdPartyTransactions/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllThirdPartyTransactionTagsResponse =
        new operations.GetAllThirdPartyTransactionTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get links to tagged third party transactions
   *
   * @remarks
   * Gets the third party transactions with the specified tag
   */
  getAllThirdPartyTransactionsWithTag(
    req: operations.GetAllThirdPartyTransactionsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllThirdPartyTransactionsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllThirdPartyTransactionsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/ThirdPartyTransactions/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllThirdPartyTransactionsWithTagResponse =
        new operations.GetAllThirdPartyTransactionsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all user tags
   *
   * @remarks
   * Get all tags from all users
   */
  getAllUserTags(
    req: operations.GetAllUserTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllUserTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllUserTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/Users/Tags";

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllUserTagsResponse =
        new operations.GetAllUserTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get links to tagged users
   *
   * @remarks
   * Gets the users with the specified tag
   */
  getAllUsersWithTag(
    req: operations.GetAllUsersWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllUsersWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllUsersWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/Users/Tag/{TagId}", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllUsersWithTagResponse =
        new operations.GetAllUsersWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get CIS instructions with tag
   *
   * @remarks
   * Gets the CIS instruction with the tag
   */
  getCisInstructionsWithTag(
    req: operations.GetCisInstructionsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisInstructionsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisInstructionsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisInstructions/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisInstructionsWithTagResponse =
        new operations.GetCisInstructionsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get CIS line types with tag
   *
   * @remarks
   * Gets the CIS line type with the tag
   */
  getCisLineTypesWithTag(
    req: operations.GetCisLineTypesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisLineTypesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisLineTypesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/CisLineTypes/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisLineTypesWithTagResponse =
        new operations.GetCisLineTypesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get CIS lines with tag
   *
   * @remarks
   * Gets the CIS line with the tag
   */
  getCisLinesWithTag(
    req: operations.GetCisLinesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCisLinesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCisLinesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisLines/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCisLinesWithTagResponse =
        new operations.GetCisLinesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employees with tag
   *
   * @remarks
   * Gets the employees with the tag
   */
  getEmployeesWithTag(
    req: operations.GetEmployeesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employees/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeesWithTagResponse =
        new operations.GetEmployeesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employers with tag
   *
   * @remarks
   * Gets the employers with the tag
   */
  getEmployersWithTag(
    req: operations.GetEmployersWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployersWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployersWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employers/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployersWithTagResponse =
        new operations.GetEmployersWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get holiday schemes with tag
   *
   * @remarks
   * Gets the holiday scheme with the tag
   */
  getHolidaySchemesWithTag(
    req: operations.GetHolidaySchemesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHolidaySchemesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHolidaySchemesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidaySchemes/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHolidaySchemesWithTagResponse =
        new operations.GetHolidaySchemesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay codes with tag
   *
   * @remarks
   * Gets the pay codes with the tag
   */
  getPayCodesWithTag(
    req: operations.GetPayCodesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayCodesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayCodesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PayCodes/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayCodesWithTagResponse =
        new operations.GetPayCodesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay instructions with tag
   *
   * @remarks
   * Gets the pay instructions with the tag
   */
  getPayInstructionsWithTag(
    req: operations.GetPayInstructionsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayInstructionsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayInstructionsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayInstructions/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayInstructionsWithTagResponse =
        new operations.GetPayInstructionsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay lines with tag
   *
   * @remarks
   * Gets the pay line with the tag
   */
  getPayLinesWithTag(
    req: operations.GetPayLinesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayLinesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayLinesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayLines/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayLinesWithTagResponse =
        new operations.GetPayLinesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay runs with tag
   *
   * @remarks
   * Gets the pay runs with the tag
   */
  getPayRunsWithTag(
    req: operations.GetPayRunsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayRunsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayRunsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRuns/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayRunsWithTagResponse =
        new operations.GetPayRunsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay schedule with tag
   *
   * @remarks
   * Gets the pay schedules with the tag
   */
  getPaySchedulesWithTag(
    req: operations.GetPaySchedulesWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPaySchedulesWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPaySchedulesWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedules/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPaySchedulesWithTagResponse =
        new operations.GetPaySchedulesWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get RTI transactions with tag
   *
   * @remarks
   * Gets the RTI transactions with the tag
   */
  getRtiTransactionsWithTag(
    req: operations.GetRtiTransactionsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRtiTransactionsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRtiTransactionsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/RtiTransactions/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRtiTransactionsWithTagResponse =
        new operations.GetRtiTransactionsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get sub contractors with tag
   *
   * @remarks
   * Gets the sub contractor with the tag
   */
  getSubContractorsWithTag(
    req: operations.GetSubContractorsWithTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSubContractorsWithTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSubContractorsWithTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractors/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSubContractorsWithTagResponse =
        new operations.GetSubContractorsWithTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get CIS instruction tag
   *
   * @remarks
   * Gets the tag from the CIS instruction
   */
  getTagFromCisInstruction(
    req: operations.GetTagFromCisInstructionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromCisInstructionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromCisInstructionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisInstruction/{CisInstructionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromCisInstructionResponse =
        new operations.GetTagFromCisInstructionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get CIS line tag
   *
   * @remarks
   * Gets the tag from the CIS line
   */
  getTagFromCisLine(
    req: operations.GetTagFromCisLineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromCisLineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromCisLineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisLine/{CisLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromCisLineResponse =
        new operations.GetTagFromCisLineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get CIS line type tag
   *
   * @remarks
   * Gets the tag from the CIS line type
   */
  getTagFromCisLineType(
    req: operations.GetTagFromCisLineTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromCisLineTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromCisLineTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/CisLineType/{CisLineTypeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromCisLineTypeResponse =
        new operations.GetTagFromCisLineTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee tag
   *
   * @remarks
   * Gets the tag from the employee
   */
  getTagFromEmployee(
    req: operations.GetTagFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromEmployeeResponse =
        new operations.GetTagFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employee revision tag
   *
   * @remarks
   * Gets the tag from the employee revision
   */
  getTagFromEmployeeRevision(
    req: operations.GetTagFromEmployeeRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromEmployeeRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromEmployeeRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Tag/{TagId}/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromEmployeeRevisionResponse =
        new operations.GetTagFromEmployeeRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employer tag
   *
   * @remarks
   * Gets the tag from the employer
   */
  getTagFromEmployer(
    req: operations.GetTagFromEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromEmployerResponse =
        new operations.GetTagFromEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get employer revision tag
   *
   * @remarks
   * Gets the tag from the employer revision
   */
  getTagFromEmployerRevision(
    req: operations.GetTagFromEmployerRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromEmployerRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromEmployerRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Tag/{TagId}/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromEmployerRevisionResponse =
        new operations.GetTagFromEmployerRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get holiday scheme tag
   *
   * @remarks
   * Gets the tag from the holiday scheme
   */
  getTagFromHolidayScheme(
    req: operations.GetTagFromHolidaySchemeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromHolidaySchemeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromHolidaySchemeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidayScheme/{HolidaySchemeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromHolidaySchemeResponse =
        new operations.GetTagFromHolidaySchemeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get holiday scheme revision tag
   *
   * @remarks
   * Gets the tag from the holiday scheme revision
   */
  getTagFromHolidaySchemeRevision(
    req: operations.GetTagFromHolidaySchemeRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromHolidaySchemeRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromHolidaySchemeRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidayScheme/{HolidaySchemeId}/Tag/{TagId}/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromHolidaySchemeRevisionResponse =
        new operations.GetTagFromHolidaySchemeRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get journal line tag
   *
   * @remarks
   * Gets a tag from the journal line
   */
  getTagFromJournalLine(
    req: operations.GetTagFromJournalLineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromJournalLineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromJournalLineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/JournalLine/{JournalLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromJournalLineResponse =
        new operations.GetTagFromJournalLineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay code tag
   *
   * @remarks
   * Gets the tag from the pay code
   */
  getTagFromPayCode(
    req: operations.GetTagFromPayCodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromPayCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromPayCodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PayCode/{PayCodeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromPayCodeResponse =
        new operations.GetTagFromPayCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay instruction tag
   *
   * @remarks
   * Gets the tag from the pay instruction
   */
  getTagFromPayInstruction(
    req: operations.GetTagFromPayInstructionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromPayInstructionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromPayInstructionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayInstruction/{PayInstructionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromPayInstructionResponse =
        new operations.GetTagFromPayInstructionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay line tag
   *
   * @remarks
   * Gets the tag from the pay line
   */
  getTagFromPayLine(
    req: operations.GetTagFromPayLineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromPayLineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromPayLineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayLine/{PayLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromPayLineResponse =
        new operations.GetTagFromPayLineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay run tag
   *
   * @remarks
   * Gets the tag from the pay run
   */
  getTagFromPayRun(
    req: operations.GetTagFromPayRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromPayRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromPayRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRun/{PayRunId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromPayRunResponse =
        new operations.GetTagFromPayRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get pay schedule tag
   *
   * @remarks
   * Gets the tag from the pay schedule
   */
  getTagFromPaySchedule(
    req: operations.GetTagFromPayScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromPayScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromPayScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromPayScheduleResponse =
        new operations.GetTagFromPayScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get Permission tag
   *
   * @remarks
   * Gets a tag from the Permission
   */
  getTagFromPermission(
    req: operations.GetTagFromPermissionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromPermissionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Permission/{PermissionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromPermissionResponse =
        new operations.GetTagFromPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get RTI transaction tag
   *
   * @remarks
   * Gets the tag from the RTI transaction
   */
  getTagFromRtiTransaction(
    req: operations.GetTagFromRtiTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromRtiTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromRtiTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/RtiTransaction/{RtiTransactionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromRtiTransactionResponse =
        new operations.GetTagFromRtiTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get sub contractor tag
   *
   * @remarks
   * Gets the tag from the sub contractor
   */
  getTagFromSubContractor(
    req: operations.GetTagFromSubContractorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromSubContractorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromSubContractorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromSubContractorResponse =
        new operations.GetTagFromSubContractorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get sub contractor revision tag
   *
   * @remarks
   * Gets the tag from the sub contractor revision
   */
  getTagFromSubContractorRevision(
    req: operations.GetTagFromSubContractorRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromSubContractorRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromSubContractorRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/Tag/{TagId}/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromSubContractorRevisionResponse =
        new operations.GetTagFromSubContractorRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get third party transaction tag
   *
   * @remarks
   * Gets a tag from the third party transaction
   */
  getTagFromThirdPartyTransaction(
    req: operations.GetTagFromThirdPartyTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromThirdPartyTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromThirdPartyTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/ThirdPartyTransaction/{ThirdPartyTransactionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromThirdPartyTransactionResponse =
        new operations.GetTagFromThirdPartyTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get user tag
   *
   * @remarks
   * Gets a tag from the user
   */
  getTagFromUser(
    req: operations.GetTagFromUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagFromUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagFromUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/User/{UserId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagFromUserResponse =
        new operations.GetTagFromUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the CIS instruction
   *
   * @remarks
   * Gets all the tags from the CIS instruction
   */
  getTagsFromCisInstruction(
    req: operations.GetTagsFromCisInstructionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromCisInstructionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromCisInstructionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisInstruction/{CisInstructionId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromCisInstructionResponse =
        new operations.GetTagsFromCisInstructionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the CIS line
   *
   * @remarks
   * Gets all the tags from the CIS line
   */
  getTagsFromCisLine(
    req: operations.GetTagsFromCisLineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromCisLineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromCisLineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisLine/{CisLineId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromCisLineResponse =
        new operations.GetTagsFromCisLineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the CIS line type
   *
   * @remarks
   * Gets all the tags from the CIS line type
   */
  getTagsFromCisLineType(
    req: operations.GetTagsFromCisLineTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromCisLineTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromCisLineTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/CisLineType/{CisLineTypeId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromCisLineTypeResponse =
        new operations.GetTagsFromCisLineTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee tags
   *
   * @remarks
   * Gets all the tags from the employee
   */
  getTagsFromEmployee(
    req: operations.GetTagsFromEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromEmployeeResponse =
        new operations.GetTagsFromEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employee revision tags
   *
   * @remarks
   * Gets all the tags from the employee revision
   */
  getTagsFromEmployeeRevision(
    req: operations.GetTagsFromEmployeeRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromEmployeeRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromEmployeeRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Tags/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromEmployeeRevisionResponse =
        new operations.GetTagsFromEmployeeRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employer tags
   *
   * @remarks
   * Gets all the tags from the employer
   */
  getTagsFromEmployer(
    req: operations.GetTagsFromEmployerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromEmployerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromEmployerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromEmployerResponse =
        new operations.GetTagsFromEmployerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all employer revision tags
   *
   * @remarks
   * Gets all the tags from the employer revision
   */
  getTagsFromEmployerRevision(
    req: operations.GetTagsFromEmployerRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromEmployerRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromEmployerRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Tags/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromEmployerRevisionResponse =
        new operations.GetTagsFromEmployerRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the holiday scheme
   *
   * @remarks
   * Gets all the tags from the holiday scheme
   */
  getTagsFromHolidayScheme(
    req: operations.GetTagsFromHolidaySchemeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromHolidaySchemeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromHolidaySchemeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidayScheme/{HolidaySchemeId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromHolidaySchemeResponse =
        new operations.GetTagsFromHolidaySchemeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all holiday scheme revision tags
   *
   * @remarks
   * Gets all the tags from the holiday scheme revision
   */
  getTagsFromHolidaySchemeRevision(
    req: operations.GetTagsFromHolidaySchemeRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromHolidaySchemeRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromHolidaySchemeRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidayScheme/{HolidaySchemeId}/Tags/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromHolidaySchemeRevisionResponse =
        new operations.GetTagsFromHolidaySchemeRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get tags from journal line
   *
   * @remarks
   * Gets all tags from the journal line
   */
  getTagsFromJournalLine(
    req: operations.GetTagsFromJournalLineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromJournalLineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromJournalLineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/JournalLine/{JournalLineId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromJournalLineResponse =
        new operations.GetTagsFromJournalLineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay code tags
   *
   * @remarks
   * Gets all the tags from the pay code
   */
  getTagsFromPayCode(
    req: operations.GetTagsFromPayCodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromPayCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromPayCodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PayCode/{PayCodeId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromPayCodeResponse =
        new operations.GetTagsFromPayCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the pay instruction
   *
   * @remarks
   * Gets all the tags from the pay instruction
   */
  getTagsFromPayInstruction(
    req: operations.GetTagsFromPayInstructionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromPayInstructionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromPayInstructionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayInstruction/{PayInstructionId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromPayInstructionResponse =
        new operations.GetTagsFromPayInstructionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the pay line
   *
   * @remarks
   * Gets all the tags from the pay line
   */
  getTagsFromPayLine(
    req: operations.GetTagsFromPayLineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromPayLineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromPayLineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayLine/{PayLineId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromPayLineResponse =
        new operations.GetTagsFromPayLineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay run tags
   *
   * @remarks
   * Gets all the tags from the pay run
   */
  getTagsFromPayRun(
    req: operations.GetTagsFromPayRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromPayRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromPayRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRun/{PayRunId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromPayRunResponse =
        new operations.GetTagsFromPayRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all pay schedule tags
   *
   * @remarks
   * Gets all the tags from the pay schedule
   */
  getTagsFromPaySchedule(
    req: operations.GetTagsFromPayScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromPayScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromPayScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromPayScheduleResponse =
        new operations.GetTagsFromPayScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get tags from Permission
   *
   * @remarks
   * Gets all tags from the Permission
   */
  getTagsFromPermission(
    req: operations.GetTagsFromPermissionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromPermissionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Permission/{PermissionId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromPermissionResponse =
        new operations.GetTagsFromPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from RTI transaction
   *
   * @remarks
   * Gets all the tags from the RTI transaction
   */
  getTagsFromRtiTransaction(
    req: operations.GetTagsFromRtiTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromRtiTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromRtiTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/RtiTransaction/{RtiTransactionId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromRtiTransactionResponse =
        new operations.GetTagsFromRtiTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all tags from the sub contractor
   *
   * @remarks
   * Gets all the tags from the sub contractor
   */
  getTagsFromSubContractor(
    req: operations.GetTagsFromSubContractorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromSubContractorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromSubContractorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromSubContractorResponse =
        new operations.GetTagsFromSubContractorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all sub contractor revision tags
   *
   * @remarks
   * Gets all the tags from the sub contractor revision
   */
  getTagsFromSubContractorRevision(
    req: operations.GetTagsFromSubContractorRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromSubContractorRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromSubContractorRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/Tags/{EffectiveDate}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromSubContractorRevisionResponse =
        new operations.GetTagsFromSubContractorRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get tags from third party transaction
   *
   * @remarks
   * Gets all tags from the third party transaction
   */
  getTagsFromThirdPartyTransaction(
    req: operations.GetTagsFromThirdPartyTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromThirdPartyTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromThirdPartyTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/ThirdPartyTransaction/{ThirdPartyTransactionId}/Tags",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromThirdPartyTransactionResponse =
        new operations.GetTagsFromThirdPartyTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get tags from user
   *
   * @remarks
   * Gets all tags from the user
   */
  getTagsFromUser(
    req: operations.GetTagsFromUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsFromUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsFromUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/User/{UserId}/Tags", req);

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsFromUserResponse =
        new operations.GetTagsFromUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.linkCollection = utils.objectToClass(
              httpRes?.data,
              shared.LinkCollection
            );
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert CIS instruction tag
   *
   * @remarks
   * Inserts a new tag on the CIS instruction
   */
  putCisInstructionTag(
    req: operations.PutCisInstructionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutCisInstructionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutCisInstructionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisInstruction/{CisInstructionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutCisInstructionTagResponse =
        new operations.PutCisInstructionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert CIS line tag
   *
   * @remarks
   * Inserts a new tag on the CIS line
   */
  putCisLineTag(
    req: operations.PutCisLineTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutCisLineTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutCisLineTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/CisLine/{CisLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutCisLineTagResponse =
        new operations.PutCisLineTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert CIS line type tag
   *
   * @remarks
   * Inserts a new tag on the CIS line type
   */
  putCisLineTypeTag(
    req: operations.PutCisLineTypeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutCisLineTypeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutCisLineTypeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/CisLineType/{CisLineTypeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutCisLineTypeTagResponse =
        new operations.PutCisLineTypeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert employee tag
   *
   * @remarks
   * Inserts a new tag on the employee
   */
  putEmployeeTag(
    req: operations.PutEmployeeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutEmployeeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutEmployeeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutEmployeeTagResponse =
        new operations.PutEmployeeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert employer tag
   *
   * @remarks
   * Inserts a new tag on the employer
   */
  putEmployerTag(
    req: operations.PutEmployerTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutEmployerTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutEmployerTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutEmployerTagResponse =
        new operations.PutEmployerTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert holiday scheme tag
   *
   * @remarks
   * Inserts a new tag on the holiday scheme
   */
  putHolidaySchemeTag(
    req: operations.PutHolidaySchemeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutHolidaySchemeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutHolidaySchemeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/HolidayScheme/{HolidaySchemeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutHolidaySchemeTagResponse =
        new operations.PutHolidaySchemeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert journal line tag
   *
   * @remarks
   * Inserts a tag on the journal line
   */
  putJournalLineTag(
    req: operations.PutJournalLineTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutJournalLineTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutJournalLineTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/JournalLine/{JournalLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutJournalLineTagResponse =
        new operations.PutJournalLineTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert pay code tag
   *
   * @remarks
   * Inserts a new tag on the pay code
   */
  putPayCodeTag(
    req: operations.PutPayCodeTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutPayCodeTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutPayCodeTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PayCode/{PayCodeId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutPayCodeTagResponse =
        new operations.PutPayCodeTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert pay instruction tag
   *
   * @remarks
   * Inserts a new tag on the pay instruction
   */
  putPayInstructionTag(
    req: operations.PutPayInstructionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutPayInstructionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutPayInstructionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayInstruction/{PayInstructionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutPayInstructionTagResponse =
        new operations.PutPayInstructionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert pay line tag
   *
   * @remarks
   * Inserts a new tag on the pay line
   */
  putPayLineTag(
    req: operations.PutPayLineTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutPayLineTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutPayLineTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/Employee/{EmployeeId}/PayLine/{PayLineId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutPayLineTagResponse =
        new operations.PutPayLineTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert pay run tag
   *
   * @remarks
   * Inserts a new tag on the pay run
   */
  putPayRunTag(
    req: operations.PutPayRunTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutPayRunTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutPayRunTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/PayRun/{PayRunId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutPayRunTagResponse =
        new operations.PutPayRunTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert pay schedule tag
   *
   * @remarks
   * Inserts a new tag on the pay schedule
   */
  putPayScheduleTag(
    req: operations.PutPayScheduleTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutPayScheduleTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutPayScheduleTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/PaySchedule/{PayScheduleId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutPayScheduleTagResponse =
        new operations.PutPayScheduleTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert Permission tag
   *
   * @remarks
   * Inserts a tag on the Permission
   */
  putPermissionTag(
    req: operations.PutPermissionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutPermissionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutPermissionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Permission/{PermissionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutPermissionTagResponse =
        new operations.PutPermissionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert RTI transaction tag
   *
   * @remarks
   * Inserts a new tag on the RTI transaction
   */
  putRtiTransactionTag(
    req: operations.PutRtiTransactionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRtiTransactionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRtiTransactionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/RtiTransaction/{RtiTransactionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRtiTransactionTagResponse =
        new operations.PutRtiTransactionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert sub contractor tag
   *
   * @remarks
   * Inserts a new tag on the sub contractor
   */
  putSubContractorTag(
    req: operations.PutSubContractorTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutSubContractorTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutSubContractorTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/SubContractor/{SubContractorId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutSubContractorTagResponse =
        new operations.PutSubContractorTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * insert third party transaction tag
   *
   * @remarks
   * Inserts a tag on the third party transaction
   */
  putThirdPartyTransactionTag(
    req: operations.PutThirdPartyTransactionTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutThirdPartyTransactionTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutThirdPartyTransactionTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/Employer/{EmployerId}/ThirdPartyTransaction/{ThirdPartyTransactionId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutThirdPartyTransactionTagResponse =
        new operations.PutThirdPartyTransactionTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Insert user tag
   *
   * @remarks
   * Inserts a tag on the user
   */
  putUserTag(
    req: operations.PutUserTagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutUserTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutUserTagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/User/{UserId}/Tag/{TagId}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutUserTagResponse =
        new operations.PutUserTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tag = utils.objectToClass(httpRes?.data, shared.Tag);
          }
          break;
        case [400, 401, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorModel = utils.objectToClass(
              httpRes?.data,
              shared.ErrorModel
            );
          }
          break;
      }

      return res;
    });
  }
}
