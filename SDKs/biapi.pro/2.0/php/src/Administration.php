<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Administration 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Delete a client
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientResponse
     */
	public function deleteClientsIdClient(
        \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients/{id_client}', \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->client = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Client', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete the client logo
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoResponse
     */
	public function deleteClientsIdClientLogo(
        \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients/{id_client}/logo', \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteClientsIdClientLogoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes all webhooks
     * 
     * Updates the deleted field with the date of the deletion<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksResponse
     */
	public function deleteWebhooks(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes all webhook authentication types
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthResponse
     */
	public function deleteWebhooksAuth(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/auth');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authProvider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthProvider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes the webhook authentication type
     * 
     * Updates the deleted field with the date of the deletion<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthResponse
     */
	public function deleteWebhooksAuthIdAuth(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/auth/{id_auth}', \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksAuthIdAuthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authProvider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthProvider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes a webhook
     * 
     * Updates the deleted field with the date of the deletion<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookResponse
     */
	public function deleteWebhooksIdWebhook(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}', \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * delete all entries
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataResponse
     */
	public function deleteWebhooksIdWebhookAddToData(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/add_to_data', \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * delete the requested entry
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyResponse
     */
	public function deleteWebhooksIdWebhookAddToDataKey(
        \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/add_to_data/{key}', \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteWebhooksIdWebhookAddToDataKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List clients
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClientsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClientsResponse
     */
	public function getClients(
        \OpenAPI\OpenAPI\Models\Operations\GetClientsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClientsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetClientsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClientsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getClients200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetClients200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get information about a client
     * 
     * If you use the manage_token or a configuration token, you will get also the client secret.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientResponse
     */
	public function getClientsIdClient(
        \OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients/{id_client}', \OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClientsIdClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->client = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Client', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get configuration of the API.
     * 
     * <br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConfigResponse
     */
	public function getConfig(
        \OpenAPI\OpenAPI\Models\Operations\GetConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/config');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConfigRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get configuration change history of the API.
     * 
     * <br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetConfigLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConfigLogsResponse
     */
	public function getConfigLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetConfigLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetConfigLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/config/logs');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetConfigLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConfigLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConfigLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetConfigLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * get performances stats on this instance
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMonitoringRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMonitoringResponse
     */
	public function getMonitoring(
        \OpenAPI\OpenAPI\Models\Operations\GetMonitoringRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMonitoringResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/monitoring');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMonitoringRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMonitoringResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get public encryption key of the API.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPublickeyResponse
     */
	public function getPublickey(
    ): \OpenAPI\OpenAPI\Models\Operations\GetPublickeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/publickey');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPublickeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get webhooks
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebhooksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebhooksResponse
     */
	public function getWebhooks(
        \OpenAPI\OpenAPI\Models\Operations\GetWebhooksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebhooksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWebhooksRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebhooksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getWebhooks200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetWebhooks200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get webhooks authentication types
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuthResponse
     */
	public function getWebhooksAuth(
        \OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/auth');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuthRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getWebhooksAuth200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetWebhooksAuth200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * retrieve the list of the value to add in webhooks when sending the requested webhook
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataResponse
     */
	public function getWebhooksIdWebhookAddToData(
        \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/add_to_data', \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getWebhooksIdWebhookAddToData200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToData200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * retrieve the value to add in the requested webhook for the requested name
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyResponse
     */
	public function getWebhooksIdWebhookAddToDataKey(
        \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/add_to_data/{key}', \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookAddToDataKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get webhooks logs.
     * 
     * Get logs of the webhooks.<br><br>By default, it selects logs for the last month. You can use "min_date" and "max_date" to change boundary dates.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsResponse
     */
	public function getWebhooksIdWebhookLogs(
        \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/logs', \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getWebhooksIdWebhookLogs200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetWebhooksIdWebhookLogs200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a client
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostClientsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostClientsResponse
     */
	public function postClients(
        \OpenAPI\OpenAPI\Models\Operations\PostClientsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostClientsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostClientsRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostClientsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->client = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Client', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the client logo
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoResponse
     */
	public function postClientsIdClientLogo(
        \OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients/{id_client}/logo', \OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostClientsIdClientLogoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->file = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\File', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Insert/update configuration key(s)/value(s) on the API.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\PostConfigResponse
     */
	public function postConfig(
    ): \OpenAPI\OpenAPI\Models\Operations\PostConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/config');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Test synchronization on a random connection.
     * 
     * It can be used to test receiving data on your webhooks.<br><br>
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\PostTestSyncResponse
     */
	public function postTestSync(
    ): \OpenAPI\OpenAPI\Models\Operations\PostTestSyncResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/test/sync');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostTestSyncResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Test synchronization on a random connection.
     * 
     * It can be used to test receiving data on your webhooks.<br><br>
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\PostTestWebhooksResponse
     */
	public function postTestWebhooks(
    ): \OpenAPI\OpenAPI\Models\Operations\PostTestWebhooksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/test/webhooks');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostTestWebhooksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Adds a new webhook
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostWebhooksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostWebhooksResponse
     */
	public function postWebhooks(
        \OpenAPI\OpenAPI\Models\Operations\PostWebhooksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostWebhooksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostWebhooksRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostWebhooksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Adds a new webhook authentication type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthResponse
     */
	public function postWebhooksAuth(
        \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/auth');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authProvider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthProvider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the webhook authentication type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthResponse
     */
	public function postWebhooksAuthIdAuth(
        \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/auth/{id_auth}', \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostWebhooksAuthIdAuthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authProvider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthProvider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a webhook
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookResponse
     */
	public function postWebhooksIdWebhook(
        \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}', \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Setup a field to store in user config when calling the endpoint
     * 
     * For each parameter, a value will be added in the webhook data. Use the key to set the name of the field. The values that can be added are to be found in the user configuration.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataResponse
     */
	public function postWebhooksIdWebhookAddToData(
        \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/add_to_data', \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * upate the requested field to store in user config when calling the endpoint
     * 
     * For each parameter, a value will be added in the webhook data. Use the key to set the name of the field. The values that can be added are to be found in the user configuration.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyResponse
     */
	public function postWebhooksIdWebhookAddToDataKey(
        \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}/add_to_data/{key}', \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostWebhooksIdWebhookAddToDataKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a client
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientResponse
     */
	public function putClientsIdClient(
        \OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/clients/{id_client}', \OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutClientsIdClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->client = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Client', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the webhook authentication type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthResponse
     */
	public function putWebhooksAuthIdAuth(
        \OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/auth/{id_auth}', \OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutWebhooksAuthIdAuthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->authProvider = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AuthProvider', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a webhook
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookResponse
     */
	public function putWebhooksIdWebhook(
        \OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webhooks/{id_webhook}', \OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutWebhooksIdWebhookResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->webhook = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Webhook', 'json');
            }
        }

        return $response;
    }
}