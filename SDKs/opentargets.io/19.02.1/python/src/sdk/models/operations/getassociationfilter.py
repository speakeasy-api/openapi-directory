"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from typing import Optional


@dataclasses.dataclass
class GetAssociationFilterRequest:
    
    datasource: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'datasource', 'style': 'form', 'explode': True }})
    r"""Data source to consider."""  
    datastructure: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'datastructure', 'style': 'form', 'explode': True }})
    r"""Type of data structure to return. Can be 'full', 'simple', 'ids', or 'count'."""  
    datatype: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'datatype', 'style': 'form', 'explode': True }})
    r"""Data type to consider."""  
    direct: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'direct', 'style': 'form', 'explode': True }})
    r"""If `true`, it returns associations that have at least one direct evidence connecting the target and the disease. If `false` it only returns associations for which there is no direct evidence connecting the target and the disease, but only evidence connecting the target to a children of the disease in the EFO ontology."""  
    disease: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'disease', 'style': 'form', 'explode': True }})
    r"""An EFO code listed as disease.id."""  
    facets: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'facets', 'style': 'form', 'explode': True }})
    r"""Returns facets"""  
    fields_: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'fields', 'style': 'form', 'explode': True }})
    r"""Fields you want to retrieve. This will get priority over the data structure requested."""  
    format: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'format', 'style': 'form', 'explode': True }})
    r"""Format to get the data back. Can be 'json', 'xml', 'tab' or 'csv'. **Note** that this option can only be used when calling the API directly and will not work in this page. The response here will always be JSON."""  
    from_: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'from', 'style': 'form', 'explode': True }})
    r"""How many initial results should be skipped. Defaults to 0."""  
    pathway: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'pathway', 'style': 'form', 'explode': True }})
    r"""A Reactome pathway identifier (returning only those targets linked to the specified pathway)."""  
    scorevalue_max: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'scorevalue_max', 'style': 'form', 'explode': True }})
    r"""Filter by maximum score value."""  
    scorevalue_min: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'scorevalue_min', 'style': 'form', 'explode': True }})
    r"""Filter by minimum score value. The default is 0, but using 0.2 is a good trade-off to filter lower quality data points."""  
    scorevalue_types: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'scorevalue_types', 'style': 'form', 'explode': True }})
    r"""Score types to apply the score value min and max filters. The default is `overall`."""  
    search: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'search', 'style': 'form', 'explode': True }})
    r"""Restrict the filtered results to those matching the passed string. The matching is done with a
    phrase match prefix.
    """  
    size: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'size', 'style': 'form', 'explode': True }})
    r"""Maximum amount of results to return. Defaults to 10, max is 10000."""  
    sort: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'sort', 'style': 'form', 'explode': True }})
    r"""Sort by the given score type. Defaults to 'overall' and descending order. Use '~' prefix to do ascending
    order e.g. '~overall'. You will call a data type score like: 'datatypes.literature', and a data source as
    'datasources.gwas'. Supports multiple entries.
    """  
    target: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'target', 'style': 'form', 'explode': True }})
    r"""A target identifier listed as target.id."""  
    target_class: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'target_class', 'style': 'form', 'explode': True }})
    r"""A ChEMBL target class identifier (returning only those targets belonging to the specified class)."""  
    therapeutic_area: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'therapeutic_area', 'style': 'form', 'explode': True }})
    r"""An EFO code of a therapeutic area."""  
    uniprotkw: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'uniprotkw', 'style': 'form', 'explode': True }})
    r"""A UniProt keyword (meaning all the targets linked to that keyword)."""  
    

@dataclasses.dataclass
class GetAssociationFilterResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    