"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Projects:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def cloudscheduler_projects_locations_jobs_create(self, request: operations.CloudschedulerProjectsLocationsJobsCreateRequest, security: operations.CloudschedulerProjectsLocationsJobsCreateSecurity) -> operations.CloudschedulerProjectsLocationsJobsCreateResponse:
        r"""Creates a job."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsCreateRequest, base_url, '/v1/{parent}/jobs', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "job", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsCreateRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Job])
                res.job = out

        return res

    def cloudscheduler_projects_locations_jobs_delete(self, request: operations.CloudschedulerProjectsLocationsJobsDeleteRequest, security: operations.CloudschedulerProjectsLocationsJobsDeleteSecurity) -> operations.CloudschedulerProjectsLocationsJobsDeleteResponse:
        r"""Deletes a job."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsDeleteRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsDeleteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.empty = out

        return res

    def cloudscheduler_projects_locations_jobs_get(self, request: operations.CloudschedulerProjectsLocationsJobsGetRequest, security: operations.CloudschedulerProjectsLocationsJobsGetSecurity) -> operations.CloudschedulerProjectsLocationsJobsGetResponse:
        r"""Gets a job."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsGetRequest, base_url, '/v1/{name}', request)
        
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Job])
                res.job = out

        return res

    def cloudscheduler_projects_locations_jobs_list(self, request: operations.CloudschedulerProjectsLocationsJobsListRequest, security: operations.CloudschedulerProjectsLocationsJobsListSecurity) -> operations.CloudschedulerProjectsLocationsJobsListResponse:
        r"""Lists jobs."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsListRequest, base_url, '/v1/{parent}/jobs', request)
        
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListJobsResponse])
                res.list_jobs_response = out

        return res

    def cloudscheduler_projects_locations_jobs_patch(self, request: operations.CloudschedulerProjectsLocationsJobsPatchRequest, security: operations.CloudschedulerProjectsLocationsJobsPatchSecurity) -> operations.CloudschedulerProjectsLocationsJobsPatchResponse:
        r"""Updates a job. If successful, the updated Job is returned. If the job does not exist, `NOT_FOUND` is returned. If UpdateJob does not successfully return, it is possible for the job to be in an Job.State.UPDATE_FAILED state. A job in this state may not be executed. If this happens, retry the UpdateJob request until a successful response is received."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsPatchRequest, base_url, '/v1/{name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "job", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsPatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Job])
                res.job = out

        return res

    def cloudscheduler_projects_locations_jobs_pause(self, request: operations.CloudschedulerProjectsLocationsJobsPauseRequest, security: operations.CloudschedulerProjectsLocationsJobsPauseSecurity) -> operations.CloudschedulerProjectsLocationsJobsPauseResponse:
        r"""Pauses a job. If a job is paused then the system will stop executing the job until it is re-enabled via ResumeJob. The state of the job is stored in state; if paused it will be set to Job.State.PAUSED. A job must be in Job.State.ENABLED to be paused."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsPauseRequest, base_url, '/v1/{name}:pause', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsPauseRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsPauseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Job])
                res.job = out

        return res

    def cloudscheduler_projects_locations_jobs_resume(self, request: operations.CloudschedulerProjectsLocationsJobsResumeRequest, security: operations.CloudschedulerProjectsLocationsJobsResumeSecurity) -> operations.CloudschedulerProjectsLocationsJobsResumeResponse:
        r"""Resume a job. This method reenables a job after it has been Job.State.PAUSED. The state of a job is stored in Job.state; after calling this method it will be set to Job.State.ENABLED. A job must be in Job.State.PAUSED to be resumed."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsResumeRequest, base_url, '/v1/{name}:resume', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsResumeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsResumeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Job])
                res.job = out

        return res

    def cloudscheduler_projects_locations_jobs_run(self, request: operations.CloudschedulerProjectsLocationsJobsRunRequest, security: operations.CloudschedulerProjectsLocationsJobsRunSecurity) -> operations.CloudschedulerProjectsLocationsJobsRunResponse:
        r"""Forces a job to run now. When this method is called, Cloud Scheduler will dispatch the job, even if the job is already running."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsJobsRunRequest, base_url, '/v1/{name}:run', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsJobsRunRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsJobsRunResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Job])
                res.job = out

        return res

    def cloudscheduler_projects_locations_list(self, request: operations.CloudschedulerProjectsLocationsListRequest, security: operations.CloudschedulerProjectsLocationsListSecurity) -> operations.CloudschedulerProjectsLocationsListResponse:
        r"""Lists information about the supported locations for this service."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloudschedulerProjectsLocationsListRequest, base_url, '/v1/{name}/locations', request)
        
        query_params = utils.get_query_params(operations.CloudschedulerProjectsLocationsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloudschedulerProjectsLocationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListLocationsResponse])
                res.list_locations_response = out

        return res

    