/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Lists subnetworks that can be used for creating clusters in a project.
   */
  containerProjectsAggregatedUsableSubnetworksList(
    req: operations.ContainerProjectsAggregatedUsableSubnetworksListRequest,
    security: operations.ContainerProjectsAggregatedUsableSubnetworksListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsAggregatedUsableSubnetworksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsAggregatedUsableSubnetworksListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/aggregated/usableSubnetworks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsAggregatedUsableSubnetworksListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsAggregatedUsableSubnetworksListResponse =
        new operations.ContainerProjectsAggregatedUsableSubnetworksListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUsableSubnetworksResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListUsableSubnetworksResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Completes master IP rotation.
   */
  containerProjectsLocationsClustersCompleteIpRotation(
    req: operations.ContainerProjectsLocationsClustersCompleteIpRotationRequest,
    security: operations.ContainerProjectsLocationsClustersCompleteIpRotationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersCompleteIpRotationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersCompleteIpRotationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:completeIpRotation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "completeIPRotationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersCompleteIpRotationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersCompleteIpRotationResponse =
        new operations.ContainerProjectsLocationsClustersCompleteIpRotationResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a cluster, consisting of the specified number and type of Google Compute Engine instances. By default, the cluster is created in the project's [default network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks). One firewall is added for the cluster. After cluster creation, the Kubelet creates routes for each node to allow the containers on that node to communicate with all other instances in the cluster. Finally, an entry is added to the project's global metadata indicating which CIDR range the cluster is using.
   */
  containerProjectsLocationsClustersCreate(
    req: operations.ContainerProjectsLocationsClustersCreateRequest,
    security: operations.ContainerProjectsLocationsClustersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsClustersCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/clusters",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createClusterRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersCreateResponse =
        new operations.ContainerProjectsLocationsClustersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the public component of the cluster signing keys in JSON Web Key format. This API is not yet intended for general use, and is not available for all clusters.
   */
  containerProjectsLocationsClustersGetJwks(
    req: operations.ContainerProjectsLocationsClustersGetJwksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersGetJwksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsClustersGetJwksRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/jwks",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersGetJwksResponse =
        new operations.ContainerProjectsLocationsClustersGetJwksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getJSONWebKeysResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetJSONWebKeysResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all clusters owned by a project in either the specified zone or all zones.
   */
  containerProjectsLocationsClustersList(
    req: operations.ContainerProjectsLocationsClustersListRequest,
    security: operations.ContainerProjectsLocationsClustersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsClustersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/clusters",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsLocationsClustersListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersListResponse =
        new operations.ContainerProjectsLocationsClustersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listClustersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListClustersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * CompleteNodePoolUpgrade will signal an on-going node pool upgrade to complete.
   */
  containerProjectsLocationsClustersNodePoolsCompleteUpgrade(
    req: operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:completeUpgrade",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsCompleteUpgradeResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a node pool for a cluster.
   */
  containerProjectsLocationsClustersNodePoolsCreate(
    req: operations.ContainerProjectsLocationsClustersNodePoolsCreateRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/nodePools",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createNodePoolRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsCreateResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a node pool from a cluster.
   */
  containerProjectsLocationsClustersNodePoolsDelete(
    req: operations.ContainerProjectsLocationsClustersNodePoolsDeleteRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1beta1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsDeleteResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsDeleteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the node pools for a cluster.
   */
  containerProjectsLocationsClustersNodePoolsList(
    req: operations.ContainerProjectsLocationsClustersNodePoolsListRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/nodePools",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsListResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNodePoolsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListNodePoolsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rolls back a previously Aborted or Failed NodePool upgrade. This makes no changes if the last upgrade successfully completed.
   */
  containerProjectsLocationsClustersNodePoolsRollback(
    req: operations.ContainerProjectsLocationsClustersNodePoolsRollbackRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsRollbackSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsRollbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsRollbackRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:rollback",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rollbackNodePoolUpgradeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsRollbackSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsRollbackResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsRollbackResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the autoscaling settings of a specific node pool.
   */
  containerProjectsLocationsClustersNodePoolsSetAutoscaling(
    req: operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setAutoscaling",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNodePoolAutoscalingRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetAutoscalingResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the NodeManagement options for a node pool.
   */
  containerProjectsLocationsClustersNodePoolsSetManagement(
    req: operations.ContainerProjectsLocationsClustersNodePoolsSetManagementRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsSetManagementSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsSetManagementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetManagementRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setManagement",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNodePoolManagementRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetManagementSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsSetManagementResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetManagementResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * SetNodePoolSizeRequest sets the size of a node pool. The new size will be used for all replicas, including future replicas created by modifying NodePool.locations.
   */
  containerProjectsLocationsClustersNodePoolsSetSize(
    req: operations.ContainerProjectsLocationsClustersNodePoolsSetSizeRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsSetSizeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsSetSizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetSizeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setSize",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNodePoolSizeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetSizeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsSetSizeResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsSetSizeResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the version and/or image type of a specific node pool.
   */
  containerProjectsLocationsClustersNodePoolsUpdate(
    req: operations.ContainerProjectsLocationsClustersNodePoolsUpdateRequest,
    security: operations.ContainerProjectsLocationsClustersNodePoolsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersNodePoolsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersNodePoolsUpdateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1beta1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateNodePoolRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersNodePoolsUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersNodePoolsUpdateResponse =
        new operations.ContainerProjectsLocationsClustersNodePoolsUpdateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the addons for a specific cluster.
   */
  containerProjectsLocationsClustersSetAddons(
    req: operations.ContainerProjectsLocationsClustersSetAddonsRequest,
    security: operations.ContainerProjectsLocationsClustersSetAddonsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetAddonsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsClustersSetAddonsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setAddons",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setAddonsConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetAddonsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetAddonsResponse =
        new operations.ContainerProjectsLocationsClustersSetAddonsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enables or disables the ABAC authorization mechanism on a cluster.
   */
  containerProjectsLocationsClustersSetLegacyAbac(
    req: operations.ContainerProjectsLocationsClustersSetLegacyAbacRequest,
    security: operations.ContainerProjectsLocationsClustersSetLegacyAbacSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetLegacyAbacResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetLegacyAbacRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setLegacyAbac",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLegacyAbacRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetLegacyAbacSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetLegacyAbacResponse =
        new operations.ContainerProjectsLocationsClustersSetLegacyAbacResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the locations for a specific cluster. Deprecated. Use [projects.locations.clusters.update](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters/update) instead.
   */
  containerProjectsLocationsClustersSetLocations(
    req: operations.ContainerProjectsLocationsClustersSetLocationsRequest,
    security: operations.ContainerProjectsLocationsClustersSetLocationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetLocationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetLocationsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setLocations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLocationsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetLocationsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetLocationsResponse =
        new operations.ContainerProjectsLocationsClustersSetLocationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the logging service for a specific cluster.
   */
  containerProjectsLocationsClustersSetLogging(
    req: operations.ContainerProjectsLocationsClustersSetLoggingRequest,
    security: operations.ContainerProjectsLocationsClustersSetLoggingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetLoggingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsClustersSetLoggingRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setLogging",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLoggingServiceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetLoggingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetLoggingResponse =
        new operations.ContainerProjectsLocationsClustersSetLoggingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the maintenance policy for a cluster.
   */
  containerProjectsLocationsClustersSetMaintenancePolicy(
    req: operations.ContainerProjectsLocationsClustersSetMaintenancePolicyRequest,
    security: operations.ContainerProjectsLocationsClustersSetMaintenancePolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetMaintenancePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetMaintenancePolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setMaintenancePolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMaintenancePolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetMaintenancePolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetMaintenancePolicyResponse =
        new operations.ContainerProjectsLocationsClustersSetMaintenancePolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets master auth materials. Currently supports changing the admin password or a specific cluster, either via password generation or explicitly setting the password.
   */
  containerProjectsLocationsClustersSetMasterAuth(
    req: operations.ContainerProjectsLocationsClustersSetMasterAuthRequest,
    security: operations.ContainerProjectsLocationsClustersSetMasterAuthSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetMasterAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetMasterAuthRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setMasterAuth",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMasterAuthRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetMasterAuthSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetMasterAuthResponse =
        new operations.ContainerProjectsLocationsClustersSetMasterAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the monitoring service for a specific cluster.
   */
  containerProjectsLocationsClustersSetMonitoring(
    req: operations.ContainerProjectsLocationsClustersSetMonitoringRequest,
    security: operations.ContainerProjectsLocationsClustersSetMonitoringSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetMonitoringResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetMonitoringRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setMonitoring",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMonitoringServiceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetMonitoringSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetMonitoringResponse =
        new operations.ContainerProjectsLocationsClustersSetMonitoringResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enables or disables Network Policy for a cluster.
   */
  containerProjectsLocationsClustersSetNetworkPolicy(
    req: operations.ContainerProjectsLocationsClustersSetNetworkPolicyRequest,
    security: operations.ContainerProjectsLocationsClustersSetNetworkPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetNetworkPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetNetworkPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setNetworkPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNetworkPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetNetworkPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetNetworkPolicyResponse =
        new operations.ContainerProjectsLocationsClustersSetNetworkPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets labels on a cluster.
   */
  containerProjectsLocationsClustersSetResourceLabels(
    req: operations.ContainerProjectsLocationsClustersSetResourceLabelsRequest,
    security: operations.ContainerProjectsLocationsClustersSetResourceLabelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersSetResourceLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersSetResourceLabelsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:setResourceLabels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLabelsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersSetResourceLabelsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersSetResourceLabelsResponse =
        new operations.ContainerProjectsLocationsClustersSetResourceLabelsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts master IP rotation.
   */
  containerProjectsLocationsClustersStartIpRotation(
    req: operations.ContainerProjectsLocationsClustersStartIpRotationRequest,
    security: operations.ContainerProjectsLocationsClustersStartIpRotationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersStartIpRotationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersStartIpRotationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:startIpRotation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startIPRotationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersStartIpRotationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersStartIpRotationResponse =
        new operations.ContainerProjectsLocationsClustersStartIpRotationResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the master for a specific cluster.
   */
  containerProjectsLocationsClustersUpdateMaster(
    req: operations.ContainerProjectsLocationsClustersUpdateMasterRequest,
    security: operations.ContainerProjectsLocationsClustersUpdateMasterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersUpdateMasterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersUpdateMasterRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:updateMaster",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateMasterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsClustersUpdateMasterSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersUpdateMasterResponse =
        new operations.ContainerProjectsLocationsClustersUpdateMasterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the OIDC discovery document for the cluster. See the [OpenID Connect Discovery 1.0 specification](https://openid.net/specs/openid-connect-discovery-1_0.html) for details. This API is not yet intended for general use, and is not available for all clusters.
   */
  containerProjectsLocationsClustersWellKnownGetOpenidConfiguration(
    req: operations.ContainerProjectsLocationsClustersWellKnownGetOpenidConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsClustersWellKnownGetOpenidConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsLocationsClustersWellKnownGetOpenidConfigurationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/.well-known/openid-configuration",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsClustersWellKnownGetOpenidConfigurationResponse =
        new operations.ContainerProjectsLocationsClustersWellKnownGetOpenidConfigurationResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOpenIDConfigResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetOpenIDConfigResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns configuration info about the Google Kubernetes Engine service.
   */
  containerProjectsLocationsGetServerConfig(
    req: operations.ContainerProjectsLocationsGetServerConfigRequest,
    security: operations.ContainerProjectsLocationsGetServerConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsGetServerConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsGetServerConfigRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}/serverConfig",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsGetServerConfigSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsGetServerConfigResponse =
        new operations.ContainerProjectsLocationsGetServerConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverConfig = utils.objectToClass(
              httpRes?.data,
              shared.ServerConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetches locations that offer Google Kubernetes Engine.
   */
  containerProjectsLocationsList(
    req: operations.ContainerProjectsLocationsListRequest,
    security: operations.ContainerProjectsLocationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/locations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsLocationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsListResponse =
        new operations.ContainerProjectsLocationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLocationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLocationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels the specified operation.
   */
  containerProjectsLocationsOperationsCancel(
    req: operations.ContainerProjectsLocationsOperationsCancelRequest,
    security: operations.ContainerProjectsLocationsOperationsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsOperationsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsOperationsCancelRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{name}:cancel",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cancelOperationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsOperationsCancelSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsOperationsCancelResponse =
        new operations.ContainerProjectsLocationsOperationsCancelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the specified operation.
   */
  containerProjectsLocationsOperationsGet(
    req: operations.ContainerProjectsLocationsOperationsGetRequest,
    security: operations.ContainerProjectsLocationsOperationsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsOperationsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsOperationsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1beta1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsLocationsOperationsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsOperationsGetResponse =
        new operations.ContainerProjectsLocationsOperationsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all operations in a project in the specified zone or all zones.
   */
  containerProjectsLocationsOperationsList(
    req: operations.ContainerProjectsLocationsOperationsListRequest,
    security: operations.ContainerProjectsLocationsOperationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsLocationsOperationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsLocationsOperationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/{parent}/operations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsLocationsOperationsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsLocationsOperationsListResponse =
        new operations.ContainerProjectsLocationsOperationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listOperationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListOperationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the addons for a specific cluster.
   */
  containerProjectsZonesClustersAddons(
    req: operations.ContainerProjectsZonesClustersAddonsRequest,
    security: operations.ContainerProjectsZonesClustersAddonsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersAddonsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersAddonsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/addons",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setAddonsConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersAddonsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersAddonsResponse =
        new operations.ContainerProjectsZonesClustersAddonsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Completes master IP rotation.
   */
  containerProjectsZonesClustersCompleteIpRotation(
    req: operations.ContainerProjectsZonesClustersCompleteIpRotationRequest,
    security: operations.ContainerProjectsZonesClustersCompleteIpRotationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersCompleteIpRotationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersCompleteIpRotationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}:completeIpRotation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "completeIPRotationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersCompleteIpRotationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersCompleteIpRotationResponse =
        new operations.ContainerProjectsZonesClustersCompleteIpRotationResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a cluster, consisting of the specified number and type of Google Compute Engine instances. By default, the cluster is created in the project's [default network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks). One firewall is added for the cluster. After cluster creation, the Kubelet creates routes for each node to allow the containers on that node to communicate with all other instances in the cluster. Finally, an entry is added to the project's global metadata indicating which CIDR range the cluster is using.
   */
  containerProjectsZonesClustersCreate(
    req: operations.ContainerProjectsZonesClustersCreateRequest,
    security: operations.ContainerProjectsZonesClustersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createClusterRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersCreateResponse =
        new operations.ContainerProjectsZonesClustersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the cluster, including the Kubernetes endpoint and all worker nodes. Firewalls and routes that were configured during cluster creation are also deleted. Other Google Compute Engine resources that might be in use by the cluster, such as load balancer resources, are not deleted if they weren't present when the cluster was initially created.
   */
  containerProjectsZonesClustersDelete(
    req: operations.ContainerProjectsZonesClustersDeleteRequest,
    security: operations.ContainerProjectsZonesClustersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersDeleteResponse =
        new operations.ContainerProjectsZonesClustersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the details for a specific cluster.
   */
  containerProjectsZonesClustersGet(
    req: operations.ContainerProjectsZonesClustersGetRequest,
    security: operations.ContainerProjectsZonesClustersGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersGetResponse =
        new operations.ContainerProjectsZonesClustersGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cluster = utils.objectToClass(httpRes?.data, shared.Cluster);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enables or disables the ABAC authorization mechanism on a cluster.
   */
  containerProjectsZonesClustersLegacyAbac(
    req: operations.ContainerProjectsZonesClustersLegacyAbacRequest,
    security: operations.ContainerProjectsZonesClustersLegacyAbacSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersLegacyAbacResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersLegacyAbacRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/legacyAbac",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLegacyAbacRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersLegacyAbacSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersLegacyAbacResponse =
        new operations.ContainerProjectsZonesClustersLegacyAbacResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all clusters owned by a project in either the specified zone or all zones.
   */
  containerProjectsZonesClustersList(
    req: operations.ContainerProjectsZonesClustersListRequest,
    security: operations.ContainerProjectsZonesClustersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersListResponse =
        new operations.ContainerProjectsZonesClustersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listClustersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListClustersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the locations for a specific cluster. Deprecated. Use [projects.locations.clusters.update](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters/update) instead.
   */
  containerProjectsZonesClustersLocations(
    req: operations.ContainerProjectsZonesClustersLocationsRequest,
    security: operations.ContainerProjectsZonesClustersLocationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersLocationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersLocationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/locations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLocationsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersLocationsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersLocationsResponse =
        new operations.ContainerProjectsZonesClustersLocationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the logging service for a specific cluster.
   */
  containerProjectsZonesClustersLogging(
    req: operations.ContainerProjectsZonesClustersLoggingRequest,
    security: operations.ContainerProjectsZonesClustersLoggingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersLoggingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersLoggingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/logging",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLoggingServiceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersLoggingSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersLoggingResponse =
        new operations.ContainerProjectsZonesClustersLoggingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the master for a specific cluster.
   */
  containerProjectsZonesClustersMaster(
    req: operations.ContainerProjectsZonesClustersMasterRequest,
    security: operations.ContainerProjectsZonesClustersMasterSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersMasterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersMasterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/master",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateMasterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersMasterSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersMasterResponse =
        new operations.ContainerProjectsZonesClustersMasterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the monitoring service for a specific cluster.
   */
  containerProjectsZonesClustersMonitoring(
    req: operations.ContainerProjectsZonesClustersMonitoringRequest,
    security: operations.ContainerProjectsZonesClustersMonitoringSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersMonitoringResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersMonitoringRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/monitoring",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMonitoringServiceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersMonitoringSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersMonitoringResponse =
        new operations.ContainerProjectsZonesClustersMonitoringResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the autoscaling settings of a specific node pool.
   */
  containerProjectsZonesClustersNodePoolsAutoscaling(
    req: operations.ContainerProjectsZonesClustersNodePoolsAutoscalingRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsAutoscalingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsAutoscalingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersNodePoolsAutoscalingRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}/autoscaling",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNodePoolAutoscalingRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsAutoscalingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsAutoscalingResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsAutoscalingResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a node pool for a cluster.
   */
  containerProjectsZonesClustersNodePoolsCreate(
    req: operations.ContainerProjectsZonesClustersNodePoolsCreateRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersNodePoolsCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createNodePoolRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsCreateResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a node pool from a cluster.
   */
  containerProjectsZonesClustersNodePoolsDelete(
    req: operations.ContainerProjectsZonesClustersNodePoolsDeleteRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersNodePoolsDeleteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsDeleteResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the requested node pool.
   */
  containerProjectsZonesClustersNodePoolsGet(
    req: operations.ContainerProjectsZonesClustersNodePoolsGetRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersNodePoolsGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsGetResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nodePool = utils.objectToClass(httpRes?.data, shared.NodePool);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the node pools for a cluster.
   */
  containerProjectsZonesClustersNodePoolsList(
    req: operations.ContainerProjectsZonesClustersNodePoolsListRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersNodePoolsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsListResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNodePoolsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListNodePoolsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rolls back a previously Aborted or Failed NodePool upgrade. This makes no changes if the last upgrade successfully completed.
   */
  containerProjectsZonesClustersNodePoolsRollback(
    req: operations.ContainerProjectsZonesClustersNodePoolsRollbackRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsRollbackSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsRollbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersNodePoolsRollbackRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}:rollback",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rollbackNodePoolUpgradeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsRollbackSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsRollbackResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsRollbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the NodeManagement options for a node pool.
   */
  containerProjectsZonesClustersNodePoolsSetManagement(
    req: operations.ContainerProjectsZonesClustersNodePoolsSetManagementRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsSetManagementSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsSetManagementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersNodePoolsSetManagementRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}/setManagement",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNodePoolManagementRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsSetManagementSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsSetManagementResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsSetManagementResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * SetNodePoolSizeRequest sets the size of a node pool. The new size will be used for all replicas, including future replicas created by modifying NodePool.locations.
   */
  containerProjectsZonesClustersNodePoolsSetSize(
    req: operations.ContainerProjectsZonesClustersNodePoolsSetSizeRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsSetSizeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsSetSizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersNodePoolsSetSizeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}/setSize",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNodePoolSizeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsSetSizeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsSetSizeResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsSetSizeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the version and/or image type of a specific node pool.
   */
  containerProjectsZonesClustersNodePoolsUpdate(
    req: operations.ContainerProjectsZonesClustersNodePoolsUpdateRequest,
    security: operations.ContainerProjectsZonesClustersNodePoolsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersNodePoolsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersNodePoolsUpdateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/nodePools/{nodePoolId}/update",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateNodePoolRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersNodePoolsUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersNodePoolsUpdateResponse =
        new operations.ContainerProjectsZonesClustersNodePoolsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets labels on a cluster.
   */
  containerProjectsZonesClustersResourceLabels(
    req: operations.ContainerProjectsZonesClustersResourceLabelsRequest,
    security: operations.ContainerProjectsZonesClustersResourceLabelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersResourceLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersResourceLabelsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}/resourceLabels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setLabelsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersResourceLabelsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersResourceLabelsResponse =
        new operations.ContainerProjectsZonesClustersResourceLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the maintenance policy for a cluster.
   */
  containerProjectsZonesClustersSetMaintenancePolicy(
    req: operations.ContainerProjectsZonesClustersSetMaintenancePolicyRequest,
    security: operations.ContainerProjectsZonesClustersSetMaintenancePolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersSetMaintenancePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersSetMaintenancePolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}:setMaintenancePolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMaintenancePolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersSetMaintenancePolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersSetMaintenancePolicyResponse =
        new operations.ContainerProjectsZonesClustersSetMaintenancePolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets master auth materials. Currently supports changing the admin password or a specific cluster, either via password generation or explicitly setting the password.
   */
  containerProjectsZonesClustersSetMasterAuth(
    req: operations.ContainerProjectsZonesClustersSetMasterAuthRequest,
    security: operations.ContainerProjectsZonesClustersSetMasterAuthSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersSetMasterAuthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersSetMasterAuthRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}:setMasterAuth",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMasterAuthRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersSetMasterAuthSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersSetMasterAuthResponse =
        new operations.ContainerProjectsZonesClustersSetMasterAuthResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enables or disables Network Policy for a cluster.
   */
  containerProjectsZonesClustersSetNetworkPolicy(
    req: operations.ContainerProjectsZonesClustersSetNetworkPolicyRequest,
    security: operations.ContainerProjectsZonesClustersSetNetworkPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersSetNetworkPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ContainerProjectsZonesClustersSetNetworkPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}:setNetworkPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setNetworkPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersSetNetworkPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersSetNetworkPolicyResponse =
        new operations.ContainerProjectsZonesClustersSetNetworkPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts master IP rotation.
   */
  containerProjectsZonesClustersStartIpRotation(
    req: operations.ContainerProjectsZonesClustersStartIpRotationRequest,
    security: operations.ContainerProjectsZonesClustersStartIpRotationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersStartIpRotationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersStartIpRotationRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}:startIpRotation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startIPRotationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ContainerProjectsZonesClustersStartIpRotationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersStartIpRotationResponse =
        new operations.ContainerProjectsZonesClustersStartIpRotationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the settings for a specific cluster.
   */
  containerProjectsZonesClustersUpdate(
    req: operations.ContainerProjectsZonesClustersUpdateRequest,
    security: operations.ContainerProjectsZonesClustersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesClustersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesClustersUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/clusters/{clusterId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateClusterRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesClustersUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesClustersUpdateResponse =
        new operations.ContainerProjectsZonesClustersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns configuration info about the Google Kubernetes Engine service.
   */
  containerProjectsZonesGetServerconfig(
    req: operations.ContainerProjectsZonesGetServerconfigRequest,
    security: operations.ContainerProjectsZonesGetServerconfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesGetServerconfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesGetServerconfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/serverconfig",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesGetServerconfigSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesGetServerconfigResponse =
        new operations.ContainerProjectsZonesGetServerconfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serverConfig = utils.objectToClass(
              httpRes?.data,
              shared.ServerConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels the specified operation.
   */
  containerProjectsZonesOperationsCancel(
    req: operations.ContainerProjectsZonesOperationsCancelRequest,
    security: operations.ContainerProjectsZonesOperationsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesOperationsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesOperationsCancelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/operations/{operationId}:cancel",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cancelOperationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesOperationsCancelSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesOperationsCancelResponse =
        new operations.ContainerProjectsZonesOperationsCancelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the specified operation.
   */
  containerProjectsZonesOperationsGet(
    req: operations.ContainerProjectsZonesOperationsGetRequest,
    security: operations.ContainerProjectsZonesOperationsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesOperationsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesOperationsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/operations/{operationId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesOperationsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesOperationsGetResponse =
        new operations.ContainerProjectsZonesOperationsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all operations in a project in the specified zone or all zones.
   */
  containerProjectsZonesOperationsList(
    req: operations.ContainerProjectsZonesOperationsListRequest,
    security: operations.ContainerProjectsZonesOperationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ContainerProjectsZonesOperationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ContainerProjectsZonesOperationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1beta1/projects/{projectId}/zones/{zone}/operations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ContainerProjectsZonesOperationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ContainerProjectsZonesOperationsListResponse =
        new operations.ContainerProjectsZonesOperationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listOperationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListOperationsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
