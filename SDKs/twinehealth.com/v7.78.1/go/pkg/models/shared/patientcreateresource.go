// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"openapi/pkg/types"
)

type PatientCreateResourceAttributesGenderEnum string

const (
	PatientCreateResourceAttributesGenderEnumMale   PatientCreateResourceAttributesGenderEnum = "male"
	PatientCreateResourceAttributesGenderEnumFemale PatientCreateResourceAttributesGenderEnum = "female"
	PatientCreateResourceAttributesGenderEnumOther  PatientCreateResourceAttributesGenderEnum = "other"
)

func (e PatientCreateResourceAttributesGenderEnum) ToPointer() *PatientCreateResourceAttributesGenderEnum {
	return &e
}

func (e *PatientCreateResourceAttributesGenderEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "male":
		fallthrough
	case "female":
		fallthrough
	case "other":
		*e = PatientCreateResourceAttributesGenderEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatientCreateResourceAttributesGenderEnum: %v", v)
	}
}

type PatientCreateResourceAttributesInput struct {
	Addresses      []Address                                  `json:"addresses,omitempty"`
	ArchiveHistory []ArchiveHistory                           `json:"archive_history,omitempty"`
	BirthDate      *types.Date                                `json:"birth_date,omitempty"`
	EmailAddress   *string                                    `json:"email_address,omitempty"`
	FirstName      *string                                    `json:"first_name,omitempty"`
	Gender         *PatientCreateResourceAttributesGenderEnum `json:"gender,omitempty"`
	Identifiers    []PatientIdentifier                        `json:"identifiers,omitempty"`
	LastName       *string                                    `json:"last_name,omitempty"`
	// Coach's note about the patient. Not visible to the patient.
	Note         *string       `json:"note,omitempty"`
	PhoneNumbers []PhoneNumber `json:"phone_numbers,omitempty"`
}

type PatientCreateResourceRelationshipsCoachesDataMeta struct {
	Primary *bool `json:"primary,omitempty"`
}

type PatientCreateResourceRelationshipsCoachesDataTypeEnum string

const (
	PatientCreateResourceRelationshipsCoachesDataTypeEnumCoach PatientCreateResourceRelationshipsCoachesDataTypeEnum = "coach"
)

func (e PatientCreateResourceRelationshipsCoachesDataTypeEnum) ToPointer() *PatientCreateResourceRelationshipsCoachesDataTypeEnum {
	return &e
}

func (e *PatientCreateResourceRelationshipsCoachesDataTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "coach":
		*e = PatientCreateResourceRelationshipsCoachesDataTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatientCreateResourceRelationshipsCoachesDataTypeEnum: %v", v)
	}
}

type PatientCreateResourceRelationshipsCoachesData struct {
	ID   string                                                `json:"id"`
	Meta *PatientCreateResourceRelationshipsCoachesDataMeta    `json:"meta,omitempty"`
	Type PatientCreateResourceRelationshipsCoachesDataTypeEnum `json:"type"`
}

type PatientCreateResourceRelationshipsCoachesInput struct {
	Data []PatientCreateResourceRelationshipsCoachesData `json:"data"`
}

// PatientCreateResourceRelationshipsGroupsDataMetaQuery - 1. If the query does not return any groups, a group with the specified name will be created and related to the patient.
// 2. If the query returns one group, that group will be related to the patient.
// 3. If the query returns more than one group, the creation of the patient will fail.
type PatientCreateResourceRelationshipsGroupsDataMetaQuery struct {
	Name         string `json:"name"`
	Organization string `json:"organization"`
}

// PatientCreateResourceRelationshipsGroupsDataMeta - Allows the specification of a query for a group rather than providing a group id directly
type PatientCreateResourceRelationshipsGroupsDataMeta struct {
	// 1. If the query does not return any groups, a group with the specified name will be created and related to the patient.
	// 2. If the query returns one group, that group will be related to the patient.
	// 3. If the query returns more than one group, the creation of the patient will fail.
	//
	Query PatientCreateResourceRelationshipsGroupsDataMetaQuery `json:"query"`
}

type PatientCreateResourceRelationshipsGroupsDataTypeEnum string

const (
	PatientCreateResourceRelationshipsGroupsDataTypeEnumGroup PatientCreateResourceRelationshipsGroupsDataTypeEnum = "group"
)

func (e PatientCreateResourceRelationshipsGroupsDataTypeEnum) ToPointer() *PatientCreateResourceRelationshipsGroupsDataTypeEnum {
	return &e
}

func (e *PatientCreateResourceRelationshipsGroupsDataTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "group":
		*e = PatientCreateResourceRelationshipsGroupsDataTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatientCreateResourceRelationshipsGroupsDataTypeEnum: %v", v)
	}
}

type PatientCreateResourceRelationshipsGroupsData struct {
	// Required if the `meta.query` is not defined.
	ID *string `json:"id,omitempty"`
	// Allows the specification of a query for a group rather than providing a group id directly
	Meta *PatientCreateResourceRelationshipsGroupsDataMeta    `json:"meta,omitempty"`
	Type PatientCreateResourceRelationshipsGroupsDataTypeEnum `json:"type"`
}

type PatientCreateResourceRelationshipsGroups struct {
	Data []PatientCreateResourceRelationshipsGroupsData `json:"data"`
}

type PatientCreateResourceRelationshipsInput struct {
	Coaches *PatientCreateResourceRelationshipsCoachesInput `json:"coaches,omitempty"`
	Groups  PatientCreateResourceRelationshipsGroups        `json:"groups"`
}

type PatientCreateResourceTypeEnum string

const (
	PatientCreateResourceTypeEnumPatient PatientCreateResourceTypeEnum = "patient"
)

func (e PatientCreateResourceTypeEnum) ToPointer() *PatientCreateResourceTypeEnum {
	return &e
}

func (e *PatientCreateResourceTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "patient":
		*e = PatientCreateResourceTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatientCreateResourceTypeEnum: %v", v)
	}
}

// PatientCreateResourceInput - Note that `data` can either be a single object or an array of objects matching the schema specified here
// (bulk create).
type PatientCreateResourceInput struct {
	Attributes    PatientCreateResourceAttributesInput     `json:"attributes"`
	ID            *string                                  `json:"id,omitempty"`
	Relationships *PatientCreateResourceRelationshipsInput `json:"relationships,omitempty"`
	Type          PatientCreateResourceTypeEnum            `json:"type"`
}
