"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from datetime import date
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class HybridTransactionClearedEnum(str, Enum):
    r"""The cleared status of the transaction"""
    CLEARED = 'cleared'
    UNCLEARED = 'uncleared'
    RECONCILED = 'reconciled'

class HybridTransactionDebtTransactionTypeEnum(str, Enum):
    r"""If the transaction is a debt/loan account transaction, the type of transaction"""
    PAYMENT = 'payment'
    REFUND = 'refund'
    FEE = 'fee'
    INTEREST = 'interest'
    ESCROW = 'escrow'
    BALANCED_ADJUSTMENT = 'balancedAdjustment'
    CREDIT = 'credit'
    CHARGE = 'charge'
    NULL = 'null'

class HybridTransactionFlagColorEnum(str, Enum):
    r"""The transaction flag"""
    RED = 'red'
    ORANGE = 'orange'
    YELLOW = 'yellow'
    GREEN = 'green'
    BLUE = 'blue'
    PURPLE = 'purple'
    NULL = 'null'

class HybridTransactionTypeEnum(str, Enum):
    r"""Whether the hybrid transaction represents a regular transaction or a subtransaction"""
    TRANSACTION = 'transaction'
    SUBTRANSACTION = 'subtransaction'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class HybridTransaction:
    
    account_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id') }})  
    account_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_name') }})  
    amount: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount') }})
    r"""The transaction amount in milliunits format"""  
    approved: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('approved') }})
    r"""Whether or not the transaction is approved"""  
    cleared: HybridTransactionClearedEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cleared') }})
    r"""The cleared status of the transaction"""  
    date_: date = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('date'), 'encoder': utils.dateisoformat(False), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso') }})
    r"""The transaction date in ISO format (e.g. 2016-12-01)"""  
    deleted: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deleted') }})
    r"""Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests."""  
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})  
    type: HybridTransactionTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""Whether the hybrid transaction represents a regular transaction or a subtransaction"""  
    category_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('category_id'), 'exclude': lambda f: f is None }})  
    category_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('category_name'), 'exclude': lambda f: f is None }})  
    debt_transaction_type: Optional[HybridTransactionDebtTransactionTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('debt_transaction_type'), 'exclude': lambda f: f is None }})
    r"""If the transaction is a debt/loan account transaction, the type of transaction"""  
    flag_color: Optional[HybridTransactionFlagColorEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('flag_color'), 'exclude': lambda f: f is None }})
    r"""The transaction flag"""  
    import_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('import_id'), 'exclude': lambda f: f is None }})
    r"""If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'."""  
    import_payee_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('import_payee_name'), 'exclude': lambda f: f is None }})
    r"""If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules"""  
    import_payee_name_original: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('import_payee_name_original'), 'exclude': lambda f: f is None }})
    r"""If the transaction was imported, the original payee name as it appeared on the statement"""  
    matched_transaction_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('matched_transaction_id'), 'exclude': lambda f: f is None }})
    r"""If transaction is matched, the id of the matched transaction"""  
    memo: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('memo'), 'exclude': lambda f: f is None }})  
    parent_transaction_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('parent_transaction_id'), 'exclude': lambda f: f is None }})
    r"""For subtransaction types, this is the id of the parent transaction.  For transaction types, this id will be always be null."""  
    payee_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('payee_id'), 'exclude': lambda f: f is None }})  
    payee_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('payee_name'), 'exclude': lambda f: f is None }})  
    transfer_account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transfer_account_id'), 'exclude': lambda f: f is None }})
    r"""If a transfer transaction, the account to which it transfers"""  
    transfer_transaction_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transfer_transaction_id'), 'exclude': lambda f: f is None }})
    r"""If a transfer transaction, the id of transaction on the other side of the transfer"""  
    