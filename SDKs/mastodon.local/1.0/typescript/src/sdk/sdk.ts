/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import { Accounts } from "./accounts";
import { Apps } from "./apps";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { Oauth } from "./oauth";
import { TODOSecurity } from "./todosecurity";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  "http://mastodon.local",
  "https://mastodon.social",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

export class SDK {
  public todoSecurity: TODOSecurity;
  public accounts: Accounts;
  public apps: Apps;
  public oauth: Oauth;

  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;

    this.todoSecurity = new TODOSecurity(
      this._defaultClient,
      this._securityClient,
      this._serverURL,
      this._language,
      this._sdkVersion,
      this._genVersion
    );

    this.accounts = new Accounts(
      this._defaultClient,
      this._securityClient,
      this._serverURL,
      this._language,
      this._sdkVersion,
      this._genVersion
    );

    this.apps = new Apps(
      this._defaultClient,
      this._securityClient,
      this._serverURL,
      this._language,
      this._sdkVersion,
      this._genVersion
    );

    this.oauth = new Oauth(
      this._defaultClient,
      this._securityClient,
      this._serverURL,
      this._language,
      this._sdkVersion,
      this._genVersion
    );
  }

  /**
   * Undo a react emoji to an announcement.
   */
  deleteApiV1AnnouncementsIdReactionsName(
    req: operations.DeleteApiV1AnnouncementsIdReactionsNameRequest,
    security: operations.DeleteApiV1AnnouncementsIdReactionsNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1AnnouncementsIdReactionsNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1AnnouncementsIdReactionsNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/announcements/{id}/reactions/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1AnnouncementsIdReactionsNameSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1AnnouncementsIdReactionsNameResponse =
        new operations.DeleteApiV1AnnouncementsIdReactionsNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1AnnouncementsIdReactionsName200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove converstation
   */
  deleteApiV1ConversationsId(
    req: operations.DeleteApiV1ConversationsIdRequest,
    security: operations.DeleteApiV1ConversationsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1ConversationsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1ConversationsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/conversations/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1ConversationsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1ConversationsIdResponse =
        new operations.DeleteApiV1ConversationsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1ConversationsId200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove a domain block, if it exists in the user's array of blocked domains.
   */
  deleteApiV1DomainBlocks(
    req: operations.DeleteApiV1DomainBlocksRequest,
    security: operations.DeleteApiV1DomainBlocksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1DomainBlocksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1DomainBlocksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/domain_blocks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1DomainBlocksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1DomainBlocksResponse =
        new operations.DeleteApiV1DomainBlocksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1DomainBlocks200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unfeature a tag
   */
  deleteApiV1FeaturedTagsId(
    req: operations.DeleteApiV1FeaturedTagsIdRequest,
    security: operations.DeleteApiV1FeaturedTagsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1FeaturedTagsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1FeaturedTagsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/featured_tags/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1FeaturedTagsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1FeaturedTagsIdResponse =
        new operations.DeleteApiV1FeaturedTagsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1FeaturedTagsId200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a filter.
   */
  deleteApiV1FiltersId(
    req: operations.DeleteApiV1FiltersIdRequest,
    security: operations.DeleteApiV1FiltersIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1FiltersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1FiltersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/filters/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1FiltersIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1FiltersIdResponse =
        new operations.DeleteApiV1FiltersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a list
   */
  deleteApiV1Lists(
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1ListsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/lists";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1ListsResponse =
        new operations.DeleteApiV1ListsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1Lists200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove accounts from the given list.
   */
  deleteApiV1ListsIdAccounts(
    req: operations.DeleteApiV1ListsIdAccountsRequest,
    security: operations.DeleteApiV1ListsIdAccountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1ListsIdAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1ListsIdAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/lists/{id}/accounts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1ListsIdAccountsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1ListsIdAccountsResponse =
        new operations.DeleteApiV1ListsIdAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1ListsIdAccounts200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
   */
  deleteApiV1PushSubscription(
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1PushSubscriptionResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/push/subscription";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1PushSubscriptionResponse =
        new operations.DeleteApiV1PushSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1PushSubscription200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a scheduled status
   */
  deleteApiV1ScheduledStatusesId(
    req: operations.DeleteApiV1ScheduledStatusesIdRequest,
    security: operations.DeleteApiV1ScheduledStatusesIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1ScheduledStatusesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1ScheduledStatusesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/scheduled_statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1ScheduledStatusesIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1ScheduledStatusesIdResponse =
        new operations.DeleteApiV1ScheduledStatusesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1ScheduledStatusesId200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  deleteApiV1StatusesId(
    req: operations.DeleteApiV1StatusesIdRequest,
    security: operations.DeleteApiV1StatusesIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1StatusesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1StatusesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1StatusesIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1StatusesIdResponse =
        new operations.DeleteApiV1StatusesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete user suggestion
   */
  deleteApiV1SuggestionsId(
    req: operations.DeleteApiV1SuggestionsIdRequest,
    security: operations.DeleteApiV1SuggestionsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteApiV1SuggestionsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteApiV1SuggestionsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/suggestions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteApiV1SuggestionsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteApiV1SuggestionsIdResponse =
        new operations.DeleteApiV1SuggestionsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteApiV1SuggestionsId200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * OEmbed as JSON
   */
  getApiOembed(
    req: operations.GetApiOembedRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiOembedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiOembedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/oembed";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiOembedResponse =
        new operations.GetApiOembedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.card = utils.objectToClass(httpRes?.data, shared.Card);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View identity proof
   */
  getApiProofs(
    req: operations.GetApiProofsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiProofsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiProofsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/proofs";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiProofsResponse =
        new operations.GetApiProofsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identityProof = utils.objectToClass(
              httpRes?.data,
              shared.IdentityProof
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View accounts matching certain criteria for filtering, up to 100 at a time. Pagination may be done with the HTTP Link header in the response.
   */
  getApiV1AdminAccounts(
    req: operations.GetApiV1AdminAccountsRequest,
    security: operations.GetApiV1AdminAccountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AdminAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AdminAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/admin/accounts";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AdminAccountsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AdminAccountsResponse =
        new operations.GetApiV1AdminAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminAccounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.adminAccounts = utils.objectToClass(
              httpRes?.data,
              shared.AdminAccount,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View admin-level information about the given account.
   */
  getApiV1AdminAccountsId(
    req: operations.GetApiV1AdminAccountsIdRequest,
    security: operations.GetApiV1AdminAccountsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AdminAccountsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AdminAccountsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AdminAccountsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AdminAccountsIdResponse =
        new operations.GetApiV1AdminAccountsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminAccount = utils.objectToClass(
              httpRes?.data,
              shared.AdminAccount
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View all reports. Pagination may be done with HTTP Link header in the response.
   */
  getApiV1AdminReports(
    req: operations.GetApiV1AdminReportsRequest,
    security: operations.GetApiV1AdminReportsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AdminReportsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AdminReportsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/admin/reports";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AdminReportsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AdminReportsResponse =
        new operations.GetApiV1AdminReportsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminReports = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.adminReports = utils.objectToClass(
              httpRes?.data,
              shared.AdminReport,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View information about the report with the given ID.
   */
  getApiV1AdminReportsId(
    req: operations.GetApiV1AdminReportsIdRequest,
    security: operations.GetApiV1AdminReportsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AdminReportsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AdminReportsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/reports/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AdminReportsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AdminReportsIdResponse =
        new operations.GetApiV1AdminReportsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminReport = utils.objectToClass(
              httpRes?.data,
              shared.AdminReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * See all currently active announcements set by admins.
   */
  getApiV1Announcements(
    req: operations.GetApiV1AnnouncementsRequest,
    security: operations.GetApiV1AnnouncementsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AnnouncementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AnnouncementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/announcements";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AnnouncementsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AnnouncementsResponse =
        new operations.GetApiV1AnnouncementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.announcements = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.announcements = utils.objectToClass(
              httpRes?.data,
              shared.Announcement,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get blocked users.
   */
  getApiV1Blocks(
    req: operations.GetApiV1BlocksRequest,
    security: operations.GetApiV1BlocksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1BlocksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1BlocksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/blocks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1BlocksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1BlocksResponse =
        new operations.GetApiV1BlocksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Statuses the user has bookmarked.
   */
  getApiV1Bookmarks(
    req: operations.GetApiV1BookmarksRequest,
    security: operations.GetApiV1BookmarksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1BookmarksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1BookmarksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/bookmarks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1BookmarksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1BookmarksResponse =
        new operations.GetApiV1BookmarksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show conversation.
   */
  getApiV1Conversations(
    req: operations.GetApiV1ConversationsRequest,
    security: operations.GetApiV1ConversationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1ConversationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1ConversationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/conversations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1ConversationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1ConversationsResponse =
        new operations.GetApiV1ConversationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.conversations = utils.objectToClass(
              httpRes?.data,
              shared.Conversation,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom emojis that are available on the server.
   */
  getApiV1CustomEmojis(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1CustomEmojisResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/custom_emojis";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1CustomEmojisResponse =
        new operations.GetApiV1CustomEmojisResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.emojis = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.emojis = utils.objectToClass(
              httpRes?.data,
              shared.Emoji,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List accounts visible in the directory.
   */
  getApiV1Directory(
    req: operations.GetApiV1DirectoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1DirectoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1DirectoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/directory";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1DirectoryResponse =
        new operations.GetApiV1DirectoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View domains the user has blocked.
   */
  getApiV1DomainBlocks(
    req: operations.GetApiV1DomainBlocksRequest,
    security: operations.GetApiV1DomainBlocksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1DomainBlocksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1DomainBlocksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/domain_blocks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1DomainBlocksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1DomainBlocksResponse =
        new operations.GetApiV1DomainBlocksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getApiV1DomainBlocks200ApplicationJSONStrings =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accounts that the user is currently featuring on their profile.
   */
  getApiV1Endorsements(
    req: operations.GetApiV1EndorsementsRequest,
    security: operations.GetApiV1EndorsementsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1EndorsementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1EndorsementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/endorsements";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1EndorsementsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1EndorsementsResponse =
        new operations.GetApiV1EndorsementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Statuses the user has favourited.
   */
  getApiV1Favourites(
    req: operations.GetApiV1FavouritesRequest,
    security: operations.GetApiV1FavouritesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1FavouritesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1FavouritesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/favourites";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1FavouritesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1FavouritesResponse =
        new operations.GetApiV1FavouritesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View your featured tags.
   */
  getApiV1FeaturedTags(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1FeaturedTagsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/featured_tags";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1FeaturedTagsResponse =
        new operations.GetApiV1FeaturedTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.featuredTags = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.featuredTags = utils.objectToClass(
              httpRes?.data,
              shared.FeaturedTag,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Shows your 10 most-used tags, with usage history for the past week.
   */
  getApiV1FeaturedTagsSuggestions(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1FeaturedTagsSuggestionsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/featured_tags/suggestions";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1FeaturedTagsSuggestionsResponse =
        new operations.GetApiV1FeaturedTagsSuggestionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.featuredTags = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.featuredTags = utils.objectToClass(
              httpRes?.data,
              shared.FeaturedTag,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  getApiV1Filters(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1FiltersResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/filters";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1FiltersResponse =
        new operations.GetApiV1FiltersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.filters = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.filters = utils.objectToClass(
              httpRes?.data,
              shared.Filter,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get one filter.
   */
  getApiV1FiltersId(
    req: operations.GetApiV1FiltersIdRequest,
    security: operations.GetApiV1FiltersIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1FiltersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1FiltersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/filters/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1FiltersIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1FiltersIdResponse =
        new operations.GetApiV1FiltersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.filter = utils.objectToClass(httpRes?.data, shared.Filter);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Pending Follows
   */
  getApiV1FollowRequests(
    req: operations.GetApiV1FollowRequestsRequest,
    security: operations.GetApiV1FollowRequestsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1FollowRequestsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1FollowRequestsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/follow_requests";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1FollowRequestsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1FollowRequestsResponse =
        new operations.GetApiV1FollowRequestsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Information about the server.
   */
  getApiV1Instance(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1InstanceResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/instance";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1InstanceResponse =
        new operations.GetApiV1InstanceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.instance = utils.objectToClass(httpRes?.data, shared.Instance);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Instance activity over the last 3 months, binned weekly.
   */
  getApiV1InstanceActivity(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1InstanceActivityResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/instance/activity";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1InstanceActivityResponse =
        new operations.GetApiV1InstanceActivityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.activities = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.activities = utils.objectToClass(
              httpRes?.data,
              shared.Activity,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Information about the server.
   */
  getApiV1InstancePeers(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1InstancePeersResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/instance/peers";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1InstancePeersResponse =
        new operations.GetApiV1InstancePeersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getApiV1InstancePeers200ApplicationJSONStrings =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch all lists that the user owns.
   */
  getApiV1Lists(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1ListsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/lists";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1ListsResponse =
        new operations.GetApiV1ListsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lists = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.lists = utils.objectToClass(
              httpRes?.data,
              shared.List,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove converstation
   */
  getApiV1ListsId(
    req: operations.GetApiV1ListsIdRequest,
    security: operations.GetApiV1ListsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1ListsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1ListsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/lists/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1ListsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1ListsIdResponse =
        new operations.GetApiV1ListsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.list = utils.objectToClass(httpRes?.data, shared.List);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View accounts in List
   */
  getApiV1ListsIdAccounts(
    req: operations.GetApiV1ListsIdAccountsRequest,
    security: operations.GetApiV1ListsIdAccountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1ListsIdAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1ListsIdAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/lists/{id}/accounts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1ListsIdAccountsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1ListsIdAccountsResponse =
        new operations.GetApiV1ListsIdAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get an attachement.
   */
  getApiV1MediaId(
    req: operations.GetApiV1MediaIdRequest,
    security: operations.GetApiV1MediaIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1MediaIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1MediaIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/media/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1MediaIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1MediaIdResponse =
        new operations.GetApiV1MediaIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.attachment = utils.objectToClass(
              httpRes?.data,
              shared.Attachment
            );
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accounts the user has muted.
   */
  getApiV1Mutes(
    req: operations.GetApiV1MutesRequest,
    security: operations.GetApiV1MutesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1MutesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1MutesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/mutes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1MutesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1MutesResponse =
        new operations.GetApiV1MutesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Notifications concerning the user. This API returns Link headers containing links to the next/previous page. However, the links can also be constructed dynamically using query params and id values.
   */
  getApiV1Notifications(
    req: operations.GetApiV1NotificationsRequest,
    security: operations.GetApiV1NotificationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1NotificationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1NotificationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/notifications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1NotificationsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1NotificationsResponse =
        new operations.GetApiV1NotificationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notifications = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.notifications = utils.objectToClass(
              httpRes?.data,
              shared.Notification,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View information about a notification with a given ID.
   */
  getApiV1NotificationsId(
    req: operations.GetApiV1NotificationsIdRequest,
    security: operations.GetApiV1NotificationsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1NotificationsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1NotificationsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/notifications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1NotificationsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1NotificationsIdResponse =
        new operations.GetApiV1NotificationsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notification = utils.objectToClass(
              httpRes?.data,
              shared.Notification
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View a poll.
   */
  getApiV1PollsId(
    req: operations.GetApiV1PollsIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1PollsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1PollsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/polls/{id}", req);

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1PollsIdResponse =
        new operations.GetApiV1PollsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.poll = utils.objectToClass(httpRes?.data, shared.Poll);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Shows your 10 most-used tags, with usage history for the past week.
   */
  getApiV1Preferences(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1PreferencesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/preferences";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1PreferencesResponse =
        new operations.GetApiV1PreferencesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.preferences = utils.objectToClass(
              httpRes?.data,
              shared.Preferences
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View the PushSubscription currently associated with this access token.
   */
  getApiV1PushSubscription(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1PushSubscriptionResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/push/subscription";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1PushSubscriptionResponse =
        new operations.GetApiV1PushSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pushSubscription = utils.objectToClass(
              httpRes?.data,
              shared.PushSubscription
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View scheduled statuses
   */
  getApiV1ScheduledStatuses(
    req: operations.GetApiV1ScheduledStatusesRequest,
    security: operations.GetApiV1ScheduledStatusesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1ScheduledStatusesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1ScheduledStatusesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/scheduled_statuses";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1ScheduledStatusesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1ScheduledStatusesResponse =
        new operations.GetApiV1ScheduledStatusesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scheduledStatuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.scheduledStatuses = utils.objectToClass(
              httpRes?.data,
              shared.ScheduledStatus,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View a single scheduled status
   */
  getApiV1ScheduledStatusesId(
    req: operations.GetApiV1ScheduledStatusesIdRequest,
    security: operations.GetApiV1ScheduledStatusesIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1ScheduledStatusesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1ScheduledStatusesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/scheduled_statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1ScheduledStatusesIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1ScheduledStatusesIdResponse =
        new operations.GetApiV1ScheduledStatusesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scheduledStatus = utils.objectToClass(
              httpRes?.data,
              shared.ScheduledStatus
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  getApiV1StatusesId(
    req: operations.GetApiV1StatusesIdRequest,
    security: operations.GetApiV1StatusesIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1StatusesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1StatusesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1StatusesIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1StatusesIdResponse =
        new operations.GetApiV1StatusesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  getApiV1StatusesIdContext(
    req: operations.GetApiV1StatusesIdContextRequest,
    security: operations.GetApiV1StatusesIdContextSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1StatusesIdContextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1StatusesIdContextRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/context",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1StatusesIdContextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1StatusesIdContextResponse =
        new operations.GetApiV1StatusesIdContextResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.context = utils.objectToClass(httpRes?.data, shared.Context);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View who favourited a given status.
   */
  getApiV1StatusesIdFavouritedBy(
    req: operations.GetApiV1StatusesIdFavouritedByRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1StatusesIdFavouritedByResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1StatusesIdFavouritedByRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/favourited_by",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1StatusesIdFavouritedByResponse =
        new operations.GetApiV1StatusesIdFavouritedByResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View who boosted a given status.
   */
  getApiV1StatusesIdRebloggedBy(
    req: operations.GetApiV1StatusesIdRebloggedByRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1StatusesIdRebloggedByResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1StatusesIdRebloggedByRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/reblogged_by",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1StatusesIdRebloggedByResponse =
        new operations.GetApiV1StatusesIdRebloggedByResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accounts the user has had past positive interactions with, but is not yet following.
   */
  getApiV1Suggestions(
    req: operations.GetApiV1SuggestionsRequest,
    security: operations.GetApiV1SuggestionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1SuggestionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1SuggestionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/suggestions";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1SuggestionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1SuggestionsResponse =
        new operations.GetApiV1SuggestionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View statuses from followed users.
   */
  getApiV1TimelinesHome(
    req: operations.GetApiV1TimelinesHomeRequest,
    security: operations.GetApiV1TimelinesHomeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1TimelinesHomeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1TimelinesHomeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/timelines/home";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1TimelinesHomeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1TimelinesHomeResponse =
        new operations.GetApiV1TimelinesHomeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 206:
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View statuses in the given list timeline.
   */
  getApiV1TimelinesListListId(
    req: operations.GetApiV1TimelinesListListIdRequest,
    security: operations.GetApiV1TimelinesListListIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1TimelinesListListIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1TimelinesListListIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/timelines/list/{list_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1TimelinesListListIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1TimelinesListListIdResponse =
        new operations.GetApiV1TimelinesListListIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Public timeline
   */
  getApiV1TimelinesPublic(
    req: operations.GetApiV1TimelinesPublicRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1TimelinesPublicResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1TimelinesPublicRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/timelines/public";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1TimelinesPublicResponse =
        new operations.GetApiV1TimelinesPublicResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View public statuses containing the given hashtag.
   */
  getApiV1TimelinesTagHashtag(
    req: operations.GetApiV1TimelinesTagHashtagRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1TimelinesTagHashtagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1TimelinesTagHashtagRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/timelines/tag/{hashtag}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1TimelinesTagHashtagResponse =
        new operations.GetApiV1TimelinesTagHashtagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Tags that are being used more frequently within the past week.
   */
  getApiV1Trends(
    req: operations.GetApiV1TrendsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1TrendsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1TrendsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/trends";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1TrendsResponse =
        new operations.GetApiV1TrendsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tags = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.tags = utils.objectToClass(
              httpRes?.data,
              shared.Tag,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search results
   */
  getApiV2Search(
    req: operations.GetApiV2SearchRequest,
    security: operations.GetApiV2SearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV2SearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV2SearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v2/search";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV2SearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV2SearchResponse =
        new operations.GetApiV2SearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getApiV2Search200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetApiV2Search200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Perform an action against an account and log this action in the moderation history.
   */
  postApiV1AdminAccountsIdAction(
    req: operations.PostApiV1AdminAccountsIdActionRequest,
    security: operations.PostApiV1AdminAccountsIdActionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminAccountsIdActionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminAccountsIdActionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}/action",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminAccountsIdActionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminAccountsIdActionResponse =
        new operations.PostApiV1AdminAccountsIdActionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Approve the given local account if it is currently pending approval.
   */
  postApiV1AdminAccountsIdApprove(
    req: operations.PostApiV1AdminAccountsIdApproveRequest,
    security: operations.PostApiV1AdminAccountsIdApproveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminAccountsIdApproveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminAccountsIdApproveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}/approve",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminAccountsIdApproveSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminAccountsIdApproveResponse =
        new operations.PostApiV1AdminAccountsIdApproveResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Re-enable a local account whose login is currently disabled.
   */
  postApiV1AdminAccountsIdEnable(
    req: operations.PostApiV1AdminAccountsIdEnableRequest,
    security: operations.PostApiV1AdminAccountsIdEnableSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminAccountsIdEnableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminAccountsIdEnableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}/enable",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminAccountsIdEnableSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminAccountsIdEnableResponse =
        new operations.PostApiV1AdminAccountsIdEnableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Reject the given local account if it is currently pending approval.
   */
  postApiV1AdminAccountsIdReject(
    req: operations.PostApiV1AdminAccountsIdRejectRequest,
    security: operations.PostApiV1AdminAccountsIdRejectSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminAccountsIdRejectResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminAccountsIdRejectRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}/reject",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminAccountsIdRejectSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminAccountsIdRejectResponse =
        new operations.PostApiV1AdminAccountsIdRejectResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Unsilence a currently silenced account.
   */
  postApiV1AdminAccountsIdUnsilence(
    req: operations.PostApiV1AdminAccountsIdUnsilenceRequest,
    security: operations.PostApiV1AdminAccountsIdUnsilenceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminAccountsIdUnsilenceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminAccountsIdUnsilenceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}/unsilence",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminAccountsIdUnsilenceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminAccountsIdUnsilenceResponse =
        new operations.PostApiV1AdminAccountsIdUnsilenceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Unsuspend a currently suspended account.
   */
  postApiV1AdminAccountsIdUnsuspend(
    req: operations.PostApiV1AdminAccountsIdUnsuspendRequest,
    security: operations.PostApiV1AdminAccountsIdUnsuspendSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminAccountsIdUnsuspendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminAccountsIdUnsuspendRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/accounts/{id}/unsuspend",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminAccountsIdUnsuspendSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminAccountsIdUnsuspendResponse =
        new operations.PostApiV1AdminAccountsIdUnsuspendResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Claim the handling of this report to yourself.
   */
  postApiV1AdminReportsIdAssignToSelf(
    req: operations.PostApiV1AdminReportsIdAssignToSelfRequest,
    security: operations.PostApiV1AdminReportsIdAssignToSelfSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminReportsIdAssignToSelfResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminReportsIdAssignToSelfRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/reports/{id}/assign_to_self",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminReportsIdAssignToSelfSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminReportsIdAssignToSelfResponse =
        new operations.PostApiV1AdminReportsIdAssignToSelfResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminReport = utils.objectToClass(
              httpRes?.data,
              shared.AdminReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Mark a report as resolved with no further action taken.
   */
  postApiV1AdminReportsIdReopen(
    req: operations.PostApiV1AdminReportsIdReopenRequest,
    security: operations.PostApiV1AdminReportsIdReopenSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminReportsIdReopenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminReportsIdReopenRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/reports/{id}/reopen",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminReportsIdReopenSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminReportsIdReopenResponse =
        new operations.PostApiV1AdminReportsIdReopenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminReport = utils.objectToClass(
              httpRes?.data,
              shared.AdminReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Mark a report as resolved with no further action taken.
   */
  postApiV1AdminReportsIdResolve(
    req: operations.PostApiV1AdminReportsIdResolveRequest,
    security: operations.PostApiV1AdminReportsIdResolveSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminReportsIdResolveResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminReportsIdResolveRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/reports/{id}/resolve",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminReportsIdResolveSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminReportsIdResolveResponse =
        new operations.PostApiV1AdminReportsIdResolveResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminReport = utils.objectToClass(
              httpRes?.data,
              shared.AdminReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unassign a report so that someone else can claim it.
   */
  postApiV1AdminReportsIdUnassign(
    req: operations.PostApiV1AdminReportsIdUnassignRequest,
    security: operations.PostApiV1AdminReportsIdUnassignSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AdminReportsIdUnassignResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AdminReportsIdUnassignRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/admin/reports/{id}/unassign",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AdminReportsIdUnassignSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AdminReportsIdUnassignResponse =
        new operations.PostApiV1AdminReportsIdUnassignResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.adminReport = utils.objectToClass(
              httpRes?.data,
              shared.AdminReport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Allows a user to mark the announcement as read.
   */
  postApiV1AnnouncementsIdDismiss(
    req: operations.PostApiV1AnnouncementsIdDismissRequest,
    security: operations.PostApiV1AnnouncementsIdDismissSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AnnouncementsIdDismissResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AnnouncementsIdDismissRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/announcements/{id}/dismiss",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AnnouncementsIdDismissSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AnnouncementsIdDismissResponse =
        new operations.PostApiV1AnnouncementsIdDismissResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postApiV1AnnouncementsIdDismiss200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove converstation
   */
  postApiV1ConversationsIdRead(
    req: operations.PostApiV1ConversationsIdReadRequest,
    security: operations.PostApiV1ConversationsIdReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1ConversationsIdReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1ConversationsIdReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/conversations/{id}/read",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1ConversationsIdReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1ConversationsIdReadResponse =
        new operations.PostApiV1ConversationsIdReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conversation = utils.objectToClass(
              httpRes?.data,
              shared.Conversation
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * "Block a domain to:
   * - hide all public posts from it
   * - hide all notifications from it
   * - remove all followers from it
   * - prevent following new users from it (but does not remove existing follows)"
   *
   */
  postApiV1DomainBlocks(
    req: Uint8Array,
    security: operations.PostApiV1DomainBlocksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1DomainBlocksResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/domain_blocks";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1DomainBlocksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1DomainBlocksResponse =
        new operations.PostApiV1DomainBlocksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postApiV1DomainBlocks200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a feature a tag.
   */
  postApiV1FeaturedTags(
    req: operations.PostApiV1FeaturedTagsRequestBody,
    security: operations.PostApiV1FeaturedTagsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1FeaturedTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1FeaturedTagsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/featured_tags";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1FeaturedTagsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1FeaturedTagsResponse =
        new operations.PostApiV1FeaturedTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.featuredTag = utils.objectToClass(
              httpRes?.data,
              shared.FeaturedTag
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  postApiV1Filters(
    req: Uint8Array,
    security: operations.PostApiV1FiltersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1FiltersResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/filters";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1FiltersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1FiltersResponse =
        new operations.PostApiV1FiltersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.filter = utils.objectToClass(httpRes?.data, shared.Filter);
          }
          break;
        case [401, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accept Follow
   */
  postApiV1FollowRequestsIdAuthorize(
    req: operations.PostApiV1FollowRequestsIdAuthorizeRequest,
    security: operations.PostApiV1FollowRequestsIdAuthorizeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1FollowRequestsIdAuthorizeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1FollowRequestsIdAuthorizeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/follow_requests/{id}/authorize",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1FollowRequestsIdAuthorizeSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1FollowRequestsIdAuthorizeResponse =
        new operations.PostApiV1FollowRequestsIdAuthorizeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accept Follow
   */
  postApiV1FollowRequestsIdReject(
    req: operations.PostApiV1FollowRequestsIdRejectRequest,
    security: operations.PostApiV1FollowRequestsIdRejectSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1FollowRequestsIdRejectResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1FollowRequestsIdRejectRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/follow_requests/{id}/reject",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1FollowRequestsIdRejectSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1FollowRequestsIdRejectResponse =
        new operations.PostApiV1FollowRequestsIdRejectResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new list.
   */
  postApiV1Lists(
    req: operations.PostApiV1ListsRequestBody,
    security: operations.PostApiV1ListsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1ListsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1ListsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/lists";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1ListsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1ListsResponse =
        new operations.PostApiV1ListsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.list = utils.objectToClass(httpRes?.data, shared.List);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add accounts to the given list. Note that the user must be following these accounts.
   */
  postApiV1ListsIdAccounts(
    req: operations.PostApiV1ListsIdAccountsRequest,
    security: operations.PostApiV1ListsIdAccountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1ListsIdAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1ListsIdAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/lists/{id}/accounts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1ListsIdAccountsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1ListsIdAccountsResponse =
        new operations.PostApiV1ListsIdAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postApiV1ListsIdAccounts200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get saved timeline position
   */
  postApiV1Markers(
    req: Record<string, any>,
    security: operations.PostApiV1MarkersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1MarkersResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/markers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1MarkersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1MarkersResponse =
        new operations.PostApiV1MarkersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postApiV1Markers200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case [401, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates an attachment to be used with a new status.
   */
  postApiV1Media(
    req: Uint8Array,
    security: operations.PostApiV1MediaSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1MediaResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/media";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1MediaSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1MediaResponse =
        new operations.PostApiV1MediaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.attachment = utils.objectToClass(
              httpRes?.data,
              shared.Attachment
            );
          }
          break;
        case [401, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Attachment, before it is attached to a status and posted.
   */
  postApiV1MediaId(
    req: operations.PostApiV1MediaIdRequest,
    security: operations.PostApiV1MediaIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1MediaIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1MediaIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/media/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1MediaIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1MediaIdResponse =
        new operations.PostApiV1MediaIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.attachment = utils.objectToClass(
              httpRes?.data,
              shared.Attachment
            );
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Clear all notifications from the server.
   */
  postApiV1NotificationsClear(
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1NotificationsClearResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/notifications/clear";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1NotificationsClearResponse =
        new operations.PostApiV1NotificationsClearResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postApiV1NotificationsClear200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Clear a single notification from the server.
   */
  postApiV1NotificationsIdDismiss(
    req: operations.PostApiV1NotificationsIdDismissRequest,
    security: operations.PostApiV1NotificationsIdDismissSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1NotificationsIdDismissResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1NotificationsIdDismissRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/notifications/{id}/dismiss",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1NotificationsIdDismissSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1NotificationsIdDismissResponse =
        new operations.PostApiV1NotificationsIdDismissResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notification = utils.objectToClass(
              httpRes?.data,
              shared.Notification
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Vote on a poll.
   */
  postApiV1PollsId(
    req: operations.PostApiV1PollsIdRequest,
    security: operations.PostApiV1PollsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1PollsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1PollsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/polls/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1PollsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1PollsIdResponse =
        new operations.PostApiV1PollsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.poll = utils.objectToClass(httpRes?.data, shared.Poll);
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Web Push API subscription to receive notifications. Each access token can have one push subscription. If you create a new subscription, the old subscription is deleted.
   */
  postApiV1PushSubscription(
    req: operations.PostApiV1PushSubscriptionRequestBody,
    security: operations.PostApiV1PushSubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1PushSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1PushSubscriptionRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/push/subscription";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1PushSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1PushSubscriptionResponse =
        new operations.PostApiV1PushSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pushSubscription = utils.objectToClass(
              httpRes?.data,
              shared.PushSubscription
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * File a report.
   */
  postApiV1Reports(
    req: operations.PostApiV1ReportsRequestBody,
    security: operations.PostApiV1ReportsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1ReportsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1ReportsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/reports";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1ReportsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1ReportsResponse =
        new operations.PostApiV1ReportsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.report = utils.objectToClass(httpRes?.data, shared.Report);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  postApiV1Statuses(
    req: operations.PostApiV1StatusesRequest,
    security: operations.PostApiV1StatusesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/statuses";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesResponse =
        new operations.PostApiV1StatusesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postApiV1Statuses200ApplicationJSONOneOf = httpRes?.data;
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Privately bookmark a status.
   */
  postApiV1StatusesIdBookmark(
    req: operations.PostApiV1StatusesIdBookmarkRequest,
    security: operations.PostApiV1StatusesIdBookmarkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdBookmarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdBookmarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/bookmark",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdBookmarkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdBookmarkResponse =
        new operations.PostApiV1StatusesIdBookmarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a status to your favourites list.
   */
  postApiV1StatusesIdFavourite(
    req: operations.PostApiV1StatusesIdFavouriteRequest,
    security: operations.PostApiV1StatusesIdFavouriteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdFavouriteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdFavouriteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/favourite",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdFavouriteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdFavouriteResponse =
        new operations.PostApiV1StatusesIdFavouriteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant.
   */
  postApiV1StatusesIdMute(
    req: operations.PostApiV1StatusesIdMuteRequest,
    security: operations.PostApiV1StatusesIdMuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdMuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdMuteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/mute",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdMuteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdMuteResponse =
        new operations.PostApiV1StatusesIdMuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Feature one of your own public statuses at the top of your profile.
   */
  postApiV1StatusesIdPin(
    req: operations.PostApiV1StatusesIdPinRequest,
    security: operations.PostApiV1StatusesIdPinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdPinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdPinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/pin",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdPinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdPinResponse =
        new operations.PostApiV1StatusesIdPinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reshare a status.
   */
  postApiV1StatusesIdReblog(
    req: operations.PostApiV1StatusesIdReblogRequest,
    security: operations.PostApiV1StatusesIdReblogSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdReblogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdReblogRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/reblog",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdReblogSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdReblogResponse =
        new operations.PostApiV1StatusesIdReblogResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove a status from your private bookmarks.
   */
  postApiV1StatusesIdUnbookmark(
    req: operations.PostApiV1StatusesIdUnbookmarkRequest,
    security: operations.PostApiV1StatusesIdUnbookmarkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdUnbookmarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdUnbookmarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/unbookmark",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdUnbookmarkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdUnbookmarkResponse =
        new operations.PostApiV1StatusesIdUnbookmarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove a status from your favourites list.
   */
  postApiV1StatusesIdUnfavourite(
    req: operations.PostApiV1StatusesIdUnfavouriteRequest,
    security: operations.PostApiV1StatusesIdUnfavouriteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdUnfavouriteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdUnfavouriteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/unfavourite",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdUnfavouriteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdUnfavouriteResponse =
        new operations.PostApiV1StatusesIdUnfavouriteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Status's conversation unmuted, or was already unmuted
   */
  postApiV1StatusesIdUnmute(
    req: operations.PostApiV1StatusesIdUnmuteRequest,
    security: operations.PostApiV1StatusesIdUnmuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdUnmuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdUnmuteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/unmute",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdUnmuteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdUnmuteResponse =
        new operations.PostApiV1StatusesIdUnmuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unfeature a status from the top of your profile.
   */
  postApiV1StatusesIdUnpin(
    req: operations.PostApiV1StatusesIdUnpinRequest,
    security: operations.PostApiV1StatusesIdUnpinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdUnpinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdUnpinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/unpin",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdUnpinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdUnpinResponse =
        new operations.PostApiV1StatusesIdUnpinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Undo a reshare of a status.
   */
  postApiV1StatusesIdUnreblog(
    req: operations.PostApiV1StatusesIdUnreblogRequest,
    security: operations.PostApiV1StatusesIdUnreblogSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1StatusesIdUnreblogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1StatusesIdUnreblogRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/statuses/{id}/unreblog",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1StatusesIdUnreblogSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1StatusesIdUnreblogResponse =
        new operations.PostApiV1StatusesIdUnreblogResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Allows a user to mark the announcement as read.
   */
  putApiV1AnnouncementsIdReactionsName(
    req: operations.PutApiV1AnnouncementsIdReactionsNameRequest,
    security: operations.PutApiV1AnnouncementsIdReactionsNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutApiV1AnnouncementsIdReactionsNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutApiV1AnnouncementsIdReactionsNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/announcements/{id}/reactions/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutApiV1AnnouncementsIdReactionsNameSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutApiV1AnnouncementsIdReactionsNameResponse =
        new operations.PutApiV1AnnouncementsIdReactionsNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putApiV1AnnouncementsIdReactionsName200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a filter.
   */
  putApiV1FiltersId(
    req: operations.PutApiV1FiltersIdRequest,
    security: operations.PutApiV1FiltersIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutApiV1FiltersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutApiV1FiltersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/v1/filters/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutApiV1FiltersIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutApiV1FiltersIdResponse =
        new operations.PutApiV1FiltersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.filter = utils.objectToClass(httpRes?.data, shared.Filter);
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change the title of a list, or which replies to show.
   */
  putApiV1Lists(
    req: operations.PutApiV1ListsRequestBody,
    security: operations.PutApiV1ListsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutApiV1ListsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutApiV1ListsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/lists";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutApiV1ListsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutApiV1ListsResponse =
        new operations.PutApiV1ListsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.list = utils.objectToClass(httpRes?.data, shared.List);
          }
          break;
        case [401, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
   */
  putApiV1PushSubscription(
    req: operations.PutApiV1PushSubscriptionRequestBody,
    security: operations.PutApiV1PushSubscriptionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutApiV1PushSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutApiV1PushSubscriptionRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/push/subscription";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutApiV1PushSubscriptionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutApiV1PushSubscriptionResponse =
        new operations.PutApiV1PushSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pushSubscription = utils.objectToClass(
              httpRes?.data,
              shared.PushSubscription
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * View a single scheduled status
   */
  putApiV1ScheduledStatusesId(
    req: operations.PutApiV1ScheduledStatusesIdRequest,
    security: operations.PutApiV1ScheduledStatusesIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutApiV1ScheduledStatusesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutApiV1ScheduledStatusesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/scheduled_statuses/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutApiV1ScheduledStatusesIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutApiV1ScheduledStatusesIdResponse =
        new operations.PutApiV1ScheduledStatusesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scheduledStatus = utils.objectToClass(
              httpRes?.data,
              shared.ScheduledStatus
            );
          }
          break;
        case [401, 404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }
}
