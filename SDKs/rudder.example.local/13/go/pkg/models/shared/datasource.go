// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// DatasourceRunParametersScheduleTypeEnum - `scheduled` enables periodic update, `notscheduled` disables them
type DatasourceRunParametersScheduleTypeEnum string

const (
	DatasourceRunParametersScheduleTypeEnumScheduled    DatasourceRunParametersScheduleTypeEnum = "scheduled"
	DatasourceRunParametersScheduleTypeEnumNotscheduled DatasourceRunParametersScheduleTypeEnum = "notscheduled"
)

func (e *DatasourceRunParametersScheduleTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "scheduled":
		fallthrough
	case "notscheduled":
		*e = DatasourceRunParametersScheduleTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DatasourceRunParametersScheduleTypeEnum: %s", s)
	}
}

// DatasourceRunParametersSchedule - Configure if data source should be fetch periodically
type DatasourceRunParametersSchedule struct {
	// `scheduled` enables periodic update, `notscheduled` disables them
	Type *DatasourceRunParametersScheduleTypeEnum `json:"type,omitempty"`
}

// DatasourceRunParameters - Parameters to configure when the data source is fetched to update node properties.
type DatasourceRunParameters struct {
	// Trigger a fetch at the beginning of a policy generation
	OnGeneration *bool `json:"onGeneration,omitempty"`
	// Trigger a fetch when a new node is accepted, for that node
	OnNewNode *bool `json:"onNewNode,omitempty"`
	// Configure if data source should be fetch periodically
	Schedule *DatasourceRunParametersSchedule `json:"schedule,omitempty"`
}

// DatasourceTypeNameEnum - Data source type name
type DatasourceTypeNameEnum string

const (
	DatasourceTypeNameEnumHTTP DatasourceTypeNameEnum = "HTTP"
)

func (e *DatasourceTypeNameEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "HTTP":
		*e = DatasourceTypeNameEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DatasourceTypeNameEnum: %s", s)
	}
}

type DatasourceTypeParametersHeaders struct {
	// Name of the header
	Name *string `json:"name,omitempty"`
	// Value of the header
	Value *string `json:"value,omitempty"`
}

// DatasourceTypeParametersRequestMethodEnum - HTTP method to use to contact the URL.
type DatasourceTypeParametersRequestMethodEnum string

const (
	DatasourceTypeParametersRequestMethodEnumGet  DatasourceTypeParametersRequestMethodEnum = "GET"
	DatasourceTypeParametersRequestMethodEnumPost DatasourceTypeParametersRequestMethodEnum = "POST"
)

func (e *DatasourceTypeParametersRequestMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "GET":
		fallthrough
	case "POST":
		*e = DatasourceTypeParametersRequestMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DatasourceTypeParametersRequestMethodEnum: %s", s)
	}
}

// DatasourceTypeParametersRequestModeNameEnum - Node by node strategy
type DatasourceTypeParametersRequestModeNameEnum string

const (
	DatasourceTypeParametersRequestModeNameEnumByNode DatasourceTypeParametersRequestModeNameEnum = "byNode"
)

func (e *DatasourceTypeParametersRequestModeNameEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "byNode":
		*e = DatasourceTypeParametersRequestModeNameEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DatasourceTypeParametersRequestModeNameEnum: %s", s)
	}
}

// DatasourceTypeParametersRequestMode - Configure the strategy used to query the HTTP data source.
type DatasourceTypeParametersRequestMode struct {
	// Node by node strategy
	Name *DatasourceTypeParametersRequestModeNameEnum `json:"name,omitempty"`
}

// DatasourceTypeParameters - You can use Rudder variable expansion (`${rudder.node`, `${node.properties...}`)
type DatasourceTypeParameters struct {
	// Check SSL certificate validity for https. Must be set to false for self-signed certificate
	CheckSsl *bool `json:"checkSsl,omitempty"`
	// Represent HTTP headers for the query. Rudder expansion available.
	Headers []DatasourceTypeParametersHeaders `json:"headers,omitempty"`
	// JSON path (as defined in [the specification](https://github.com/jayway/JsonPath/), without the leading `$.`) to find the interesting sub-json or string/number/boolean value in the answer. Let empty to use the whole answer as value.
	Path *string `json:"path,omitempty"`
	// HTTP method to use to contact the URL.
	RequestMethod *DatasourceTypeParametersRequestMethodEnum `json:"requestMethod,omitempty"`
	// Configure the strategy used to query the HTTP data source.
	RequestMode *DatasourceTypeParametersRequestMode `json:"requestMode,omitempty"`
	// Timeout in seconds for each HTTP request
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// URL to contact. Rudder expansion available.
	URL *string `json:"url,omitempty"`
}

// DatasourceType - Define and configure data source type.
type DatasourceType struct {
	// Data source type name
	Name *DatasourceTypeNameEnum `json:"name,omitempty"`
	// You can use Rudder variable expansion (`${rudder.node`, `${node.properties...}`)
	Parameters *DatasourceTypeParameters `json:"parameters,omitempty"`
}

type Datasource struct {
	// Description of the goal of the data source to create.
	Description *string `json:"description,omitempty"`
	// Enable or disable data source.
	Enabled *bool `json:"enabled,omitempty"`
	// Unique identifier of the data source to create.
	ID *string `json:"id,omitempty"`
	// The human readable name of the data source to create.
	Name *string `json:"name,omitempty"`
	// Parameters to configure when the data source is fetched to update node properties.
	RunParameters *DatasourceRunParameters `json:"runParameters,omitempty"`
	// Define and configure data source type.
	Type *DatasourceType `json:"type,omitempty"`
	// Duration in seconds before aborting data source update. The main goal is to prevent never ending requests. If a periodicity if configured, you should set that timeout at a lower value.
	UpdateTimeout *int64 `json:"updateTimeout,omitempty"`
}
