// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

type UserSettingsSecurity struct {
	OAuth shared.SchemeOAuth `security:"scheme,type=oauth2"`
}

type UserSettingsPathParams struct {
	// The user ID or email address of the user. For user-level apps, pass `me` as the value for userId.
	UserID string `pathParam:"style=simple,explode=false,name=userId"`
}

// UserSettingsLoginTypeEnum - `0` - Facebook.<br>`1` - Google.<br>`99` - API.<br>`100` - Zoom.<br>`101` - SSO.
type UserSettingsLoginTypeEnum string

const (
	UserSettingsLoginTypeEnumZero             UserSettingsLoginTypeEnum = "0"
	UserSettingsLoginTypeEnumOne              UserSettingsLoginTypeEnum = "1"
	UserSettingsLoginTypeEnumNinetyNine       UserSettingsLoginTypeEnum = "99"
	UserSettingsLoginTypeEnumOneHundred       UserSettingsLoginTypeEnum = "100"
	UserSettingsLoginTypeEnumOneHundredAndOne UserSettingsLoginTypeEnum = "101"
)

func (e *UserSettingsLoginTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "1":
		fallthrough
	case "99":
		fallthrough
	case "100":
		fallthrough
	case "101":
		*e = UserSettingsLoginTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettingsLoginTypeEnum: %s", s)
	}
}

// UserSettingsOptionEnum - `meeting_authentication`: Use this query parameter to view [meeting authentication configuration](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) applied on the user's account.<br>`recording_authentication`: Use this query parameter to view [recording authentication configuration](https://support.zoom.us/hc/en-us/articles/360037756671-Authentication-Profiles-for-Cloud-Recordings) applied on the user's account.<br>
// `meeting_security`: Use this query parameter to view meeting security settings applied on the user's account.<br>
type UserSettingsOptionEnum string

const (
	UserSettingsOptionEnumMeetingAuthentication   UserSettingsOptionEnum = "meeting_authentication"
	UserSettingsOptionEnumRecordingAuthentication UserSettingsOptionEnum = "recording_authentication"
)

func (e *UserSettingsOptionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "meeting_authentication":
		fallthrough
	case "recording_authentication":
		*e = UserSettingsOptionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettingsOptionEnum: %s", s)
	}
}

type UserSettingsQueryParams struct {
	// Provide the name of the field by which you would like to filter the response. For example, if you provide "host_video" as the value of this field, you will get a response similar to the following:<br>
	// {
	//     "schedule_meeting": {
	//         "host_video": false
	//     }
	// }
	// <br>You can provide multiple values by separating them with commas(example: "host_video,participant_video”).
	CustomQueryFields *string `queryParam:"style=form,explode=true,name=custom_query_fields"`
	// `0` - Facebook.<br>`1` - Google.<br>`99` - API.<br>`100` - Zoom.<br>`101` - SSO.
	LoginType *UserSettingsLoginTypeEnum `queryParam:"style=form,explode=true,name=login_type"`
	// `meeting_authentication`: Use this query parameter to view [meeting authentication configuration](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) applied on the user's account.<br>`recording_authentication`: Use this query parameter to view [recording authentication configuration](https://support.zoom.us/hc/en-us/articles/360037756671-Authentication-Profiles-for-Cloud-Recordings) applied on the user's account.<br>
	// `meeting_security`: Use this query parameter to view meeting security settings applied on the user's account.<br>
	Option *UserSettingsOptionEnum `queryParam:"style=form,explode=true,name=option"`
}

type UserSettingsRequest struct {
	PathParams  UserSettingsPathParams
	QueryParams UserSettingsQueryParams
	Security    UserSettingsSecurity
}

// UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum - Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
//
// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
type UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum string

const (
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnumEnhancedEncryption UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum = "enhanced_encryption"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnumE2ee               UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum = "e2ee"
)

func (e *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "enhanced_encryption":
		fallthrough
	case "e2ee":
		*e = UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum string

const (
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumZero  UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "0"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumFour  UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "4"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumFive  UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "5"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumSix   UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "6"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumSeven UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "7"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumEight UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "8"
)

func (e *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "4":
		fallthrough
	case "5":
		fallthrough
	case "6":
		fallthrough
	case "7":
		fallthrough
	case "8":
		*e = UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum: %s", s)
	}
}

// UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement - Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
type UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement struct {
	ConsecutiveCharactersLength *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum
	// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
	//
	HaveLetter *bool
	// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
	HaveNumber *bool
	// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
	HaveSpecialCharacter *bool
	// If set to `true`, the passcode must include both uppercase and lowercase characters.
	HaveUpperAndLowerCharacters *bool
	// The minimum length that the meeting/webinar passcode needs to have.
	Length *int64
	// If set to `true`, the passcode must only contain numbers and no other characters.
	OnlyAllowNumeric *bool
	// If set to `true`, users will be informed if the provided passcode is weak.
	WeakEnhanceDetection *bool
}

// UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum -
//
// Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
// `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
type UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum string

const (
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnumZero UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum = "0"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnumOne  UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum = "1"
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnumTwo  UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum = "2"
)

func (e *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "1":
		fallthrough
	case "2":
		*e = UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum: %s", s)
	}
}

// UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings - Specify the settings to be applied if waiting room is enabled.
type UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings struct {
	//
	// Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
	// `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
	ParticipantsToPlaceInWaitingRoom *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum
	// Specify who can admit participants from the waiting room. The value of this field can be one of the following:<br>
	// `0`: Host and co-hosts only<br> `1`: Host, co-hosts, and anyone who bypassed the waiting room (only if host and co-hosts are not present).
	//
	//
	//
	UsersWhoCanAdmitParticipantsFromWaitingRoom *int64
	// If the value of the `participants_to_place_in_waiting_room` field is `2`, use this setting to specify the domains that can bypass the waiting room feature. Separate multiple domains with commas(example: "aaa.com,bbb.com").
	WhitelistedDomainsForWaitingRoom *string
}

type UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurity struct {
	// `true`: Require that all meetings are secured with at least one security option.
	//
	// This setting can only be disabled by Enterprise, ISV, Business (with more than 100 licenses), and Education accounts. [Learn more](https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#meeting-security).
	AutoSecurity *bool
	// If set to `true`, meeting passcode will be encrypted and included in the invite link to allow participants to join with just one click without having to enter the passcode.
	//
	EmbedPasswordInJoinLink *bool
	// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
	// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
	//
	// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
	EncryptionType *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum
	// Allow use of end-to-end encryption for meetings. If set to `true`, you can specify the encryption type in `encryption_type` field.
	EndToEndEncryptedMeetings *bool
	// If set to `true`, all instant, and scheduled meetings that users can join via client, or room systems will be passcode-protected. The Personal Meeting ID (PMI) meetings are not included in this setting.
	MeetingPassword *bool
	// Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
	MeetingPasswordRequirement *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement
	// Require passcode for participants joining by phone. If set to `true`, a numeric passcode will be required for participants joining by phone if your meeting has a passcode. For meeting with an alphanumeric passcode, a numeric version will be generated.
	PhonePassword *bool
	// If set to `true`, all Personal Meeting ID (PMI) meetings that users can join via client, or room systems will be passcode-protected.
	//
	PmiPassword *bool
	// Require a passcode for meetings which have already been scheduled.
	//
	RequirePasswordForScheduledMeeting *bool
	// Require a passcode for webinars which have already been scheduled.
	//
	RequirePasswordForScheduledWebinar *bool
	// When participants join a meeting, place them in a waiting room and require the host to admit them individually. Enabling the waiting room automatically disables the setting for allowing participants to join before host.
	//
	WaitingRoom *bool
	// Specify the settings to be applied if waiting room is enabled.
	WaitingRoomSettings *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings
	// If set to `true`, a passcode will be generated when scheduling a Webinar and participants require the passcode to join the Webinar.
	//
	WebinarPassword *bool
}

type UserSettings200ApplicationXMLMeetingWebinarSecuritySettings struct {
	MeetingSecurity *UserSettings200ApplicationXMLMeetingWebinarSecuritySettingsMeetingSecurity
}

// UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum - Authentication type
type UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum string

const (
	UserSettings200ApplicationXML22AuthenticationOptionsTypeEnumInternally              UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum = "internally"
	UserSettings200ApplicationXML22AuthenticationOptionsTypeEnumEnforceLogin            UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum = "enforce_login"
	UserSettings200ApplicationXML22AuthenticationOptionsTypeEnumEnforceLoginWithDomains UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum = "enforce_login_with_domains"
)

func (e *UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "internally":
		fallthrough
	case "enforce_login":
		fallthrough
	case "enforce_login_with_domains":
		*e = UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationXML22AuthenticationOptions struct {
	// Authentication default option
	DefaultOption *bool
	// Authentication domians
	Domains *string
	// Authentication id
	ID *string
	// Authentication name
	Name *string
	// Authentication type
	Type *UserSettings200ApplicationXML22AuthenticationOptionsTypeEnum
	// Authentication visible
	Visible *bool
}

type UserSettings200ApplicationXML22 struct {
	// Authentication Options
	AuthenticationOptions []UserSettings200ApplicationXML22AuthenticationOptions
	// Only authenticated users can view cloud recordings
	RecordingAuthentication *bool
}

// UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum -  Authentication type. Specify one of the following authentication types for the authentication profile:<br>
//   - `enforce_login`: This option allows any users to join the meeting or webinar, as long as they are signed into their Zoom account.
//   - `enforce_login_with_domains`: This option, allows you to specify a rule so that only those Zoom users whose email addresses contain a certain domain, can join the meeting or webinar. You can either add multiple domains using a comma in between and/or use a wildcard for listing domains.<br>
//   - `enforce_login_with_same_account`: This option allows users to join the meeting or webinar with the same Zoom account.
type UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum string

const (
	UserSettings200ApplicationXML21AuthenticationOptionsTypeEnumEnforceLogin                UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum = "enforce_login"
	UserSettings200ApplicationXML21AuthenticationOptionsTypeEnumEnforceLoginWithSameAccount UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum = "enforce_login_with_same_account"
	UserSettings200ApplicationXML21AuthenticationOptionsTypeEnumEnforceLoginWithDomains     UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum = "enforce_login_with_domains"
)

func (e *UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "enforce_login":
		fallthrough
	case "enforce_login_with_same_account":
		fallthrough
	case "enforce_login_with_domains":
		*e = UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationXML21AuthenticationOptions struct {
	// Authentication default option
	DefaultOption *bool
	// Authentication domains
	Domains *string
	// Authentication id
	ID *string
	// Authentication name
	Name *string
	//  Authentication type. Specify one of the following authentication types for the authentication profile:<br>
	//  * `enforce_login`: This option allows any users to join the meeting or webinar, as long as they are signed into their Zoom account.
	//  * `enforce_login_with_domains`: This option, allows you to specify a rule so that only those Zoom users whose email addresses contain a certain domain, can join the meeting or webinar. You can either add multiple domains using a comma in between and/or use a wildcard for listing domains.<br>
	//  * `enforce_login_with_same_account`: This option allows users to join the meeting or webinar with the same Zoom account.
	Type *UserSettings200ApplicationXML21AuthenticationOptionsTypeEnum
	// Authentication visible
	Visible *bool
}

type UserSettings200ApplicationXML21 struct {
	// Meeting Authentication Options
	AuthenticationOptions []UserSettings200ApplicationXML21AuthenticationOptions
	// Only authenticated users can join meetings
	MeetingAuthentication *bool
}

type UserSettings200ApplicationXML2Type string

const (
	UserSettings200ApplicationXML2TypeUserSettings200ApplicationXML21 UserSettings200ApplicationXML2Type = "userSettings_200ApplicationXML_2_1"
	UserSettings200ApplicationXML2TypeUserSettings200ApplicationXML22 UserSettings200ApplicationXML2Type = "userSettings_200ApplicationXML_2_2"
)

type UserSettings200ApplicationXML2 struct {
	UserSettings200ApplicationXML21 *UserSettings200ApplicationXML21
	UserSettings200ApplicationXML22 *UserSettings200ApplicationXML22

	Type UserSettings200ApplicationXML2Type
}

func CreateUserSettings200ApplicationXML2UserSettings200ApplicationXML21(userSettings200ApplicationXML21 UserSettings200ApplicationXML21) UserSettings200ApplicationXML2 {
	typ := UserSettings200ApplicationXML2TypeUserSettings200ApplicationXML21

	return UserSettings200ApplicationXML2{
		UserSettings200ApplicationXML21: &userSettings200ApplicationXML21,
		Type:                            typ,
	}
}

func CreateUserSettings200ApplicationXML2UserSettings200ApplicationXML22(userSettings200ApplicationXML22 UserSettings200ApplicationXML22) UserSettings200ApplicationXML2 {
	typ := UserSettings200ApplicationXML2TypeUserSettings200ApplicationXML22

	return UserSettings200ApplicationXML2{
		UserSettings200ApplicationXML22: &userSettings200ApplicationXML22,
		Type:                            typ,
	}
}

func (u *UserSettings200ApplicationXML2) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	userSettings200ApplicationXML21 := new(UserSettings200ApplicationXML21)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationXML21); err == nil {
		u.UserSettings200ApplicationXML21 = userSettings200ApplicationXML21
		u.Type = UserSettings200ApplicationXML2TypeUserSettings200ApplicationXML21
		return nil
	}

	userSettings200ApplicationXML22 := new(UserSettings200ApplicationXML22)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationXML22); err == nil {
		u.UserSettings200ApplicationXML22 = userSettings200ApplicationXML22
		u.Type = UserSettings200ApplicationXML2TypeUserSettings200ApplicationXML22
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UserSettings200ApplicationXML2) MarshalJSON() ([]byte, error) {
	if u.UserSettings200ApplicationXML21 != nil {
		return json.Marshal(u.UserSettings200ApplicationXML21)
	}

	if u.UserSettings200ApplicationXML22 != nil {
		return json.Marshal(u.UserSettings200ApplicationXML22)
	}

	return nil, nil
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsNotificationSettings struct {
	// When an alternative host is set or removed from a meeting.
	AlternativeHostReminder *bool
	// When a meeting is cancelled.
	CancelMeetingReminder *bool
	// When attendees join meeting before host.
	JbhReminder *bool
	// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
	ScheduleForReminder *bool
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsFeatureSettings struct {
	// Host meeting in China.
	CnMeeting *bool
	// Host meeting in India.
	InMeeting *bool
	// Large meeting feature.
	LargeMeeting *bool
	// Large meeting capacity: can be 500 or 1000, depending on if the user has a large meeting capacity plan subscription or not.
	LargeMeetingCapacity *int64
	// User’s meeting capacity.
	MeetingCapacity *int64
	// Webinar feature.
	Webinar *bool
	// Webinar capacity: can be 100, 500, 1000, 3000, 5000 or 10000, depending on if the user has a webinar capacity plan subscription or not.
	WebinarCapacity *int64
	// Zoom phone feature.
	ZoomPhone *bool
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum - If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumHk UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "HK"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumAu UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "AU"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumIn UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "IN"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumTy UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "TY"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumCn UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "CN"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumUs UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "US"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumCa UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "CA"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumDe UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "DE"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumNl UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "NL"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumLa UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "LA"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "HK":
		fallthrough
	case "AU":
		fallthrough
	case "IN":
		fallthrough
	case "TY":
		fallthrough
	case "CN":
		fallthrough
	case "US":
		fallthrough
	case "CA":
		fallthrough
	case "DE":
		fallthrough
	case "NL":
		fallthrough
	case "LA":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum: %s", s)
	}
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum - Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnumHost UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum = "host"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnumAll  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum = "all"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnumNone UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum = "none"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "host":
		fallthrough
	case "all":
		fallthrough
	case "none":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum: %s", s)
	}
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettingsFiles struct {
	// Unique identifier of the file.
	ID *string
	// Indicates whether or not this file is the default virtual background file.
	IsDefault *bool
	// File name.
	Name *string
	// File size.
	Size *string
	// File type.
	Type *string
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings - Settings to manage virtual background.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings struct {
	// Allow user to upload custom backgrounds.
	AllowUploadCustom *bool
	// Allow use of videos for virtual backgrounds.
	AllowVideos *bool
	// Enable virtual background.
	Enable *bool
	Files  []UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettingsFiles
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum - Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
// `host`: Only host can share the screen.<br>
// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnumHost UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum = "host"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnumAll  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum = "all"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "host":
		fallthrough
	case "all":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum: %s", s)
	}
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum - Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
// `host`: Only a host can share the screen when someone else is sharing.<br>
// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnumHost UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum = "host"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnumAll  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum = "all"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "host":
		fallthrough
	case "all":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum: %s", s)
	}
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettings struct {
	// Allow live streaming.
	AllowLiveStreaming *bool
	// Allow participants to use annotation tools.
	Annotation *bool
	// Allow host to put attendee on hold.
	//
	// **This field has been deprecated and is no longer supported.**
	AttendeeOnHold *bool
	// Auto save all in-meeting chats.
	AutoSavingChat *bool
	// Allow host to split meeting participants into separate breakout rooms.
	BreakoutRoom *bool
	// Enable chat during meeting for all participants.
	Chat *bool
	// Enable closed captions.
	ClosedCaption *bool
	// Allow the host to add co-hosts.
	CoHost *bool
	// If set to `true`, you can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting your real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
	CustomDataCenterRegions *bool
	// Allow custom live streaming.
	CustomLiveStreamingService *bool
	// Custom service instructions.
	CustomServiceInstructions *string
	// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
	//
	DataCenterRegions *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum
	// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
	E2eEncryption *bool
	// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
	EntryExitChime *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum
	// Allow another user to take control of the camera.
	FarEndCameraControl *bool
	// Enable option to send feedback to Zoom at the end of the meeting.
	Feedback *bool
	// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not.
	FileTransfer *bool
	// Enable group HD video.
	GroupHd *bool
	// Enable non-verbal feedback through screens.
	NonVerbalFeedback *bool
	// Add polls to the meeting controls.
	Polling *bool
	// Enable 1:1 private chat between participants during meetings.
	PrivateChat *bool
	// Record and play their own voice.
	RecordPlayVoice *bool
	// Enable remote control during screensharing.
	RemoteControl *bool
	// Allow host to provide 1:1 remote support to a participant.
	RemoteSupport *bool
	// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not.
	RequestPermissionToUnmute *bool
	// Allow host and participants to share their screen or content during meetings
	//
	ScreenSharing *bool
	// Share dual camera (deprecated).
	ShareDualCamera *bool
	// Always show meeting controls during a meeting.
	ShowMeetingControlToolbar *bool
	// Enable virtual background.
	VirtualBackground *bool
	// Settings to manage virtual background.
	VirtualBackgroundSettings *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings
	// Enable Waiting room - if enabled, attendees can only join after host approves.
	WaitingRoom *bool
	// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
	// `host`: Only host can share the screen.<br>
	// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
	//
	WhoCanShareScreen *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum
	// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
	// `host`: Only a host can share the screen when someone else is sharing.<br>
	// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
	//
	WhoCanShareScreenWhenSomeoneIsSharing *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum
	// Allow livestreaming by host through Workplace by Facebook.
	WorkplaceByFacebook *bool
}

type UserSettings200ApplicationXMLUserSettingsProfileRecordingStorageLocation struct {
	// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
	//
	// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
	AllowedValues []string
	// Abbreviated country code.
	Value *string
}

type UserSettings200ApplicationXMLUserSettingsProfile struct {
	RecordingStorageLocation *UserSettings200ApplicationXMLUserSettingsProfileRecordingStorageLocation
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum - Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
type UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnumLocal UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum = "local"
	UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnumCloud UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum = "cloud"
	UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnumNone  UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum = "none"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "local":
		fallthrough
	case "cloud":
		fallthrough
	case "none":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum: %s", s)
	}
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl - Setting to allow cloud recording access only from specific IP address ranges.
type UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl struct {
	// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
	//
	//
	Enable *bool
	// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
	//
	// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
	//
	//
	IPAddressesOrRanges *string
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement - This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
type UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement struct {
	// Indicates whether or not passcode must contain at least one alphabetical letter (a, b, c..).
	HaveLetter *bool
	// Indicates whether or not passcode must contain at least one number(1, 2, 3..).
	HaveNumber *bool
	// Indicates whether or not passcode must contain at least one special character(!, @, #..).
	HaveSpecialCharacter *bool
	// Minimum required length for the passcode.
	Length *int64
	// Indicates whether or not passcode must contain only numeric characters.
	OnlyAllowNumeric *bool
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettings struct {
	// Ask host to confirm the disclaimer.
	AskHostToConfirmDisclaimer *bool
	// This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:<br>
	// * `true`: Ask participants for consent when a recording starts. <br>
	// * `false`: Do not ask participants for consent when a recording starts.
	AskParticipantsToConsentDisclaimer *bool
	// Auto delete cloud recordings.
	AutoDeleteCmr *bool
	// A specified number of days of auto delete cloud recordings.
	AutoDeleteCmrDays *int64
	// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
	AutoRecording *UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum
	// Cloud recording.
	CloudRecording *bool
	// Host can pause/stop the auto recording in the cloud.
	HostPauseStopRecording *bool
	// Setting to allow cloud recording access only from specific IP address ranges.
	//
	IPAddressAccessControl *UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl
	// Local recording.
	LocalRecording *bool
	// Record an audio only file.
	RecordAudioFile *bool
	// Record the gallery view.
	RecordGalleryView *bool
	// Record the active speaker view.
	RecordSpeakerView *bool
	// Audio transcript.
	RecordingAudioTranscript *bool
	// Show a disclaimer to participants before a recording starts
	//
	RecordingDisclaimer *bool
	// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
	RecordingPasswordRequirement *UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement
	// Save chat text from the meeting.
	SaveChatText *bool
	// Show timestamp on video.
	ShowTimestamp *bool
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum - Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnumBoth       UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "both"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnumTelephony  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "telephony"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnumVoip       UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "voip"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnumThirdParty UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "thirdParty"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "both":
		fallthrough
	case "telephony":
		fallthrough
	case "voip":
		fallthrough
	case "thirdParty":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumZero  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "0"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumFour  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "4"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumFive  UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "5"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumSix   UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "6"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumSeven UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "7"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumEight UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "8"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "4":
		fallthrough
	case "5":
		fallthrough
	case "6":
		fallthrough
	case "7":
		fallthrough
	case "8":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum: %s", s)
	}
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement - Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement struct {
	ConsecutiveCharactersLength *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum
	// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
	//
	HaveLetter *bool
	// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
	HaveNumber *bool
	// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
	HaveSpecialCharacter *bool
	// If set to `true`, the passcode must include both uppercase and lowercase characters.
	HaveUpperAndLowerCharacters *bool
	// The minimum length that the meeting/webinar passcode needs to have.
	Length *int64
	// If set to `true`, the passcode must only contain numbers and no other characters.
	OnlyAllowNumeric *bool
	// If set to `true`, users will be informed if the provided passcode is weak.
	WeakEnhanceDetection *bool
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum - Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum string

const (
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnumJbhOnly UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum = "jbh_only"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnumAll     UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum = "all"
	UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnumNone    UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum = "none"
)

func (e *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "jbh_only":
		fallthrough
	case "all":
		fallthrough
	case "none":
		*e = UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum: %s", s)
	}
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettings1 struct {
	// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
	AudioType *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsAudioTypeEnum
	// Passcode for already scheduled meetings
	//
	DefaultPasswordForScheduledMeetings *string
	// If the value is set to `true`, the meeting passcode will be encrypted and included in the join meeting link to allow participants to join with just one click without having to enter the passcode.
	//
	EmbedPasswordInJoinLink *bool
	// Require a passcode for personal meetings if attendees can join before host.
	ForcePmiJbhPassword *bool
	// Start meetings with host video on.
	HostVideo *bool
	// Join the meeting before host arrives.
	JoinBeforeHost *bool
	// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
	MeetingPasswordRequirement *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement
	// Start meetings with participants video on.
	ParticipantsVideo *bool
	// Personal Meeting Setting.<br><br>
	// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
	// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
	// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
	//
	//
	//
	PersonalMeeting *bool
	// PMI passcode
	//
	PmiPassword *string
	// Generate and require passcode for participants joining by phone.
	PstnPasswordProtected *bool
	// Require a passcode for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
	//
	RequirePasswordForInstantMeetings *bool
	// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
	//
	RequirePasswordForPmiMeetings *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum
	// Require a passcode for meetings which have already been scheduled
	//
	RequirePasswordForScheduledMeetings *bool
	// Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
	//
	RequirePasswordForSchedulingNewMeetings *bool
	// Use Personal Meeting ID (PMI) when starting an instant meeting
	//
	UsePmiForInstantMeetings *bool
	// Use Personal Meeting ID (PMI) when scheduling a meeting
	//
	UsePmiForScheduledMeetings *bool
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsTelephonyRegions - Indicates where most of the participants call into or call from duriing a meeting.
type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsTelephonyRegions struct {
	// Telephony region options provided by Zoom to select from.
	AllowedValues []string
	// Telephony regions selected by the account to indicate where most of the participants call into or call from during a meeting.
	SelectionValues []string
}

type UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettings2 struct {
	// Third party audio conference info.
	AudioConferenceInfo *string
	// Show the international numbers link on the invitation email.
	ShowInternationalNumbersLink *bool
	// Indicates where most of the participants call into or call from duriing a meeting.
	TelephonyRegions *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettingsTelephonyRegions
	// Third party audio conference.
	ThirdPartyAudio *bool
}

// UserSettings200ApplicationXMLUserSettingsUserSettingsTSPSettings - Account Settings: TSP.
type UserSettings200ApplicationXMLUserSettingsUserSettingsTSPSettings struct {
	// Call Out
	CallOut *bool
	// Call Out Countries/Regions
	CallOutCountries []interface{}
	// Show international numbers link on the invitation email
	ShowInternationalNumbersLink *bool
}

type UserSettings200ApplicationXMLUserSettings struct {
	EmailNotification *UserSettings200ApplicationXMLUserSettingsUserSettingsNotificationSettings
	Feature           *UserSettings200ApplicationXMLUserSettingsUserSettingsFeatureSettings
	InMeeting         *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettings
	Profile           *UserSettings200ApplicationXMLUserSettingsProfile
	Recording         *UserSettings200ApplicationXMLUserSettingsUserSettingsRecordingSettings
	ScheduleMeeting   *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettings1
	Telephony         *UserSettings200ApplicationXMLUserSettingsUserSettingsMeetingSettings2
	// Account Settings: TSP.
	Tsp *UserSettings200ApplicationXMLUserSettingsUserSettingsTSPSettings
}

type UserSettings200ApplicationXMLType string

const (
	UserSettings200ApplicationXMLTypeUserSettings200ApplicationXMLUserSettings                   UserSettings200ApplicationXMLType = "userSettings_200ApplicationXML_User settings"
	UserSettings200ApplicationXMLTypeUserSettings200ApplicationXML2                              UserSettings200ApplicationXMLType = "userSettings_200ApplicationXML_2"
	UserSettings200ApplicationXMLTypeUserSettings200ApplicationXMLMeetingWebinarSecuritySettings UserSettings200ApplicationXMLType = "userSettings_200ApplicationXML_Meeting/Webinar Security Settings"
)

type UserSettings200ApplicationXML struct {
	UserSettings200ApplicationXMLUserSettings                   *UserSettings200ApplicationXMLUserSettings
	UserSettings200ApplicationXML2                              *UserSettings200ApplicationXML2
	UserSettings200ApplicationXMLMeetingWebinarSecuritySettings *UserSettings200ApplicationXMLMeetingWebinarSecuritySettings

	Type UserSettings200ApplicationXMLType
}

func CreateUserSettings200ApplicationXMLUserSettings200ApplicationXMLUserSettings(userSettings200ApplicationXMLUserSettings UserSettings200ApplicationXMLUserSettings) UserSettings200ApplicationXML {
	typ := UserSettings200ApplicationXMLTypeUserSettings200ApplicationXMLUserSettings

	return UserSettings200ApplicationXML{
		UserSettings200ApplicationXMLUserSettings: &userSettings200ApplicationXMLUserSettings,
		Type: typ,
	}
}

func CreateUserSettings200ApplicationXMLUserSettings200ApplicationXML2(userSettings200ApplicationXML2 UserSettings200ApplicationXML2) UserSettings200ApplicationXML {
	typ := UserSettings200ApplicationXMLTypeUserSettings200ApplicationXML2

	return UserSettings200ApplicationXML{
		UserSettings200ApplicationXML2: &userSettings200ApplicationXML2,
		Type:                           typ,
	}
}

func CreateUserSettings200ApplicationXMLUserSettings200ApplicationXMLMeetingWebinarSecuritySettings(userSettings200ApplicationXMLMeetingWebinarSecuritySettings UserSettings200ApplicationXMLMeetingWebinarSecuritySettings) UserSettings200ApplicationXML {
	typ := UserSettings200ApplicationXMLTypeUserSettings200ApplicationXMLMeetingWebinarSecuritySettings

	return UserSettings200ApplicationXML{
		UserSettings200ApplicationXMLMeetingWebinarSecuritySettings: &userSettings200ApplicationXMLMeetingWebinarSecuritySettings,
		Type: typ,
	}
}

func (u *UserSettings200ApplicationXML) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	userSettings200ApplicationXMLUserSettings := new(UserSettings200ApplicationXMLUserSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationXMLUserSettings); err == nil {
		u.UserSettings200ApplicationXMLUserSettings = userSettings200ApplicationXMLUserSettings
		u.Type = UserSettings200ApplicationXMLTypeUserSettings200ApplicationXMLUserSettings
		return nil
	}

	userSettings200ApplicationXML2 := new(UserSettings200ApplicationXML2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationXML2); err == nil {
		u.UserSettings200ApplicationXML2 = userSettings200ApplicationXML2
		u.Type = UserSettings200ApplicationXMLTypeUserSettings200ApplicationXML2
		return nil
	}

	userSettings200ApplicationXMLMeetingWebinarSecuritySettings := new(UserSettings200ApplicationXMLMeetingWebinarSecuritySettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationXMLMeetingWebinarSecuritySettings); err == nil {
		u.UserSettings200ApplicationXMLMeetingWebinarSecuritySettings = userSettings200ApplicationXMLMeetingWebinarSecuritySettings
		u.Type = UserSettings200ApplicationXMLTypeUserSettings200ApplicationXMLMeetingWebinarSecuritySettings
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UserSettings200ApplicationXML) MarshalJSON() ([]byte, error) {
	if u.UserSettings200ApplicationXMLUserSettings != nil {
		return json.Marshal(u.UserSettings200ApplicationXMLUserSettings)
	}

	if u.UserSettings200ApplicationXML2 != nil {
		return json.Marshal(u.UserSettings200ApplicationXML2)
	}

	if u.UserSettings200ApplicationXMLMeetingWebinarSecuritySettings != nil {
		return json.Marshal(u.UserSettings200ApplicationXMLMeetingWebinarSecuritySettings)
	}

	return nil, nil
}

// UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum - Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
//
// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
type UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum string

const (
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnumEnhancedEncryption UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum = "enhanced_encryption"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnumE2ee               UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum = "e2ee"
)

func (e *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "enhanced_encryption":
		fallthrough
	case "e2ee":
		*e = UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum string

const (
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumZero  UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "0"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumFour  UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "4"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumFive  UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "5"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumSix   UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "6"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumSeven UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "7"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnumEight UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "8"
)

func (e *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "4":
		fallthrough
	case "5":
		fallthrough
	case "6":
		fallthrough
	case "7":
		fallthrough
	case "8":
		*e = UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum: %s", s)
	}
}

// UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement - Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
type UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement struct {
	ConsecutiveCharactersLength *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum `json:"consecutive_characters_length,omitempty"`
	// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
	//
	HaveLetter *bool `json:"have_letter,omitempty"`
	// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
	HaveNumber *bool `json:"have_number,omitempty"`
	// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
	HaveSpecialCharacter *bool `json:"have_special_character,omitempty"`
	// If set to `true`, the passcode must include both uppercase and lowercase characters.
	HaveUpperAndLowerCharacters *bool `json:"have_upper_and_lower_characters,omitempty"`
	// The minimum length that the meeting/webinar passcode needs to have.
	Length *int64 `json:"length,omitempty"`
	// If set to `true`, the passcode must only contain numbers and no other characters.
	OnlyAllowNumeric *bool `json:"only_allow_numeric,omitempty"`
	// If set to `true`, users will be informed if the provided passcode is weak.
	WeakEnhanceDetection *bool `json:"weak_enhance_detection,omitempty"`
}

// UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum -
//
// Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
// `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
type UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum string

const (
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnumZero UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum = "0"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnumOne  UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum = "1"
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnumTwo  UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum = "2"
)

func (e *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "1":
		fallthrough
	case "2":
		*e = UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum: %s", s)
	}
}

// UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings - Specify the settings to be applied if waiting room is enabled.
type UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings struct {
	//
	// Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
	// `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
	ParticipantsToPlaceInWaitingRoom *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum `json:"participants_to_place_in_waiting_room,omitempty"`
	// Specify who can admit participants from the waiting room. The value of this field can be one of the following:<br>
	// `0`: Host and co-hosts only<br> `1`: Host, co-hosts, and anyone who bypassed the waiting room (only if host and co-hosts are not present).
	//
	//
	//
	UsersWhoCanAdmitParticipantsFromWaitingRoom *int64 `json:"users_who_can_admit_participants_from_waiting_room,omitempty"`
	// If the value of the `participants_to_place_in_waiting_room` field is `2`, use this setting to specify the domains that can bypass the waiting room feature. Separate multiple domains with commas(example: "aaa.com,bbb.com").
	WhitelistedDomainsForWaitingRoom *string `json:"whitelisted_domains_for_waiting_room,omitempty"`
}

type UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurity struct {
	// `true`: Require that all meetings are secured with at least one security option.
	//
	// This setting can only be disabled by Enterprise, ISV, Business (with more than 100 licenses), and Education accounts. [Learn more](https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#meeting-security).
	AutoSecurity *bool `json:"auto_security,omitempty"`
	// If set to `true`, meeting passcode will be encrypted and included in the invite link to allow participants to join with just one click without having to enter the passcode.
	//
	EmbedPasswordInJoinLink *bool `json:"embed_password_in_join_link,omitempty"`
	// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
	// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
	//
	// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
	EncryptionType *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum `json:"encryption_type,omitempty"`
	// Allow use of end-to-end encryption for meetings. If set to `true`, you can specify the encryption type in `encryption_type` field.
	EndToEndEncryptedMeetings *bool `json:"end_to_end_encrypted_meetings,omitempty"`
	// If set to `true`, all instant, and scheduled meetings that users can join via client, or room systems will be passcode-protected. The Personal Meeting ID (PMI) meetings are not included in this setting.
	MeetingPassword *bool `json:"meeting_password,omitempty"`
	// Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
	MeetingPasswordRequirement *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement `json:"meeting_password_requirement,omitempty"`
	// Require passcode for participants joining by phone. If set to `true`, a numeric passcode will be required for participants joining by phone if your meeting has a passcode. For meeting with an alphanumeric passcode, a numeric version will be generated.
	PhonePassword *bool `json:"phone_password,omitempty"`
	// If set to `true`, all Personal Meeting ID (PMI) meetings that users can join via client, or room systems will be passcode-protected.
	//
	PmiPassword *bool `json:"pmi_password,omitempty"`
	// Require a passcode for meetings which have already been scheduled.
	//
	RequirePasswordForScheduledMeeting *bool `json:"require_password_for_scheduled_meeting,omitempty"`
	// Require a passcode for webinars which have already been scheduled.
	//
	RequirePasswordForScheduledWebinar *bool `json:"require_password_for_scheduled_webinar,omitempty"`
	// When participants join a meeting, place them in a waiting room and require the host to admit them individually. Enabling the waiting room automatically disables the setting for allowing participants to join before host.
	//
	WaitingRoom *bool `json:"waiting_room,omitempty"`
	// Specify the settings to be applied if waiting room is enabled.
	WaitingRoomSettings *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings `json:"waiting_room_settings,omitempty"`
	// If set to `true`, a passcode will be generated when scheduling a Webinar and participants require the passcode to join the Webinar.
	//
	WebinarPassword *bool `json:"webinar_password,omitempty"`
}

type UserSettings200ApplicationJSONMeetingWebinarSecuritySettings struct {
	MeetingSecurity *UserSettings200ApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurity `json:"meeting_security,omitempty"`
}

// UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum - Authentication type
type UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum string

const (
	UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnumInternally              UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum = "internally"
	UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnumEnforceLogin            UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum = "enforce_login"
	UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnumEnforceLoginWithDomains UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum = "enforce_login_with_domains"
)

func (e *UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "internally":
		fallthrough
	case "enforce_login":
		fallthrough
	case "enforce_login_with_domains":
		*e = UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationJSON22AuthenticationOptions struct {
	// Authentication default option
	DefaultOption *bool `json:"default_option,omitempty"`
	// Authentication domians
	Domains *string `json:"domains,omitempty"`
	// Authentication id
	ID *string `json:"id,omitempty"`
	// Authentication name
	Name *string `json:"name,omitempty"`
	// Authentication type
	Type *UserSettings200ApplicationJSON22AuthenticationOptionsTypeEnum `json:"type,omitempty"`
	// Authentication visible
	Visible *bool `json:"visible,omitempty"`
}

type UserSettings200ApplicationJSON22 struct {
	// Authentication Options
	AuthenticationOptions []UserSettings200ApplicationJSON22AuthenticationOptions `json:"authentication_options,omitempty"`
	// Only authenticated users can view cloud recordings
	RecordingAuthentication *bool `json:"recording_authentication,omitempty"`
}

// UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum -  Authentication type. Specify one of the following authentication types for the authentication profile:<br>
//   - `enforce_login`: This option allows any users to join the meeting or webinar, as long as they are signed into their Zoom account.
//   - `enforce_login_with_domains`: This option, allows you to specify a rule so that only those Zoom users whose email addresses contain a certain domain, can join the meeting or webinar. You can either add multiple domains using a comma in between and/or use a wildcard for listing domains.<br>
//   - `enforce_login_with_same_account`: This option allows users to join the meeting or webinar with the same Zoom account.
type UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum string

const (
	UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnumEnforceLogin                UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum = "enforce_login"
	UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnumEnforceLoginWithSameAccount UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum = "enforce_login_with_same_account"
	UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnumEnforceLoginWithDomains     UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum = "enforce_login_with_domains"
)

func (e *UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "enforce_login":
		fallthrough
	case "enforce_login_with_same_account":
		fallthrough
	case "enforce_login_with_domains":
		*e = UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationJSON21AuthenticationOptions struct {
	// Authentication default option
	DefaultOption *bool `json:"default_option,omitempty"`
	// Authentication domains
	Domains *string `json:"domains,omitempty"`
	// Authentication id
	ID *string `json:"id,omitempty"`
	// Authentication name
	Name *string `json:"name,omitempty"`
	//  Authentication type. Specify one of the following authentication types for the authentication profile:<br>
	//  * `enforce_login`: This option allows any users to join the meeting or webinar, as long as they are signed into their Zoom account.
	//  * `enforce_login_with_domains`: This option, allows you to specify a rule so that only those Zoom users whose email addresses contain a certain domain, can join the meeting or webinar. You can either add multiple domains using a comma in between and/or use a wildcard for listing domains.<br>
	//  * `enforce_login_with_same_account`: This option allows users to join the meeting or webinar with the same Zoom account.
	Type *UserSettings200ApplicationJSON21AuthenticationOptionsTypeEnum `json:"type,omitempty"`
	// Authentication visible
	Visible *bool `json:"visible,omitempty"`
}

type UserSettings200ApplicationJSON21 struct {
	// Meeting Authentication Options
	AuthenticationOptions []UserSettings200ApplicationJSON21AuthenticationOptions `json:"authentication_options,omitempty"`
	// Only authenticated users can join meetings
	MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`
}

type UserSettings200ApplicationJSON2Type string

const (
	UserSettings200ApplicationJSON2TypeUserSettings200ApplicationJSON21 UserSettings200ApplicationJSON2Type = "userSettings_200ApplicationJSON_2_1"
	UserSettings200ApplicationJSON2TypeUserSettings200ApplicationJSON22 UserSettings200ApplicationJSON2Type = "userSettings_200ApplicationJSON_2_2"
)

type UserSettings200ApplicationJSON2 struct {
	UserSettings200ApplicationJSON21 *UserSettings200ApplicationJSON21
	UserSettings200ApplicationJSON22 *UserSettings200ApplicationJSON22

	Type UserSettings200ApplicationJSON2Type
}

func CreateUserSettings200ApplicationJSON2UserSettings200ApplicationJSON21(userSettings200ApplicationJSON21 UserSettings200ApplicationJSON21) UserSettings200ApplicationJSON2 {
	typ := UserSettings200ApplicationJSON2TypeUserSettings200ApplicationJSON21

	return UserSettings200ApplicationJSON2{
		UserSettings200ApplicationJSON21: &userSettings200ApplicationJSON21,
		Type:                             typ,
	}
}

func CreateUserSettings200ApplicationJSON2UserSettings200ApplicationJSON22(userSettings200ApplicationJSON22 UserSettings200ApplicationJSON22) UserSettings200ApplicationJSON2 {
	typ := UserSettings200ApplicationJSON2TypeUserSettings200ApplicationJSON22

	return UserSettings200ApplicationJSON2{
		UserSettings200ApplicationJSON22: &userSettings200ApplicationJSON22,
		Type:                             typ,
	}
}

func (u *UserSettings200ApplicationJSON2) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	userSettings200ApplicationJSON21 := new(UserSettings200ApplicationJSON21)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationJSON21); err == nil {
		u.UserSettings200ApplicationJSON21 = userSettings200ApplicationJSON21
		u.Type = UserSettings200ApplicationJSON2TypeUserSettings200ApplicationJSON21
		return nil
	}

	userSettings200ApplicationJSON22 := new(UserSettings200ApplicationJSON22)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationJSON22); err == nil {
		u.UserSettings200ApplicationJSON22 = userSettings200ApplicationJSON22
		u.Type = UserSettings200ApplicationJSON2TypeUserSettings200ApplicationJSON22
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UserSettings200ApplicationJSON2) MarshalJSON() ([]byte, error) {
	if u.UserSettings200ApplicationJSON21 != nil {
		return json.Marshal(u.UserSettings200ApplicationJSON21)
	}

	if u.UserSettings200ApplicationJSON22 != nil {
		return json.Marshal(u.UserSettings200ApplicationJSON22)
	}

	return nil, nil
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsNotificationSettings struct {
	// When an alternative host is set or removed from a meeting.
	AlternativeHostReminder *bool `json:"alternative_host_reminder,omitempty"`
	// When a meeting is cancelled.
	CancelMeetingReminder *bool `json:"cancel_meeting_reminder,omitempty"`
	// When attendees join meeting before host.
	JbhReminder *bool `json:"jbh_reminder,omitempty"`
	// Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
	ScheduleForReminder *bool `json:"schedule_for_reminder,omitempty"`
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsFeatureSettings struct {
	// Host meeting in China.
	CnMeeting *bool `json:"cn_meeting,omitempty"`
	// Host meeting in India.
	InMeeting *bool `json:"in_meeting,omitempty"`
	// Large meeting feature.
	LargeMeeting *bool `json:"large_meeting,omitempty"`
	// Large meeting capacity: can be 500 or 1000, depending on if the user has a large meeting capacity plan subscription or not.
	LargeMeetingCapacity *int64 `json:"large_meeting_capacity,omitempty"`
	// User’s meeting capacity.
	MeetingCapacity *int64 `json:"meeting_capacity,omitempty"`
	// Webinar feature.
	Webinar *bool `json:"webinar,omitempty"`
	// Webinar capacity: can be 100, 500, 1000, 3000, 5000 or 10000, depending on if the user has a webinar capacity plan subscription or not.
	WebinarCapacity *int64 `json:"webinar_capacity,omitempty"`
	// Zoom phone feature.
	ZoomPhone *bool `json:"zoom_phone,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum - If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumHk UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "HK"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumAu UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "AU"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumIn UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "IN"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumTy UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "TY"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumCn UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "CN"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumUs UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "US"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumCa UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "CA"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumDe UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "DE"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumNl UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "NL"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnumLa UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum = "LA"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "HK":
		fallthrough
	case "AU":
		fallthrough
	case "IN":
		fallthrough
	case "TY":
		fallthrough
	case "CN":
		fallthrough
	case "US":
		fallthrough
	case "CA":
		fallthrough
	case "DE":
		fallthrough
	case "NL":
		fallthrough
	case "LA":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum: %s", s)
	}
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum - Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnumHost UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum = "host"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnumAll  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum = "all"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnumNone UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum = "none"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "host":
		fallthrough
	case "all":
		fallthrough
	case "none":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum: %s", s)
	}
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettingsFiles struct {
	// Unique identifier of the file.
	ID *string `json:"id,omitempty"`
	// Indicates whether or not this file is the default virtual background file.
	IsDefault *bool `json:"is_default,omitempty"`
	// File name.
	Name *string `json:"name,omitempty"`
	// File size.
	Size *string `json:"size,omitempty"`
	// File type.
	Type *string `json:"type,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings - Settings to manage virtual background.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings struct {
	// Allow user to upload custom backgrounds.
	AllowUploadCustom *bool `json:"allow_upload_custom,omitempty"`
	// Allow use of videos for virtual backgrounds.
	AllowVideos *bool `json:"allow_videos,omitempty"`
	// Enable virtual background.
	Enable *bool                                                                                                 `json:"enable,omitempty"`
	Files  []UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettingsFiles `json:"files,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum - Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
// `host`: Only host can share the screen.<br>
// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnumHost UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum = "host"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnumAll  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum = "all"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "host":
		fallthrough
	case "all":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum: %s", s)
	}
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum - Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
// `host`: Only a host can share the screen when someone else is sharing.<br>
// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnumHost UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum = "host"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnumAll  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum = "all"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "host":
		fallthrough
	case "all":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum: %s", s)
	}
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettings struct {
	// Allow live streaming.
	AllowLiveStreaming *bool `json:"allow_live_streaming,omitempty"`
	// Allow participants to use annotation tools.
	Annotation *bool `json:"annotation,omitempty"`
	// Allow host to put attendee on hold.
	//
	// **This field has been deprecated and is no longer supported.**
	AttendeeOnHold *bool `json:"attendee_on_hold,omitempty"`
	// Auto save all in-meeting chats.
	AutoSavingChat *bool `json:"auto_saving_chat,omitempty"`
	// Allow host to split meeting participants into separate breakout rooms.
	BreakoutRoom *bool `json:"breakout_room,omitempty"`
	// Enable chat during meeting for all participants.
	Chat *bool `json:"chat,omitempty"`
	// Enable closed captions.
	ClosedCaption *bool `json:"closed_caption,omitempty"`
	// Allow the host to add co-hosts.
	CoHost *bool `json:"co_host,omitempty"`
	// If set to `true`, you can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting your real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used.
	CustomDataCenterRegions *bool `json:"custom_data_center_regions,omitempty"`
	// Allow custom live streaming.
	CustomLiveStreamingService *bool `json:"custom_live_streaming_service,omitempty"`
	// Custom service instructions.
	CustomServiceInstructions *string `json:"custom_service_instructions,omitempty"`
	// If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: ["DE", "NL", "HK", "AU", "IN", "LA", "TY", "CN", "US", "CA"]).
	//
	DataCenterRegions *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum `json:"data_center_regions,omitempty"`
	// Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP).
	E2eEncryption *bool `json:"e2e_encryption,omitempty"`
	// Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound.
	EntryExitChime *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum `json:"entry_exit_chime,omitempty"`
	// Allow another user to take control of the camera.
	FarEndCameraControl *bool `json:"far_end_camera_control,omitempty"`
	// Enable option to send feedback to Zoom at the end of the meeting.
	Feedback *bool `json:"feedback,omitempty"`
	// Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not.
	FileTransfer *bool `json:"file_transfer,omitempty"`
	// Enable group HD video.
	GroupHd *bool `json:"group_hd,omitempty"`
	// Enable non-verbal feedback through screens.
	NonVerbalFeedback *bool `json:"non_verbal_feedback,omitempty"`
	// Add polls to the meeting controls.
	Polling *bool `json:"polling,omitempty"`
	// Enable 1:1 private chat between participants during meetings.
	PrivateChat *bool `json:"private_chat,omitempty"`
	// Record and play their own voice.
	RecordPlayVoice *bool `json:"record_play_voice,omitempty"`
	// Enable remote control during screensharing.
	RemoteControl *bool `json:"remote_control,omitempty"`
	// Allow host to provide 1:1 remote support to a participant.
	RemoteSupport *bool `json:"remote_support,omitempty"`
	// Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not.
	RequestPermissionToUnmute *bool `json:"request_permission_to_unmute,omitempty"`
	// Allow host and participants to share their screen or content during meetings
	//
	ScreenSharing *bool `json:"screen_sharing,omitempty"`
	// Share dual camera (deprecated).
	ShareDualCamera *bool `json:"share_dual_camera,omitempty"`
	// Always show meeting controls during a meeting.
	ShowMeetingControlToolbar *bool `json:"show_meeting_control_toolbar,omitempty"`
	// Enable virtual background.
	VirtualBackground *bool `json:"virtual_background,omitempty"`
	// Settings to manage virtual background.
	VirtualBackgroundSettings *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings `json:"virtual_background_settings,omitempty"`
	// Enable Waiting room - if enabled, attendees can only join after host approves.
	WaitingRoom *bool `json:"waiting_room,omitempty"`
	// Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
	// `host`: Only host can share the screen.<br>
	// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
	//
	WhoCanShareScreen *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum `json:"who_can_share_screen,omitempty"`
	// Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
	// `host`: Only a host can share the screen when someone else is sharing.<br>
	// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
	//
	WhoCanShareScreenWhenSomeoneIsSharing *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum `json:"who_can_share_screen_when_someone_is_sharing,omitempty"`
	// Allow livestreaming by host through Workplace by Facebook.
	WorkplaceByFacebook *bool `json:"workplace_by_facebook,omitempty"`
}

type UserSettings200ApplicationJSONUserSettingsProfileRecordingStorageLocation struct {
	// Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
	//
	// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
	AllowedValues []string `json:"allowed_values,omitempty"`
	// Abbreviated country code.
	Value *string `json:"value,omitempty"`
}

type UserSettings200ApplicationJSONUserSettingsProfile struct {
	RecordingStorageLocation *UserSettings200ApplicationJSONUserSettingsProfileRecordingStorageLocation `json:"recording_storage_location,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum - Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
type UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnumLocal UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum = "local"
	UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnumCloud UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum = "cloud"
	UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnumNone  UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum = "none"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "local":
		fallthrough
	case "cloud":
		fallthrough
	case "none":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum: %s", s)
	}
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl - Setting to allow cloud recording access only from specific IP address ranges.
type UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl struct {
	// If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
	//
	//
	Enable *bool `json:"enable,omitempty"`
	// IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
	//
	// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
	//
	//
	IPAddressesOrRanges *string `json:"ip_addresses_or_ranges,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement - This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
type UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement struct {
	// Indicates whether or not passcode must contain at least one alphabetical letter (a, b, c..).
	HaveLetter *bool `json:"have_letter,omitempty"`
	// Indicates whether or not passcode must contain at least one number(1, 2, 3..).
	HaveNumber *bool `json:"have_number,omitempty"`
	// Indicates whether or not passcode must contain at least one special character(!, @, #..).
	HaveSpecialCharacter *bool `json:"have_special_character,omitempty"`
	// Minimum required length for the passcode.
	Length *int64 `json:"length,omitempty"`
	// Indicates whether or not passcode must contain only numeric characters.
	OnlyAllowNumeric *bool `json:"only_allow_numeric,omitempty"`
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettings struct {
	// Ask host to confirm the disclaimer.
	AskHostToConfirmDisclaimer *bool `json:"ask_host_to_confirm_disclaimer,omitempty"`
	// This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:<br>
	// * `true`: Ask participants for consent when a recording starts. <br>
	// * `false`: Do not ask participants for consent when a recording starts.
	AskParticipantsToConsentDisclaimer *bool `json:"ask_participants_to_consent_disclaimer,omitempty"`
	// Auto delete cloud recordings.
	AutoDeleteCmr *bool `json:"auto_delete_cmr,omitempty"`
	// A specified number of days of auto delete cloud recordings.
	AutoDeleteCmrDays *int64 `json:"auto_delete_cmr_days,omitempty"`
	// Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled.
	AutoRecording *UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum `json:"auto_recording,omitempty"`
	// Cloud recording.
	CloudRecording *bool `json:"cloud_recording,omitempty"`
	// Host can pause/stop the auto recording in the cloud.
	HostPauseStopRecording *bool `json:"host_pause_stop_recording,omitempty"`
	// Setting to allow cloud recording access only from specific IP address ranges.
	//
	IPAddressAccessControl *UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl `json:"ip_address_access_control,omitempty"`
	// Local recording.
	LocalRecording *bool `json:"local_recording,omitempty"`
	// Record an audio only file.
	RecordAudioFile *bool `json:"record_audio_file,omitempty"`
	// Record the gallery view.
	RecordGalleryView *bool `json:"record_gallery_view,omitempty"`
	// Record the active speaker view.
	RecordSpeakerView *bool `json:"record_speaker_view,omitempty"`
	// Audio transcript.
	RecordingAudioTranscript *bool `json:"recording_audio_transcript,omitempty"`
	// Show a disclaimer to participants before a recording starts
	//
	RecordingDisclaimer *bool `json:"recording_disclaimer,omitempty"`
	// This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
	RecordingPasswordRequirement *UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement `json:"recording_password_requirement,omitempty"`
	// Save chat text from the meeting.
	SaveChatText *bool `json:"save_chat_text,omitempty"`
	// Show timestamp on video.
	ShowTimestamp *bool `json:"show_timestamp,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum - Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnumBoth       UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "both"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnumTelephony  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "telephony"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnumVoip       UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "voip"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnumThirdParty UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum = "thirdParty"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "both":
		fallthrough
	case "telephony":
		fallthrough
	case "voip":
		fallthrough
	case "thirdParty":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum: %s", s)
	}
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumZero  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "0"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumFour  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "4"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumFive  UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "5"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumSix   UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "6"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumSeven UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "7"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnumEight UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum = "8"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "0":
		fallthrough
	case "4":
		fallthrough
	case "5":
		fallthrough
	case "6":
		fallthrough
	case "7":
		fallthrough
	case "8":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum: %s", s)
	}
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement - Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement struct {
	ConsecutiveCharactersLength *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum `json:"consecutive_characters_length,omitempty"`
	// If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...).
	//
	HaveLetter *bool `json:"have_letter,omitempty"`
	// If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...).
	HaveNumber *bool `json:"have_number,omitempty"`
	// If set to `true`, the passcode must have at least 1 special character (!,@,#...).
	HaveSpecialCharacter *bool `json:"have_special_character,omitempty"`
	// If set to `true`, the passcode must include both uppercase and lowercase characters.
	HaveUpperAndLowerCharacters *bool `json:"have_upper_and_lower_characters,omitempty"`
	// The minimum length that the meeting/webinar passcode needs to have.
	Length *int64 `json:"length,omitempty"`
	// If set to `true`, the passcode must only contain numbers and no other characters.
	OnlyAllowNumeric *bool `json:"only_allow_numeric,omitempty"`
	// If set to `true`, users will be informed if the provided passcode is weak.
	WeakEnhanceDetection *bool `json:"weak_enhance_detection,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum - Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum string

const (
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnumJbhOnly UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum = "jbh_only"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnumAll     UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum = "all"
	UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnumNone    UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum = "none"
)

func (e *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "jbh_only":
		fallthrough
	case "all":
		fallthrough
	case "none":
		*e = UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum: %s", s)
	}
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettings1 struct {
	// Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference.
	AudioType *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum `json:"audio_type,omitempty"`
	// Passcode for already scheduled meetings
	//
	DefaultPasswordForScheduledMeetings *string `json:"default_password_for_scheduled_meetings,omitempty"`
	// If the value is set to `true`, the meeting passcode will be encrypted and included in the join meeting link to allow participants to join with just one click without having to enter the passcode.
	//
	EmbedPasswordInJoinLink *bool `json:"embed_password_in_join_link,omitempty"`
	// Require a passcode for personal meetings if attendees can join before host.
	ForcePmiJbhPassword *bool `json:"force_pmi_jbh_password,omitempty"`
	// Start meetings with host video on.
	HostVideo *bool `json:"host_video,omitempty"`
	// Join the meeting before host arrives.
	JoinBeforeHost *bool `json:"join_before_host,omitempty"`
	// Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
	MeetingPasswordRequirement *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement `json:"meeting_password_requirement,omitempty"`
	// Start meetings with participants video on.
	ParticipantsVideo *bool `json:"participants_video,omitempty"`
	// Personal Meeting Setting.<br><br>
	// `true`: Indicates that the **"Enable Personal Meeting ID"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
	// `false`: Indicates that the **"Enable Personal Meeting ID"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
	// For Zoom Phone only:If a user has been assigned a desk phone, **"Elevate to Zoom Meeting"** on desk phone will be disabled.
	//
	//
	//
	PersonalMeeting *bool `json:"personal_meeting,omitempty"`
	// PMI passcode
	//
	PmiPassword *string `json:"pmi_password,omitempty"`
	// Generate and require passcode for participants joining by phone.
	PstnPasswordProtected *bool `json:"pstn_password_protected,omitempty"`
	// Require a passcode for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
	//
	RequirePasswordForInstantMeetings *bool `json:"require_password_for_instant_meetings,omitempty"`
	// Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
	//
	RequirePasswordForPmiMeetings *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum `json:"require_password_for_pmi_meetings,omitempty"`
	// Require a passcode for meetings which have already been scheduled
	//
	RequirePasswordForScheduledMeetings *bool `json:"require_password_for_scheduled_meetings,omitempty"`
	// Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
	//
	RequirePasswordForSchedulingNewMeetings *bool `json:"require_password_for_scheduling_new_meetings,omitempty"`
	// Use Personal Meeting ID (PMI) when starting an instant meeting
	//
	UsePmiForInstantMeetings *bool `json:"use_pmi_for_instant_meetings,omitempty"`
	// Use Personal Meeting ID (PMI) when scheduling a meeting
	//
	UsePmiForScheduledMeetings *bool `json:"use_pmi_for_scheduled_meetings,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsTelephonyRegions - Indicates where most of the participants call into or call from duriing a meeting.
type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsTelephonyRegions struct {
	// Telephony region options provided by Zoom to select from.
	AllowedValues []string `json:"allowed_values,omitempty"`
	// Telephony regions selected by the account to indicate where most of the participants call into or call from during a meeting.
	SelectionValues []string `json:"selection_values,omitempty"`
}

type UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettings2 struct {
	// Third party audio conference info.
	AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`
	// Show the international numbers link on the invitation email.
	ShowInternationalNumbersLink *bool `json:"show_international_numbers_link,omitempty"`
	// Indicates where most of the participants call into or call from duriing a meeting.
	TelephonyRegions *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettingsTelephonyRegions `json:"telephony_regions,omitempty"`
	// Third party audio conference.
	ThirdPartyAudio *bool `json:"third_party_audio,omitempty"`
}

// UserSettings200ApplicationJSONUserSettingsUserSettingsTSPSettings - Account Settings: TSP.
type UserSettings200ApplicationJSONUserSettingsUserSettingsTSPSettings struct {
	// Call Out
	CallOut *bool `json:"call_out,omitempty"`
	// Call Out Countries/Regions
	CallOutCountries []interface{} `json:"call_out_countries,omitempty"`
	// Show international numbers link on the invitation email
	ShowInternationalNumbersLink *bool `json:"show_international_numbers_link,omitempty"`
}

type UserSettings200ApplicationJSONUserSettings struct {
	EmailNotification *UserSettings200ApplicationJSONUserSettingsUserSettingsNotificationSettings `json:"email_notification,omitempty"`
	Feature           *UserSettings200ApplicationJSONUserSettingsUserSettingsFeatureSettings      `json:"feature,omitempty"`
	InMeeting         *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettings      `json:"in_meeting,omitempty"`
	Profile           *UserSettings200ApplicationJSONUserSettingsProfile                          `json:"profile,omitempty"`
	Recording         *UserSettings200ApplicationJSONUserSettingsUserSettingsRecordingSettings    `json:"recording,omitempty"`
	ScheduleMeeting   *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettings1     `json:"schedule_meeting,omitempty"`
	Telephony         *UserSettings200ApplicationJSONUserSettingsUserSettingsMeetingSettings2     `json:"telephony,omitempty"`
	// Account Settings: TSP.
	Tsp *UserSettings200ApplicationJSONUserSettingsUserSettingsTSPSettings `json:"tsp,omitempty"`
}

type UserSettings200ApplicationJSONType string

const (
	UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSONUserSettings                   UserSettings200ApplicationJSONType = "userSettings_200ApplicationJSON_User settings"
	UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSON2                              UserSettings200ApplicationJSONType = "userSettings_200ApplicationJSON_2"
	UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSONMeetingWebinarSecuritySettings UserSettings200ApplicationJSONType = "userSettings_200ApplicationJSON_Meeting/Webinar Security Settings"
)

type UserSettings200ApplicationJSON struct {
	UserSettings200ApplicationJSONUserSettings                   *UserSettings200ApplicationJSONUserSettings
	UserSettings200ApplicationJSON2                              *UserSettings200ApplicationJSON2
	UserSettings200ApplicationJSONMeetingWebinarSecuritySettings *UserSettings200ApplicationJSONMeetingWebinarSecuritySettings

	Type UserSettings200ApplicationJSONType
}

func CreateUserSettings200ApplicationJSONUserSettings200ApplicationJSONUserSettings(userSettings200ApplicationJSONUserSettings UserSettings200ApplicationJSONUserSettings) UserSettings200ApplicationJSON {
	typ := UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSONUserSettings

	return UserSettings200ApplicationJSON{
		UserSettings200ApplicationJSONUserSettings: &userSettings200ApplicationJSONUserSettings,
		Type: typ,
	}
}

func CreateUserSettings200ApplicationJSONUserSettings200ApplicationJSON2(userSettings200ApplicationJSON2 UserSettings200ApplicationJSON2) UserSettings200ApplicationJSON {
	typ := UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSON2

	return UserSettings200ApplicationJSON{
		UserSettings200ApplicationJSON2: &userSettings200ApplicationJSON2,
		Type:                            typ,
	}
}

func CreateUserSettings200ApplicationJSONUserSettings200ApplicationJSONMeetingWebinarSecuritySettings(userSettings200ApplicationJSONMeetingWebinarSecuritySettings UserSettings200ApplicationJSONMeetingWebinarSecuritySettings) UserSettings200ApplicationJSON {
	typ := UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSONMeetingWebinarSecuritySettings

	return UserSettings200ApplicationJSON{
		UserSettings200ApplicationJSONMeetingWebinarSecuritySettings: &userSettings200ApplicationJSONMeetingWebinarSecuritySettings,
		Type: typ,
	}
}

func (u *UserSettings200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	userSettings200ApplicationJSONUserSettings := new(UserSettings200ApplicationJSONUserSettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationJSONUserSettings); err == nil {
		u.UserSettings200ApplicationJSONUserSettings = userSettings200ApplicationJSONUserSettings
		u.Type = UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSONUserSettings
		return nil
	}

	userSettings200ApplicationJSON2 := new(UserSettings200ApplicationJSON2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationJSON2); err == nil {
		u.UserSettings200ApplicationJSON2 = userSettings200ApplicationJSON2
		u.Type = UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSON2
		return nil
	}

	userSettings200ApplicationJSONMeetingWebinarSecuritySettings := new(UserSettings200ApplicationJSONMeetingWebinarSecuritySettings)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&userSettings200ApplicationJSONMeetingWebinarSecuritySettings); err == nil {
		u.UserSettings200ApplicationJSONMeetingWebinarSecuritySettings = userSettings200ApplicationJSONMeetingWebinarSecuritySettings
		u.Type = UserSettings200ApplicationJSONTypeUserSettings200ApplicationJSONMeetingWebinarSecuritySettings
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u UserSettings200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.UserSettings200ApplicationJSONUserSettings != nil {
		return json.Marshal(u.UserSettings200ApplicationJSONUserSettings)
	}

	if u.UserSettings200ApplicationJSON2 != nil {
		return json.Marshal(u.UserSettings200ApplicationJSON2)
	}

	if u.UserSettings200ApplicationJSONMeetingWebinarSecuritySettings != nil {
		return json.Marshal(u.UserSettings200ApplicationJSONMeetingWebinarSecuritySettings)
	}

	return nil, nil
}

type UserSettingsResponse struct {
	Body        []byte
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// **HTTP Status Code:** `200`<br>
	// User settings returned.
	UserSettings200ApplicationJSONOneOf *UserSettings200ApplicationJSON
}
