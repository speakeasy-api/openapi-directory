/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import {
  objectToClass,
  SpeakeasyBase,
  SpeakeasyMetadata,
} from "../../../internal/utils";
import { Manifest } from "./manifest";
import { Expose, Transform, Type } from "class-transformer";

/**
 * A description of the detector used.
 */
export class SnapshotDetector extends SpeakeasyBase {
  /**
   * The name of the detector used.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name: string;

  /**
   * The url of the detector used.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "url" })
  url: string;

  /**
   * The version of the detector used.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "version" })
  version: string;
}

export class SnapshotJob extends SpeakeasyBase {
  /**
   * Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository's current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you're using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you're using a build matrix, then you'll also need to add additional key(s) to distinguish between each submission inside a matrix variation.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "correlator" })
  correlator: string;

  /**
   * The url for the job.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "html_url" })
  htmlUrl?: string;

  /**
   * The external ID of the job.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id: string;
}

/**
 * Create a new snapshot of a repository's dependencies.
 */
export class Snapshot extends SpeakeasyBase {
  /**
   * A description of the detector used.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "detector" })
  @Type(() => SnapshotDetector)
  detector: SnapshotDetector;

  @SpeakeasyMetadata()
  @Expose({ name: "job" })
  @Type(() => SnapshotJob)
  job: SnapshotJob;

  /**
   * A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.
   */
  @SpeakeasyMetadata({ elemType: Manifest })
  @Expose({ name: "manifests" })
  @Transform(
    ({ value }) => {
      const obj: Record<string, Manifest> = {};
      for (const key in value) {
        obj[key] = objectToClass(value[key], Manifest);
      }
      return obj;
    },
    { toClassOnly: true }
  )
  manifests?: Record<string, Manifest>;

  /**
   * User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "metadata" })
  metadata?: Record<string, any>;

  /**
   * The repository branch that triggered this snapshot.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "ref" })
  ref: string;

  /**
   * The time at which the snapshot was scanned.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "scanned" })
  @Transform(({ value }) => new Date(value), { toClassOnly: true })
  scanned: Date;

  /**
   * The commit SHA associated with this dependency snapshot. Maximum length: 40 characters.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "sha" })
  sha: string;

  /**
   * The version of the repository snapshot submission.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "version" })
  version: number;
}
