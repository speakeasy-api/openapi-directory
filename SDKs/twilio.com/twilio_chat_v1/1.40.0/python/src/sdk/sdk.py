"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://chat.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_channel(self, request: operations.CreateChannelRequest, security: operations.CreateChannelSecurity, server_url: Optional[str] = None) -> operations.CreateChannelResponse:
        base_url = operations.CREATE_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateChannelRequest, base_url, '/v1/Services/{ServiceSid}/Channels', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannel])
                res.chat_v1_service_channel = out

        return res

    def create_credential(self, request: operations.CreateCredentialCreateCredentialRequest, security: operations.CreateCredentialSecurity, server_url: Optional[str] = None) -> operations.CreateCredentialResponse:
        base_url = operations.CREATE_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Credentials'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1Credential])
                res.chat_v1_credential = out

        return res

    def create_invite(self, request: operations.CreateInviteRequest, security: operations.CreateInviteSecurity, server_url: Optional[str] = None) -> operations.CreateInviteResponse:
        base_url = operations.CREATE_INVITE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateInviteRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelInvite])
                res.chat_v1_service_channel_invite = out

        return res

    def create_member(self, request: operations.CreateMemberRequest, security: operations.CreateMemberSecurity, server_url: Optional[str] = None) -> operations.CreateMemberResponse:
        base_url = operations.CREATE_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateMemberRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelMember])
                res.chat_v1_service_channel_member = out

        return res

    def create_message(self, request: operations.CreateMessageRequest, security: operations.CreateMessageSecurity, server_url: Optional[str] = None) -> operations.CreateMessageResponse:
        base_url = operations.CREATE_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateMessageRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelMessage])
                res.chat_v1_service_channel_message = out

        return res

    def create_role(self, request: operations.CreateRoleRequest, security: operations.CreateRoleSecurity, server_url: Optional[str] = None) -> operations.CreateRoleResponse:
        base_url = operations.CREATE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateRoleRequest, base_url, '/v1/Services/{ServiceSid}/Roles', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceRole])
                res.chat_v1_service_role = out

        return res

    def create_service(self, request: operations.CreateServiceCreateServiceRequest, security: operations.CreateServiceSecurity, server_url: Optional[str] = None) -> operations.CreateServiceResponse:
        base_url = operations.CREATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1Service])
                res.chat_v1_service = out

        return res

    def create_user(self, request: operations.CreateUserRequest, security: operations.CreateUserSecurity, server_url: Optional[str] = None) -> operations.CreateUserResponse:
        base_url = operations.CREATE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateUserRequest, base_url, '/v1/Services/{ServiceSid}/Users', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceUser])
                res.chat_v1_service_user = out

        return res

    def delete_channel(self, request: operations.DeleteChannelRequest, security: operations.DeleteChannelSecurity, server_url: Optional[str] = None) -> operations.DeleteChannelResponse:
        base_url = operations.DELETE_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteChannelRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_credential(self, request: operations.DeleteCredentialRequest, security: operations.DeleteCredentialSecurity, server_url: Optional[str] = None) -> operations.DeleteCredentialResponse:
        base_url = operations.DELETE_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteCredentialRequest, base_url, '/v1/Credentials/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_invite(self, request: operations.DeleteInviteRequest, security: operations.DeleteInviteSecurity, server_url: Optional[str] = None) -> operations.DeleteInviteResponse:
        base_url = operations.DELETE_INVITE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteInviteRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_member(self, request: operations.DeleteMemberRequest, security: operations.DeleteMemberSecurity, server_url: Optional[str] = None) -> operations.DeleteMemberResponse:
        base_url = operations.DELETE_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteMemberRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_message(self, request: operations.DeleteMessageRequest, security: operations.DeleteMessageSecurity, server_url: Optional[str] = None) -> operations.DeleteMessageResponse:
        base_url = operations.DELETE_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteMessageRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_role(self, request: operations.DeleteRoleRequest, security: operations.DeleteRoleSecurity, server_url: Optional[str] = None) -> operations.DeleteRoleResponse:
        base_url = operations.DELETE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteRoleRequest, base_url, '/v1/Services/{ServiceSid}/Roles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service(self, request: operations.DeleteServiceRequest, security: operations.DeleteServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceResponse:
        base_url = operations.DELETE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_user(self, request: operations.DeleteUserRequest, security: operations.DeleteUserSecurity, server_url: Optional[str] = None) -> operations.DeleteUserResponse:
        base_url = operations.DELETE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteUserRequest, base_url, '/v1/Services/{ServiceSid}/Users/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_channel(self, request: operations.FetchChannelRequest, security: operations.FetchChannelSecurity, server_url: Optional[str] = None) -> operations.FetchChannelResponse:
        base_url = operations.FETCH_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchChannelRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannel])
                res.chat_v1_service_channel = out

        return res

    def fetch_credential(self, request: operations.FetchCredentialRequest, security: operations.FetchCredentialSecurity, server_url: Optional[str] = None) -> operations.FetchCredentialResponse:
        base_url = operations.FETCH_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchCredentialRequest, base_url, '/v1/Credentials/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1Credential])
                res.chat_v1_credential = out

        return res

    def fetch_invite(self, request: operations.FetchInviteRequest, security: operations.FetchInviteSecurity, server_url: Optional[str] = None) -> operations.FetchInviteResponse:
        base_url = operations.FETCH_INVITE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchInviteRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelInvite])
                res.chat_v1_service_channel_invite = out

        return res

    def fetch_member(self, request: operations.FetchMemberRequest, security: operations.FetchMemberSecurity, server_url: Optional[str] = None) -> operations.FetchMemberResponse:
        base_url = operations.FETCH_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMemberRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelMember])
                res.chat_v1_service_channel_member = out

        return res

    def fetch_message(self, request: operations.FetchMessageRequest, security: operations.FetchMessageSecurity, server_url: Optional[str] = None) -> operations.FetchMessageResponse:
        base_url = operations.FETCH_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchMessageRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelMessage])
                res.chat_v1_service_channel_message = out

        return res

    def fetch_role(self, request: operations.FetchRoleRequest, security: operations.FetchRoleSecurity, server_url: Optional[str] = None) -> operations.FetchRoleResponse:
        base_url = operations.FETCH_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchRoleRequest, base_url, '/v1/Services/{ServiceSid}/Roles/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceRole])
                res.chat_v1_service_role = out

        return res

    def fetch_service(self, request: operations.FetchServiceRequest, security: operations.FetchServiceSecurity, server_url: Optional[str] = None) -> operations.FetchServiceResponse:
        base_url = operations.FETCH_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1Service])
                res.chat_v1_service = out

        return res

    def fetch_user(self, request: operations.FetchUserRequest, security: operations.FetchUserSecurity, server_url: Optional[str] = None) -> operations.FetchUserResponse:
        base_url = operations.FETCH_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchUserRequest, base_url, '/v1/Services/{ServiceSid}/Users/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceUser])
                res.chat_v1_service_user = out

        return res

    def list_channel(self, request: operations.ListChannelRequest, security: operations.ListChannelSecurity, server_url: Optional[str] = None) -> operations.ListChannelResponse:
        base_url = operations.LIST_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListChannelRequest, base_url, '/v1/Services/{ServiceSid}/Channels', request)
        
        query_params = utils.get_query_params(operations.ListChannelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListChannelListChannelResponse])
                res.list_channel_response = out

        return res

    def list_credential(self, request: operations.ListCredentialRequest, security: operations.ListCredentialSecurity, server_url: Optional[str] = None) -> operations.ListCredentialResponse:
        base_url = operations.LIST_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Credentials'
        
        query_params = utils.get_query_params(operations.ListCredentialRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListCredentialListCredentialResponse])
                res.list_credential_response = out

        return res

    def list_invite(self, request: operations.ListInviteRequest, security: operations.ListInviteSecurity, server_url: Optional[str] = None) -> operations.ListInviteResponse:
        base_url = operations.LIST_INVITE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListInviteRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Invites', request)
        
        query_params = utils.get_query_params(operations.ListInviteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInviteListInviteResponse])
                res.list_invite_response = out

        return res

    def list_member(self, request: operations.ListMemberRequest, security: operations.ListMemberSecurity, server_url: Optional[str] = None) -> operations.ListMemberResponse:
        base_url = operations.LIST_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMemberRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members', request)
        
        query_params = utils.get_query_params(operations.ListMemberRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMemberListMemberResponse])
                res.list_member_response = out

        return res

    def list_message(self, request: operations.ListMessageRequest, security: operations.ListMessageSecurity, server_url: Optional[str] = None) -> operations.ListMessageResponse:
        base_url = operations.LIST_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListMessageRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages', request)
        
        query_params = utils.get_query_params(operations.ListMessageRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListMessageListMessageResponse])
                res.list_message_response = out

        return res

    def list_role(self, request: operations.ListRoleRequest, security: operations.ListRoleSecurity, server_url: Optional[str] = None) -> operations.ListRoleResponse:
        base_url = operations.LIST_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListRoleRequest, base_url, '/v1/Services/{ServiceSid}/Roles', request)
        
        query_params = utils.get_query_params(operations.ListRoleRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListRoleListRoleResponse])
                res.list_role_response = out

        return res

    def list_service(self, request: operations.ListServiceRequest, security: operations.ListServiceSecurity, server_url: Optional[str] = None) -> operations.ListServiceResponse:
        base_url = operations.LIST_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        query_params = utils.get_query_params(operations.ListServiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceListServiceResponse])
                res.list_service_response = out

        return res

    def list_user(self, request: operations.ListUserRequest, security: operations.ListUserSecurity, server_url: Optional[str] = None) -> operations.ListUserResponse:
        base_url = operations.LIST_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUserRequest, base_url, '/v1/Services/{ServiceSid}/Users', request)
        
        query_params = utils.get_query_params(operations.ListUserRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUserListUserResponse])
                res.list_user_response = out

        return res

    def list_user_channel(self, request: operations.ListUserChannelRequest, security: operations.ListUserChannelSecurity, server_url: Optional[str] = None) -> operations.ListUserChannelResponse:
        r"""List all Channels for a given User."""
        base_url = operations.LIST_USER_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListUserChannelRequest, base_url, '/v1/Services/{ServiceSid}/Users/{UserSid}/Channels', request)
        
        query_params = utils.get_query_params(operations.ListUserChannelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListUserChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListUserChannelListUserChannelResponse])
                res.list_user_channel_response = out

        return res

    def update_channel(self, request: operations.UpdateChannelRequest, security: operations.UpdateChannelSecurity, server_url: Optional[str] = None) -> operations.UpdateChannelResponse:
        base_url = operations.UPDATE_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateChannelRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannel])
                res.chat_v1_service_channel = out

        return res

    def update_credential(self, request: operations.UpdateCredentialRequest, security: operations.UpdateCredentialSecurity, server_url: Optional[str] = None) -> operations.UpdateCredentialResponse:
        base_url = operations.UPDATE_CREDENTIAL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateCredentialRequest, base_url, '/v1/Credentials/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateCredentialResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1Credential])
                res.chat_v1_credential = out

        return res

    def update_member(self, request: operations.UpdateMemberRequest, security: operations.UpdateMemberSecurity, server_url: Optional[str] = None) -> operations.UpdateMemberResponse:
        base_url = operations.UPDATE_MEMBER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMemberRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMemberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelMember])
                res.chat_v1_service_channel_member = out

        return res

    def update_message(self, request: operations.UpdateMessageRequest, security: operations.UpdateMessageSecurity, server_url: Optional[str] = None) -> operations.UpdateMessageResponse:
        base_url = operations.UPDATE_MESSAGE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateMessageRequest, base_url, '/v1/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMessageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceChannelMessage])
                res.chat_v1_service_channel_message = out

        return res

    def update_role(self, request: operations.UpdateRoleRequest, security: operations.UpdateRoleSecurity, server_url: Optional[str] = None) -> operations.UpdateRoleResponse:
        base_url = operations.UPDATE_ROLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateRoleRequest, base_url, '/v1/Services/{ServiceSid}/Roles/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceRole])
                res.chat_v1_service_role = out

        return res

    def update_service(self, request: operations.UpdateServiceRequest, security: operations.UpdateServiceSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceResponse:
        base_url = operations.UPDATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1Service])
                res.chat_v1_service = out

        return res

    def update_user(self, request: operations.UpdateUserRequest, security: operations.UpdateUserSecurity, server_url: Optional[str] = None) -> operations.UpdateUserResponse:
        base_url = operations.UPDATE_USER_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateUserRequest, base_url, '/v1/Services/{ServiceSid}/Users/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ChatV1ServiceUser])
                res.chat_v1_service_user = out

        return res

    