<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class PortfolioConstruction 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Investable Portfolio
     * 
     * Compute an investable portfolio as close as possible, in terms of assets weights, to a desired portfolio, taking into account:
     * * The desired assets weights
     * * The desired assets groups weights
     * * The desired maximum assets groups weights
     * * The prices of the assets
     * * The portfolio value
     * * The requirement to purchase some assets by round lots or by odd lots
     * * The possibility to purchase some assets by a fractional quantity of shares
     * * The requirement to purchase a minimum number of shares, or a minimum monetary value, for some assets
     * 
     * References
     * * [Steiner, Andreas, Accuracy and Rounding in Portfolio Construction](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2261131)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionInvestableRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionInvestableResponse
     */
	public function postPortfolioConstructionInvestable(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionInvestableRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionInvestableResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/construction/investable');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionInvestableResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioConstructionInvestable200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionInvestable200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Mimicking Portfolio
     * 
     * Construct a portfolio as close as possible, in terms of returns, to a benchmark, optionally subject to:
     * * Minimum and maximum weights constraints
     * * Maximum group weights constraints
     * * Minimum and maximum portfolio exposure constraints
     * 
     * References 
     * * Konstantinos Benidis, Yiyong Feng, Daniel P. Palomar, Optimization Methods for Financial Index Tracking: From Theory to Practice, now publishers Inc (7 juin 2018)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionMimickingRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionMimickingResponse
     */
	public function postPortfolioConstructionMimicking(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionMimickingRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionMimickingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/construction/mimicking');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionMimickingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioConstructionMimicking200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionMimicking200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Random Portfolio
     * 
     * Construct one or several random portfolio(s), optionally subject to:       
     * * Minimum and maximum weights constraints
     * * Minimum and maximum portfolio exposure constraints
     * 
     * > Because of the nature of the endpoint, subsequent calls with the same input data will result in different output data.
     * 
     * References
     * * [William Thornton Shaw, Monte Carlo Portfolio Optimization for General Investor Risk-Return Objectives and Arbitrary Return Distributions: A Solution for Long-Only Portfolios](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=1680224)
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionRandomRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionRandomResponse
     */
	public function postPortfolioConstructionRandom(
        \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionRandomRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionRandomResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/portfolio/construction/random');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionRandomResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postPortfolioConstructionRandom200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostPortfolioConstructionRandom200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}