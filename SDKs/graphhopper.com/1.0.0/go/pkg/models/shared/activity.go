// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

// ActivityTypeEnum - type of activity
type ActivityTypeEnum string

const (
	ActivityTypeEnumStart           ActivityTypeEnum = "start"
	ActivityTypeEnumEnd             ActivityTypeEnum = "end"
	ActivityTypeEnumService         ActivityTypeEnum = "service"
	ActivityTypeEnumPickupShipment  ActivityTypeEnum = "pickupShipment"
	ActivityTypeEnumDeliverShipment ActivityTypeEnum = "deliverShipment"
	ActivityTypeEnumPickup          ActivityTypeEnum = "pickup"
	ActivityTypeEnumDelivery        ActivityTypeEnum = "delivery"
	ActivityTypeEnumBreak           ActivityTypeEnum = "break"
)

func (e *ActivityTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "start":
		fallthrough
	case "end":
		fallthrough
	case "service":
		fallthrough
	case "pickupShipment":
		fallthrough
	case "deliverShipment":
		fallthrough
	case "pickup":
		fallthrough
	case "delivery":
		fallthrough
	case "break":
		*e = ActivityTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ActivityTypeEnum: %s", s)
	}
}

type Activity struct {
	// Address of activity
	Address *ResponseAddress `json:"address,omitempty"`
	// Arrival date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`.
	ArrDateTime *time.Time `json:"arr_date_time,omitempty"`
	// Arrival time at this activity in seconds. If type is `start`, this is not available (since it makes no sense to have `arr_time` at start). However, `end_time` is available and actually means \"departure time\" at start location. It is important to note that `arr_time` does not necessarily mean \"start of underlying activity\", it solely means arrival time at activity location. If this activity has no time windows and if there are no further preparation times, `arr_time` is equal to activity start time.
	ArrTime *int64 `json:"arr_time,omitempty"`
	// cumulated distance from start to this activity in m
	Distance *int64 `json:"distance,omitempty"`
	// cumulated driving time from start to this driver activity in seconds
	DrivingTime *int64 `json:"driving_time,omitempty"`
	// End date time with offset like this 1970-01-01T01:00+01:00. If you do not use time-dependent optimization, this is `null`.
	EndDateTime *time.Time `json:"end_date_time,omitempty"`
	// End time of and thus departure time at this activity. If type is `end`, this is not available (since it makes no sense to have an `end_time` at end) `end_time` at each activity is equal to the departure time at the activity location.
	EndTime *int64 `json:"end_time,omitempty"`
	// Id referring to the underlying service or shipment, i.e. the shipment or service this activity belongs to
	ID *string `json:"id,omitempty"`
	// Array with size/capacity dimensions after this activity
	LoadAfter []int `json:"load_after,omitempty"`
	// Array with size/capacity dimensions before this activity
	LoadBefore []int `json:"load_before,omitempty"`
	// Id that refers to address
	LocationID *string `json:"location_id,omitempty"`
	// preparation time at this activity in seconds
	PreparationTime *int64 `json:"preparation_time,omitempty"`
	// type of activity
	Type *ActivityTypeEnum `json:"type,omitempty"`
	// Waiting time at this activity in seconds. A waiting time can occur if the activity has at least one time window. If `arr_time` < `time_window.earliest` a waiting time of `time_window_earliest` - `arr_time` occurs.
	WaitingTime *int64 `json:"waiting_time,omitempty"`
}
