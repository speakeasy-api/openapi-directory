/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.operations;

import org.openapis.openapi.utils.SpeakeasyMetadata;

public class GetmeasureRequest {
    /**
     * Starting timestamp (utc) of the requested measurements.
     * Please note measurement retrieving is limited to 1024 measurements.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=date_begin")
    public Integer dateBegin;
    public GetmeasureRequest withDateBegin(Integer dateBegin) {
        this.dateBegin = dateBegin;
        return this;
    }
    
    /**
     * Ending timestamp (utc) of the request measurements.
     * If you want only the last measurement, do not provide date_begin, and set date_end to `last`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=date_end")
    public String dateEnd;
    public GetmeasureRequest withDateEnd(String dateEnd) {
        this.dateEnd = dateEnd;
        return this;
    }
    
    /**
     * Id of the device whose module's measurements you want to retrieve. This _id can be found in the user's devices field.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=device_id")
    public String deviceId;
    public GetmeasureRequest withDeviceId(String deviceId) {
        this.deviceId = deviceId;
        return this;
    }
    
    /**
     * Limits the number of measurements returned (default &amp; max is 1024)
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=limit")
    public Integer limit;
    public GetmeasureRequest withLimit(Integer limit) {
        this.limit = limit;
        return this;
    }
    
    /**
     * If you don't specify any module_id you will retrieve the device's measurements. If you specify a module_id you will retrieve the module's measurements.
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=module_id")
    public String moduleId;
    public GetmeasureRequest withModuleId(String moduleId) {
        this.moduleId = moduleId;
        return this;
    }
    
    /**
     * Allows you to choose the format of the answer.
     * If you build a mobile app and bandwith usage is an issue, use `optimize = true`.
     * Use `optimize = false`, for an easier parse. In this case, values are indexed by sorted timestamp.
     * Example of un-optimized response :
     * ```json
     * {"status": "ok", 
     *   "body": {
     *     "1347575400": [18.3,39],
     *     "1347586200": [20.6,48]
     *   },
     * "time_exec": 0.012136936187744}
     * ```
     * If optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time:
     * ```json
     * {"status": "ok",
     *   "body": [
     *     {"beg_time": 1347575400,
     *      "step_time": 10800,
     *      "value": 
     *         [[18.3,39],
     *         [ 20.6,48]]
     *     }],
     * "time_exec": 0.014238119125366}
     * ```
     * Default value is `true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=optimize")
    public Boolean optimize;
    public GetmeasureRequest withOptimize(Boolean optimize) {
        this.optimize = optimize;
        return this;
    }
    
    /**
     * In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2).
     * For instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to `false` (default case), and timestamped at 00:00 if real_time is set to `true`.
     * NB : The servers always store data with real_time set to `true` and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to `false`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=real_time")
    public Boolean realTime;
    public GetmeasureRequest withRealTime(Boolean realTime) {
        this.realTime = realTime;
        return this;
    }
    
    /**
     * Defines the time interval between two measurements.
     * Possible values :
     * max -&gt; every value stored will be returned
     * 30min -&gt; 1 value every 30 minutes
     * 1hour -&gt; 1 value every hour
     * 3hours -&gt; 1 value every 3 hours
     * 1day -&gt; 1 value per day
     * 1week -&gt; 1 value per week
     * 1month -&gt; 1 value per month
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=scale")
    public GetmeasureScaleEnum scale;
    public GetmeasureRequest withScale(GetmeasureScaleEnum scale) {
        this.scale = scale;
        return this;
    }
    
    /**
     * Measures you are interested in. Data you can request depends on the scale.
     * **For Weather Station:**
     *   * max -&gt; Temperature (\u00b0C), CO2 (ppm), Humidity (%), Pressure (mbar), Noise (db), Rain (mm), WindStrength (km/h), WindAngle (angles), Guststrength (km/h), GustAngle (angles)
     *   * 30min, 1hour, 3hours -&gt; Same as above + min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain, date_max_gust
     *   * 1day, 1week, 1month -&gt; Same as above + date_min_temp, date_max_temp, date_min_hum, date_max_hum, date_min_pressure, date_max_pressure, date_min_noise, date_max_noise, date_min_co2, date_max_co2
     * 
     * **For Thermostat:**
     *   * max -&gt; temperature (\u00b0C), sp_temperature (\u00b0C), boileron (sec), boileroff (sec)
     *   * 30min, 1hour, 3hours -&gt; temperature, sp_temperature, min_temp,
     * max_temp, sum_boiler_on, sum_boiler_off
     *   * 1day, 1week, 1month -&gt; temperature, min_temp, date_min_temp,
     * max_temp, sum_boiler_on, sum_boiler_off
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=false,name=type")
    public GetmeasureTypeEnum[] type;
    public GetmeasureRequest withType(GetmeasureTypeEnum[] type) {
        this.type = type;
        return this;
    }
    
}
