"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Optional

class Analytics:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def analytics_audience_name_exists(self, request: operations.AnalyticsAudienceNameExistsRequest, security: operations.AnalyticsAudienceNameExistsSecurity) -> operations.AnalyticsAudienceNameExistsResponse:
        r"""Returns whether audience definition exists."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsAudienceNameExistsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('HEAD', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsAudienceNameExistsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 404]:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsAudienceNameExistsDefaultApplicationJSON])
                res.analytics_audience_name_exists_default_application_json_object = out

        return res

    def analytics_crash_free_device_percentages(self, request: operations.AnalyticsCrashFreeDevicePercentagesRequest, security: operations.AnalyticsCrashFreeDevicePercentagesSecurity) -> operations.AnalyticsCrashFreeDevicePercentagesResponse:
        r"""Percentage of crash-free device by day in the time range based on the selected versions. Api will return -1 if crash devices is greater than active devices."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCrashFreeDevicePercentagesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/crashfree_device_percentages', request)
        
        query_params = utils.get_query_params(operations.AnalyticsCrashFreeDevicePercentagesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCrashFreeDevicePercentagesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashFreeDevicePercentages200ApplicationJSON])
                res.analytics_crash_free_device_percentages_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashFreeDevicePercentagesDefaultApplicationJSON])
                res.analytics_crash_free_device_percentages_default_application_json_object = out

        return res

    def analytics_crash_group_counts(self, request: operations.AnalyticsCrashGroupCountsRequest, security: operations.AnalyticsCrashGroupCountsSecurity) -> operations.AnalyticsCrashGroupCountsResponse:
        r"""Available for UWP apps only.
        Count of crashes by day in the time range of the selected crash group with selected version. Available for UWP apps only.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCrashGroupCountsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/crash_counts', request)
        
        query_params = utils.get_query_params(operations.AnalyticsCrashGroupCountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCrashGroupCountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupCounts200ApplicationJSON])
                res.analytics_crash_group_counts_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupCountsDefaultApplicationJSON])
                res.analytics_crash_group_counts_default_application_json_object = out

        return res

    def analytics_crash_group_model_counts(self, request: operations.AnalyticsCrashGroupModelCountsRequest, security: operations.AnalyticsCrashGroupModelCountsSecurity) -> operations.AnalyticsCrashGroupModelCountsResponse:
        r"""Available for UWP apps only.
        Top models of the selected crash group with selected version. Available for UWP apps only.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCrashGroupModelCountsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/models', request)
        
        query_params = utils.get_query_params(operations.AnalyticsCrashGroupModelCountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCrashGroupModelCountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupModelCounts200ApplicationJSON])
                res.analytics_crash_group_model_counts_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupModelCountsDefaultApplicationJSON])
                res.analytics_crash_group_model_counts_default_application_json_object = out

        return res

    def analytics_crash_group_operating_system_counts(self, request: operations.AnalyticsCrashGroupOperatingSystemCountsRequest, security: operations.AnalyticsCrashGroupOperatingSystemCountsSecurity) -> operations.AnalyticsCrashGroupOperatingSystemCountsResponse:
        r"""Available for UWP apps only.
        Top OSes of the selected crash group with selected version. Available for UWP apps only.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCrashGroupOperatingSystemCountsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/operating_systems', request)
        
        query_params = utils.get_query_params(operations.AnalyticsCrashGroupOperatingSystemCountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCrashGroupOperatingSystemCountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupOperatingSystemCounts200ApplicationJSON])
                res.analytics_crash_group_operating_system_counts_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupOperatingSystemCountsDefaultApplicationJSON])
                res.analytics_crash_group_operating_system_counts_default_application_json_object = out

        return res

    def analytics_crash_group_totals(self, request: operations.AnalyticsCrashGroupTotalsRequest, security: operations.AnalyticsCrashGroupTotalsSecurity) -> operations.AnalyticsCrashGroupTotalsResponse:
        r"""Available for UWP apps only.
        Overall crashes and affected users count of the selected crash group with selected version. Available for UWP apps only.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCrashGroupTotalsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/overall', request)
        
        query_params = utils.get_query_params(operations.AnalyticsCrashGroupTotalsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCrashGroupTotalsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupTotals200ApplicationJSON])
                res.analytics_crash_group_totals_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupTotalsDefaultApplicationJSON])
                res.analytics_crash_group_totals_default_application_json_object = out

        return res

    def analytics_crash_groups_totals(self, request: operations.AnalyticsCrashGroupsTotalsRequest, security: operations.AnalyticsCrashGroupsTotalsSecurity) -> operations.AnalyticsCrashGroupsTotalsResponse:
        r"""Overall crashes and affected users count of the selected crash groups with selected versions."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCrashGroupsTotalsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCrashGroupsTotalsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AnalyticsCrashGroupsTotals200ApplicationJSON]])
                res.analytics_crash_groups_totals_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCrashGroupsTotalsDefaultApplicationJSON])
                res.analytics_crash_groups_totals_default_application_json_object = out

        return res

    def analytics_create_or_update_audience(self, request: operations.AnalyticsCreateOrUpdateAudienceRequest, security: operations.AnalyticsCreateOrUpdateAudienceSecurity) -> operations.AnalyticsCreateOrUpdateAudienceResponse:
        r"""Creates or updates audience definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsCreateOrUpdateAudienceRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsCreateOrUpdateAudienceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCreateOrUpdateAudience200ApplicationJSON])
                res.analytics_create_or_update_audience_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsCreateOrUpdateAudienceDefaultApplicationJSON])
                res.analytics_create_or_update_audience_default_application_json_object = out

        return res

    def analytics_delete_audience(self, request: operations.AnalyticsDeleteAudienceRequest, security: operations.AnalyticsDeleteAudienceSecurity) -> operations.AnalyticsDeleteAudienceResponse:
        r"""Deletes audience definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsDeleteAudienceRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsDeleteAudienceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 404]:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsDeleteAudienceDefaultApplicationJSON])
                res.analytics_delete_audience_default_application_json_object = out

        return res

    def analytics_distribution_release_counts(self, request: operations.AnalyticsDistributionReleaseCountsRequest, security: operations.AnalyticsDistributionReleaseCountsSecurity) -> operations.AnalyticsDistributionReleaseCountsResponse:
        r"""Count of total downloads for the provided distribution releases."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsDistributionReleaseCountsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/distribution/release_counts', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsDistributionReleaseCountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsDistributionReleaseCounts200ApplicationJSON])
                res.analytics_distribution_release_counts_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsDistributionReleaseCountsDefaultApplicationJSON])
                res.analytics_distribution_release_counts_default_application_json_object = out

        return res

    def analytics_event_properties(self, request: operations.AnalyticsEventPropertiesRequest, security: operations.AnalyticsEventPropertiesSecurity) -> operations.AnalyticsEventPropertiesResponse:
        r"""Event properties."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsEventPropertiesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/properties', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsEventPropertiesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsEventProperties200ApplicationJSON])
                res.analytics_event_properties_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsEventPropertiesDefaultApplicationJSON])
                res.analytics_event_properties_default_application_json_object = out

        return res

    def analytics_events_delete(self, request: operations.AnalyticsEventsDeleteRequest, security: operations.AnalyticsEventsDeleteSecurity) -> operations.AnalyticsEventsDeleteResponse:
        r"""Delete the set of Events with the specified event names."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsEventsDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsEventsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsEventsDeleteDefaultApplicationJSON])
                res.analytics_events_delete_default_application_json_object = out

        return res

    def analytics_events_delete_logs(self, request: operations.AnalyticsEventsDeleteLogsRequest, security: operations.AnalyticsEventsDeleteLogsSecurity) -> operations.AnalyticsEventsDeleteLogsResponse:
        r"""Delete the set of Events with the specified event names."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsEventsDeleteLogsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/event_logs/{event_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsEventsDeleteLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsEventsDeleteLogsDefaultApplicationJSON])
                res.analytics_events_delete_logs_default_application_json_object = out

        return res

    def analytics_generic_log_flow(self, request: operations.AnalyticsGenericLogFlowRequest, security: operations.AnalyticsGenericLogFlowSecurity) -> operations.AnalyticsGenericLogFlowResponse:
        r"""Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsGenericLogFlowRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/generic_log_flow', request)
        
        query_params = utils.get_query_params(operations.AnalyticsGenericLogFlowRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsGenericLogFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsGenericLogFlow200ApplicationJSON])
                res.analytics_generic_log_flow_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsGenericLogFlowDefaultApplicationJSON])
                res.analytics_generic_log_flow_default_application_json_object = out

        return res

    def analytics_get_audience(self, request: operations.AnalyticsGetAudienceRequest, security: operations.AnalyticsGetAudienceSecurity) -> operations.AnalyticsGetAudienceResponse:
        r"""Gets audience definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsGetAudienceRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsGetAudienceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsGetAudience200ApplicationJSON])
                res.analytics_get_audience_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsGetAudienceDefaultApplicationJSON])
                res.analytics_get_audience_default_application_json_object = out

        return res

    def analytics_list_audiences(self, request: operations.AnalyticsListAudiencesRequest, security: operations.AnalyticsListAudiencesSecurity) -> operations.AnalyticsListAudiencesResponse:
        r"""Get list of audiences."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsListAudiencesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences', request)
        
        query_params = utils.get_query_params(operations.AnalyticsListAudiencesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsListAudiencesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListAudiences200ApplicationJSON])
                res.analytics_list_audiences_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListAudiencesDefaultApplicationJSON])
                res.analytics_list_audiences_default_application_json_object = out

        return res

    def analytics_list_custom_properties(self, request: operations.AnalyticsListCustomPropertiesRequest, security: operations.AnalyticsListCustomPropertiesSecurity) -> operations.AnalyticsListCustomPropertiesResponse:
        r"""Get list of custom properties."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsListCustomPropertiesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/custom_properties', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsListCustomPropertiesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListCustomProperties200ApplicationJSON])
                res.analytics_list_custom_properties_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListCustomPropertiesDefaultApplicationJSON])
                res.analytics_list_custom_properties_default_application_json_object = out

        return res

    def analytics_list_device_properties(self, request: operations.AnalyticsListDevicePropertiesRequest, security: operations.AnalyticsListDevicePropertiesSecurity) -> operations.AnalyticsListDevicePropertiesResponse:
        r"""Get list of device properties."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsListDevicePropertiesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsListDevicePropertiesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListDeviceProperties200ApplicationJSON])
                res.analytics_list_device_properties_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListDevicePropertiesDefaultApplicationJSON])
                res.analytics_list_device_properties_default_application_json_object = out

        return res

    def analytics_list_device_property_values(self, request: operations.AnalyticsListDevicePropertyValuesRequest, security: operations.AnalyticsListDevicePropertyValuesSecurity) -> operations.AnalyticsListDevicePropertyValuesResponse:
        r"""Get list of device property values."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsListDevicePropertyValuesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties/{property_name}/values', request)
        
        query_params = utils.get_query_params(operations.AnalyticsListDevicePropertyValuesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsListDevicePropertyValuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListDevicePropertyValues200ApplicationJSON])
                res.analytics_list_device_property_values_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsListDevicePropertyValuesDefaultApplicationJSON])
                res.analytics_list_device_property_values_default_application_json_object = out

        return res

    def analytics_log_flow(self, request: operations.AnalyticsLogFlowRequest, security: operations.AnalyticsLogFlowSecurity) -> operations.AnalyticsLogFlowResponse:
        r"""Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsLogFlowRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/log_flow', request)
        
        query_params = utils.get_query_params(operations.AnalyticsLogFlowRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsLogFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsLogFlow200ApplicationJSON])
                res.analytics_log_flow_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsLogFlowDefaultApplicationJSON])
                res.analytics_log_flow_default_application_json_object = out

        return res

    def analytics_test_audience(self, request: operations.AnalyticsTestAudienceRequest, security: operations.AnalyticsTestAudienceSecurity) -> operations.AnalyticsTestAudienceResponse:
        r"""Tests audience definition."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnalyticsTestAudienceRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/definition/test', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnalyticsTestAudienceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsTestAudience200ApplicationJSON])
                res.analytics_test_audience_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AnalyticsTestAudienceDefaultApplicationJSON])
                res.analytics_test_audience_default_application_json_object = out

        return res

    def app_block_logs(self, request: operations.AppBlockLogsRequest, security: operations.AppBlockLogsSecurity) -> operations.AppBlockLogsResponse:
        r"""**Warning, this operation is not reversible.** 
        
        A successful call to this API will permanently stop ingesting any logs received via SDK by app_id, and cannot be restored. We advise caution when using this API, it is designed to permanently disable an app_id.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppBlockLogsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/devices/block_logs', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppBlockLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                res.app_block_logs_200_application_json_string_string = http_res.content

        return res

    def crashes_list_session_logs(self, request: operations.CrashesListSessionLogsRequest, security: operations.CrashesListSessionLogsSecurity) -> operations.CrashesListSessionLogsResponse:
        r"""Get session logs by crash ID"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CrashesListSessionLogsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/session_logs', request)
        
        query_params = utils.get_query_params(operations.CrashesListSessionLogsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CrashesListSessionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.CrashesListSessionLogs200ApplicationJSON])
                res.crashes_list_session_logs_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.CrashesListSessionLogsDefaultApplicationJSON])
                res.crashes_list_session_logs_default_application_json_object = out

        return res

    def devices_block_logs(self, request: operations.DevicesBlockLogsRequest, security: operations.DevicesBlockLogsSecurity) -> operations.DevicesBlockLogsResponse:
        r"""**Warning, this operation is not reversible.**
        
         A successful call to this API will permanently stop ingesting any logs received via SDK for the given installation ID, and cannot be restored. We advise caution when using this API, it is designed to permanently disable collection from a specific installation of the app on a device, usually following the request from a user.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesBlockLogsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/devices/block_logs/{install_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesBlockLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                res.devices_block_logs_200_application_json_string_string = http_res.content

        return res

    