"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import maxpodsconstraint as shared_maxpodsconstraint
from ..shared import nodeconfig as shared_nodeconfig
from ..shared import nodemanagement as shared_nodemanagement
from ..shared import nodenetworkconfig as shared_nodenetworkconfig
from ..shared import nodepoolautoscaling as shared_nodepoolautoscaling
from ..shared import placementpolicy as shared_placementpolicy
from ..shared import statuscondition as shared_statuscondition
from ..shared import updateinfo as shared_updateinfo
from ..shared import upgradesettings as shared_upgradesettings
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class NodePoolStatusEnum(str, Enum):
    r"""[Output only] The status of the nodes in this pool instance."""
    STATUS_UNSPECIFIED = 'STATUS_UNSPECIFIED'
    PROVISIONING = 'PROVISIONING'
    RUNNING = 'RUNNING'
    RUNNING_WITH_ERROR = 'RUNNING_WITH_ERROR'
    RECONCILING = 'RECONCILING'
    STOPPING = 'STOPPING'
    ERROR = 'ERROR'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class NodePool:
    r"""NodePool contains the name and configuration for a cluster's node pool. Node pools are a set of nodes (i.e. VM's), with a common configuration and specification, under the control of the cluster master. They may have a set of Kubernetes labels applied to them, which may be used to reference them during pod scheduling. They may also be resized up or down, to accommodate the workload."""
    
    autoscaling: Optional[shared_nodepoolautoscaling.NodePoolAutoscaling] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('autoscaling'), 'exclude': lambda f: f is None }})
    r"""NodePoolAutoscaling contains information required by cluster autoscaler to adjust the size of the node pool to the current cluster usage."""  
    conditions: Optional[list[shared_statuscondition.StatusCondition]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conditions'), 'exclude': lambda f: f is None }})
    r"""Which conditions caused the current node pool state."""  
    config: Optional[shared_nodeconfig.NodeConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config'), 'exclude': lambda f: f is None }})
    r"""Parameters that describe the nodes in a cluster. GKE Autopilot clusters do not recognize parameters in `NodeConfig`. Use AutoprovisioningNodePoolDefaults instead."""  
    etag: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('etag'), 'exclude': lambda f: f is None }})
    r"""This checksum is computed by the server based on the value of node pool fields, and may be sent on update requests to ensure the client has an up-to-date value before proceeding."""  
    initial_node_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('initialNodeCount'), 'exclude': lambda f: f is None }})
    r"""The initial node count for the pool. You must ensure that your Compute Engine [resource quota](https://cloud.google.com/compute/quotas) is sufficient for this number of instances. You must also have available firewall and routes quota."""  
    instance_group_urls: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('instanceGroupUrls'), 'exclude': lambda f: f is None }})
    r"""[Output only] The resource URLs of the [managed instance groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances) associated with this node pool. During the node pool blue-green upgrade operation, the URLs contain both blue and green resources."""  
    locations: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('locations'), 'exclude': lambda f: f is None }})
    r"""The list of Google Compute Engine [zones](https://cloud.google.com/compute/docs/zones#available) in which the NodePool's nodes should be located. If this value is unspecified during node pool creation, the [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations) value will be used, instead. Warning: changing node pool locations will result in nodes being added and/or removed."""  
    management: Optional[shared_nodemanagement.NodeManagement] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('management'), 'exclude': lambda f: f is None }})
    r"""NodeManagement defines the set of node management services turned on for the node pool."""  
    max_pods_constraint: Optional[shared_maxpodsconstraint.MaxPodsConstraint] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxPodsConstraint'), 'exclude': lambda f: f is None }})
    r"""Constraints applied to pods."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name of the node pool."""  
    network_config: Optional[shared_nodenetworkconfig.NodeNetworkConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('networkConfig'), 'exclude': lambda f: f is None }})
    r"""Parameters for node pool-level network config."""  
    placement_policy: Optional[shared_placementpolicy.PlacementPolicy] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('placementPolicy'), 'exclude': lambda f: f is None }})
    r"""PlacementPolicy defines the placement policy used by the node pool."""  
    pod_ipv4_cidr_size: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('podIpv4CidrSize'), 'exclude': lambda f: f is None }})
    r"""[Output only] The pod CIDR block size per node in this node pool."""  
    self_link: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selfLink'), 'exclude': lambda f: f is None }})
    r"""[Output only] Server-defined URL for the resource."""  
    status: Optional[NodePoolStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""[Output only] The status of the nodes in this pool instance."""  
    status_message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('statusMessage'), 'exclude': lambda f: f is None }})
    r"""[Output only] Deprecated. Use conditions instead. Additional information about the current status of this node pool instance, if available."""  
    update_info: Optional[shared_updateinfo.UpdateInfo] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updateInfo'), 'exclude': lambda f: f is None }})
    r"""UpdateInfo contains resource (instance groups, etc), status and other intermediate information relevant to a node pool upgrade."""  
    upgrade_settings: Optional[shared_upgradesettings.UpgradeSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('upgradeSettings'), 'exclude': lambda f: f is None }})
    r"""These upgrade settings control the level of parallelism and the level of disruption caused by an upgrade. maxUnavailable controls the number of nodes that can be simultaneously unavailable. maxSurge controls the number of additional nodes that can be added to the node pool temporarily for the time of the upgrade to increase the number of available nodes. (maxUnavailable + maxSurge) determines the level of parallelism (how many nodes are being upgraded at the same time). Note: upgrades inevitably introduce some disruption since workloads need to be moved from old nodes to new, upgraded ones. Even if maxUnavailable=0, this holds true. (Disruption stays within the limits of PodDisruptionBudget, if it is configured.) Consider a hypothetical node pool with 5 nodes having maxSurge=2, maxUnavailable=1. This means the upgrade process upgrades 3 nodes simultaneously. It creates 2 additional (upgraded) nodes, then it brings down 3 old (not yet upgraded) nodes at the same time. This ensures that there are always at least 4 nodes available. These upgrade settings configure the upgrade strategy for the node pool. Use strategy to switch between the strategies applied to the node pool. If the strategy is ROLLING, use max_surge and max_unavailable to control the level of parallelism and the level of disruption caused by upgrade. 1. maxSurge controls the number of additional nodes that can be added to the node pool temporarily for the time of the upgrade to increase the number of available nodes. 2. maxUnavailable controls the number of nodes that can be simultaneously unavailable. 3. (maxUnavailable + maxSurge) determines the level of parallelism (how many nodes are being upgraded at the same time). If the strategy is BLUE_GREEN, use blue_green_settings to configure the blue-green upgrade related settings. 1. standard_rollout_policy is the default policy. The policy is used to control the way blue pool gets drained. The draining is executed in the batch mode. The batch size could be specified as either percentage of the node pool size or the number of nodes. batch_soak_duration is the soak time after each batch gets drained. 2. node_pool_soak_duration is the soak time after all blue nodes are drained. After this period, the blue pool nodes will be deleted."""  
    version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('version'), 'exclude': lambda f: f is None }})
    r"""The version of Kubernetes running on this NodePool's nodes. If unspecified, it defaults as described [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version)."""  
    