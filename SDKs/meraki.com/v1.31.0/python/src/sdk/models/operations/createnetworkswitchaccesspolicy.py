"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum(str, Enum):
    r"""Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'."""
    EIGHT_HUNDRED_AND_TWO_1X = '802.1x'
    HYBRID_AUTHENTICATION = 'Hybrid authentication'
    MAC_AUTHENTICATION_BYPASS = 'MAC authentication bypass'

class CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum(str, Enum):
    r"""Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'"""
    BOTH = 'both'
    INBOUND = 'inbound'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequestBodyDot1x:
    r"""802.1x Settings"""
    
    control_direction: Optional[CreateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('controlDirection'), 'exclude': lambda f: f is None }})
    r"""Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'"""  
    
class CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum(str, Enum):
    r"""Choose the Host Mode for the access policy."""
    MULTI_AUTH = 'Multi-Auth'
    MULTI_DOMAIN = 'Multi-Domain'
    MULTI_HOST = 'Multi-Host'
    SINGLE_HOST = 'Single-Host'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth:
    r"""Critical auth settings for when authentication is rejected by the RADIUS server"""
    
    data_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataVlanId'), 'exclude': lambda f: f is None }})
    r"""VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth"""  
    suspend_port_bounce: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('suspendPortBounce'), 'exclude': lambda f: f is None }})
    r"""Enable to suspend port bounce when RADIUS servers are unreachable"""  
    voice_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('voiceVlanId'), 'exclude': lambda f: f is None }})
    r"""VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequestBodyRadius:
    r"""Object for RADIUS Settings"""
    
    critical_auth: Optional[CreateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('criticalAuth'), 'exclude': lambda f: f is None }})
    r"""Critical auth settings for when authentication is rejected by the RADIUS server"""  
    failed_auth_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failedAuthVlanId'), 'exclude': lambda f: f is None }})
    r"""VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth"""  
    re_authentication_interval: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reAuthenticationInterval'), 'exclude': lambda f: f is None }})
    r"""Re-authentication period in seconds. Will be null if hostMode is Multi-Auth"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers:
    
    host: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host') }})
    r"""Public IP address of the RADIUS accounting server"""  
    port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port') }})
    r"""UDP port that the RADIUS Accounting server listens on for access requests"""  
    secret: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('secret') }})
    r"""RADIUS client shared secret"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequestBodyRadiusServers:
    
    host: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host') }})
    r"""Public IP address of the RADIUS server"""  
    port: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port') }})
    r"""UDP port that the RADIUS server listens on for access requests"""  
    secret: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('secret') }})
    r"""RADIUS client shared secret"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequestBody:
    
    host_mode: CreateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hostMode') }})
    r"""Choose the Host Mode for the access policy."""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""Name of the access policy"""  
    radius_accounting_enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusAccountingEnabled') }})
    r"""Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients"""  
    radius_coa_support_enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusCoaSupportEnabled') }})
    r"""Change of authentication for RADIUS re-authentication and disconnection"""  
    radius_servers: list[CreateNetworkSwitchAccessPolicyRequestBodyRadiusServers] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusServers') }})
    r"""List of RADIUS servers to require connecting devices to authenticate against before granting network access"""  
    radius_testing_enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusTestingEnabled') }})
    r"""If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers"""  
    url_redirect_walled_garden_enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('urlRedirectWalledGardenEnabled') }})
    r"""Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication"""  
    access_policy_type: Optional[CreateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('accessPolicyType'), 'exclude': lambda f: f is None }})
    r"""Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'."""  
    dot1x: Optional[CreateNetworkSwitchAccessPolicyRequestBodyDot1x] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dot1x'), 'exclude': lambda f: f is None }})
    r"""802.1x Settings"""  
    guest_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('guestVlanId'), 'exclude': lambda f: f is None }})
    r"""ID for the guest VLAN allow unauthorized devices access to limited network resources"""  
    increase_access_speed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('increaseAccessSpeed'), 'exclude': lambda f: f is None }})
    r"""Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication."""  
    radius: Optional[CreateNetworkSwitchAccessPolicyRequestBodyRadius] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radius'), 'exclude': lambda f: f is None }})
    r"""Object for RADIUS Settings"""  
    radius_accounting_servers: Optional[list[CreateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusAccountingServers'), 'exclude': lambda f: f is None }})
    r"""List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access"""  
    radius_group_attribute: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusGroupAttribute'), 'exclude': lambda f: f is None }})
    r"""Acceptable values are `\\"\\"` for None, or `\\"11\\"` for Group Policies ACL"""  
    url_redirect_walled_garden_ranges: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('urlRedirectWalledGardenRanges'), 'exclude': lambda f: f is None }})
    r"""IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication"""  
    voice_vlan_clients: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('voiceVlanClients'), 'exclude': lambda f: f is None }})
    r"""CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'."""  
    

@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyRequest:
    
    network_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'networkId', 'style': 'simple', 'explode': False }})  
    request_body: CreateNetworkSwitchAccessPolicyRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    
class CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum(str, Enum):
    r"""Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'."""
    EIGHT_HUNDRED_AND_TWO_1X = '802.1x'
    HYBRID_AUTHENTICATION = 'Hybrid authentication'
    MAC_AUTHENTICATION_BYPASS = 'MAC authentication bypass'

class CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum(str, Enum):
    r"""Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'"""
    BOTH = 'both'
    INBOUND = 'inbound'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1x:
    r"""802.1x Settings"""
    
    control_direction: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1xControlDirectionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('controlDirection'), 'exclude': lambda f: f is None }})
    r"""Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'"""  
    
class CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum(str, Enum):
    r"""Choose the Host Mode for the access policy."""
    MULTI_AUTH = 'Multi-Auth'
    MULTI_DOMAIN = 'Multi-Domain'
    MULTI_HOST = 'Multi-Host'
    SINGLE_HOST = 'Single-Host'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusCriticalAuth:
    r"""Critical auth settings for when authentication is rejected by the RADIUS server"""
    
    data_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dataVlanId'), 'exclude': lambda f: f is None }})
    r"""VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth"""  
    suspend_port_bounce: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('suspendPortBounce'), 'exclude': lambda f: f is None }})
    r"""Enable to suspend port bounce when RADIUS servers are unreachable"""  
    voice_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('voiceVlanId'), 'exclude': lambda f: f is None }})
    r"""VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicy201ApplicationJSONRadius:
    r"""Object for RADIUS Settings"""
    
    critical_auth: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusCriticalAuth] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('criticalAuth'), 'exclude': lambda f: f is None }})
    r"""Critical auth settings for when authentication is rejected by the RADIUS server"""  
    failed_auth_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failedAuthVlanId'), 'exclude': lambda f: f is None }})
    r"""VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth"""  
    re_authentication_interval: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reAuthenticationInterval'), 'exclude': lambda f: f is None }})
    r"""Re-authentication period in seconds. Will be null if hostMode is Multi-Auth"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusAccountingServers:
    
    host: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Public IP address of the RADIUS accounting server"""  
    port: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""UDP port that the RADIUS Accounting server listens on for access requests"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusServers:
    
    host: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Public IP address of the RADIUS server"""  
    port: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('port'), 'exclude': lambda f: f is None }})
    r"""UDP port that the RADIUS server listens on for access requests"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicy201ApplicationJSON:
    r"""Successful operation"""
    
    access_policy_type: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSONAccessPolicyTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('accessPolicyType'), 'exclude': lambda f: f is None }})
    r"""Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'."""  
    dot1x: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSONDot1x] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dot1x'), 'exclude': lambda f: f is None }})
    r"""802.1x Settings"""  
    guest_vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('guestVlanId'), 'exclude': lambda f: f is None }})
    r"""ID for the guest VLAN allow unauthorized devices access to limited network resources"""  
    host_mode: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSONHostModeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('hostMode'), 'exclude': lambda f: f is None }})
    r"""Choose the Host Mode for the access policy."""  
    increase_access_speed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('increaseAccessSpeed'), 'exclude': lambda f: f is None }})
    r"""Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Name of the access policy"""  
    radius: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSONRadius] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radius'), 'exclude': lambda f: f is None }})
    r"""Object for RADIUS Settings"""  
    radius_accounting_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusAccountingEnabled'), 'exclude': lambda f: f is None }})
    r"""Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients"""  
    radius_accounting_servers: Optional[list[CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusAccountingServers]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusAccountingServers'), 'exclude': lambda f: f is None }})
    r"""List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access"""  
    radius_coa_support_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusCoaSupportEnabled'), 'exclude': lambda f: f is None }})
    r"""Change of authentication for RADIUS re-authentication and disconnection"""  
    radius_group_attribute: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusGroupAttribute'), 'exclude': lambda f: f is None }})
    r"""Acceptable values are `\\"\\"` for None, or `\\"11\\"` for Group Policies ACL"""  
    radius_servers: Optional[list[CreateNetworkSwitchAccessPolicy201ApplicationJSONRadiusServers]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusServers'), 'exclude': lambda f: f is None }})
    r"""List of RADIUS servers to require connecting devices to authenticate against before granting network access"""  
    radius_testing_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('radiusTestingEnabled'), 'exclude': lambda f: f is None }})
    r"""If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers"""  
    url_redirect_walled_garden_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('urlRedirectWalledGardenEnabled'), 'exclude': lambda f: f is None }})
    r"""Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication"""  
    url_redirect_walled_garden_ranges: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('urlRedirectWalledGardenRanges'), 'exclude': lambda f: f is None }})
    r"""IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication"""  
    voice_vlan_clients: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('voiceVlanClients'), 'exclude': lambda f: f is None }})
    r"""CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'."""  
    

@dataclasses.dataclass
class CreateNetworkSwitchAccessPolicyResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    create_network_switch_access_policy_201_application_json_object: Optional[CreateNetworkSwitchAccessPolicy201ApplicationJSON] = dataclasses.field(default=None)
    r"""Successful operation"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    