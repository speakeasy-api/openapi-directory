"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodePool = exports.NodePoolStatusEnum = void 0;
var utils_1 = require("../../../internal/utils");
var maxpodsconstraint_1 = require("./maxpodsconstraint");
var nodeconfig_1 = require("./nodeconfig");
var nodemanagement_1 = require("./nodemanagement");
var nodenetworkconfig_1 = require("./nodenetworkconfig");
var nodepoolautoscaling_1 = require("./nodepoolautoscaling");
var placementpolicy_1 = require("./placementpolicy");
var statuscondition_1 = require("./statuscondition");
var updateinfo_1 = require("./updateinfo");
var upgradesettings_1 = require("./upgradesettings");
var class_transformer_1 = require("class-transformer");
/**
 * [Output only] The status of the nodes in this pool instance.
 */
var NodePoolStatusEnum;
(function (NodePoolStatusEnum) {
    NodePoolStatusEnum["StatusUnspecified"] = "STATUS_UNSPECIFIED";
    NodePoolStatusEnum["Provisioning"] = "PROVISIONING";
    NodePoolStatusEnum["Running"] = "RUNNING";
    NodePoolStatusEnum["RunningWithError"] = "RUNNING_WITH_ERROR";
    NodePoolStatusEnum["Reconciling"] = "RECONCILING";
    NodePoolStatusEnum["Stopping"] = "STOPPING";
    NodePoolStatusEnum["Error"] = "ERROR";
})(NodePoolStatusEnum = exports.NodePoolStatusEnum || (exports.NodePoolStatusEnum = {}));
/**
 * NodePool contains the name and configuration for a cluster's node pool. Node pools are a set of nodes (i.e. VM's), with a common configuration and specification, under the control of the cluster master. They may have a set of Kubernetes labels applied to them, which may be used to reference them during pod scheduling. They may also be resized up or down, to accommodate the workload. These upgrade settings control the level of parallelism and the level of disruption caused by an upgrade. maxUnavailable controls the number of nodes that can be simultaneously unavailable. maxSurge controls the number of additional nodes that can be added to the node pool temporarily for the time of the upgrade to increase the number of available nodes. (maxUnavailable + maxSurge) determines the level of parallelism (how many nodes are being upgraded at the same time). Note: upgrades inevitably introduce some disruption since workloads need to be moved from old nodes to new, upgraded ones. Even if maxUnavailable=0, this holds true. (Disruption stays within the limits of PodDisruptionBudget, if it is configured.) Consider a hypothetical node pool with 5 nodes having maxSurge=2, maxUnavailable=1. This means the upgrade process upgrades 3 nodes simultaneously. It creates 2 additional (upgraded) nodes, then it brings down 3 old (not yet upgraded) nodes at the same time. This ensures that there are always at least 4 nodes available.
 */
var NodePool = /** @class */ (function (_super) {
    __extends(NodePool, _super);
    function NodePool() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "autoscaling" }),
        (0, class_transformer_1.Type)(function () { return nodepoolautoscaling_1.NodePoolAutoscaling; }),
        __metadata("design:type", nodepoolautoscaling_1.NodePoolAutoscaling)
    ], NodePool.prototype, "autoscaling", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: statuscondition_1.StatusCondition }),
        (0, class_transformer_1.Expose)({ name: "conditions" }),
        (0, class_transformer_1.Type)(function () { return statuscondition_1.StatusCondition; }),
        __metadata("design:type", Array)
    ], NodePool.prototype, "conditions", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "config" }),
        (0, class_transformer_1.Type)(function () { return nodeconfig_1.NodeConfig; }),
        __metadata("design:type", nodeconfig_1.NodeConfig)
    ], NodePool.prototype, "config", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "etag" }),
        __metadata("design:type", String)
    ], NodePool.prototype, "etag", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "initialNodeCount" }),
        __metadata("design:type", Number)
    ], NodePool.prototype, "initialNodeCount", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "instanceGroupUrls" }),
        __metadata("design:type", Array)
    ], NodePool.prototype, "instanceGroupUrls", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "locations" }),
        __metadata("design:type", Array)
    ], NodePool.prototype, "locations", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "management" }),
        (0, class_transformer_1.Type)(function () { return nodemanagement_1.NodeManagement; }),
        __metadata("design:type", nodemanagement_1.NodeManagement)
    ], NodePool.prototype, "management", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "maxPodsConstraint" }),
        (0, class_transformer_1.Type)(function () { return maxpodsconstraint_1.MaxPodsConstraint; }),
        __metadata("design:type", maxpodsconstraint_1.MaxPodsConstraint)
    ], NodePool.prototype, "maxPodsConstraint", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "name" }),
        __metadata("design:type", String)
    ], NodePool.prototype, "name", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "networkConfig" }),
        (0, class_transformer_1.Type)(function () { return nodenetworkconfig_1.NodeNetworkConfig; }),
        __metadata("design:type", nodenetworkconfig_1.NodeNetworkConfig)
    ], NodePool.prototype, "networkConfig", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "placementPolicy" }),
        (0, class_transformer_1.Type)(function () { return placementpolicy_1.PlacementPolicy; }),
        __metadata("design:type", placementpolicy_1.PlacementPolicy)
    ], NodePool.prototype, "placementPolicy", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "podIpv4CidrSize" }),
        __metadata("design:type", Number)
    ], NodePool.prototype, "podIpv4CidrSize", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "selfLink" }),
        __metadata("design:type", String)
    ], NodePool.prototype, "selfLink", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "status" }),
        __metadata("design:type", String)
    ], NodePool.prototype, "status", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "statusMessage" }),
        __metadata("design:type", String)
    ], NodePool.prototype, "statusMessage", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "updateInfo" }),
        (0, class_transformer_1.Type)(function () { return updateinfo_1.UpdateInfo; }),
        __metadata("design:type", updateinfo_1.UpdateInfo)
    ], NodePool.prototype, "updateInfo", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "upgradeSettings" }),
        (0, class_transformer_1.Type)(function () { return upgradesettings_1.UpgradeSettings; }),
        __metadata("design:type", upgradesettings_1.UpgradeSettings)
    ], NodePool.prototype, "upgradeSettings", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "version" }),
        __metadata("design:type", String)
    ], NodePool.prototype, "version", void 0);
    return NodePool;
}(utils_1.SpeakeasyBase));
exports.NodePool = NodePool;
