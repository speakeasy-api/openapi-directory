"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class SubscriptionInput:
    r"""A JSON object containing sibscription information"""
    
    custom: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom'), 'exclude': lambda f: f is None }})
    r"""The `custom` value is only for your custom references, you may use it to save additional attributes. The custom value is not used in any other place. This field may contain any datatype that you like: null (default), string, integer, boolean, object etc..."""  
    database_hold_time_h: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('database_hold_time_h'), 'exclude': lambda f: f is None }})
    r"""The number of hours this event is retained in the database. *Only use larger numbers if you know what you are doing.* A couple of hours is enough for most use cases."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Additional field to add some notes about this subscription."""  
    populate_events: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('populate_events'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, resource references in an event (e.g. the location an item moved to) are resolved and populated with data instead of giving just an ID."""  
    target_retry: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('target_retry'), 'exclude': lambda f: f is None }})
    r"""Set to `true` if you want our server to retry if `target_url` is not giving back a `2xx` success code."""  
    target_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('target_url'), 'exclude': lambda f: f is None }})
    r"""Url to an external service that all applicable events are pushed to (webhook). Configure to `null` if you don't wish to use this (default)."""  
    topic_filter: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('topic_filter'), 'exclude': lambda f: f is None }})
    r"""MQTT filter that is applied to all events. Allows you to select and filter events. See [Event filtering](https://intellifi.zendesk.com/hc/en-us/articles/360008791494) for more information"""  
    verify_target_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('verify_target_certificate'), 'exclude': lambda f: f is None }})
    r"""Whether or not the `target_url` endpoint TLS certificate is verified to be valid."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Subscription:
    r"""A JSON object containing the subscription"""
    
    custom: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom'), 'exclude': lambda f: f is None }})
    r"""The `custom` value is only for your custom references, you may use it to save additional attributes. The custom value is not used in any other place. This field may contain any datatype that you like: null (default), string, integer, boolean, object etc..."""  
    database_hold_time_h: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('database_hold_time_h'), 'exclude': lambda f: f is None }})
    r"""The number of hours this event is retained in the database. *Only use larger numbers if you know what you are doing.* A couple of hours is enough for most use cases."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Additional field to add some notes about this subscription."""  
    events_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('events_url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    populate_events: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('populate_events'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, resource references in an event (e.g. the location an item moved to) are resolved and populated with data instead of giving just an ID."""  
    target_delivery_last_failure: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('target_delivery_last_failure'), 'exclude': lambda f: f is None }})
    r"""If `target_url` is set or has been set before, and delivery to the target URL failed at least once, this contains debugging information about the nature of the most recent failure."""  
    target_delivery_status: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('target_delivery_status'), 'exclude': lambda f: f is None }})
    r"""If `target_url` is set, `target_delivery_status.ok` will be `true` or `false` depending on whether events are being succesfully delivered. `target_delivery_status.since` indicates when t his status last changed."""  
    target_retry: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('target_retry'), 'exclude': lambda f: f is None }})
    r"""Set to `true` if you want our server to retry if `target_url` is not giving back a `2xx` success code."""  
    target_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('target_url'), 'exclude': lambda f: f is None }})
    r"""Url to an external service that all applicable events are pushed to (webhook). Configure to `null` if you don't wish to use this (default)."""  
    time_created: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_created'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created."""  
    time_updated: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_updated'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated."""  
    topic_filter: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('topic_filter'), 'exclude': lambda f: f is None }})
    r"""MQTT filter that is applied to all events. Allows you to select and filter events. See [Event filtering](https://intellifi.zendesk.com/hc/en-us/articles/360008791494) for more information"""  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    verify_target_certificate: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('verify_target_certificate'), 'exclude': lambda f: f is None }})
    r"""Whether or not the `target_url` endpoint TLS certificate is verified to be valid."""  
    