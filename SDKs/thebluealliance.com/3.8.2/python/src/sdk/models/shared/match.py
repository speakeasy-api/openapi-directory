"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import match_alliance as shared_match_alliance
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class MatchAlliances:
    r"""A list of alliances, the teams on the alliances, and their score."""
    
    blue: Optional[shared_match_alliance.MatchAlliance] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blue'), 'exclude': lambda f: f is None }})  
    red: Optional[shared_match_alliance.MatchAlliance] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('red'), 'exclude': lambda f: f is None }})  
    
class MatchCompLevelEnum(str, Enum):
    r"""The competition level the match was played at."""
    QM = 'qm'
    EF = 'ef'
    QF = 'qf'
    SF = 'sf'
    F = 'f'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class MatchVideos:
    
    key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})
    r"""Unique key representing this video"""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Can be one of 'youtube' or 'tba'"""  
    
class MatchWinningAllianceEnum(str, Enum):
    r"""The color (red/blue) of the winning alliance. Will contain an empty string in the event of no winner, or a tie."""
    RED = 'red'
    BLUE = 'blue'
    UNKNOWN = ''


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Match:
    r"""Successful response"""
    
    comp_level: MatchCompLevelEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('comp_level') }})
    r"""The competition level the match was played at."""  
    event_key: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('event_key') }})
    r"""Event key of the event the match was played at."""  
    key: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key') }})
    r"""TBA match key with the format `yyyy[EVENT_CODE]_[COMP_LEVEL]m[MATCH_NUMBER]`, where `yyyy` is the year, and `EVENT_CODE` is the event code of the event, `COMP_LEVEL` is (qm, ef, qf, sf, f), and `MATCH_NUMBER` is the match number in the competition level. A set number may be appended to the competition level if more than one match in required per set."""  
    match_number: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('match_number') }})
    r"""The match number of the match in the competition level."""  
    set_number: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('set_number') }})
    r"""The set number in a series of matches where more than one match is required in the match series."""  
    actual_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('actual_time'), 'exclude': lambda f: f is None }})
    r"""UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of actual match start time."""  
    alliances: Optional[MatchAlliances] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('alliances'), 'exclude': lambda f: f is None }})
    r"""A list of alliances, the teams on the alliances, and their score."""  
    post_result_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('post_result_time'), 'exclude': lambda f: f is None }})
    r"""UNIX timestamp (seconds since 1-Jan-1970 00:00:00) when the match result was posted."""  
    predicted_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('predicted_time'), 'exclude': lambda f: f is None }})
    r"""UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the TBA predicted match start time."""  
    score_breakdown: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('score_breakdown'), 'exclude': lambda f: f is None }})
    r"""Score breakdown for auto, teleop, etc. points. Varies from year to year. May be null."""  
    time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time'), 'exclude': lambda f: f is None }})
    r"""UNIX timestamp (seconds since 1-Jan-1970 00:00:00) of the scheduled match time, as taken from the published schedule."""  
    videos: Optional[list[MatchVideos]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('videos'), 'exclude': lambda f: f is None }})
    r"""Array of video objects associated with this match."""  
    winning_alliance: Optional[MatchWinningAllianceEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('winning_alliance'), 'exclude': lambda f: f is None }})
    r"""The color (red/blue) of the winning alliance. Will contain an empty string in the event of no winner, or a tie."""  
    