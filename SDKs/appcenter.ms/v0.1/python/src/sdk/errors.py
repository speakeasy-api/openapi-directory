"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Errors:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def errors_app_builds_list(self, request: operations.ErrorsAppBuildsListRequest, security: operations.ErrorsAppBuildsListSecurity) -> operations.ErrorsAppBuildsListResponse:
        r"""List of app builds"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsAppBuildsListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/availableAppBuilds', request)
        
        query_params = utils.get_query_params(operations.ErrorsAppBuildsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsAppBuildsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsAppBuildsList200ApplicationJSON])
                res.errors_app_builds_list_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsAppBuildsListDefaultApplicationJSON])
                res.errors_app_builds_list_default_application_json_object = out

        return res

    def errors_available_versions(self, request: operations.ErrorsAvailableVersionsRequest, security: operations.ErrorsAvailableVersionsSecurity) -> operations.ErrorsAvailableVersionsResponse:
        r"""Get all available versions in the time range."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsAvailableVersionsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/available_versions', request)
        
        query_params = utils.get_query_params(operations.ErrorsAvailableVersionsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsAvailableVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsAvailableVersions200ApplicationJSON])
                res.errors_available_versions_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsAvailableVersionsDefaultApplicationJSON])
                res.errors_available_versions_default_application_json_object = out

        return res

    def errors_counts_per_day(self, request: operations.ErrorsCountsPerDayRequest, security: operations.ErrorsCountsPerDaySecurity) -> operations.ErrorsCountsPerDayResponse:
        r"""Count of crashes or errors by day in the time range based the selected versions. If SingleErrorTypeParameter is not provided, defaults to handlederror."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsCountsPerDayRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorCountsPerDay', request)
        
        query_params = utils.get_query_params(operations.ErrorsCountsPerDayRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsCountsPerDayResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsCountsPerDay200ApplicationJSON])
                res.errors_counts_per_day_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsCountsPerDayDefaultApplicationJSON])
                res.errors_counts_per_day_default_application_json_object = out

        return res

    def errors_delete_error(self, request: operations.ErrorsDeleteErrorRequest, security: operations.ErrorsDeleteErrorSecurity) -> operations.ErrorsDeleteErrorResponse:
        r"""Delete a specific error and related attachments and blobs for an app. Searchable data will not be deleted immediately and may take up to 30 days."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsDeleteErrorRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsDeleteErrorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsDeleteError200ApplicationJSON])
                res.errors_delete_error_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsDeleteErrorDefaultApplicationJSON])
                res.errors_delete_error_default_application_json_object = out

        return res

    def errors_error_attachment_location(self, request: operations.ErrorsErrorAttachmentLocationRequest, security: operations.ErrorsErrorAttachmentLocationSecurity) -> operations.ErrorsErrorAttachmentLocationResponse:
        r"""Error attachment location."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorAttachmentLocationRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/location', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorAttachmentLocationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorAttachmentLocation200ApplicationJSON])
                res.errors_error_attachment_location_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorAttachmentLocationDefaultApplicationJSON])
                res.errors_error_attachment_location_default_application_json_object = out

        return res

    def errors_error_attachment_text(self, request: operations.ErrorsErrorAttachmentTextRequest, security: operations.ErrorsErrorAttachmentTextSecurity) -> operations.ErrorsErrorAttachmentTextResponse:
        r"""Error attachment text."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorAttachmentTextRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments/{attachmentId}/text', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorAttachmentTextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorAttachmentText200ApplicationJSON])
                res.errors_error_attachment_text_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorAttachmentTextDefaultApplicationJSON])
                res.errors_error_attachment_text_default_application_json_object = out

        return res

    def errors_error_attachments(self, request: operations.ErrorsErrorAttachmentsRequest, security: operations.ErrorsErrorAttachmentsSecurity) -> operations.ErrorsErrorAttachmentsResponse:
        r"""List error attachments."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorAttachmentsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/attachments', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorAttachmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ErrorsErrorAttachments200ApplicationJSON]])
                res.errors_error_attachments_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorAttachmentsDefaultApplicationJSON])
                res.errors_error_attachments_default_application_json_object = out

        return res

    def errors_error_download(self, request: operations.ErrorsErrorDownloadRequest, security: operations.ErrorsErrorDownloadSecurity) -> operations.ErrorsErrorDownloadResponse:
        r"""Download details for a specific error."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorDownloadRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/download', request)
        
        query_params = utils.get_query_params(operations.ErrorsErrorDownloadRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorDownloadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.errors_error_download_200_application_json_file_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorDownloadDefaultApplicationJSON])
                res.errors_error_download_default_application_json_object = out

        return res

    def errors_error_groups_search(self, request: operations.ErrorsErrorGroupsSearchRequest, security: operations.ErrorsErrorGroupsSearchSecurity) -> operations.ErrorsErrorGroupsSearchResponse:
        r"""Error groups list based on search parameters"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorGroupsSearchRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/search', request)
        
        query_params = utils.get_query_params(operations.ErrorsErrorGroupsSearchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorGroupsSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorGroupsSearch200ApplicationJSON])
                res.errors_error_groups_search_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorGroupsSearchDefaultApplicationJSON])
                res.errors_error_groups_search_default_application_json_object = out

        return res

    def errors_error_location(self, request: operations.ErrorsErrorLocationRequest, security: operations.ErrorsErrorLocationSecurity) -> operations.ErrorsErrorLocationResponse:
        r"""Error location."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorLocationRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/location', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorLocationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorLocation200ApplicationJSON])
                res.errors_error_location_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorLocationDefaultApplicationJSON])
                res.errors_error_location_default_application_json_object = out

        return res

    def errors_error_search(self, request: operations.ErrorsErrorSearchRequest, security: operations.ErrorsErrorSearchSecurity) -> operations.ErrorsErrorSearchResponse:
        r"""Errors list based on search parameters"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorSearchRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/search', request)
        
        query_params = utils.get_query_params(operations.ErrorsErrorSearchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorSearch200ApplicationJSON])
                res.errors_error_search_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorSearchDefaultApplicationJSON])
                res.errors_error_search_default_application_json_object = out

        return res

    def errors_error_stack_trace(self, request: operations.ErrorsErrorStackTraceRequest, security: operations.ErrorsErrorStackTraceSecurity) -> operations.ErrorsErrorStackTraceResponse:
        r"""Error Stacktrace details."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsErrorStackTraceRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}/stacktrace', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsErrorStackTraceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DiagnosticsStackTrace])
                res.diagnostics_stack_trace = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsErrorStackTraceDefaultApplicationJSON])
                res.errors_error_stack_trace_default_application_json_object = out

        return res

    def errors_get_error_details(self, request: operations.ErrorsGetErrorDetailsRequest, security: operations.ErrorsGetErrorDetailsSecurity) -> operations.ErrorsGetErrorDetailsResponse:
        r"""Error details."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGetErrorDetailsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/{errorId}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGetErrorDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGetErrorDetails200ApplicationJSON])
                res.errors_get_error_details_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGetErrorDetailsDefaultApplicationJSON])
                res.errors_get_error_details_default_application_json_object = out

        return res

    def errors_group_counts_per_day(self, request: operations.ErrorsGroupCountsPerDayRequest, security: operations.ErrorsGroupCountsPerDaySecurity) -> operations.ErrorsGroupCountsPerDayResponse:
        r"""Count of errors by day in the time range of the selected error group with selected version"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupCountsPerDayRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorCountsPerDay', request)
        
        query_params = utils.get_query_params(operations.ErrorsGroupCountsPerDayRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupCountsPerDayResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupCountsPerDay200ApplicationJSON])
                res.errors_group_counts_per_day_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupCountsPerDayDefaultApplicationJSON])
                res.errors_group_counts_per_day_default_application_json_object = out

        return res

    def errors_group_details(self, request: operations.ErrorsGroupDetailsRequest, security: operations.ErrorsGroupDetailsSecurity) -> operations.ErrorsGroupDetailsResponse:
        r"""Error group details"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupDetailsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupDetails200ApplicationJSON])
                res.errors_group_details_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupDetailsDefaultApplicationJSON])
                res.errors_group_details_default_application_json_object = out

        return res

    def errors_group_error_free_device_percentages(self, request: operations.ErrorsGroupErrorFreeDevicePercentagesRequest, security: operations.ErrorsGroupErrorFreeDevicePercentagesSecurity) -> operations.ErrorsGroupErrorFreeDevicePercentagesResponse:
        r"""Percentage of error-free devices by day in the time range. Api will return -1 if crash devices is greater than active devices"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupErrorFreeDevicePercentagesRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errorfreeDevicePercentages', request)
        
        query_params = utils.get_query_params(operations.ErrorsGroupErrorFreeDevicePercentagesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupErrorFreeDevicePercentagesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupErrorFreeDevicePercentages200ApplicationJSON])
                res.errors_group_error_free_device_percentages_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupErrorFreeDevicePercentagesDefaultApplicationJSON])
                res.errors_group_error_free_device_percentages_default_application_json_object = out

        return res

    def errors_group_error_stack_trace(self, request: operations.ErrorsGroupErrorStackTraceRequest, security: operations.ErrorsGroupErrorStackTraceSecurity) -> operations.ErrorsGroupErrorStackTraceResponse:
        r"""Gets the stack trace for the error group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupErrorStackTraceRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/stacktrace', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupErrorStackTraceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DiagnosticsStackTrace])
                res.diagnostics_stack_trace = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupErrorStackTraceDefaultApplicationJSON])
                res.errors_group_error_stack_trace_default_application_json_object = out

        return res

    def errors_group_list(self, request: operations.ErrorsGroupListRequest, security: operations.ErrorsGroupListSecurity) -> operations.ErrorsGroupListResponse:
        r"""List of error groups"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups', request)
        
        query_params = utils.get_query_params(operations.ErrorsGroupListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupList200ApplicationJSON])
                res.errors_group_list_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupListDefaultApplicationJSON])
                res.errors_group_list_default_application_json_object = out

        return res

    def errors_group_model_counts(self, request: operations.ErrorsGroupModelCountsRequest, security: operations.ErrorsGroupModelCountsSecurity) -> operations.ErrorsGroupModelCountsResponse:
        r"""Top models of the selected error group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupModelCountsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/models', request)
        
        query_params = utils.get_query_params(operations.ErrorsGroupModelCountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupModelCountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupModelCounts200ApplicationJSON])
                res.errors_group_model_counts_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupModelCountsDefaultApplicationJSON])
                res.errors_group_model_counts_default_application_json_object = out

        return res

    def errors_group_operating_system_counts(self, request: operations.ErrorsGroupOperatingSystemCountsRequest, security: operations.ErrorsGroupOperatingSystemCountsSecurity) -> operations.ErrorsGroupOperatingSystemCountsResponse:
        r"""Top OSes of the selected error group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGroupOperatingSystemCountsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/operatingSystems', request)
        
        query_params = utils.get_query_params(operations.ErrorsGroupOperatingSystemCountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGroupOperatingSystemCountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupOperatingSystemCounts200ApplicationJSON])
                res.errors_group_operating_system_counts_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGroupOperatingSystemCountsDefaultApplicationJSON])
                res.errors_group_operating_system_counts_default_application_json_object = out

        return res

    def errors_latest_error_details(self, request: operations.ErrorsLatestErrorDetailsRequest, security: operations.ErrorsLatestErrorDetailsSecurity) -> operations.ErrorsLatestErrorDetailsResponse:
        r"""Latest error details."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsLatestErrorDetailsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors/latest', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsLatestErrorDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsLatestErrorDetails200ApplicationJSON])
                res.errors_latest_error_details_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsLatestErrorDetailsDefaultApplicationJSON])
                res.errors_latest_error_details_default_application_json_object = out

        return res

    def errors_list_for_group(self, request: operations.ErrorsListForGroupRequest, security: operations.ErrorsListForGroupSecurity) -> operations.ErrorsListForGroupResponse:
        r"""Get all errors for group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsListForGroupRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}/errors', request)
        
        query_params = utils.get_query_params(operations.ErrorsListForGroupRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsListForGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsListForGroup200ApplicationJSON])
                res.errors_list_for_group_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsListForGroupDefaultApplicationJSON])
                res.errors_list_for_group_default_application_json_object = out

        return res

    def errors_list_session_logs(self, request: operations.ErrorsListSessionLogsRequest, security: operations.ErrorsListSessionLogsSecurity) -> operations.ErrorsListSessionLogsResponse:
        r"""Get session logs by error ID"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsListSessionLogsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/{errorId}/sessionLogs', request)
        
        query_params = utils.get_query_params(operations.ErrorsListSessionLogsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsListSessionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsListSessionLogs200ApplicationJSON])
                res.errors_list_session_logs_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsListSessionLogsDefaultApplicationJSON])
                res.errors_list_session_logs_default_application_json_object = out

        return res

    def errors_update_state(self, request: operations.ErrorsUpdateStateRequest, security: operations.ErrorsUpdateStateSecurity) -> operations.ErrorsUpdateStateResponse:
        r"""Update error group state"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsUpdateStateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/errorGroups/{errorGroupId}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsUpdateStateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsUpdateState200ApplicationJSON])
                res.errors_update_state_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsUpdateStateDefaultApplicationJSON])
                res.errors_update_state_default_application_json_object = out

        return res

    def errors_get_retention_settings(self, request: operations.ErrorsGetRetentionSettingsRequest, security: operations.ErrorsGetRetentionSettingsSecurity) -> operations.ErrorsGetRetentionSettingsResponse:
        r"""gets the retention settings in days
        gets the retention settings in days
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ErrorsGetRetentionSettingsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/errors/retention_settings', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ErrorsGetRetentionSettingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGetRetentionSettings200ApplicationJSON])
                res.errors_get_retention_settings_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ErrorsGetRetentionSettingsDefaultApplicationJSON])
                res.errors_get_retention_settings_default_application_json_object = out

        return res

    