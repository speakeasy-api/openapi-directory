/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Address } from "./address";
import { ErrorT } from "./error";
import { V1Money } from "./v1money";
import { V1OrderHistoryEntry } from "./v1orderhistoryentry";
import { V1Tender } from "./v1tender";
import { Expose, Type } from "class-transformer";

/**
 * V1Order
 */
export class V1Order extends SpeakeasyBase {
  /**
   * For Bitcoin transactions, the price of the buyer's order in satoshi (100 million satoshi equals 1 BTC).
   */
  @SpeakeasyMetadata()
  @Expose({ name: "btc_price_satoshi" })
  btcPriceSatoshi?: number;

  /**
   * For Bitcoin transactions, the address that the buyer sent Bitcoin to.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "btc_receive_address" })
  btcReceiveAddress?: string;

  /**
   * The email address of the order's buyer.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "buyer_email" })
  buyerEmail?: string;

  /**
   * A note provided by the buyer when the order was created, if any.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "buyer_note" })
  buyerNote?: string;

  /**
   * A note provided by the merchant when the order's state was set to CANCELED, if any.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "canceled_note" })
  canceledNote?: string;

  /**
   * A note provided by the merchant when the order's state was set to COMPLETED, if any
   */
  @SpeakeasyMetadata()
  @Expose({ name: "completed_note" })
  completedNote?: string;

  /**
   * The time when the order was created, in ISO 8601 format.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "created_at" })
  createdAt?: string;

  /**
   * Any errors that occurred during the request.
   */
  @SpeakeasyMetadata({ elemType: ErrorT })
  @Expose({ name: "errors" })
  @Type(() => ErrorT)
  errors?: ErrorT[];

  /**
   * The time when the order expires if no action is taken, in ISO 8601 format.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "expires_at" })
  expiresAt?: string;

  /**
   * The order's unique identifier.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: string;

  /**
   * The history of actions associated with the order.
   */
  @SpeakeasyMetadata({ elemType: V1OrderHistoryEntry })
  @Expose({ name: "order_history" })
  @Type(() => V1OrderHistoryEntry)
  orderHistory?: V1OrderHistoryEntry[];

  /**
   * The unique identifier of the payment associated with the order.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "payment_id" })
  paymentId?: string;

  /**
   * The promo code provided by the buyer, if any.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "promo_code" })
  promoCode?: string;

  /**
   * The name of the order's buyer.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "recipient_name" })
  recipientName?: string;

  /**
   * The phone number to use for the order's delivery.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "recipient_phone_number" })
  recipientPhoneNumber?: string;

  /**
   * A note provided by the merchant when the order's state was set to REFUNDED, if any.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "refunded_note" })
  refundedNote?: string;

  /**
   * Represents a postal address in a country. The address format is based
   *
   * @remarks
   * on an [open-source library from Google](https://github.com/google/libaddressinput). For more information,
   * see [AddressValidationMetadata](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata).
   * This format has dedicated fields for four address components: postal code,
   * locality (city), administrative district (state, prefecture, or province), and
   * sublocality (town or village). These components have dedicated fields in the
   * `Address` object because software sometimes behaves differently based on them.
   * For example, sales tax software may charge different amounts of sales tax
   * based on the postal code, and some software is only available in
   * certain states due to compliance reasons.
   *
   * For the remaining address components, the `Address` type provides the
   * `address_line_1` and `address_line_2` fields for free-form data entry.
   * These fields are free-form because the remaining address components have
   * too many variations around the world and typical software does not parse
   * these components. These fields enable users to enter anything they want.
   *
   * Note that, in the current implementation, all other `Address` type fields are blank.
   * These include `address_line_3`, `sublocality_2`, `sublocality_3`,
   * `administrative_district_level_2`, `administrative_district_level_3`,
   * `first_name`, `last_name`, and `organization`.
   *
   * When it comes to localization, the seller's language preferences
   * (see [Language preferences](https://developer.squareup.com/docs/locations-api#location-specific-and-seller-level-language-preferences))
   * are ignored for addresses. Even though Square products (such as Square Point of Sale
   * and the Seller Dashboard) mostly use a seller's language preference in
   * communication, when it comes to addresses, they will use English for a US address,
   * Japanese for an address in Japan, and so on.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "shipping_address" })
  @Type(() => Address)
  shippingAddress?: Address;

  /**
   * Whether the tax is an ADDITIVE tax or an INCLUSIVE tax.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "state" })
  state?: string;

  @SpeakeasyMetadata()
  @Expose({ name: "subtotal_money" })
  @Type(() => V1Money)
  subtotalMoney?: V1Money;

  /**
   * A tender represents a discrete monetary exchange. Square represents this
   *
   * @remarks
   * exchange as a money object with a specific currency and amount, where the
   * amount is given in the smallest denomination of the given currency.
   *
   * Square POS can accept more than one form of tender for a single payment (such
   * as by splitting a bill between a credit card and a gift card). The `tender`
   * field of the Payment object lists all forms of tender used for the payment.
   *
   * Split tender payments behave slightly differently from single tender payments:
   *
   * The receipt_url for a split tender corresponds only to the first tender listed
   * in the tender field. To get the receipt URLs for the remaining tenders, use
   * the receipt_url fields of the corresponding Tender objects.
   *
   * *A note on gift cards**: when a customer purchases a Square gift card from a
   * merchant, the merchant receives the full amount of the gift card in the
   * associated payment.
   *
   * When that gift card is used as a tender, the balance of the gift card is
   * reduced and the merchant receives no funds. A `Tender` object with a type of
   * `SQUARE_GIFT_CARD` indicates a gift card was used for some or all of the
   * associated payment.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "tender" })
  @Type(() => V1Tender)
  tender?: V1Tender;

  @SpeakeasyMetadata()
  @Expose({ name: "total_discount_money" })
  @Type(() => V1Money)
  totalDiscountMoney?: V1Money;

  @SpeakeasyMetadata()
  @Expose({ name: "total_price_money" })
  @Type(() => V1Money)
  totalPriceMoney?: V1Money;

  @SpeakeasyMetadata()
  @Expose({ name: "total_shipping_money" })
  @Type(() => V1Money)
  totalShippingMoney?: V1Money;

  @SpeakeasyMetadata()
  @Expose({ name: "total_tax_money" })
  @Type(() => V1Money)
  totalTaxMoney?: V1Money;

  /**
   * The time when the order was last modified, in ISO 8601 format.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "updated_at" })
  updatedAt?: string;
}
