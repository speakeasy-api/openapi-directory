// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetPlaylistsPlaylistIDTracksSecurity struct {
	AuthHeader string `security:"scheme,type=apiKey,subtype=header,name=Authorization"`
	ClientID   string `security:"scheme,type=apiKey,subtype=query,name=client_id"`
}

type GetPlaylistsPlaylistIDTracksRequest struct {
	// Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	//
	Access []shared.AccessEnum `queryParam:"style=form,explode=false,name=access"`
	// Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *bool `queryParam:"style=form,explode=true,name=linked_partitioning"`
	// SoundCloud playlist id
	PlaylistID int64 `pathParam:"style=simple,explode=false,name=playlist_id"`
	// A secret token to fetch private playlists/tracks
	SecretToken *string `queryParam:"style=form,explode=true,name=secret_token"`
}

type GetPlaylistsPlaylistIDTracks200ApplicationJSONType string

const (
	GetPlaylistsPlaylistIDTracks200ApplicationJSONTypeTracks       GetPlaylistsPlaylistIDTracks200ApplicationJSONType = "Tracks"
	GetPlaylistsPlaylistIDTracks200ApplicationJSONTypeArrayOfTrack GetPlaylistsPlaylistIDTracks200ApplicationJSONType = "arrayOfTrack"
)

type GetPlaylistsPlaylistIDTracks200ApplicationJSON struct {
	Tracks       *shared.Tracks
	ArrayOfTrack []shared.Track

	Type GetPlaylistsPlaylistIDTracks200ApplicationJSONType
}

func CreateGetPlaylistsPlaylistIDTracks200ApplicationJSONTracks(tracks shared.Tracks) GetPlaylistsPlaylistIDTracks200ApplicationJSON {
	typ := GetPlaylistsPlaylistIDTracks200ApplicationJSONTypeTracks

	return GetPlaylistsPlaylistIDTracks200ApplicationJSON{
		Tracks: &tracks,
		Type:   typ,
	}
}

func CreateGetPlaylistsPlaylistIDTracks200ApplicationJSONArrayOfTrack(arrayOfTrack []shared.Track) GetPlaylistsPlaylistIDTracks200ApplicationJSON {
	typ := GetPlaylistsPlaylistIDTracks200ApplicationJSONTypeArrayOfTrack

	return GetPlaylistsPlaylistIDTracks200ApplicationJSON{
		ArrayOfTrack: arrayOfTrack,
		Type:         typ,
	}
}

func (u *GetPlaylistsPlaylistIDTracks200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	tracks := new(shared.Tracks)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&tracks); err == nil {
		u.Tracks = tracks
		u.Type = GetPlaylistsPlaylistIDTracks200ApplicationJSONTypeTracks
		return nil
	}

	arrayOfTrack := []shared.Track{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfTrack); err == nil {
		u.ArrayOfTrack = arrayOfTrack
		u.Type = GetPlaylistsPlaylistIDTracks200ApplicationJSONTypeArrayOfTrack
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetPlaylistsPlaylistIDTracks200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.Tracks != nil {
		return json.Marshal(u.Tracks)
	}

	if u.ArrayOfTrack != nil {
		return json.Marshal(u.ArrayOfTrack)
	}

	return nil, nil
}

type GetPlaylistsPlaylistIDTracksResponse struct {
	ContentType string
	// Bad Request
	Error       *shared.Error
	StatusCode  int
	RawResponse *http.Response
	// Success
	GetPlaylistsPlaylistIDTracks200ApplicationJSONOneOf *GetPlaylistsPlaylistIDTracks200ApplicationJSON
}
