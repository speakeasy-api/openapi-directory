"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Pipelines:
    r"""Bitbucket Pipelines brings continuous delivery to Bitbucket
    Cloud, empowering teams with full branching to deployment
    visibility and faster feedback loops.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def create_deployment_variable(self, request: operations.CreateDeploymentVariableRequest) -> operations.CreateDeploymentVariableResponse:
        r"""Create a variable for an environment
        Create a deployment environment level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateDeploymentVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeploymentVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.deployment_variable = out
        elif http_res.status_code in [404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_pipeline_for_repository(self, request: operations.CreatePipelineForRepositoryRequest) -> operations.CreatePipelineForRepositoryResponse:
        r"""Run a pipeline
        Endpoint to create and initiate a pipeline.
        There are a couple of different options to initiate a pipeline, where the payload of the request will determine which type of pipeline will be instantiated.
        # Trigger a Pipeline for a branch
        One way to trigger pipelines is by specifying the branch for which you want to trigger a pipeline.
        The specified branch will be used to determine which pipeline definition from the `bitbucket-pipelines.yml` file will be applied to initiate the pipeline. The pipeline will then do a clone of the repository and checkout the latest revision of the specified branch.
        
        ### Example
        
        ```
        $ curl -X POST -is -u username:password \
          -H 'Content-Type: application/json' \
         https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
          -d '
          {
            \"target\": {
              \"ref_type\": \"branch\",
              \"type\": \"pipeline_ref_target\",
              \"ref_name\": \"master\"
            }
          }'
        ```
        # Trigger a Pipeline for a commit on a branch or tag
        You can initiate a pipeline for a specific commit and in the context of a specified reference (e.g. a branch, tag or bookmark).
        The specified reference will be used to determine which pipeline definition from the bitbucket-pipelines.yml file will be applied to initiate the pipeline. The pipeline will clone the repository and then do a checkout the specified reference.
        
        The following reference types are supported:
        
        * `branch`
        * `named_branch`
        * `bookmark`
         * `tag`
        
        ### Example
        
        ```
        $ curl -X POST -is -u username:password \
          -H 'Content-Type: application/json' \
          https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
          -d '
          {
            \"target\": {
              \"commit\": {
                \"type\": \"commit\",
                \"hash\": \"ce5b7431602f7cbba007062eeb55225c6e18e956\"
              },
              \"ref_type\": \"branch\",
              \"type\": \"pipeline_ref_target\",
              \"ref_name\": \"master\"
            }
          }'
        ```
        # Trigger a specific pipeline definition for a commit
        You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit.
        In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition. The resulting pipeline will then clone the repository and checkout the specified revision.
        
        ### Example
        
        ```
        $ curl -X POST -is -u username:password \
          -H 'Content-Type: application/json' \
         https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
         -d '
          {
             \"target\": {
              \"commit\": {
                 \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",
                 \"type\":\"commit\"
               },
                \"selector\": {
                   \"type\":\"custom\",
                      \"pattern\":\"Deploy to production\"
                  },
                \"type\":\"pipeline_commit_target\"
           }
          }'
        ```
        # Trigger a specific pipeline definition for a commit on a branch or tag
        You can trigger a specific pipeline that is defined in your `bitbucket-pipelines.yml` file for a specific commit in the context of a specified reference.
        In addition to the commit revision, you specify the type and pattern of the selector that identifies the pipeline definition, as well as the reference information. The resulting pipeline will then clone the repository a checkout the specified reference.
        
        ### Example
        
        ```
        $ curl -X POST -is -u username:password \
          -H 'Content-Type: application/json' \
         https://api.bitbucket.org/2.0/repositories/jeroendr/meat-demo2/pipelines/ \
         -d '
          {
             \"target\": {
              \"commit\": {
                 \"hash\":\"a3c4e02c9a3755eccdc3764e6ea13facdf30f923\",
                 \"type\":\"commit\"
               },
               \"selector\": {
                  \"type\": \"custom\",
                  \"pattern\": \"Deploy to production\"
               },
               \"type\": \"pipeline_ref_target\",
               \"ref_name\": \"master\",
               \"ref_type\": \"branch\"
             }
          }'
        ```
        
        
        # Trigger a custom pipeline with variables
        In addition to triggering a custom pipeline that is defined in your `bitbucket-pipelines.yml` file as shown in the examples above, you can specify variables that will be available for your build. In the request, provide a list of variables, specifying the following for each variable: key, value, and whether it should be secured or not (this field is optional and defaults to not secured).
        
        ### Example
        
        ```
        $ curl -X POST -is -u username:password \
          -H 'Content-Type: application/json' \
         https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
         -d '
          {
            \"target\": {
              \"type\": \"pipeline_ref_target\",
              \"ref_type\": \"branch\",
              \"ref_name\": \"master\",
              \"selector\": {
                \"type\": \"custom\",
                \"pattern\": \"Deploy to production\"
              }
            },
            \"variables\": [
              {
                \"key\": \"var1key\",
                \"value\": \"var1value\",
                \"secured\": true
              },
              {
                \"key\": \"var2key\",
                \"value\": \"var2value\"
              }
            ]
          }'
        ```
        
        # Trigger a pull request pipeline
        
        You can also initiate a pipeline for a specific pull request.
        
        ### Example
        
        ```
        $ curl -X POST -is -u username:password \
          -H 'Content-Type: application/json' \
         https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/pipelines/ \
         -d '
          {
        	\"target\": {
              \"type\": \"pipeline_pullrequest_target\",
        	  \"source\": \"pull-request-branch\",
              \"destination\": \"master\",
              \"destination_commit\": {
              	 \"hash\" : \"9f848b7\"
              },
              \"commit\": {
              	\"hash\" : \"1a372fc\"
              },
              \"pullrequest\" : {
              	\"id\" : \"3\"
              },
        	  \"selector\": {
                \"type\": \"pull-requests\",
                \"pattern\": \"**\"
              }
            }
          }'
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreatePipelineForRepositoryRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePipelineForRepositoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_pipeline_variable_for_team(self, request: operations.CreatePipelineVariableForTeamRequest) -> operations.CreatePipelineVariableForTeamResponse:
        r"""Create a variable for a user
        Create an account level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreatePipelineVariableForTeamRequest, base_url, '/teams/{username}/pipelines_config/variables/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePipelineVariableForTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code in [404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_pipeline_variable_for_user(self, request: operations.CreatePipelineVariableForUserRequest) -> operations.CreatePipelineVariableForUserResponse:
        r"""Create a variable for a user
        Create a user level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreatePipelineVariableForUserRequest, base_url, '/users/{selected_user}/pipelines_config/variables/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePipelineVariableForUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code in [404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_pipeline_variable_for_workspace(self, request: operations.CreatePipelineVariableForWorkspaceRequest) -> operations.CreatePipelineVariableForWorkspaceResponse:
        r"""Create a variable for a workspace
        Create a workspace level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreatePipelineVariableForWorkspaceRequest, base_url, '/workspaces/{workspace}/pipelines-config/variables', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreatePipelineVariableForWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code in [404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_repository_pipeline_known_host(self, request: operations.CreateRepositoryPipelineKnownHostRequest) -> operations.CreateRepositoryPipelineKnownHostResponse:
        r"""Create a known host
        Create a repository level known host.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateRepositoryPipelineKnownHostRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRepositoryPipelineKnownHostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_known_host = out
        elif http_res.status_code in [404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_repository_pipeline_schedule(self, request: operations.CreateRepositoryPipelineScheduleRequest) -> operations.CreateRepositoryPipelineScheduleResponse:
        r"""Create a schedule
        Create a schedule for the given repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateRepositoryPipelineScheduleRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRepositoryPipelineScheduleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_schedule = out
        elif http_res.status_code in [400, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def create_repository_pipeline_variable(self, request: operations.CreateRepositoryPipelineVariableRequest) -> operations.CreateRepositoryPipelineVariableResponse:
        r"""Create a variable for a repository
        Create a repository level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateRepositoryPipelineVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateRepositoryPipelineVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code in [404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_deployment_variable(self, request: operations.DeleteDeploymentVariableRequest) -> operations.DeleteDeploymentVariableResponse:
        r"""Delete a variable for an environment
        Delete a deployment environment level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteDeploymentVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteDeploymentVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_pipeline_variable_for_team(self, request: operations.DeletePipelineVariableForTeamRequest) -> operations.DeletePipelineVariableForTeamResponse:
        r"""Delete a variable for a team
        Delete a team level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeletePipelineVariableForTeamRequest, base_url, '/teams/{username}/pipelines_config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeletePipelineVariableForTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_pipeline_variable_for_user(self, request: operations.DeletePipelineVariableForUserRequest) -> operations.DeletePipelineVariableForUserResponse:
        r"""Delete a variable for a user
        Delete an account level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeletePipelineVariableForUserRequest, base_url, '/users/{selected_user}/pipelines_config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeletePipelineVariableForUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_pipeline_variable_for_workspace(self, request: operations.DeletePipelineVariableForWorkspaceRequest) -> operations.DeletePipelineVariableForWorkspaceResponse:
        r"""Delete a variable for a workspace
        Delete a workspace level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeletePipelineVariableForWorkspaceRequest, base_url, '/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeletePipelineVariableForWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repository_pipeline_cache(self, request: operations.DeleteRepositoryPipelineCacheRequest) -> operations.DeleteRepositoryPipelineCacheResponse:
        r"""Delete a cache
        Delete a repository cache.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoryPipelineCacheRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoryPipelineCacheResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repository_pipeline_caches(self, request: operations.DeleteRepositoryPipelineCachesRequest) -> operations.DeleteRepositoryPipelineCachesResponse:
        r"""Delete caches
        Delete repository cache versions by name.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoryPipelineCachesRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches', request)
        
        query_params = utils.get_query_params(operations.DeleteRepositoryPipelineCachesRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoryPipelineCachesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repository_pipeline_key_pair(self, request: operations.DeleteRepositoryPipelineKeyPairRequest) -> operations.DeleteRepositoryPipelineKeyPairResponse:
        r"""Delete SSH key pair
        Delete the repository SSH key pair.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoryPipelineKeyPairRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoryPipelineKeyPairResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repository_pipeline_known_host(self, request: operations.DeleteRepositoryPipelineKnownHostRequest) -> operations.DeleteRepositoryPipelineKnownHostResponse:
        r"""Delete a known host
        Delete a repository level known host.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoryPipelineKnownHostRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoryPipelineKnownHostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repository_pipeline_schedule(self, request: operations.DeleteRepositoryPipelineScheduleRequest) -> operations.DeleteRepositoryPipelineScheduleResponse:
        r"""Delete a schedule
        Delete a schedule.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoryPipelineScheduleRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoryPipelineScheduleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repository_pipeline_variable(self, request: operations.DeleteRepositoryPipelineVariableRequest) -> operations.DeleteRepositoryPipelineVariableResponse:
        r"""Delete a variable for a repository
        Delete a repository level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoryPipelineVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoryPipelineVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_deployment_variables(self, request: operations.GetDeploymentVariablesRequest) -> operations.GetDeploymentVariablesResponse:
        r"""List variables for an environment
        Find deployment environment level variables.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetDeploymentVariablesRequest, base_url, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetDeploymentVariablesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedDeploymentVariable])
                res.paginated_deployment_variable = out

        return res

    def get_oidc_configuration(self, request: operations.GetOIDCConfigurationRequest) -> operations.GetOIDCConfigurationResponse:
        r"""Get OpenID configuration for OIDC in Pipelines
        This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetOIDCConfigurationRequest, base_url, '/workspaces/{workspace}/pipelines-config/identity/oidc/.well-known/openid-configuration', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetOIDCConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_oidc_keys(self, request: operations.GetOIDCKeysRequest) -> operations.GetOIDCKeysResponse:
        r"""Get keys for OIDC in Pipelines
        This is part of OpenID Connect for Pipelines, see https://support.atlassian.com/bitbucket-cloud/docs/integrate-pipelines-with-resource-servers-using-oidc/
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetOIDCKeysRequest, base_url, '/workspaces/{workspace}/pipelines-config/identity/oidc/keys.json', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetOIDCKeysResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_container_log(self, request: operations.GetPipelineContainerLogRequest) -> operations.GetPipelineContainerLogResponse:
        r"""Get the logs for the build container or a service container for a given step of a pipeline.
        Retrieve the log file for a build container or service container.
        
        This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineContainerLogRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/logs/{log_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineContainerLogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/octet-stream'):
                res.body = http_res.content

        return res

    def get_pipeline_for_repository(self, request: operations.GetPipelineForRepositoryRequest) -> operations.GetPipelineForRepositoryResponse:
        r"""Get a pipeline
        Retrieve a specified pipeline
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineForRepositoryRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineForRepositoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_step_for_repository(self, request: operations.GetPipelineStepForRepositoryRequest) -> operations.GetPipelineStepForRepositoryResponse:
        r"""Get a step of a pipeline
        Retrieve a given step of a pipeline.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineStepForRepositoryRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineStepForRepositoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_step = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_step_log_for_repository(self, request: operations.GetPipelineStepLogForRepositoryRequest) -> operations.GetPipelineStepLogForRepositoryResponse:
        r"""Get log file for a step
        Retrieve the log file for a given step of a pipeline.
        
        This endpoint supports (and encourages!) the use of [HTTP Range requests](https://tools.ietf.org/html/rfc7233) to deal with potentially very large log files.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineStepLogForRepositoryRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/log', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineStepLogForRepositoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code in [304, 404, 416]:
            if utils.match_content_type(content_type, 'application/octet-stream'):
                res.body = http_res.content

        return res

    def get_pipeline_steps_for_repository(self, request: operations.GetPipelineStepsForRepositoryRequest) -> operations.GetPipelineStepsForRepositoryResponse:
        r"""List steps for a pipeline
        Find steps for the given pipeline.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineStepsForRepositoryRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineStepsForRepositoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineSteps])
                res.paginated_pipeline_steps = out

        return res

    def get_pipeline_test_report_test_case_reasons(self, request: operations.GetPipelineTestReportTestCaseReasonsRequest) -> operations.GetPipelineTestReportTestCaseReasonsResponse:
        r"""Get test case reasons (output) for a given test case in a step of a pipeline."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineTestReportTestCaseReasonsRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases/{test_case_uuid}/test_case_reasons', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineTestReportTestCaseReasonsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_test_report_test_cases(self, request: operations.GetPipelineTestReportTestCasesRequest) -> operations.GetPipelineTestReportTestCasesResponse:
        r"""Get test cases for a given step of a pipeline."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineTestReportTestCasesRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports/test_cases', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineTestReportTestCasesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_test_reports(self, request: operations.GetPipelineTestReportsRequest) -> operations.GetPipelineTestReportsResponse:
        r"""Get a summary of test reports for a given step of a pipeline."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineTestReportsRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/steps/{step_uuid}/test_reports', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineTestReportsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_variable_for_team(self, request: operations.GetPipelineVariableForTeamRequest) -> operations.GetPipelineVariableForTeamResponse:
        r"""Get a variable for a team
        Retrieve a team level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineVariableForTeamRequest, base_url, '/teams/{username}/pipelines_config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineVariableForTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_variable_for_user(self, request: operations.GetPipelineVariableForUserRequest) -> operations.GetPipelineVariableForUserResponse:
        r"""Get a variable for a user
        Retrieve a user level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineVariableForUserRequest, base_url, '/users/{selected_user}/pipelines_config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineVariableForUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_variable_for_workspace(self, request: operations.GetPipelineVariableForWorkspaceRequest) -> operations.GetPipelineVariableForWorkspaceResponse:
        r"""Get variable for a workspace
        Retrieve a workspace level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineVariableForWorkspaceRequest, base_url, '/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineVariableForWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_pipeline_variables_for_team(self, request: operations.GetPipelineVariablesForTeamRequest) -> operations.GetPipelineVariablesForTeamResponse:
        r"""List variables for an account
        Find account level variables.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineVariablesForTeamRequest, base_url, '/teams/{username}/pipelines_config/variables/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineVariablesForTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineVariables])
                res.paginated_pipeline_variables = out

        return res

    def get_pipeline_variables_for_user(self, request: operations.GetPipelineVariablesForUserRequest) -> operations.GetPipelineVariablesForUserResponse:
        r"""List variables for a user
        Find user level variables.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineVariablesForUserRequest, base_url, '/users/{selected_user}/pipelines_config/variables/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineVariablesForUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineVariables])
                res.paginated_pipeline_variables = out

        return res

    def get_pipeline_variables_for_workspace(self, request: operations.GetPipelineVariablesForWorkspaceRequest) -> operations.GetPipelineVariablesForWorkspaceResponse:
        r"""List variables for a workspace
        Find workspace level variables.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelineVariablesForWorkspaceRequest, base_url, '/workspaces/{workspace}/pipelines-config/variables', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelineVariablesForWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineVariables])
                res.paginated_pipeline_variables = out

        return res

    def get_pipelines_for_repository(self, request: operations.GetPipelinesForRepositoryRequest) -> operations.GetPipelinesForRepositoryResponse:
        r"""List pipelines
        Find pipelines
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPipelinesForRepositoryRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPipelinesForRepositoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelines])
                res.paginated_pipelines = out

        return res

    def get_repository_pipeline_cache_content_uri(self, request: operations.GetRepositoryPipelineCacheContentURIRequest) -> operations.GetRepositoryPipelineCacheContentURIResponse:
        r"""Get cache content URI
        Retrieve the URI of the content of the specified cache.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineCacheContentURIRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches/{cache_uuid}/content-uri', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineCacheContentURIResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PipelineCacheContentURI])
                res.pipeline_cache_content_uri = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_caches(self, request: operations.GetRepositoryPipelineCachesRequest) -> operations.GetRepositoryPipelineCachesResponse:
        r"""List caches
        Retrieve the repository pipelines caches.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineCachesRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines-config/caches/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineCachesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineCaches])
                res.paginated_pipeline_caches = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_config(self, request: operations.GetRepositoryPipelineConfigRequest) -> operations.GetRepositoryPipelineConfigResponse:
        r"""Get configuration
        Retrieve the repository pipelines configuration.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineConfigRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipelines_config = out

        return res

    def get_repository_pipeline_known_host(self, request: operations.GetRepositoryPipelineKnownHostRequest) -> operations.GetRepositoryPipelineKnownHostResponse:
        r"""Get a known host
        Retrieve a repository level known host.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineKnownHostRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineKnownHostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_known_host = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_known_hosts(self, request: operations.GetRepositoryPipelineKnownHostsRequest) -> operations.GetRepositoryPipelineKnownHostsResponse:
        r"""List known hosts
        Find repository level known hosts.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineKnownHostsRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineKnownHostsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineKnownHosts])
                res.paginated_pipeline_known_hosts = out

        return res

    def get_repository_pipeline_schedule(self, request: operations.GetRepositoryPipelineScheduleRequest) -> operations.GetRepositoryPipelineScheduleResponse:
        r"""Get a schedule
        Retrieve a schedule by its UUID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineScheduleRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineScheduleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_schedule = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_schedule_executions(self, request: operations.GetRepositoryPipelineScheduleExecutionsRequest) -> operations.GetRepositoryPipelineScheduleExecutionsResponse:
        r"""List executions of a schedule
        Retrieve the executions of a given schedule.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineScheduleExecutionsRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}/executions/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineScheduleExecutionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineScheduleExecutions])
                res.paginated_pipeline_schedule_executions = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_schedules(self, request: operations.GetRepositoryPipelineSchedulesRequest) -> operations.GetRepositoryPipelineSchedulesResponse:
        r"""List schedules
        Retrieve the configured schedules for the given repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineSchedulesRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineSchedulesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineSchedules])
                res.paginated_pipeline_schedules = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_ssh_key_pair(self, request: operations.GetRepositoryPipelineSSHKeyPairRequest) -> operations.GetRepositoryPipelineSSHKeyPairResponse:
        r"""Get SSH key pair
        Retrieve the repository SSH key pair excluding the SSH private key. The private key is a write only field and will never be exposed in the logs or the REST API.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineSSHKeyPairRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineSSHKeyPairResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_ssh_key_pair = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_variable(self, request: operations.GetRepositoryPipelineVariableRequest) -> operations.GetRepositoryPipelineVariableResponse:
        r"""Get a variable for a repository
        Retrieve a repository level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repository_pipeline_variables(self, request: operations.GetRepositoryPipelineVariablesRequest) -> operations.GetRepositoryPipelineVariablesResponse:
        r"""List variables for a repository
        Find repository level variables.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoryPipelineVariablesRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoryPipelineVariablesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedPipelineVariables])
                res.paginated_pipeline_variables = out

        return res

    def stop_pipeline(self, request: operations.StopPipelineRequest) -> operations.StopPipelineResponse:
        r"""Stop a pipeline
        Signal the stop of a pipeline and all of its steps that not have completed yet.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPipelineRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines/{pipeline_uuid}/stopPipeline', request)
        
        
        client = self._client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPipelineResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_deployment_variable(self, request: operations.UpdateDeploymentVariableRequest) -> operations.UpdateDeploymentVariableResponse:
        r"""Update a variable for an environment
        Update a deployment environment level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateDeploymentVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/deployments_config/environments/{environment_uuid}/variables/{variable_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateDeploymentVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.deployment_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_pipeline_variable_for_team(self, request: operations.UpdatePipelineVariableForTeamRequest) -> operations.UpdatePipelineVariableForTeamResponse:
        r"""Update a variable for a team
        Update a team level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdatePipelineVariableForTeamRequest, base_url, '/teams/{username}/pipelines_config/variables/{variable_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdatePipelineVariableForTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_pipeline_variable_for_user(self, request: operations.UpdatePipelineVariableForUserRequest) -> operations.UpdatePipelineVariableForUserResponse:
        r"""Update a variable for a user
        Update a user level variable.
        This endpoint has been deprecated, and you should use the new workspaces endpoint. For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdatePipelineVariableForUserRequest, base_url, '/users/{selected_user}/pipelines_config/variables/{variable_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdatePipelineVariableForUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_pipeline_variable_for_workspace(self, request: operations.UpdatePipelineVariableForWorkspaceRequest) -> operations.UpdatePipelineVariableForWorkspaceResponse:
        r"""Update variable for a workspace
        Update a workspace level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdatePipelineVariableForWorkspaceRequest, base_url, '/workspaces/{workspace}/pipelines-config/variables/{variable_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdatePipelineVariableForWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_repository_build_number(self, request: operations.UpdateRepositoryBuildNumberRequest) -> operations.UpdateRepositoryBuildNumberResponse:
        r"""Update the next build number
        Update the next build number that should be assigned to a pipeline. The next build number that will be configured has to be strictly higher than the current latest build number for this repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRepositoryBuildNumberRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/build_number', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRepositoryBuildNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_build_number = out
        elif http_res.status_code in [400, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_repository_pipeline_config(self, request: operations.UpdateRepositoryPipelineConfigRequest) -> operations.UpdateRepositoryPipelineConfigResponse:
        r"""Update configuration
        Update the pipelines configuration for a repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRepositoryPipelineConfigRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRepositoryPipelineConfigResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipelines_config = out

        return res

    def update_repository_pipeline_key_pair(self, request: operations.UpdateRepositoryPipelineKeyPairRequest) -> operations.UpdateRepositoryPipelineKeyPairResponse:
        r"""Update SSH key pair
        Create or update the repository SSH key pair. The private key will be set as a default SSH identity in your build container.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRepositoryPipelineKeyPairRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/key_pair', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRepositoryPipelineKeyPairResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_ssh_key_pair = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_repository_pipeline_known_host(self, request: operations.UpdateRepositoryPipelineKnownHostRequest) -> operations.UpdateRepositoryPipelineKnownHostResponse:
        r"""Update a known host
        Update a repository level known host.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRepositoryPipelineKnownHostRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/ssh/known_hosts/{known_host_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRepositoryPipelineKnownHostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_known_host = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_repository_pipeline_schedule(self, request: operations.UpdateRepositoryPipelineScheduleRequest) -> operations.UpdateRepositoryPipelineScheduleResponse:
        r"""Update a schedule
        Update a schedule.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRepositoryPipelineScheduleRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/schedules/{schedule_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRepositoryPipelineScheduleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_schedule = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def update_repository_pipeline_variable(self, request: operations.UpdateRepositoryPipelineVariableRequest) -> operations.UpdateRepositoryPipelineVariableResponse:
        r"""Update a variable for a repository
        Update a repository level variable.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateRepositoryPipelineVariableRequest, base_url, '/repositories/{workspace}/{repo_slug}/pipelines_config/variables/{variable_uuid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateRepositoryPipelineVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.pipeline_variable = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    