"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import googleclouddialogflowcxv3beta1intent as shared_googleclouddialogflowcxv3beta1intent
from ..shared import googleclouddialogflowcxv3beta1page as shared_googleclouddialogflowcxv3beta1page
from ..shared import googleclouddialogflowcxv3beta1responsemessagetext as shared_googleclouddialogflowcxv3beta1responsemessagetext
from ..shared import googleclouddialogflowcxv3beta1testrundifference as shared_googleclouddialogflowcxv3beta1testrundifference
from ..shared import googlerpcstatus as shared_googlerpcstatus
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GoogleCloudDialogflowCxV3beta1ConversationTurnVirtualAgentOutput:
    r"""The output from the virtual agent."""
    
    current_page: Optional[shared_googleclouddialogflowcxv3beta1page.GoogleCloudDialogflowCxV3beta1Page] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currentPage'), 'exclude': lambda f: f is None }})
    r"""A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page)."""  
    diagnostic_info: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('diagnosticInfo'), 'exclude': lambda f: f is None }})
    r"""Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage."""  
    differences: Optional[list[shared_googleclouddialogflowcxv3beta1testrundifference.GoogleCloudDialogflowCxV3beta1TestRunDifference]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('differences'), 'exclude': lambda f: f is None }})
    r"""Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any."""  
    session_parameters: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sessionParameters'), 'exclude': lambda f: f is None }})
    r"""The session parameters available to the bot at this point."""  
    status: Optional[shared_googlerpcstatus.GoogleRPCStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors)."""  
    text_responses: Optional[list[shared_googleclouddialogflowcxv3beta1responsemessagetext.GoogleCloudDialogflowCxV3beta1ResponseMessageText]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('textResponses'), 'exclude': lambda f: f is None }})
    r"""The text responses from the agent for the turn."""  
    triggered_intent: Optional[shared_googleclouddialogflowcxv3beta1intent.GoogleCloudDialogflowCxV3beta1Intent] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('triggeredIntent'), 'exclude': lambda f: f is None }})
    r"""An intent represents a user's intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GoogleCloudDialogflowCxV3beta1ConversationTurnVirtualAgentOutputInput:
    r"""The output from the virtual agent."""
    
    current_page: Optional[shared_googleclouddialogflowcxv3beta1page.GoogleCloudDialogflowCxV3beta1PageInput] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('currentPage'), 'exclude': lambda f: f is None }})
    r"""A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page)."""  
    diagnostic_info: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('diagnosticInfo'), 'exclude': lambda f: f is None }})
    r"""Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage."""  
    session_parameters: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sessionParameters'), 'exclude': lambda f: f is None }})
    r"""The session parameters available to the bot at this point."""  
    status: Optional[shared_googlerpcstatus.GoogleRPCStatus] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors)."""  
    text_responses: Optional[list[shared_googleclouddialogflowcxv3beta1responsemessagetext.GoogleCloudDialogflowCxV3beta1ResponseMessageTextInput]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('textResponses'), 'exclude': lambda f: f is None }})
    r"""The text responses from the agent for the turn."""  
    triggered_intent: Optional[shared_googleclouddialogflowcxv3beta1intent.GoogleCloudDialogflowCxV3beta1Intent] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('triggeredIntent'), 'exclude': lambda f: f is None }})
    r"""An intent represents a user's intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent."""  
    