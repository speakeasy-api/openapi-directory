/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import {
  objectToClass,
  SpeakeasyBase,
  SpeakeasyMetadata,
} from "../../../internal/utils";
import { PolicyControllerMonitoringConfig } from "./policycontrollermonitoringconfig";
import { PolicyControllerPolicyContentSpec } from "./policycontrollerpolicycontentspec";
import { PolicyControllerPolicyControllerDeploymentConfig } from "./policycontrollerpolicycontrollerdeploymentconfig";
import { PolicyControllerTemplateLibraryConfig } from "./policycontrollertemplatelibraryconfig";
import { Expose, Transform, Type } from "class-transformer";

/**
 * The install_spec represents the intended state specified by the latest request that mutated install_spec in the feature spec, not the lifecycle state of the feature observed by the Hub feature controller that is reported in the feature state.
 */
export enum PolicyControllerHubConfigInstallSpecEnum {
  InstallSpecUnspecified = "INSTALL_SPEC_UNSPECIFIED",
  InstallSpecNotInstalled = "INSTALL_SPEC_NOT_INSTALLED",
  InstallSpecEnabled = "INSTALL_SPEC_ENABLED",
  InstallSpecSuspended = "INSTALL_SPEC_SUSPENDED",
}

/**
 * Configuration for Policy Controller
 */
export class PolicyControllerHubConfig extends SpeakeasyBase {
  /**
   * Sets the interval for Policy Controller Audit Scans (in seconds). When set to 0, this disables audit functionality altogether.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "auditIntervalSeconds" })
  auditIntervalSeconds?: string;

  /**
   * The maximum number of audit violations to be stored in a constraint. If not set, the internal default (currently 20) will be used.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "constraintViolationLimit" })
  constraintViolationLimit?: string;

  /**
   * Map of deployment configs to deployments (“admission”, “audit”, “mutation”).
   */
  @SpeakeasyMetadata({
    elemType: PolicyControllerPolicyControllerDeploymentConfig,
  })
  @Expose({ name: "deploymentConfigs" })
  @Transform(
    ({ value }) => {
      const obj: Record<
        string,
        PolicyControllerPolicyControllerDeploymentConfig
      > = {};
      for (const key in value) {
        obj[key] = objectToClass(
          value[key],
          PolicyControllerPolicyControllerDeploymentConfig
        );
      }
      return obj;
    },
    { toClassOnly: true }
  )
  deploymentConfigs?: Record<
    string,
    PolicyControllerPolicyControllerDeploymentConfig
  >;

  /**
   * The set of namespaces that are excluded from Policy Controller checks. Namespaces do not need to currently exist on the cluster.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "exemptableNamespaces" })
  exemptableNamespaces?: string[];

  /**
   * The install_spec represents the intended state specified by the latest request that mutated install_spec in the feature spec, not the lifecycle state of the feature observed by the Hub feature controller that is reported in the feature state.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "installSpec" })
  installSpec?: PolicyControllerHubConfigInstallSpecEnum;

  /**
   * Logs all denies and dry run failures.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "logDeniesEnabled" })
  logDeniesEnabled?: boolean;

  /**
   * MonitoringConfig specifies the backends Policy Controller should export metrics to. For example, to specify metrics should be exported to Cloud Monitoring and Prometheus, specify backends: ["cloudmonitoring", "prometheus"]
   */
  @SpeakeasyMetadata()
  @Expose({ name: "monitoring" })
  @Type(() => PolicyControllerMonitoringConfig)
  monitoring?: PolicyControllerMonitoringConfig;

  /**
   * Enables the ability to mutate resources using Policy Controller.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "mutationEnabled" })
  mutationEnabled?: boolean;

  /**
   * PolicyContentSpec defines the user's desired content configuration on the cluster.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "policyContent" })
  @Type(() => PolicyControllerPolicyContentSpec)
  policyContent?: PolicyControllerPolicyContentSpec;

  /**
   * Enables the ability to use Constraint Templates that reference to objects other than the object currently being evaluated.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "referentialRulesEnabled" })
  referentialRulesEnabled?: boolean;

  /**
   * The config specifying which default library templates to install.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "templateLibraryConfig" })
  @Type(() => PolicyControllerTemplateLibraryConfig)
  templateLibraryConfig?: PolicyControllerTemplateLibraryConfig;
}
