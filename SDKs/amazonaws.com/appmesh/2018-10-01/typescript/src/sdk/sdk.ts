/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  /**
   * The AWS App Mesh multi-region endpoint
   */
  "http://appmesh.{region}.amazonaws.com",
  /**
   * The AWS App Mesh multi-region endpoint
   */
  "https://appmesh.{region}.amazonaws.com",
  /**
   * The AWS App Mesh endpoint for China (Beijing) and China (Ningxia)
   */
  "http://appmesh.{region}.amazonaws.com.cn",
  /**
   * The AWS App Mesh endpoint for China (Beijing) and China (Ningxia)
   */
  "https://appmesh.{region}.amazonaws.com.cn",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * <p>AWS App Mesh is a service mesh based on the Envoy proxy that makes it easy to monitor and
 *
 * @remarks
 *          control containerized microservices. App Mesh standardizes how your microservices
 *          communicate, giving you end-to-end visibility and helping to ensure high-availability for
 *          your applications.</p>
 *          <p>App Mesh gives you consistent visibility and network traffic controls for every
 *          microservice in an application. You can use App Mesh with Amazon ECS
 *          (using the Amazon EC2 launch type), Amazon EKS, and Kubernetes on AWS.</p>
 *          <note>
 *             <p>App Mesh supports containerized microservice applications that use service discovery
 *             naming for their components. To use App Mesh, you must have a containerized application
 *             running on Amazon EC2 instances, hosted in either Amazon ECS, Amazon EKS, or Kubernetes on AWS. For
 *             more information about service discovery on Amazon ECS, see <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html">Service Discovery</a> in the
 *                <i>Amazon Elastic Container Service Developer Guide</i>. Kubernetes <code>kube-dns</code> is supported.
 *             For more information, see <a href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">DNS
 *                for Services and Pods</a> in the Kubernetes documentation.</p>
 *          </note>
 *
 * @see {@link https://docs.aws.amazon.com/appmesh/} - Amazon Web Services documentation
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * <p>Creates a new service mesh. A service mesh is a logical boundary for network traffic
   *          between the services that reside within it.</p>
   *          <p>After you create your service mesh, you can create virtual nodes, virtual routers, and
   *          routes to distribute traffic between the applications in your mesh.</p>
   */
  createMesh(
    req: operations.CreateMeshRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateMeshResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateMeshRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/meshes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateMeshResponse =
        new operations.CreateMeshResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createMeshOutput = utils.objectToClass(
              httpRes?.data,
              shared.CreateMeshOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a new route that is associated with a virtual router.</p>
   *          <p>You can use the <code>prefix</code> parameter in your route specification for path-based
   *          routing of requests. For example, if your virtual router service name is
   *             <code>my-service.local</code>, and you want the route to match requests to
   *             <code>my-service.local/metrics</code>, then your prefix should be
   *          <code>/metrics</code>.</p>
   *          <p>If your route matches a request, you can distribute traffic to one or more target
   *          virtual nodes with relative weighting.</p>
   */
  createRoute(
    req: operations.CreateRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRouteResponse =
        new operations.CreateRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createRouteOutput = utils.objectToClass(
              httpRes?.data,
              shared.CreateRouteOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a new virtual node within a service mesh.</p>
   *          <p>A virtual node acts as logical pointer to a particular task group, such as an Amazon ECS
   *          service or a Kubernetes deployment. When you create a virtual node, you must specify the
   *          DNS service discovery name for your task group.</p>
   *          <p>Any inbound traffic that your virtual node expects should be specified as a
   *             <code>listener</code>. Any outbound traffic that your virtual node expects to reach
   *          should be specified as a <code>backend</code>.</p>
   *          <p>The response metadata for your new virtual node contains the <code>arn</code> that is
   *          associated with the virtual node. Set this value (either the full ARN or the truncated
   *          resource name, for example, <code>mesh/default/virtualNode/simpleapp</code>, as the
   *             <code>APPMESH_VIRTUAL_NODE_NAME</code> environment variable for your task group's Envoy
   *          proxy container in your task definition or pod spec. This is then mapped to the
   *             <code>node.id</code> and <code>node.cluster</code> Envoy parameters.</p>
   *          <note>
   *             <p>If you require your Envoy stats or tracing to use a different name, you can override
   *             the <code>node.cluster</code> value that is set by
   *                <code>APPMESH_VIRTUAL_NODE_NAME</code> with the
   *                <code>APPMESH_VIRTUAL_NODE_CLUSTER</code> environment variable.</p>
   *          </note>
   */
  createVirtualNode(
    req: operations.CreateVirtualNodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateVirtualNodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateVirtualNodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualNodes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateVirtualNodeResponse =
        new operations.CreateVirtualNodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createVirtualNodeOutput = utils.objectToClass(
              httpRes?.data,
              shared.CreateVirtualNodeOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a new virtual router within a service mesh.</p>
   *          <p>Virtual routers handle traffic for one or more service names within your mesh. After you
   *          create your virtual router, create and associate routes for your virtual router that direct
   *          incoming requests to different virtual nodes.</p>
   */
  createVirtualRouter(
    req: operations.CreateVirtualRouterRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateVirtualRouterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateVirtualRouterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouters",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateVirtualRouterResponse =
        new operations.CreateVirtualRouterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createVirtualRouterOutput = utils.objectToClass(
              httpRes?.data,
              shared.CreateVirtualRouterOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Deletes an existing service mesh.</p>
   *          <p>You must delete all resources (routes, virtual routers, virtual nodes) in the service
   *          mesh before you can delete the mesh itself.</p>
   */
  deleteMesh(
    req: operations.DeleteMeshRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteMeshResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteMeshRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/meshes/{meshName}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteMeshResponse =
        new operations.DeleteMeshResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteMeshOutput = utils.objectToClass(
              httpRes?.data,
              shared.DeleteMeshOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an existing route.
   */
  deleteRoute(
    req: operations.DeleteRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRouteResponse =
        new operations.DeleteRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteRouteOutput = utils.objectToClass(
              httpRes?.data,
              shared.DeleteRouteOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an existing virtual node.
   */
  deleteVirtualNode(
    req: operations.DeleteVirtualNodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteVirtualNodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteVirtualNodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualNodes/{virtualNodeName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteVirtualNodeResponse =
        new operations.DeleteVirtualNodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteVirtualNodeOutput = utils.objectToClass(
              httpRes?.data,
              shared.DeleteVirtualNodeOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Deletes an existing virtual router.</p>
   *          <p>You must delete any routes associated with the virtual router before you can delete the
   *          router itself.</p>
   */
  deleteVirtualRouter(
    req: operations.DeleteVirtualRouterRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteVirtualRouterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteVirtualRouterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouters/{virtualRouterName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteVirtualRouterResponse =
        new operations.DeleteVirtualRouterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteVirtualRouterOutput = utils.objectToClass(
              httpRes?.data,
              shared.DeleteVirtualRouterOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceInUseException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Describes an existing service mesh.
   */
  describeMesh(
    req: operations.DescribeMeshRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DescribeMeshResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DescribeMeshRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/meshes/{meshName}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DescribeMeshResponse =
        new operations.DescribeMeshResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.describeMeshOutput = utils.objectToClass(
              httpRes?.data,
              shared.DescribeMeshOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Describes an existing route.
   */
  describeRoute(
    req: operations.DescribeRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DescribeRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DescribeRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DescribeRouteResponse =
        new operations.DescribeRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.describeRouteOutput = utils.objectToClass(
              httpRes?.data,
              shared.DescribeRouteOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Describes an existing virtual node.
   */
  describeVirtualNode(
    req: operations.DescribeVirtualNodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DescribeVirtualNodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DescribeVirtualNodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualNodes/{virtualNodeName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DescribeVirtualNodeResponse =
        new operations.DescribeVirtualNodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.describeVirtualNodeOutput = utils.objectToClass(
              httpRes?.data,
              shared.DescribeVirtualNodeOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Describes an existing virtual router.
   */
  describeVirtualRouter(
    req: operations.DescribeVirtualRouterRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DescribeVirtualRouterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DescribeVirtualRouterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouters/{virtualRouterName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DescribeVirtualRouterResponse =
        new operations.DescribeVirtualRouterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.describeVirtualRouterOutput = utils.objectToClass(
              httpRes?.data,
              shared.DescribeVirtualRouterOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of existing service meshes.
   */
  listMeshes(
    req: operations.ListMeshesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMeshesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMeshesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/meshes";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMeshesResponse =
        new operations.ListMeshesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMeshesOutput = utils.objectToClass(
              httpRes?.data,
              shared.ListMeshesOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of existing routes in a service mesh.
   */
  listRoutes(
    req: operations.ListRoutesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRoutesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRoutesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRoutesResponse =
        new operations.ListRoutesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRoutesOutput = utils.objectToClass(
              httpRes?.data,
              shared.ListRoutesOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of existing virtual nodes.
   */
  listVirtualNodes(
    req: operations.ListVirtualNodesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVirtualNodesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVirtualNodesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualNodes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVirtualNodesResponse =
        new operations.ListVirtualNodesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVirtualNodesOutput = utils.objectToClass(
              httpRes?.data,
              shared.ListVirtualNodesOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of existing virtual routers in a service mesh.
   */
  listVirtualRouters(
    req: operations.ListVirtualRoutersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListVirtualRoutersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListVirtualRoutersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouters",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListVirtualRoutersResponse =
        new operations.ListVirtualRoutersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listVirtualRoutersOutput = utils.objectToClass(
              httpRes?.data,
              shared.ListVirtualRoutersOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing route for a specified service mesh and virtual router.
   */
  updateRoute(
    req: operations.UpdateRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRouteResponse =
        new operations.UpdateRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateRouteOutput = utils.objectToClass(
              httpRes?.data,
              shared.UpdateRouteOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing virtual node in a specified service mesh.
   */
  updateVirtualNode(
    req: operations.UpdateVirtualNodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVirtualNodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVirtualNodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualNodes/{virtualNodeName}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVirtualNodeResponse =
        new operations.UpdateVirtualNodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateVirtualNodeOutput = utils.objectToClass(
              httpRes?.data,
              shared.UpdateVirtualNodeOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing virtual router in a specified service mesh.
   */
  updateVirtualRouter(
    req: operations.UpdateVirtualRouterRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateVirtualRouterResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateVirtualRouterRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/meshes/{meshName}/virtualRouters/{virtualRouterName}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateVirtualRouterResponse =
        new operations.UpdateVirtualRouterResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateVirtualRouterOutput = utils.objectToClass(
              httpRes?.data,
              shared.UpdateVirtualRouterOutput
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.badRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.forbiddenException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServerErrorException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tooManyRequestsException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
