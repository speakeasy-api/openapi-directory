/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a new custom dashboard. For examples on how you can use this API to create dashboards, see Managing dashboards by API (https://cloud.google.com/monitoring/dashboards/api-dashboard). This method requires the monitoring.dashboards.create permission on the specified project. For more information about permissions, see Cloud Identity and Access Management (https://cloud.google.com/iam).
   */
  monitoringProjectsDashboardsCreate(
    req: operations.MonitoringProjectsDashboardsCreateRequest,
    security: operations.MonitoringProjectsDashboardsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsDashboardsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MonitoringProjectsDashboardsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/dashboards",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "dashboard",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MonitoringProjectsDashboardsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsDashboardsCreateResponse =
        new operations.MonitoringProjectsDashboardsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dashboard = utils.objectToClass(
              httpRes?.data,
              shared.Dashboard
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an existing custom dashboard.This method requires the monitoring.dashboards.delete permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
   */
  monitoringProjectsDashboardsDelete(
    req: operations.MonitoringProjectsDashboardsDeleteRequest,
    security: operations.MonitoringProjectsDashboardsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsDashboardsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MonitoringProjectsDashboardsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MonitoringProjectsDashboardsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsDashboardsDeleteResponse =
        new operations.MonitoringProjectsDashboardsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetches a specific dashboard.This method requires the monitoring.dashboards.get permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
   */
  monitoringProjectsDashboardsGet(
    req: operations.MonitoringProjectsDashboardsGetRequest,
    security: operations.MonitoringProjectsDashboardsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsDashboardsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MonitoringProjectsDashboardsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MonitoringProjectsDashboardsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsDashboardsGetResponse =
        new operations.MonitoringProjectsDashboardsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dashboard = utils.objectToClass(
              httpRes?.data,
              shared.Dashboard
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the existing dashboards.This method requires the monitoring.dashboards.list permission on the specified project. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
   */
  monitoringProjectsDashboardsList(
    req: operations.MonitoringProjectsDashboardsListRequest,
    security: operations.MonitoringProjectsDashboardsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsDashboardsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MonitoringProjectsDashboardsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/dashboards",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MonitoringProjectsDashboardsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsDashboardsListResponse =
        new operations.MonitoringProjectsDashboardsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDashboardsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDashboardsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replaces an existing custom dashboard with a new definition.This method requires the monitoring.dashboards.update permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam).
   */
  monitoringProjectsDashboardsPatch(
    req: operations.MonitoringProjectsDashboardsPatchRequest,
    security: operations.MonitoringProjectsDashboardsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsDashboardsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MonitoringProjectsDashboardsPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "dashboard",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MonitoringProjectsDashboardsPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsDashboardsPatchResponse =
        new operations.MonitoringProjectsDashboardsPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dashboard = utils.objectToClass(
              httpRes?.data,
              shared.Dashboard
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists possible values for a given label name.
   */
  monitoringProjectsLocationPrometheusApiV1LabelValues(
    req: operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/label/{label}/values",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelValuesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists labels for metrics.
   */
  monitoringProjectsLocationPrometheusApiV1Labels(
    req: operations.MonitoringProjectsLocationPrometheusApiV1LabelsRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1LabelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1LabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/labels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listLabelsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1LabelsResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists labels for metrics.
   */
  monitoringProjectsLocationPrometheusApiV1LabelsList(
    req: operations.MonitoringProjectsLocationPrometheusApiV1LabelsListRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1LabelsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1LabelsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/labels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1LabelsListResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1LabelsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists metadata for metrics.
   */
  monitoringProjectsLocationPrometheusApiV1MetadataList(
    req: operations.MonitoringProjectsLocationPrometheusApiV1MetadataListRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1MetadataListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1MetadataListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1MetadataListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/metadata",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1MetadataListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1MetadataListResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1MetadataListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Evaluate a PromQL query at a single point in time.
   */
  monitoringProjectsLocationPrometheusApiV1Query(
    req: operations.MonitoringProjectsLocationPrometheusApiV1QueryRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1QuerySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1QueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/query",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "queryInstantRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1QuerySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1QueryResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists exemplars relevant to a given PromQL query,
   */
  monitoringProjectsLocationPrometheusApiV1QueryExemplars(
    req: operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/query_exemplars",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "queryExemplarsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryExemplarsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Evaluate a PromQL query with start, end time range.
   */
  monitoringProjectsLocationPrometheusApiV1QueryRange(
    req: operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/query_range",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "queryRangeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1QueryRangeResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists metadata for metrics.
   */
  monitoringProjectsLocationPrometheusApiV1Series(
    req: operations.MonitoringProjectsLocationPrometheusApiV1SeriesRequest,
    security: operations.MonitoringProjectsLocationPrometheusApiV1SeriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MonitoringProjectsLocationPrometheusApiV1SeriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.MonitoringProjectsLocationPrometheusApiV1SeriesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/location/{location}/prometheus/api/v1/series",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "querySeriesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.MonitoringProjectsLocationPrometheusApiV1SeriesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MonitoringProjectsLocationPrometheusApiV1SeriesResponse =
        new operations.MonitoringProjectsLocationPrometheusApiV1SeriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.httpBody = utils.objectToClass(httpRes?.data, shared.HttpBody);
          }
          break;
      }

      return res;
    });
  }
}
