// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type ClipAssetType string

const (
	ClipAssetTypeVideoAsset ClipAssetType = "VideoAsset"
	ClipAssetTypeImageAsset ClipAssetType = "ImageAsset"
	ClipAssetTypeTitleAsset ClipAssetType = "TitleAsset"
	ClipAssetTypeHTMLAsset  ClipAssetType = "HtmlAsset"
	ClipAssetTypeAudioAsset ClipAssetType = "AudioAsset"
	ClipAssetTypeLumaAsset  ClipAssetType = "LumaAsset"
)

type ClipAsset struct {
	VideoAsset *VideoAsset
	ImageAsset *ImageAsset
	TitleAsset *TitleAsset
	HTMLAsset  *HTMLAsset
	AudioAsset *AudioAsset
	LumaAsset  *LumaAsset

	Type ClipAssetType
}

func CreateClipAssetVideoAsset(videoAsset VideoAsset) ClipAsset {
	typ := ClipAssetTypeVideoAsset

	return ClipAsset{
		VideoAsset: &videoAsset,
		Type:       typ,
	}
}

func CreateClipAssetImageAsset(imageAsset ImageAsset) ClipAsset {
	typ := ClipAssetTypeImageAsset

	return ClipAsset{
		ImageAsset: &imageAsset,
		Type:       typ,
	}
}

func CreateClipAssetTitleAsset(titleAsset TitleAsset) ClipAsset {
	typ := ClipAssetTypeTitleAsset

	return ClipAsset{
		TitleAsset: &titleAsset,
		Type:       typ,
	}
}

func CreateClipAssetHTMLAsset(htmlAsset HTMLAsset) ClipAsset {
	typ := ClipAssetTypeHTMLAsset

	return ClipAsset{
		HTMLAsset: &htmlAsset,
		Type:      typ,
	}
}

func CreateClipAssetAudioAsset(audioAsset AudioAsset) ClipAsset {
	typ := ClipAssetTypeAudioAsset

	return ClipAsset{
		AudioAsset: &audioAsset,
		Type:       typ,
	}
}

func CreateClipAssetLumaAsset(lumaAsset LumaAsset) ClipAsset {
	typ := ClipAssetTypeLumaAsset

	return ClipAsset{
		LumaAsset: &lumaAsset,
		Type:      typ,
	}
}

func (u *ClipAsset) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	videoAsset := new(VideoAsset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&videoAsset); err == nil {
		u.VideoAsset = videoAsset
		u.Type = ClipAssetTypeVideoAsset
		return nil
	}

	imageAsset := new(ImageAsset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&imageAsset); err == nil {
		u.ImageAsset = imageAsset
		u.Type = ClipAssetTypeImageAsset
		return nil
	}

	titleAsset := new(TitleAsset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&titleAsset); err == nil {
		u.TitleAsset = titleAsset
		u.Type = ClipAssetTypeTitleAsset
		return nil
	}

	htmlAsset := new(HTMLAsset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&htmlAsset); err == nil {
		u.HTMLAsset = htmlAsset
		u.Type = ClipAssetTypeHTMLAsset
		return nil
	}

	audioAsset := new(AudioAsset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&audioAsset); err == nil {
		u.AudioAsset = audioAsset
		u.Type = ClipAssetTypeAudioAsset
		return nil
	}

	lumaAsset := new(LumaAsset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&lumaAsset); err == nil {
		u.LumaAsset = lumaAsset
		u.Type = ClipAssetTypeLumaAsset
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u ClipAsset) MarshalJSON() ([]byte, error) {
	if u.VideoAsset != nil {
		return json.Marshal(u.VideoAsset)
	}

	if u.ImageAsset != nil {
		return json.Marshal(u.ImageAsset)
	}

	if u.TitleAsset != nil {
		return json.Marshal(u.TitleAsset)
	}

	if u.HTMLAsset != nil {
		return json.Marshal(u.HTMLAsset)
	}

	if u.AudioAsset != nil {
		return json.Marshal(u.AudioAsset)
	}

	if u.LumaAsset != nil {
		return json.Marshal(u.LumaAsset)
	}

	return nil, nil
}

// ClipEffectEnum - A motion effect to apply to the Clip. <ul>
//
//	<li>`zoomIn` - slow zoom in</li>
//	<li>`zoomOut` - slow zoom out</li>
//	<li>`slideLeft` - slow slide (pan) left</li>
//	<li>`slideRight` - slow slide (pan) right</li>
//	<li>`slideUp` - slow slide (pan) up</li>
//	<li>`slideDown` - slow slide (pan) down</li>
//
// </ul>
type ClipEffectEnum string

const (
	ClipEffectEnumZoomIn     ClipEffectEnum = "zoomIn"
	ClipEffectEnumZoomOut    ClipEffectEnum = "zoomOut"
	ClipEffectEnumSlideLeft  ClipEffectEnum = "slideLeft"
	ClipEffectEnumSlideRight ClipEffectEnum = "slideRight"
	ClipEffectEnumSlideUp    ClipEffectEnum = "slideUp"
	ClipEffectEnumSlideDown  ClipEffectEnum = "slideDown"
)

func (e *ClipEffectEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "zoomIn":
		fallthrough
	case "zoomOut":
		fallthrough
	case "slideLeft":
		fallthrough
	case "slideRight":
		fallthrough
	case "slideUp":
		fallthrough
	case "slideDown":
		*e = ClipEffectEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ClipEffectEnum: %s", s)
	}
}

// ClipFilterEnum - A filter effect to apply to the Clip. <ul>
//
//	<li>`boost` - boost contrast and saturation</li>
//	<li>`contrast` - increase contrast</li>
//	<li>`darken` - darken the scene</li>
//	<li>`greyscale` - remove colour</li>
//	<li>`lighten` - lighten the scene</li>
//	<li>`muted` - reduce saturation and contrast</li>
//	<li>`invert` - invert colors</li>
//
// </ul>
type ClipFilterEnum string

const (
	ClipFilterEnumBoost     ClipFilterEnum = "boost"
	ClipFilterEnumContrast  ClipFilterEnum = "contrast"
	ClipFilterEnumDarken    ClipFilterEnum = "darken"
	ClipFilterEnumGreyscale ClipFilterEnum = "greyscale"
	ClipFilterEnumLighten   ClipFilterEnum = "lighten"
	ClipFilterEnumMuted     ClipFilterEnum = "muted"
	ClipFilterEnumNegative  ClipFilterEnum = "negative"
)

func (e *ClipFilterEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "boost":
		fallthrough
	case "contrast":
		fallthrough
	case "darken":
		fallthrough
	case "greyscale":
		fallthrough
	case "lighten":
		fallthrough
	case "muted":
		fallthrough
	case "negative":
		*e = ClipFilterEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ClipFilterEnum: %s", s)
	}
}

// ClipFitEnum - Set how the asset should be scaled to fit the viewport using one of the following options:
//
//	<ul>
//	  <li>`cover` - stretch the asset to fill the viewport without maintaining the aspect ratio.</li>
//	  <li>`contain` - fit the entire asset within the viewport while maintaining the original aspect ratio.</li>
//	  <li>`crop` - scale the asset to fill the viewport while maintaining the aspect ratio. The asset will be cropped if it exceeds the bounds of the viewport.</li>
//	  <li>`none` - preserves the original asset dimensions and does not apply any scaling.</li>
//	</ul>
type ClipFitEnum string

const (
	ClipFitEnumCover   ClipFitEnum = "cover"
	ClipFitEnumContain ClipFitEnum = "contain"
	ClipFitEnumCrop    ClipFitEnum = "crop"
	ClipFitEnumNone    ClipFitEnum = "none"
)

func (e *ClipFitEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "cover":
		fallthrough
	case "contain":
		fallthrough
	case "crop":
		fallthrough
	case "none":
		*e = ClipFitEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ClipFitEnum: %s", s)
	}
}

// ClipPositionEnum - Place the asset in one of nine predefined positions of the viewport. This is most effective for when the asset is scaled and you want to position the element to a specific position. <ul>
//
//	<li>`top` - top (center)</li>
//	<li>`topRight` - top right</li>
//	<li>`right` - right (center)</li>
//	<li>`bottomRight` - bottom right</li>
//	<li>`bottom` - bottom (center)</li>
//	<li>`bottomLeft` - bottom left</li>
//	<li>`left` - left (center)</li>
//	<li>`topLeft` - top left</li>
//	<li>`center` - center</li>
//
// </ul>
type ClipPositionEnum string

const (
	ClipPositionEnumTop         ClipPositionEnum = "top"
	ClipPositionEnumTopRight    ClipPositionEnum = "topRight"
	ClipPositionEnumRight       ClipPositionEnum = "right"
	ClipPositionEnumBottomRight ClipPositionEnum = "bottomRight"
	ClipPositionEnumBottom      ClipPositionEnum = "bottom"
	ClipPositionEnumBottomLeft  ClipPositionEnum = "bottomLeft"
	ClipPositionEnumLeft        ClipPositionEnum = "left"
	ClipPositionEnumTopLeft     ClipPositionEnum = "topLeft"
	ClipPositionEnumCenter      ClipPositionEnum = "center"
)

func (e *ClipPositionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "top":
		fallthrough
	case "topRight":
		fallthrough
	case "right":
		fallthrough
	case "bottomRight":
		fallthrough
	case "bottom":
		fallthrough
	case "bottomLeft":
		fallthrough
	case "left":
		fallthrough
	case "topLeft":
		fallthrough
	case "center":
		*e = ClipPositionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for ClipPositionEnum: %s", s)
	}
}

// Clip - A clip is a container for a specific type of asset, i.e. a title, image, video, audio or html. You use a Clip to define when an asset will display on the timeline, how long it will play for and transitions, filters and effects to apply to it.
type Clip struct {
	// The type of asset to display for the duration of this Clip. Value must be one of <b>TitleAsset</b>, <b>ImageAsset</b>, <b>VideoAsset</b>, <b>HtmlAsset</b>, <b>AudioAsset</b> or <b>LumaAsset</b>
	Asset ClipAsset `json:"asset"`
	// A motion effect to apply to the Clip. <ul>
	//   <li>`zoomIn` - slow zoom in</li>
	//   <li>`zoomOut` - slow zoom out</li>
	//   <li>`slideLeft` - slow slide (pan) left</li>
	//   <li>`slideRight` - slow slide (pan) right</li>
	//   <li>`slideUp` - slow slide (pan) up</li>
	//   <li>`slideDown` - slow slide (pan) down</li>
	// </ul>
	Effect *ClipEffectEnum `json:"effect,omitempty"`
	// A filter effect to apply to the Clip. <ul>
	//   <li>`boost` - boost contrast and saturation</li>
	//   <li>`contrast` - increase contrast</li>
	//   <li>`darken` - darken the scene</li>
	//   <li>`greyscale` - remove colour</li>
	//   <li>`lighten` - lighten the scene</li>
	//   <li>`muted` - reduce saturation and contrast</li>
	//   <li>`invert` - invert colors</li>
	// </ul>
	Filter *ClipFilterEnum `json:"filter,omitempty"`
	// Set how the asset should be scaled to fit the viewport using one of the following options:
	//   <ul>
	//     <li>`cover` - stretch the asset to fill the viewport without maintaining the aspect ratio.</li>
	//     <li>`contain` - fit the entire asset within the viewport while maintaining the original aspect ratio.</li>
	//     <li>`crop` - scale the asset to fill the viewport while maintaining the aspect ratio. The asset will be cropped if it exceeds the bounds of the viewport.</li>
	//     <li>`none` - preserves the original asset dimensions and does not apply any scaling.</li>
	//   </ul>
	Fit *ClipFitEnum `json:"fit,omitempty"`
	// The length, in seconds, the Clip should play for.
	Length float64 `json:"length"`
	// Offsets the position of an asset horizontally or vertically by a relative distance.
	Offset *Offset `json:"offset,omitempty"`
	// Sets the opacity of the Clip where 1 is opaque and 0 is transparent.
	Opacity *float64 `json:"opacity,omitempty"`
	// Place the asset in one of nine predefined positions of the viewport. This is most effective for when the asset is scaled and you want to position the element to a specific position. <ul>
	//   <li>`top` - top (center)</li>
	//   <li>`topRight` - top right</li>
	//   <li>`right` - right (center)</li>
	//   <li>`bottomRight` - bottom right</li>
	//   <li>`bottom` - bottom (center)</li>
	//   <li>`bottomLeft` - bottom left</li>
	//   <li>`left` - left (center)</li>
	//   <li>`topLeft` - top left</li>
	//   <li>`center` - center</li>
	// </ul>
	Position *ClipPositionEnum `json:"position,omitempty"`
	// Scale the asset to a fraction of the viewport size - i.e. setting the scale to 0.5 will scale asset to half the size of the viewport. This is useful for picture-in-picture video and  scaling images such as logos and watermarks.
	Scale *float64 `json:"scale,omitempty"`
	// The start position of the Clip on the timeline, in seconds.
	Start float64 `json:"start"`
	// In and out transitions for a clip - i.e. fade in and fade out
	Transition *Transition `json:"transition,omitempty"`
}
