"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Distribute:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def apple_mapping_test_flight_groups(self, request: operations.AppleMappingTestFlightGroupsRequest, security: operations.AppleMappingTestFlightGroupsSecurity) -> operations.AppleMappingTestFlightGroupsResponse:
        r"""Fetch all apple test flight groups"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppleMappingTestFlightGroupsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/apple_test_flight_groups', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppleMappingTestFlightGroupsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppleMappingTestFlightGroups200ApplicationJSON]])
                res.apple_mapping_test_flight_groups_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppleMappingTestFlightGroupsDefaultApplicationJSON])
                res.apple_mapping_test_flight_groups_default_application_json_object = out

        return res

    def apple_mapping_create(self, request: operations.AppleMappingCreateRequest, security: operations.AppleMappingCreateSecurity) -> operations.AppleMappingCreateResponse:
        r"""Create a mapping for an existing app in apple store for the specified application."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppleMappingCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppleMappingCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppleMappingCreate201ApplicationJSON])
                res.apple_mapping_create_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppleMappingCreateDefaultApplicationJSON])
                res.apple_mapping_create_default_application_json_object = out

        return res

    def apple_mapping_delete(self, request: operations.AppleMappingDeleteRequest, security: operations.AppleMappingDeleteSecurity) -> operations.AppleMappingDeleteResponse:
        r"""Delete mapping of apple app to an existing app in apple store."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppleMappingDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'string')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppleMappingDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppleMappingDeleteDefaultApplicationJSON])
                res.apple_mapping_delete_default_application_json_object = out

        return res

    def apple_mapping_get(self, request: operations.AppleMappingGetRequest, security: operations.AppleMappingGetSecurity) -> operations.AppleMappingGetResponse:
        r"""Get mapping of apple app to an existing app in apple store."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppleMappingGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppleMappingGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppleMappingGet200ApplicationJSON])
                res.apple_mapping_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppleMappingGetDefaultApplicationJSON])
                res.apple_mapping_get_default_application_json_object = out

        return res

    def devices_device_details(self, request: operations.DevicesDeviceDetailsRequest, security: operations.DevicesDeviceDetailsSecurity) -> operations.DevicesDeviceDetailsResponse:
        r"""Returns the device details."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesDeviceDetailsRequest, base_url, '/v0.1/user/devices/{device_udid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesDeviceDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesDeviceDetails200ApplicationJSON])
                res.devices_device_details_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesDeviceDetails400ApplicationJSON])
                res.devices_device_details_400_application_json_object = out
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesDeviceDetails403ApplicationJSON])
                res.devices_device_details_403_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesDeviceDetails404ApplicationJSON])
                res.devices_device_details_404_application_json_object = out

        return res

    def devices_get_release_update_devices_status(self, request: operations.DevicesGetReleaseUpdateDevicesStatusRequest, security: operations.DevicesGetReleaseUpdateDevicesStatusSecurity) -> operations.DevicesGetReleaseUpdateDevicesStatusResponse:
        r"""Returns the resign status to the caller"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesGetReleaseUpdateDevicesStatusRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices/{resign_id}', request)
        
        query_params = utils.get_query_params(operations.DevicesGetReleaseUpdateDevicesStatusRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesGetReleaseUpdateDevicesStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesGetReleaseUpdateDevicesStatus200ApplicationJSON])
                res.devices_get_release_update_devices_status_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesGetReleaseUpdateDevicesStatus400ApplicationJSON])
                res.devices_get_release_update_devices_status_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesGetReleaseUpdateDevicesStatus404ApplicationJSON])
                res.devices_get_release_update_devices_status_404_application_json_object = out

        return res

    def devices_list(self, request: operations.DevicesListRequest, security: operations.DevicesListSecurity) -> operations.DevicesListResponse:
        r"""Returns all devices associated with the given distribution group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices', request)
        
        query_params = utils.get_query_params(operations.DevicesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DevicesList200ApplicationJSON]])
                res.devices_list_200_application_json_objects = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesList400ApplicationJSON])
                res.devices_list_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesList404ApplicationJSON])
                res.devices_list_404_application_json_object = out

        return res

    def devices_list_csv_format(self, request: operations.DevicesListCsvFormatRequest, security: operations.DevicesListCsvFormatSecurity) -> operations.DevicesListCsvFormatResponse:
        r"""Returns all devices associated with the given distribution group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesListCsvFormatRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices/download_devices_list', request)
        
        query_params = utils.get_query_params(operations.DevicesListCsvFormatRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesListCsvFormatResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code in [400, 404, 500]:
            if utils.match_content_type(content_type, 'text/csv'):
                res.body = http_res.content

        return res

    def devices_register_user_for_device(self, request: operations.DevicesRegisterUserForDeviceRequest, security: operations.DevicesRegisterUserForDeviceSecurity) -> operations.DevicesRegisterUserForDeviceResponse:
        r"""Registers a user for an existing device"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesRegisterUserForDeviceRequest, base_url, '/v0.1/users/{user_id}/devices/register', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesRegisterUserForDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesRegisterUserForDevice200ApplicationJSON])
                res.devices_register_user_for_device_200_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesRegisterUserForDevice404ApplicationJSON])
                res.devices_register_user_for_device_404_application_json_object = out

        return res

    def devices_remove_user_device(self, request: operations.DevicesRemoveUserDeviceRequest, security: operations.DevicesRemoveUserDeviceSecurity) -> operations.DevicesRemoveUserDeviceResponse:
        r"""Removes an existing device from a user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DevicesRemoveUserDeviceRequest, base_url, '/v0.1/user/devices/{device_udid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesRemoveUserDeviceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesRemoveUserDevice403ApplicationJSON])
                res.devices_remove_user_device_403_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesRemoveUserDevice404ApplicationJSON])
                res.devices_remove_user_device_404_application_json_object = out

        return res

    def devices_user_devices_list(self) -> operations.DevicesUserDevicesListResponse:
        r"""Returns all devices associated with the given user."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/user/devices'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DevicesUserDevicesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DevicesUserDevicesList200ApplicationJSON]])
                res.devices_user_devices_list_200_application_json_objects = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesUserDevicesList400ApplicationJSON])
                res.devices_user_devices_list_400_application_json_object = out
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DevicesUserDevicesList403ApplicationJSON])
                res.devices_user_devices_list_403_application_json_object = out

        return res

    def distibution_releases_install_analytics(self, request: operations.DistibutionReleasesInstallAnalyticsRequest) -> operations.DistibutionReleasesInstallAnalyticsResponse:
        r"""Notify download(s) for the provided distribution release(s)."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistibutionReleasesInstallAnalyticsRequest, base_url, '/v0.1/public/apps/{owner_name}/{app_name}/install_analytics', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistibutionReleasesInstallAnalyticsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def provisioning_profile(self, request: operations.ProvisioningProfileRequest, security: operations.ProvisioningProfileSecurity) -> operations.ProvisioningProfileResponse:
        r"""Return information about the provisioning profile. Only available for iOS."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ProvisioningProfileRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/provisioning_profile', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ProvisioningProfileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ProvisioningProfileResponse])
                res.provisioning_profile_response = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ProvisioningProfile400ApplicationJSON])
                res.provisioning_profile_400_application_json_object = out

        return res

    def releases_add_distribution_group(self, request: operations.ReleasesAddDistributionGroupRequest, security: operations.ReleasesAddDistributionGroupSecurity) -> operations.ReleasesAddDistributionGroupResponse:
        r"""Distributes a release to a group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesAddDistributionGroupRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesAddDistributionGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddDistributionGroup201ApplicationJSON])
                res.releases_add_distribution_group_201_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddDistributionGroup400ApplicationJSON])
                res.releases_add_distribution_group_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddDistributionGroup404ApplicationJSON])
                res.releases_add_distribution_group_404_application_json_object = out

        return res

    def releases_add_store(self, request: operations.ReleasesAddStoreRequest, security: operations.ReleasesAddStoreSecurity) -> operations.ReleasesAddStoreResponse:
        r"""Distributes a release to a store"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesAddStoreRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesAddStoreResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddStore201ApplicationJSON])
                res.releases_add_store_201_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddStore400ApplicationJSON])
                res.releases_add_store_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddStore404ApplicationJSON])
                res.releases_add_store_404_application_json_object = out

        return res

    def releases_add_testers(self, request: operations.ReleasesAddTestersRequest, security: operations.ReleasesAddTestersSecurity) -> operations.ReleasesAddTestersResponse:
        r"""Distributes a release to a user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesAddTestersRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesAddTestersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddTesters201ApplicationJSON])
                res.releases_add_testers_201_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddTesters400ApplicationJSON])
                res.releases_add_testers_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesAddTesters404ApplicationJSON])
                res.releases_add_testers_404_application_json_object = out

        return res

    def releases_available_to_tester(self, request: operations.ReleasesAvailableToTesterRequest, security: operations.ReleasesAvailableToTesterSecurity) -> operations.ReleasesAvailableToTesterResponse:
        r"""Return detailed information about releases avaiable to a tester."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesAvailableToTesterRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/filter_by_tester', request)
        
        query_params = utils.get_query_params(operations.ReleasesAvailableToTesterRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesAvailableToTesterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ReleasesAvailableToTester200ApplicationJSON]])
                res.releases_available_to_tester_200_application_json_objects = out

        return res

    def releases_create_release_upload(self, request: operations.ReleasesCreateReleaseUploadRequest, security: operations.ReleasesCreateReleaseUploadSecurity) -> operations.ReleasesCreateReleaseUploadResponse:
        r"""Initiate a new release upload. This API is part of multi-step upload process."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesCreateReleaseUploadRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/uploads/releases', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesCreateReleaseUploadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesCreateReleaseUpload201ApplicationJSON])
                res.releases_create_release_upload_201_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesCreateReleaseUpload400ApplicationJSON])
                res.releases_create_release_upload_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesCreateReleaseUpload404ApplicationJSON])
                res.releases_create_release_upload_404_application_json_object = out

        return res

    def releases_delete(self, request: operations.ReleasesDeleteRequest, security: operations.ReleasesDeleteSecurity) -> operations.ReleasesDeleteResponse:
        r"""Deletes a release."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesDelete404ApplicationJSON])
                res.releases_delete_404_application_json_object = out
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesDelete500ApplicationJSON])
                res.releases_delete_500_application_json_object = out

        return res

    def releases_delete_distribution_group(self, request: operations.ReleasesDeleteDistributionGroupRequest, security: operations.ReleasesDeleteDistributionGroupSecurity) -> operations.ReleasesDeleteDistributionGroupResponse:
        r"""Delete the given distribution group from the release"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesDeleteDistributionGroupRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesDeleteDistributionGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesDeleteDistributionGroup404ApplicationJSON])
                res.releases_delete_distribution_group_404_application_json_object = out

        return res

    def releases_delete_distribution_store(self, request: operations.ReleasesDeleteDistributionStoreRequest, security: operations.ReleasesDeleteDistributionStoreSecurity) -> operations.ReleasesDeleteDistributionStoreResponse:
        r"""Delete the given distribution store from the release"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesDeleteDistributionStoreRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores/{store_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesDeleteDistributionStoreResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesDeleteDistributionStore404ApplicationJSON])
                res.releases_delete_distribution_store_404_application_json_object = out

        return res

    def releases_delete_distribution_tester(self, request: operations.ReleasesDeleteDistributionTesterRequest, security: operations.ReleasesDeleteDistributionTesterSecurity) -> operations.ReleasesDeleteDistributionTesterResponse:
        r"""Delete the given tester from the release"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesDeleteDistributionTesterRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesDeleteDistributionTesterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesDeleteDistributionTester404ApplicationJSON])
                res.releases_delete_distribution_tester_404_application_json_object = out

        return res

    def releases_delete_tester_from_destinations(self, request: operations.ReleasesDeleteTesterFromDestinationsRequest, security: operations.ReleasesDeleteTesterFromDestinationsSecurity) -> operations.ReleasesDeleteTesterFromDestinationsResponse:
        r"""Delete the given tester from the all releases"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesDeleteTesterFromDestinationsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/testers/{tester_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesDeleteTesterFromDestinationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesDeleteTesterFromDestinations404ApplicationJSON])
                res.releases_delete_tester_from_destinations_404_application_json_object = out

        return res

    def releases_delete_with_distribution_group_id(self, request: operations.ReleasesDeleteWithDistributionGroupIDRequest, security: operations.ReleasesDeleteWithDistributionGroupIDSecurity) -> operations.ReleasesDeleteWithDistributionGroupIDResponse:
        r"""Deletes a release with id 'release_id' in a given distribution group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesDeleteWithDistributionGroupIDRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesDeleteWithDistributionGroupIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def releases_get_ios_manifest(self, request: operations.ReleasesGetIosManifestRequest) -> operations.ReleasesGetIosManifestResponse:
        r"""Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetIosManifestRequest, base_url, '/v0.1/public/apps/{app_id}/releases/{release_id}/ios_manifest', request)
        
        query_params = utils.get_query_params(operations.ReleasesGetIosManifestRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetIosManifestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetIosManifest400ApplicationJSON])
                res.releases_get_ios_manifest_400_application_json_object = out
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetIosManifest403ApplicationJSON])
                res.releases_get_ios_manifest_403_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetIosManifest404ApplicationJSON])
                res.releases_get_ios_manifest_404_application_json_object = out

        return res

    def releases_get_latest_by_distribution_group(self, request: operations.ReleasesGetLatestByDistributionGroupRequest, security: operations.ReleasesGetLatestByDistributionGroupSecurity) -> operations.ReleasesGetLatestByDistributionGroupResponse:
        r"""Return detailed information about a distributed release in a given distribution group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetLatestByDistributionGroupRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}', request)
        
        query_params = utils.get_query_params(operations.ReleasesGetLatestByDistributionGroupRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetLatestByDistributionGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByDistributionGroup200ApplicationJSON])
                res.releases_get_latest_by_distribution_group_200_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByDistributionGroup404ApplicationJSON])
                res.releases_get_latest_by_distribution_group_404_application_json_object = out
        elif http_res.status_code == 501:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByDistributionGroup501ApplicationJSON])
                res.releases_get_latest_by_distribution_group_501_application_json_object = out

        return res

    def releases_get_latest_by_hash(self, request: operations.ReleasesGetLatestByHashRequest, security: operations.ReleasesGetLatestByHashSecurity) -> operations.ReleasesGetLatestByHashResponse:
        r"""If 'latest' is not specified then it will return the specified release if it's enabled. If 'latest' is specified, regardless of whether a release hash is provided, the latest enabled release is returned."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetLatestByHashRequest, base_url, '/v0.1/sdk/apps/{app_secret}/releases/{release_hash}', request)
        
        query_params = utils.get_query_params(operations.ReleasesGetLatestByHashRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetLatestByHashResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByHash200ApplicationJSON])
                res.releases_get_latest_by_hash_200_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByHash404ApplicationJSON])
                res.releases_get_latest_by_hash_404_application_json_object = out

        return res

    def releases_get_latest_by_public_distribution_group(self, request: operations.ReleasesGetLatestByPublicDistributionGroupRequest) -> operations.ReleasesGetLatestByPublicDistributionGroupResponse:
        r"""Get a release with 'latest' for the given public group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetLatestByPublicDistributionGroupRequest, base_url, '/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases/latest', request)
        
        query_params = utils.get_query_params(operations.ReleasesGetLatestByPublicDistributionGroupRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetLatestByPublicDistributionGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByPublicDistributionGroup200ApplicationJSON])
                res.releases_get_latest_by_public_distribution_group_200_application_json_object = out
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByPublicDistributionGroup403ApplicationJSON])
                res.releases_get_latest_by_public_distribution_group_403_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByPublicDistributionGroup404ApplicationJSON])
                res.releases_get_latest_by_public_distribution_group_404_application_json_object = out

        return res

    def releases_get_latest_by_user(self, request: operations.ReleasesGetLatestByUserRequest, security: operations.ReleasesGetLatestByUserSecurity) -> operations.ReleasesGetLatestByUserResponse:
        r"""Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups)."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetLatestByUserRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', request)
        
        query_params = utils.get_query_params(operations.ReleasesGetLatestByUserRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetLatestByUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByUser200ApplicationJSON])
                res.releases_get_latest_by_user_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByUser400ApplicationJSON])
                res.releases_get_latest_by_user_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestByUser404ApplicationJSON])
                res.releases_get_latest_by_user_404_application_json_object = out

        return res

    def releases_get_latest_private_release(self, request: operations.ReleasesGetLatestPrivateReleaseRequest, security: operations.ReleasesGetLatestPrivateReleaseSecurity) -> operations.ReleasesGetLatestPrivateReleaseResponse:
        r"""Get the latest release distributed to a private group the given user is a member of for the given app."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetLatestPrivateReleaseRequest, base_url, '/v0.1/sdk/apps/{app_secret}/releases/private/latest', request)
        
        query_params = utils.get_query_params(operations.ReleasesGetLatestPrivateReleaseRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetLatestPrivateReleaseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestPrivateRelease200ApplicationJSON])
                res.releases_get_latest_private_release_200_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestPrivateRelease404ApplicationJSON])
                res.releases_get_latest_private_release_404_application_json_object = out

        return res

    def releases_get_latest_public_release(self, request: operations.ReleasesGetLatestPublicReleaseRequest) -> operations.ReleasesGetLatestPublicReleaseResponse:
        r"""Get the latest public release for the given app."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetLatestPublicReleaseRequest, base_url, '/v0.1/public/sdk/apps/{app_secret}/releases/latest', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetLatestPublicReleaseResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestPublicRelease200ApplicationJSON])
                res.releases_get_latest_public_release_200_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetLatestPublicRelease404ApplicationJSON])
                res.releases_get_latest_public_release_404_application_json_object = out

        return res

    def releases_get_public_groups_for_release_by_hash(self, request: operations.ReleasesGetPublicGroupsForReleaseByHashRequest) -> operations.ReleasesGetPublicGroupsForReleaseByHashResponse:
        r"""Get all public distribution groups that a given release has been distributed to"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetPublicGroupsForReleaseByHashRequest, base_url, '/v0.1/public/sdk/apps/{app_secret}/releases/{release_hash}/public_distribution_groups', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetPublicGroupsForReleaseByHashResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ReleasesGetPublicGroupsForReleaseByHash200ApplicationJSON]])
                res.releases_get_public_groups_for_release_by_hash_200_application_json_objects = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetPublicGroupsForReleaseByHash404ApplicationJSON])
                res.releases_get_public_groups_for_release_by_hash_404_application_json_object = out

        return res

    def releases_get_release_upload_status(self, request: operations.ReleasesGetReleaseUploadStatusRequest, security: operations.ReleasesGetReleaseUploadStatusSecurity) -> operations.ReleasesGetReleaseUploadStatusResponse:
        r"""Get the current status of the release upload."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetReleaseUploadStatusRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetReleaseUploadStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetReleaseUploadStatus200ApplicationJSON])
                res.releases_get_release_upload_status_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetReleaseUploadStatus400ApplicationJSON])
                res.releases_get_release_upload_status_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetReleaseUploadStatus404ApplicationJSON])
                res.releases_get_release_upload_status_404_application_json_object = out

        return res

    def releases_get_sparkle_feed(self, request: operations.ReleasesGetSparkleFeedRequest) -> operations.ReleasesGetSparkleFeedResponse:
        r"""Gets the sparkle feed of the releases that are distributed to all the public distribution groups."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesGetSparkleFeedRequest, base_url, '/v0.1/public/sparkle/apps/{app_secret}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesGetSparkleFeedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesGetSparkleFeedDefaultApplicationJSON])
                res.releases_get_sparkle_feed_default_application_json_object = out

        return res

    def releases_list(self, request: operations.ReleasesListRequest, security: operations.ReleasesListSecurity) -> operations.ReleasesListResponse:
        r"""Return basic information about releases."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases', request)
        
        query_params = utils.get_query_params(operations.ReleasesListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ReleasesList200ApplicationJSON]])
                res.releases_list_200_application_json_objects = out

        return res

    def releases_list_by_distribution_group(self, request: operations.ReleasesListByDistributionGroupRequest, security: operations.ReleasesListByDistributionGroupSecurity) -> operations.ReleasesListByDistributionGroupResponse:
        r"""Return basic information about distributed releases in a given distribution group."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesListByDistributionGroupRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesListByDistributionGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ReleasesListByDistributionGroup200ApplicationJSON]])
                res.releases_list_by_distribution_group_200_application_json_objects = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesListByDistributionGroup404ApplicationJSON])
                res.releases_list_by_distribution_group_404_application_json_object = out

        return res

    def releases_list_latest(self, request: operations.ReleasesListLatestRequest, security: operations.ReleasesListLatestSecurity) -> operations.ReleasesListLatestResponse:
        r"""Get the latest release from every distribution group associated with an application."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesListLatestRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/recent_releases', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesListLatestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ReleasesListLatest200ApplicationJSON]])
                res.releases_list_latest_200_application_json_objects = out

        return res

    def releases_put_distribution_group(self, request: operations.ReleasesPutDistributionGroupRequest, security: operations.ReleasesPutDistributionGroupSecurity) -> operations.ReleasesPutDistributionGroupResponse:
        r"""Update details about the specified distribution group associated with the release"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesPutDistributionGroupRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesPutDistributionGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesPutDistributionGroup404ApplicationJSON])
                res.releases_put_distribution_group_404_application_json_object = out

        return res

    def releases_put_distribution_tester(self, request: operations.ReleasesPutDistributionTesterRequest, security: operations.ReleasesPutDistributionTesterSecurity) -> operations.ReleasesPutDistributionTesterResponse:
        r"""Update details about the specified tester associated with the release"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesPutDistributionTesterRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesPutDistributionTesterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesPutDistributionTester404ApplicationJSON])
                res.releases_put_distribution_tester_404_application_json_object = out

        return res

    def releases_update(self, request: operations.ReleasesUpdateRequest, security: operations.ReleasesUpdateSecurity) -> operations.ReleasesUpdateResponse:
        r"""Updates a release."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesUpdateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdate200ApplicationJSON])
                res.releases_update_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdate400ApplicationJSON])
                res.releases_update_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdate404ApplicationJSON])
                res.releases_update_404_application_json_object = out

        return res

    def releases_update_details(self, request: operations.ReleasesUpdateDetailsRequest, security: operations.ReleasesUpdateDetailsSecurity) -> operations.ReleasesUpdateDetailsResponse:
        r"""Update details of a release."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesUpdateDetailsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesUpdateDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdateDetails200ApplicationJSON])
                res.releases_update_details_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdateDetails400ApplicationJSON])
                res.releases_update_details_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdateDetails404ApplicationJSON])
                res.releases_update_details_404_application_json_object = out

        return res

    def releases_update_release_upload_status(self, request: operations.ReleasesUpdateReleaseUploadStatusRequest, security: operations.ReleasesUpdateReleaseUploadStatusSecurity) -> operations.ReleasesUpdateReleaseUploadStatusResponse:
        r"""Update the current status of the release upload."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReleasesUpdateReleaseUploadStatusRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/uploads/releases/{upload_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.ReleasesUpdateReleaseUploadStatusRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReleasesUpdateReleaseUploadStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdateReleaseUploadStatus200ApplicationJSON])
                res.releases_update_release_upload_status_200_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdateReleaseUploadStatus400ApplicationJSON])
                res.releases_update_release_upload_status_400_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ReleasesUpdateReleaseUploadStatus404ApplicationJSON])
                res.releases_update_release_upload_status_404_application_json_object = out

        return res

    def store_notifications_get_notification_by_app_id(self, request: operations.StoreNotificationsGetNotificationByAppIDRequest, security: operations.StoreNotificationsGetNotificationByAppIDSecurity) -> operations.StoreNotificationsGetNotificationByAppIDResponse:
        r"""Application specific store service status"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreNotificationsGetNotificationByAppIDRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/store_service_status', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreNotificationsGetNotificationByAppIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreNotificationsGetNotificationByAppID200ApplicationJSON])
                res.store_notifications_get_notification_by_app_id_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreNotificationsGetNotificationByAppIDDefaultApplicationJSON])
                res.store_notifications_get_notification_by_app_id_default_application_json_object = out

        return res

    def store_release_publish_logs_get(self, request: operations.StoreReleasePublishLogsGetRequest, security: operations.StoreReleasePublishLogsGetSecurity) -> operations.StoreReleasePublishLogsGetResponse:
        r"""Returns publish logs for a particular release published to a particular store"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasePublishLogsGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_logs', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasePublishLogsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasePublishLogsGetDefaultApplicationJSON])
                res.store_release_publish_logs_get_default_application_json_object = out

        return res

    def store_releases_delete(self, request: operations.StoreReleasesDeleteRequest, security: operations.StoreReleasesDeleteSecurity) -> operations.StoreReleasesDeleteResponse:
        r"""delete the release with release Id"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasesDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'string')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesDeleteDefaultApplicationJSON])
                res.store_releases_delete_default_application_json_object = out

        return res

    def store_releases_get(self, request: operations.StoreReleasesGetRequest, security: operations.StoreReleasesGetSecurity) -> operations.StoreReleasesGetResponse:
        r"""Return releases published in a store for releaseId and storeId"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasesGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasesGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.StoreReleasesGet200ApplicationJSON]])
                res.store_releases_get_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesGetDefaultApplicationJSON])
                res.store_releases_get_default_application_json_object = out

        return res

    def store_releases_get_latest(self, request: operations.StoreReleasesGetLatestRequest, security: operations.StoreReleasesGetLatestSecurity) -> operations.StoreReleasesGetLatestResponse:
        r"""Returns the latest release published in a store."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasesGetLatestRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasesGetLatestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.StoreReleasesGetLatest200ApplicationJSON]])
                res.store_releases_get_latest_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesGetLatestDefaultApplicationJSON])
                res.store_releases_get_latest_default_application_json_object = out

        return res

    def store_releases_get_publish_error(self, request: operations.StoreReleasesGetPublishErrorRequest, security: operations.StoreReleasesGetPublishErrorSecurity) -> operations.StoreReleasesGetPublishErrorResponse:
        r"""Return the Error Details of release which failed in publishing."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasesGetPublishErrorRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_error_details', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasesGetPublishErrorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesGetPublishError200ApplicationJSON])
                res.store_releases_get_publish_error_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesGetPublishErrorDefaultApplicationJSON])
                res.store_releases_get_publish_error_default_application_json_object = out

        return res

    def store_releases_get_real_time_status_by_release_id(self, request: operations.StoreReleasesGetRealTimeStatusByReleaseIDRequest, security: operations.StoreReleasesGetRealTimeStatusByReleaseIDSecurity) -> operations.StoreReleasesGetRealTimeStatusByReleaseIDResponse:
        r"""Return the Real time Status publishing of release from store."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasesGetRealTimeStatusByReleaseIDRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/realtimestatus', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasesGetRealTimeStatusByReleaseIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesGetRealTimeStatusByReleaseID200ApplicationJSON])
                res.store_releases_get_real_time_status_by_release_id_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesGetRealTimeStatusByReleaseIDDefaultApplicationJSON])
                res.store_releases_get_real_time_status_by_release_id_default_application_json_object = out

        return res

    def store_releases_list(self, request: operations.StoreReleasesListRequest, security: operations.StoreReleasesListSecurity) -> operations.StoreReleasesListResponse:
        r"""Return all releases published  in a store"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoreReleasesListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoreReleasesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.StoreReleasesList200ApplicationJSON]])
                res.store_releases_list_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoreReleasesListDefaultApplicationJSON])
                res.store_releases_list_default_application_json_object = out

        return res

    def stores_create(self, request: operations.StoresCreateRequest, security: operations.StoresCreateSecurity) -> operations.StoresCreateResponse:
        r"""Create a new external store for the specified application."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoresCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoresCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoresCreate201ApplicationJSON])
                res.stores_create_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoresCreateDefaultApplicationJSON])
                res.stores_create_default_application_json_object = out

        return res

    def stores_delete(self, request: operations.StoresDeleteRequest, security: operations.StoresDeleteSecurity) -> operations.StoresDeleteResponse:
        r"""delete the store based on specific store name."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoresDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'string')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoresDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoresDeleteDefaultApplicationJSON])
                res.stores_delete_default_application_json_object = out

        return res

    def stores_get(self, request: operations.StoresGetRequest, security: operations.StoresGetSecurity) -> operations.StoresGetResponse:
        r"""Return the store details for specified store name."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoresGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoresGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoresGet200ApplicationJSON])
                res.stores_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoresGetDefaultApplicationJSON])
                res.stores_get_default_application_json_object = out

        return res

    def stores_list(self, request: operations.StoresListRequest, security: operations.StoresListSecurity) -> operations.StoresListResponse:
        r"""Get all the store details from Storage store table for a particular application."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoresListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoresListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.StoresList200ApplicationJSON]])
                res.stores_list_200_application_json_objects = out

        return res

    def stores_patch(self, request: operations.StoresPatchRequest, security: operations.StoresPatchSecurity) -> operations.StoresPatchResponse:
        r"""Update the store."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StoresPatchRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StoresPatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.StoresPatchDefaultApplicationJSON])
                res.stores_patch_default_application_json_object = out

        return res

    