/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Content {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Identical to GET /account/profile/items/{itemId}/next route but for users
   * that are not logged in i.e. this endpoint does not require authorisation
   *
   */
  getAnonNextPlaybackItem(
    req: operations.GetAnonNextPlaybackItemRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAnonNextPlaybackItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAnonNextPlaybackItemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/items/{itemId}/next", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAnonNextPlaybackItemResponse =
        new operations.GetAnonNextPlaybackItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nextPlaybackItem = utils.objectToClass(
              httpRes?.data,
              shared.NextPlaybackItem
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of an item with the specified id.
   */
  getItem(
    req: operations.GetItemRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/items/{id}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemResponse = new operations.GetItemResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemDetail = utils.objectToClass(
              httpRes?.data,
              shared.ItemDetail
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the List of child summary items under an item.
   *
   * If the item is a Season then the children will be episodes and ordered by episode number.
   *
   * If the item is a Show then the children will be Seasons and ordered by season number.
   *
   * Returns 404 if no children found.
   *
   */
  getItemChildrenList(
    req: operations.GetItemChildrenListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemChildrenListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemChildrenListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/items/{id}/children", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemChildrenListResponse =
        new operations.GetItemChildrenListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of an item with the specified id.
   */
  getItemDownloadables(
    req: operations.GetItemDownloadablesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemDownloadablesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemDownloadablesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/items/downloadable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itemDownloadableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemDownloadablesResponse =
        new operations.GetItemDownloadablesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemDownloadableList = utils.objectToClass(
              httpRes?.data,
              shared.ItemDownloadableList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of items related to the parent item.
   *
   * Note for now, due to the size of the list being unknown, only a single page will be returned.
   *
   */
  getItemRelatedList(
    req: operations.GetItemRelatedListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemRelatedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemRelatedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/items/{id}/related", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemRelatedListResponse =
        new operations.GetItemRelatedListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the media clip files associated with items.
   *
   */
  getItemsMediaClipFiles(
    req: operations.GetItemsMediaClipFilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemsMediaClipFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemsMediaClipFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/itv/items/clips";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "itemDownloadableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemsMediaClipFilesResponse =
        new operations.GetItemsMediaClipFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemClipFilesList = utils.objectToClass(
              httpRes?.data,
              shared.ItemClipFilesList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of items under the specified item list
   */
  getList(
    req: operations.GetListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/lists/{id}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetListResponse = new operations.GetListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns an array of item lists with their first page of content resolved.
   */
  getLists(
    req: operations.GetListsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetListsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetListsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/lists";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetListsResponse = new operations.GetListsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemLists = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.itemLists = utils.objectToClass(
              httpRes?.data,
              shared.ItemList,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the free / public video files associated with an item given maximum resolution,
   * device type and one or more delivery types.
   *
   * Returns an array of video file objects which each include a url to a video.
   *
   * The first entry in the array contains what is predicted to be the best match.
   * The remainder of the entries, if any, may contain resolutions below what was
   * requests. For example if you request HD-720 the response may also contain
   * SD entries.
   *
   * If you specify multiple delivery types, then the response array will insert
   * types in the order you specify them in the query. For example `stream,progressive`
   * would return an array with 0 or more stream files followed by 0 or more progressive files.
   *
   * If no files are found a 404 is returned.
   *
   */
  getPublicItemMediaFiles(
    req: operations.GetPublicItemMediaFilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPublicItemMediaFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPublicItemMediaFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/items/{id}/videos", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPublicItemMediaFilesResponse =
        new operations.GetPublicItemMediaFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mediaFiles = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.mediaFiles = utils.objectToClass(
              httpRes?.data,
              shared.MediaFile,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns schedules for a defined set of channels over a requested period.
   *
   * Schedules are requested in hour blocks and returned grouped by the channel
   * they belong to.
   *
   * For example, to load 12 hours of schedules for channels `4343` and `5234`,
   * on 21/2/2017 starting from 08:00.
   *
   * ```
   * channels=4343,5234
   * date=2017-02-21
   * hour=8
   * duration=12
   * ```
   *
   * Please remember that `date` and `hour` combined represent a normal datetime,
   * so they should be converted to UTC on the client - this will help to avoid
   * issues with EPG schedules near midnight.
   *
   * If a channel id is passed which doesn't exist then this endpoint will
   * return an empty schedule list for it. If instead we returned 404,
   * this would invalidate all other channel schedules in the same request
   * which would be unfriendly for clients presenting these channel schedules.
   *
   */
  getSchedules(
    req: operations.GetSchedulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSchedulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSchedulesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/schedules";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSchedulesResponse =
        new operations.GetSchedulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemScheduleLists = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.itemScheduleLists = utils.objectToClass(
              httpRes?.data,
              shared.ItemScheduleList,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the details of a Plan with the specified id.
   */
  getPlansId(
    req: operations.GetPlansIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPlansIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPlansIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/plans/{id}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPlansIdResponse =
        new operations.GetPlansIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.plan = utils.objectToClass(httpRes?.data, shared.Plan);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search the catalog of items and people.
   */
  search(
    req: operations.SearchRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/search";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchResponse = new operations.SearchResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.searchResults = utils.objectToClass(
              httpRes?.data,
              shared.SearchResults
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }
}
