<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Projects 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Creates a new EkmConnection in a given Project and Location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateResponse
     */
	public function cloudkmsProjectsLocationsEkmConnectionsCreate(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/ekmConnections', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "ekmConnectionInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->ekmConnection = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EkmConnection', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists EkmConnections.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListResponse
     */
	public function cloudkmsProjectsLocationsEkmConnectionsList(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/ekmConnections', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listEkmConnectionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListEkmConnectionsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Verifies that Cloud KMS can successfully connect to the external key manager specified by an EkmConnection. If there is an error connecting to the EKM, this method returns a FAILED_PRECONDITION status containing structured information as described at https://cloud.google.com/kms/docs/reference/ekm_errors.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivitySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityResponse
     */
	public function cloudkmsProjectsLocationsEkmConnectionsVerifyConnectivity(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivitySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:verifyConnectivity', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsEkmConnectionsVerifyConnectivityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->verifyConnectivityResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate random bytes using the Cloud KMS randomness source in the provided location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesResponse
     */
	public function cloudkmsProjectsLocationsGenerateRandomBytes(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{location}:generateRandomBytes', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "generateRandomBytesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsGenerateRandomBytesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->generateRandomBytesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GenerateRandomBytesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new KeyRing in a given Project and Location.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCreate(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/keyRings', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->keyRing = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\KeyRing', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new CryptoKey within a KeyRing. CryptoKey.purpose and CryptoKey.version_template.algorithm are required.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCreate(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/cryptoKeys', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "cryptoKeyInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKey = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKey', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Decrypts data that was encrypted with a public key retrieved from GetPublicKey corresponding to a CryptoKeyVersion with CryptoKey.purpose ASYMMETRIC_DECRYPT.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecrypt(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:asymmetricDecrypt', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "asymmetricDecryptRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricDecryptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asymmetricDecryptResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsymmetricDecryptResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Signs data using a CryptoKeyVersion with CryptoKey.purpose ASYMMETRIC_SIGN, producing a signature that can be verified with the public key retrieved from GetPublicKey.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSign(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:asymmetricSign', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "asymmetricSignRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsAsymmetricSignResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asymmetricSignResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsymmetricSignResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new CryptoKeyVersion in a CryptoKey. The server will assign the next sequential id. If unset, state will be set to ENABLED.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreate(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/cryptoKeyVersions', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "cryptoKeyVersionInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKeyVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKeyVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Schedule a CryptoKeyVersion for destruction. Upon calling this method, CryptoKeyVersion.state will be set to DESTROY_SCHEDULED, and destroy_time will be set to the time destroy_scheduled_duration in the future. At that time, the state will automatically change to DESTROYED, and the key material will be irrevocably destroyed. Before the destroy_time is reached, RestoreCryptoKeyVersion may be called to reverse the process.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroy(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:destroy', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsDestroyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKeyVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKeyVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the public key for the given CryptoKeyVersion. The CryptoKey.purpose must be ASYMMETRIC_SIGN or ASYMMETRIC_DECRYPT.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKey(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}/publicKey', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsGetPublicKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->publicKey = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PublicKey', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Import wrapped key material into a CryptoKeyVersion. All requests must specify a CryptoKey. If a CryptoKeyVersion is additionally specified in the request, key material will be reimported into that version. Otherwise, a new version will be created, and will be assigned the next sequential id within the CryptoKey.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImport(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/cryptoKeyVersions:import', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "importCryptoKeyVersionRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsImportResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKeyVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKeyVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists CryptoKeyVersions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsList(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/cryptoKeyVersions', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listCryptoKeyVersionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListCryptoKeyVersionsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Signs data using a CryptoKeyVersion with CryptoKey.purpose MAC, producing a tag that can be verified by another source with the same key.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSign(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:macSign', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "macSignRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacSignResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->macSignResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MacSignResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Verifies MAC tag using a CryptoKeyVersion with CryptoKey.purpose MAC, and returns a response that indicates whether or not the verification was successful.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerify(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:macVerify', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "macVerifyRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsMacVerifyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->macVerifyResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MacVerifyResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a CryptoKeyVersion's metadata. state may be changed between ENABLED and DISABLED using this method. See DestroyCryptoKeyVersion and RestoreCryptoKeyVersion to move between other states.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatch(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "cryptoKeyVersionInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKeyVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKeyVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Restore a CryptoKeyVersion in the DESTROY_SCHEDULED state. Upon restoration of the CryptoKeyVersion, state will be set to DISABLED, and destroy_time will be cleared.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestore(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:restore', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysCryptoKeyVersionsRestoreResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKeyVersion = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKeyVersion', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Decrypts data that was protected by Encrypt. The CryptoKey.purpose must be ENCRYPT_DECRYPT.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysDecrypt(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:decrypt', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "decryptRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysDecryptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->decryptResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DecryptResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Encrypts data, so that it can only be recovered by a call to Decrypt. The CryptoKey.purpose must be ENCRYPT_DECRYPT.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysEncrypt(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:encrypt', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "encryptRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysEncryptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->encryptResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EncryptResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists CryptoKeys.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysList(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/cryptoKeys', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listCryptoKeysResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListCryptoKeysResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the version of a CryptoKey that will be used in Encrypt. Returns an error if called on a key whose purpose is not ENCRYPT_DECRYPT.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersion(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}:updatePrimaryVersion', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateCryptoKeyPrimaryVersionRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsCryptoKeysUpdatePrimaryVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cryptoKey = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CryptoKey', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new ImportJob within a KeyRing. ImportJob.import_method is required.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsImportJobsCreate(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/importJobs', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "importJobInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->importJob = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ImportJob', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns metadata for a given ImportJob.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsImportJobsGet(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->importJob = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ImportJob', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicy(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{resource}:getIamPolicy', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsGetIamPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->policy = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Policy', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists ImportJobs.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsImportJobsList(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/importJobs', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listImportJobsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListImportJobsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicy(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{resource}:setIamPolicy', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "setIamPolicyRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsSetIamPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->policy = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Policy', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissions(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{resource}:testIamPermissions', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "testIamPermissionsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsImportJobsTestIamPermissionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->testIamPermissionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TestIamPermissionsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists KeyRings.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListResponse
     */
	public function cloudkmsProjectsLocationsKeyRingsList(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/keyRings', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsKeyRingsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listKeyRingsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListKeyRingsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists information about the supported locations for this service.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListResponse
     */
	public function cloudkmsProjectsLocationsList(
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}/locations', \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CloudkmsProjectsLocationsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listLocationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListLocationsResponse', 'json');
            }
        }

        return $response;
    }
}