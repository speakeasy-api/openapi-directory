/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  "https://api.increase.com",
  "https://sandbox.increase.com",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * Action a Real-Time Decision
   */
  actionARealTimeDecision(
    req: operations.ActionARealTimeDecisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ActionARealTimeDecisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ActionARealTimeDecisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/real_time_decisions/{real_time_decision_id}/action",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "actionARealTimeDecisionParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ActionARealTimeDecisionResponse =
        new operations.ActionARealTimeDecisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.realTimeDecision = utils.objectToClass(
              httpRes?.data,
              shared.RealTimeDecision
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Approve a Check Transfer
   */
  approveACheckTransfer(
    req: operations.ApproveACheckTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ApproveACheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ApproveACheckTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/check_transfers/{check_transfer_id}/approve",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ApproveACheckTransferResponse =
        new operations.ApproveACheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Approve a Wire Transfer
   */
  approveAWireTransfer(
    req: operations.ApproveAWireTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ApproveAWireTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ApproveAWireTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/wire_transfers/{wire_transfer_id}/approve",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ApproveAWireTransferResponse =
        new operations.ApproveAWireTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransfer = utils.objectToClass(
              httpRes?.data,
              shared.WireTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Approve an Account Transfer
   */
  approveAnAccountTransfer(
    req: operations.ApproveAnAccountTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ApproveAnAccountTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ApproveAnAccountTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account_transfers/{account_transfer_id}/approve",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ApproveAnAccountTransferResponse =
        new operations.ApproveAnAccountTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AccountTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Approve an ACH Transfer
   *
   * @remarks
   * Approves an ACH Transfer in a pending_approval state.
   */
  approveAnAchTransfer(
    req: operations.ApproveAnAchTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ApproveAnAchTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ApproveAnAchTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ach_transfers/{ach_transfer_id}/approve",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ApproveAnAchTransferResponse =
        new operations.ApproveAnAchTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AchTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a pending ACH Transfer
   *
   * @remarks
   * Cancels an ACH Transfer in a pending_approval state.
   */
  cancelAPendingAchTransfer(
    req: operations.CancelAPendingAchTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelAPendingAchTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelAPendingAchTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ach_transfers/{ach_transfer_id}/cancel",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelAPendingAchTransferResponse =
        new operations.CancelAPendingAchTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AchTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a pending Check Transfer
   */
  cancelAPendingCheckTransfer(
    req: operations.CancelAPendingCheckTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelAPendingCheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelAPendingCheckTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/check_transfers/{check_transfer_id}/cancel",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelAPendingCheckTransferResponse =
        new operations.CancelAPendingCheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel a pending Wire Transfer
   */
  cancelAPendingWireTransfer(
    req: operations.CancelAPendingWireTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelAPendingWireTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelAPendingWireTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/wire_transfers/{wire_transfer_id}/cancel",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelAPendingWireTransferResponse =
        new operations.CancelAPendingWireTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransfer = utils.objectToClass(
              httpRes?.data,
              shared.WireTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel an Account Transfer
   */
  cancelAnAccountTransfer(
    req: operations.CancelAnAccountTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelAnAccountTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelAnAccountTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account_transfers/{account_transfer_id}/cancel",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelAnAccountTransferResponse =
        new operations.CancelAnAccountTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AccountTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Close an Account
   */
  closeAnAccount(
    req: operations.CloseAnAccountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CloseAnAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CloseAnAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{account_id}/close",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloseAnAccountResponse =
        new operations.CloseAnAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Complete a Sandbox Account Transfer
   *
   * @remarks
   * If your account is configured to require approval for each transfer, this endpoint simulates the approval of an [Account Transfer](#account-transfers). You can also approve sandbox Account Transfers in the dashboard. This transfer must first have a `status` of `pending_approval`.
   */
  completeASandboxAccountTransfer(
    req: operations.CompleteASandboxAccountTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CompleteASandboxAccountTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CompleteASandboxAccountTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/account_transfers/{account_transfer_id}/complete",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CompleteASandboxAccountTransferResponse =
        new operations.CompleteASandboxAccountTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AccountTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Card
   */
  createACard(
    req: shared.CreateACardParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateACardParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/cards";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateACardResponse =
        new operations.CreateACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.card = utils.objectToClass(httpRes?.data, shared.Card);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Card Dispute
   */
  createACardDispute(
    req: shared.CreateACardDisputeParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateACardDisputeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateACardDisputeParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/card_disputes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateACardDisputeResponse =
        new operations.CreateACardDisputeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardDispute = utils.objectToClass(
              httpRes?.data,
              shared.CardDispute
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Card Profile
   */
  createACardProfile(
    req: shared.CreateACardProfileParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateACardProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateACardProfileParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/card_profiles";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateACardProfileResponse =
        new operations.CreateACardProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardProfile = utils.objectToClass(
              httpRes?.data,
              shared.CardProfile
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Check Deposit
   */
  createACheckDeposit(
    req: shared.CreateACheckDepositParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateACheckDepositResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateACheckDepositParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/check_deposits";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateACheckDepositResponse =
        new operations.CreateACheckDepositResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkDeposit = utils.objectToClass(
              httpRes?.data,
              shared.CheckDeposit
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Check Transfer
   */
  createACheckTransfer(
    req: shared.CreateACheckTransferParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateACheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateACheckTransferParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/check_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateACheckTransferResponse =
        new operations.CreateACheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a File
   *
   * @remarks
   * To upload a file to Increase, you'll need to send a request of Content-Type `multipart/form-data`. The request should contain the file you would like to upload, as well as the parameters for creating a file.
   */
  createAFile(
    req: shared.CreateAFileParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAFileParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAFileResponse =
        new operations.CreateAFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Limit
   */
  createALimit(
    req: shared.CreateALimitParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateALimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateALimitParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/limits";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateALimitResponse =
        new operations.CreateALimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limit = utils.objectToClass(httpRes?.data, shared.Limit);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a supplemental document for an Entity
   */
  createASupplementalDocumentForAnEntity(
    req: operations.CreateASupplementalDocumentForAnEntityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateASupplementalDocumentForAnEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateASupplementalDocumentForAnEntityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/{entity_id}/supplemental_documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createASupplementalDocumentForAnEntityParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateASupplementalDocumentForAnEntityResponse =
        new operations.CreateASupplementalDocumentForAnEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entity = utils.objectToClass(httpRes?.data, shared.Entity);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Wire Drawdown Request
   */
  createAWireDrawdownRequest(
    req: shared.CreateAWireDrawdownRequestParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAWireDrawdownRequestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAWireDrawdownRequestParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/wire_drawdown_requests";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAWireDrawdownRequestResponse =
        new operations.CreateAWireDrawdownRequestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireDrawdownRequest = utils.objectToClass(
              httpRes?.data,
              shared.WireDrawdownRequest
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a Wire Transfer
   */
  createAWireTransfer(
    req: shared.CreateAWireTransferParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAWireTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAWireTransferParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/wire_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAWireTransferResponse =
        new operations.CreateAWireTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransfer = utils.objectToClass(
              httpRes?.data,
              shared.WireTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an Account
   */
  createAnAccount(
    req: shared.CreateAnAccountParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnAccountParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/accounts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnAccountResponse =
        new operations.CreateAnAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an Account Number
   */
  createAnAccountNumber(
    req: shared.CreateAnAccountNumberParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnAccountNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnAccountNumberParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account_numbers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnAccountNumberResponse =
        new operations.CreateAnAccountNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountNumber = utils.objectToClass(
              httpRes?.data,
              shared.AccountNumber
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an Account Transfer
   */
  createAnAccountTransfer(
    req: shared.CreateAnAccountTransferParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnAccountTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnAccountTransferParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnAccountTransferResponse =
        new operations.CreateAnAccountTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AccountTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an ACH Prenotification
   */
  createAnAchPrenotification(
    req: shared.CreateAnAchPrenotificationParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnAchPrenotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnAchPrenotificationParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ach_prenotifications";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnAchPrenotificationResponse =
        new operations.CreateAnAchPrenotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achPrenotification = utils.objectToClass(
              httpRes?.data,
              shared.AchPrenotification
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an ACH Return
   */
  createAnAchReturn(
    req: shared.CreateAnAchReturnParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnAchReturnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnAchReturnParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/inbound_ach_transfer_returns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnAchReturnResponse =
        new operations.CreateAnAchReturnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundAchTransferReturn = utils.objectToClass(
              httpRes?.data,
              shared.InboundAchTransferReturn
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an ACH Transfer
   */
  createAnAchTransfer(
    req: shared.CreateAnAchTransferParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnAchTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnAchTransferParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ach_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnAchTransferResponse =
        new operations.CreateAnAchTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AchTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an Entity
   */
  createAnEntity(
    req: shared.CreateAnEntityParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnEntityParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnEntityResponse =
        new operations.CreateAnEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entity = utils.objectToClass(httpRes?.data, shared.Entity);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an Event Subscription
   */
  createAnEventSubscription(
    req: shared.CreateAnEventSubscriptionParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnEventSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnEventSubscriptionParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/event_subscriptions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnEventSubscriptionResponse =
        new operations.CreateAnEventSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventSubscription = utils.objectToClass(
              httpRes?.data,
              shared.EventSubscription
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an External Account
   */
  createAnExternalAccount(
    req: shared.CreateAnExternalAccountParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnExternalAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnExternalAccountParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/external_accounts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAnExternalAccountResponse =
        new operations.CreateAnExternalAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.externalAccount = utils.objectToClass(
              httpRes?.data,
              shared.ExternalAccount
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deposit a Sandbox Check Transfer
   *
   * @remarks
   * Simulates a [Check Transfer](#check-transfers) being deposited at a bank. This transfer must first have a `status` of `mailed`.
   */
  depositASandboxCheckTransfer(
    req: operations.DepositASandboxCheckTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DepositASandboxCheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DepositASandboxCheckTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/check_transfers/{check_transfer_id}/deposit",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DepositASandboxCheckTransferResponse =
        new operations.DepositASandboxCheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Account Numbers
   */
  listAccountNumbers(
    req: operations.ListAccountNumbersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountNumbersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountNumbersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account_numbers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountNumbersResponse =
        new operations.ListAccountNumbersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountNumberList = utils.objectToClass(
              httpRes?.data,
              shared.AccountNumberList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Account Statements
   */
  listAccountStatements(
    req: operations.ListAccountStatementsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountStatementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountStatementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account_statements";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountStatementsResponse =
        new operations.ListAccountStatementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountStatementList = utils.objectToClass(
              httpRes?.data,
              shared.AccountStatementList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Account Transfers
   */
  listAccountTransfers(
    req: operations.ListAccountTransfersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountTransfersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountTransfersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account_transfers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountTransfersResponse =
        new operations.ListAccountTransfersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountTransferList = utils.objectToClass(
              httpRes?.data,
              shared.AccountTransferList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Accounts
   */
  listAccounts(
    req: operations.ListAccountsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/accounts";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAccountsResponse =
        new operations.ListAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountList = utils.objectToClass(
              httpRes?.data,
              shared.AccountList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List ACH Prenotifications
   */
  listAchPrenotifications(
    req: operations.ListAchPrenotificationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAchPrenotificationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAchPrenotificationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ach_prenotifications";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAchPrenotificationsResponse =
        new operations.ListAchPrenotificationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achPrenotificationList = utils.objectToClass(
              httpRes?.data,
              shared.AchPrenotificationList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List ACH Transfers
   */
  listAchTransfers(
    req: operations.ListAchTransfersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAchTransfersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAchTransfersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ach_transfers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAchTransfersResponse =
        new operations.ListAchTransfersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransferList = utils.objectToClass(
              httpRes?.data,
              shared.AchTransferList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Card Disputes
   */
  listCardDisputes(
    req: operations.ListCardDisputesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCardDisputesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCardDisputesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/card_disputes";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCardDisputesResponse =
        new operations.ListCardDisputesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardDisputeList = utils.objectToClass(
              httpRes?.data,
              shared.CardDisputeList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Card Profiles
   */
  listCardProfiles(
    req: operations.ListCardProfilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCardProfilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCardProfilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/card_profiles";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCardProfilesResponse =
        new operations.ListCardProfilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardProfileList = utils.objectToClass(
              httpRes?.data,
              shared.CardProfileList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Cards
   */
  listCards(
    req: operations.ListCardsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCardsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCardsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/cards";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCardsResponse =
        new operations.ListCardsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardList = utils.objectToClass(httpRes?.data, shared.CardList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Check Deposits
   */
  listCheckDeposits(
    req: operations.ListCheckDepositsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCheckDepositsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCheckDepositsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/check_deposits";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCheckDepositsResponse =
        new operations.ListCheckDepositsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkDepositList = utils.objectToClass(
              httpRes?.data,
              shared.CheckDepositList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Check Transfers
   */
  listCheckTransfers(
    req: operations.ListCheckTransfersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCheckTransfersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCheckTransfersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/check_transfers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCheckTransfersResponse =
        new operations.ListCheckTransfersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransferList = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransferList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Declined Transactions
   */
  listDeclinedTransactions(
    req: operations.ListDeclinedTransactionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeclinedTransactionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeclinedTransactionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/declined_transactions";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeclinedTransactionsResponse =
        new operations.ListDeclinedTransactionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.declinedTransactionList = utils.objectToClass(
              httpRes?.data,
              shared.DeclinedTransactionList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Digital Wallet Tokens
   */
  listDigitalWalletTokens(
    req: operations.ListDigitalWalletTokensRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDigitalWalletTokensResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDigitalWalletTokensRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/digital_wallet_tokens";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDigitalWalletTokensResponse =
        new operations.ListDigitalWalletTokensResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.digitalWalletTokenList = utils.objectToClass(
              httpRes?.data,
              shared.DigitalWalletTokenList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Documents
   */
  listDocuments(
    req: operations.ListDocumentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDocumentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDocumentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/documents";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDocumentsResponse =
        new operations.ListDocumentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.documentList = utils.objectToClass(
              httpRes?.data,
              shared.DocumentList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Entities
   */
  listEntities(
    req: operations.ListEntitiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEntitiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEntitiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/entities";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEntitiesResponse =
        new operations.ListEntitiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityList = utils.objectToClass(
              httpRes?.data,
              shared.EntityList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Event Subscriptions
   */
  listEventSubscriptions(
    req: operations.ListEventSubscriptionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEventSubscriptionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEventSubscriptionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/event_subscriptions";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEventSubscriptionsResponse =
        new operations.ListEventSubscriptionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventSubscriptionList = utils.objectToClass(
              httpRes?.data,
              shared.EventSubscriptionList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Events
   */
  listEvents(
    req: operations.ListEventsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/events";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEventsResponse =
        new operations.ListEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventList = utils.objectToClass(
              httpRes?.data,
              shared.EventList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List External Accounts
   */
  listExternalAccounts(
    req: operations.ListExternalAccountsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListExternalAccountsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListExternalAccountsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/external_accounts";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListExternalAccountsResponse =
        new operations.ListExternalAccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.externalAccountList = utils.objectToClass(
              httpRes?.data,
              shared.ExternalAccountList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Files
   */
  listFiles(
    req: operations.ListFilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFilesResponse =
        new operations.ListFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fileList = utils.objectToClass(httpRes?.data, shared.FileList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Inbound ACH Transfer Returns
   */
  listInboundAchTransferReturns(
    req: operations.ListInboundAchTransferReturnsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInboundAchTransferReturnsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInboundAchTransferReturnsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/inbound_ach_transfer_returns";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInboundAchTransferReturnsResponse =
        new operations.ListInboundAchTransferReturnsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundAchTransferReturnList = utils.objectToClass(
              httpRes?.data,
              shared.InboundAchTransferReturnList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Inbound Wire Drawdown Requests
   */
  listInboundWireDrawdownRequests(
    req: operations.ListInboundWireDrawdownRequestsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListInboundWireDrawdownRequestsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListInboundWireDrawdownRequestsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/inbound_wire_drawdown_requests";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListInboundWireDrawdownRequestsResponse =
        new operations.ListInboundWireDrawdownRequestsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundWireDrawdownRequestList = utils.objectToClass(
              httpRes?.data,
              shared.InboundWireDrawdownRequestList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Limits
   */
  listLimits(
    req: operations.ListLimitsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListLimitsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListLimitsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/limits";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListLimitsResponse =
        new operations.ListLimitsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limitList = utils.objectToClass(
              httpRes?.data,
              shared.LimitList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List OAuth Connections
   */
  listOauthConnections(
    req: operations.ListOauthConnectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListOauthConnectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListOauthConnectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/oauth_connections";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListOauthConnectionsResponse =
        new operations.ListOauthConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oauthConnectionList = utils.objectToClass(
              httpRes?.data,
              shared.OauthConnectionList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Pending Transactions
   */
  listPendingTransactions(
    req: operations.ListPendingTransactionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPendingTransactionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPendingTransactionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/pending_transactions";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPendingTransactionsResponse =
        new operations.ListPendingTransactionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pendingTransactionList = utils.objectToClass(
              httpRes?.data,
              shared.PendingTransactionList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Routing Numbers
   *
   * @remarks
   * You can use this API to confirm if a routing number is valid, such as when a user is providing you with bank account details. Since routing numbers uniquely identify a bank, this will always return 0 or 1 entry. In Sandbox, the only valid routing number for this method is 110000000.
   */
  listRoutingNumbers(
    req: operations.ListRoutingNumbersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRoutingNumbersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRoutingNumbersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/routing_numbers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRoutingNumbersResponse =
        new operations.ListRoutingNumbersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.routingNumberList = utils.objectToClass(
              httpRes?.data,
              shared.RoutingNumberList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Transactions
   */
  listTransactions(
    req: operations.ListTransactionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTransactionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTransactionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/transactions";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTransactionsResponse =
        new operations.ListTransactionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transactionList = utils.objectToClass(
              httpRes?.data,
              shared.TransactionList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Wire Drawdown Requests
   */
  listWireDrawdownRequests(
    req: operations.ListWireDrawdownRequestsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWireDrawdownRequestsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWireDrawdownRequestsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/wire_drawdown_requests";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWireDrawdownRequestsResponse =
        new operations.ListWireDrawdownRequestsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireDrawdownRequestList = utils.objectToClass(
              httpRes?.data,
              shared.WireDrawdownRequestList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * List Wire Transfers
   */
  listWireTransfers(
    req: operations.ListWireTransfersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWireTransfersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWireTransfersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/wire_transfers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWireTransfersResponse =
        new operations.ListWireTransfersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransferList = utils.objectToClass(
              httpRes?.data,
              shared.WireTransferList
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Mail a Sandbox Check Transfer
   *
   * @remarks
   * Simulates the mailing of a [Check Transfer](#check-transfers), which happens once per weekday in production but can be sped up in sandbox. This transfer must first have a `status` of `pending_approval` or `pending_submission`.
   */
  mailASandboxCheckTransfer(
    req: operations.MailASandboxCheckTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.MailASandboxCheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MailASandboxCheckTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/check_transfers/{check_transfer_id}/mail",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MailASandboxCheckTransferResponse =
        new operations.MailASandboxCheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reject a Sandbox Check Deposit
   *
   * @remarks
   * Simulates the rejection of a [Check Deposit](#check-deposits) by Increase due to factors like poor image quality. This Check Deposit must first have a `status` of `pending`.
   */
  rejectASandboxCheckDeposit(
    req: operations.RejectASandboxCheckDepositRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RejectASandboxCheckDepositResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RejectASandboxCheckDepositRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/check_deposits/{check_deposit_id}/reject",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RejectASandboxCheckDepositResponse =
        new operations.RejectASandboxCheckDepositResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkDeposit = utils.objectToClass(
              httpRes?.data,
              shared.CheckDeposit
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request a stop payment on a Check Transfer
   */
  requestAStopPaymentOnACheckTransfer(
    req: operations.RequestAStopPaymentOnACheckTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestAStopPaymentOnACheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RequestAStopPaymentOnACheckTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/check_transfers/{check_transfer_id}/stop_payment",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestAStopPaymentOnACheckTransferResponse =
        new operations.RequestAStopPaymentOnACheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Card
   */
  retrieveACard(
    req: operations.RetrieveACardRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveACardRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/cards/{card_id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveACardResponse =
        new operations.RetrieveACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.card = utils.objectToClass(httpRes?.data, shared.Card);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Card Dispute
   */
  retrieveACardDispute(
    req: operations.RetrieveACardDisputeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveACardDisputeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveACardDisputeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/card_disputes/{card_dispute_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveACardDisputeResponse =
        new operations.RetrieveACardDisputeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardDispute = utils.objectToClass(
              httpRes?.data,
              shared.CardDispute
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Card Profile
   */
  retrieveACardProfile(
    req: operations.RetrieveACardProfileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveACardProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveACardProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/card_profiles/{card_profile_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveACardProfileResponse =
        new operations.RetrieveACardProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardProfile = utils.objectToClass(
              httpRes?.data,
              shared.CardProfile
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Check Deposit
   */
  retrieveACheckDeposit(
    req: operations.RetrieveACheckDepositRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveACheckDepositResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveACheckDepositRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/check_deposits/{check_deposit_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveACheckDepositResponse =
        new operations.RetrieveACheckDepositResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkDeposit = utils.objectToClass(
              httpRes?.data,
              shared.CheckDeposit
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Check Transfer
   */
  retrieveACheckTransfer(
    req: operations.RetrieveACheckTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveACheckTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveACheckTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/check_transfers/{check_transfer_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveACheckTransferResponse =
        new operations.RetrieveACheckTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkTransfer = utils.objectToClass(
              httpRes?.data,
              shared.CheckTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Declined Transaction
   */
  retrieveADeclinedTransaction(
    req: operations.RetrieveADeclinedTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveADeclinedTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveADeclinedTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/declined_transactions/{declined_transaction_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveADeclinedTransactionResponse =
        new operations.RetrieveADeclinedTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.declinedTransaction = utils.objectToClass(
              httpRes?.data,
              shared.DeclinedTransaction
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Digital Wallet Token
   */
  retrieveADigitalWalletToken(
    req: operations.RetrieveADigitalWalletTokenRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveADigitalWalletTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveADigitalWalletTokenRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/digital_wallet_tokens/{digital_wallet_token_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveADigitalWalletTokenResponse =
        new operations.RetrieveADigitalWalletTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.digitalWalletToken = utils.objectToClass(
              httpRes?.data,
              shared.DigitalWalletToken
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Document
   */
  retrieveADocument(
    req: operations.RetrieveADocumentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveADocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveADocumentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/documents/{document_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveADocumentResponse =
        new operations.RetrieveADocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.document = utils.objectToClass(httpRes?.data, shared.Document);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a File
   */
  retrieveAFile(
    req: operations.RetrieveAFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{file_id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAFileResponse =
        new operations.RetrieveAFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Limit
   */
  retrieveALimit(
    req: operations.RetrieveALimitRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveALimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveALimitRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/limits/{limit_id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveALimitResponse =
        new operations.RetrieveALimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limit = utils.objectToClass(httpRes?.data, shared.Limit);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Pending Transaction
   */
  retrieveAPendingTransaction(
    req: operations.RetrieveAPendingTransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAPendingTransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAPendingTransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/pending_transactions/{pending_transaction_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAPendingTransactionResponse =
        new operations.RetrieveAPendingTransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.pendingTransaction = utils.objectToClass(
              httpRes?.data,
              shared.PendingTransaction
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Real-Time Decision
   */
  retrieveARealTimeDecision(
    req: operations.RetrieveARealTimeDecisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveARealTimeDecisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveARealTimeDecisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/real_time_decisions/{real_time_decision_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveARealTimeDecisionResponse =
        new operations.RetrieveARealTimeDecisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.realTimeDecision = utils.objectToClass(
              httpRes?.data,
              shared.RealTimeDecision
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Transaction
   */
  retrieveATransaction(
    req: operations.RetrieveATransactionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveATransactionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveATransactionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/transactions/{transaction_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveATransactionResponse =
        new operations.RetrieveATransactionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transaction = utils.objectToClass(
              httpRes?.data,
              shared.Transaction
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Wire Drawdown Request
   */
  retrieveAWireDrawdownRequest(
    req: operations.RetrieveAWireDrawdownRequestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAWireDrawdownRequestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAWireDrawdownRequestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/wire_drawdown_requests/{wire_drawdown_request_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAWireDrawdownRequestResponse =
        new operations.RetrieveAWireDrawdownRequestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireDrawdownRequest = utils.objectToClass(
              httpRes?.data,
              shared.WireDrawdownRequest
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Wire Transfer
   */
  retrieveAWireTransfer(
    req: operations.RetrieveAWireTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAWireTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAWireTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/wire_transfers/{wire_transfer_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAWireTransferResponse =
        new operations.RetrieveAWireTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransfer = utils.objectToClass(
              httpRes?.data,
              shared.WireTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Account
   */
  retrieveAnAccount(
    req: operations.RetrieveAnAccountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{account_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnAccountResponse =
        new operations.RetrieveAnAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Account Number
   */
  retrieveAnAccountNumber(
    req: operations.RetrieveAnAccountNumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnAccountNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnAccountNumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account_numbers/{account_number_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnAccountNumberResponse =
        new operations.RetrieveAnAccountNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountNumber = utils.objectToClass(
              httpRes?.data,
              shared.AccountNumber
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Account Statement
   */
  retrieveAnAccountStatement(
    req: operations.RetrieveAnAccountStatementRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnAccountStatementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnAccountStatementRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account_statements/{account_statement_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnAccountStatementResponse =
        new operations.RetrieveAnAccountStatementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountStatement = utils.objectToClass(
              httpRes?.data,
              shared.AccountStatement
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Account Transfer
   */
  retrieveAnAccountTransfer(
    req: operations.RetrieveAnAccountTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnAccountTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnAccountTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account_transfers/{account_transfer_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnAccountTransferResponse =
        new operations.RetrieveAnAccountTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AccountTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an ACH Prenotification
   */
  retrieveAnAchPrenotification(
    req: operations.RetrieveAnAchPrenotificationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnAchPrenotificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnAchPrenotificationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ach_prenotifications/{ach_prenotification_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnAchPrenotificationResponse =
        new operations.RetrieveAnAchPrenotificationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achPrenotification = utils.objectToClass(
              httpRes?.data,
              shared.AchPrenotification
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an ACH Transfer
   */
  retrieveAnAchTransfer(
    req: operations.RetrieveAnAchTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnAchTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnAchTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ach_transfers/{ach_transfer_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnAchTransferResponse =
        new operations.RetrieveAnAchTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AchTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Entity
   */
  retrieveAnEntity(
    req: operations.RetrieveAnEntityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnEntityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/entities/{entity_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnEntityResponse =
        new operations.RetrieveAnEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entity = utils.objectToClass(httpRes?.data, shared.Entity);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Event
   */
  retrieveAnEvent(
    req: operations.RetrieveAnEventRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnEventRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/events/{event_id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnEventResponse =
        new operations.RetrieveAnEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.event = utils.objectToClass(httpRes?.data, shared.Event);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Event Subscription
   */
  retrieveAnEventSubscription(
    req: operations.RetrieveAnEventSubscriptionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnEventSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnEventSubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/event_subscriptions/{event_subscription_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnEventSubscriptionResponse =
        new operations.RetrieveAnEventSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventSubscription = utils.objectToClass(
              httpRes?.data,
              shared.EventSubscription
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an External Account
   */
  retrieveAnExternalAccount(
    req: operations.RetrieveAnExternalAccountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnExternalAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnExternalAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/external_accounts/{external_account_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnExternalAccountResponse =
        new operations.RetrieveAnExternalAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.externalAccount = utils.objectToClass(
              httpRes?.data,
              shared.ExternalAccount
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Inbound ACH Transfer Return
   */
  retrieveAnInboundAchTransferReturn(
    req: operations.RetrieveAnInboundAchTransferReturnRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnInboundAchTransferReturnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnInboundAchTransferReturnRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/inbound_ach_transfer_returns/{inbound_ach_transfer_return_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnInboundAchTransferReturnResponse =
        new operations.RetrieveAnInboundAchTransferReturnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundAchTransferReturn = utils.objectToClass(
              httpRes?.data,
              shared.InboundAchTransferReturn
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Inbound Wire Drawdown Request
   */
  retrieveAnInboundWireDrawdownRequest(
    req: operations.RetrieveAnInboundWireDrawdownRequestRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnInboundWireDrawdownRequestResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnInboundWireDrawdownRequestRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/inbound_wire_drawdown_requests/{inbound_wire_drawdown_request_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnInboundWireDrawdownRequestResponse =
        new operations.RetrieveAnInboundWireDrawdownRequestResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundWireDrawdownRequest = utils.objectToClass(
              httpRes?.data,
              shared.InboundWireDrawdownRequest
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an OAuth Connection
   */
  retrieveAnOauthConnection(
    req: operations.RetrieveAnOauthConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAnOauthConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAnOauthConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/oauth_connections/{oauth_connection_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAnOauthConnectionResponse =
        new operations.RetrieveAnOauthConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.oauthConnection = utils.objectToClass(
              httpRes?.data,
              shared.OauthConnection
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve Group details
   *
   * @remarks
   * Returns details for the currently authenticated Group.
   */
  retrieveGroupDetails(
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveGroupDetailsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/groups/current";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveGroupDetailsResponse =
        new operations.RetrieveGroupDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.group = utils.objectToClass(httpRes?.data, shared.Group);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve sensitive details for a Card
   */
  retrieveSensitiveDetailsForACard(
    req: operations.RetrieveSensitiveDetailsForACardRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveSensitiveDetailsForACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveSensitiveDetailsForACardRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/cards/{card_id}/details",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveSensitiveDetailsForACardResponse =
        new operations.RetrieveSensitiveDetailsForACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardDetails = utils.objectToClass(
              httpRes?.data,
              shared.CardDetails
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a Sandbox ACH Transfer
   *
   * @remarks
   * Simulates the return of an [ACH Transfer](#ach-transfers) by the Federal Reserve due to an error condition. This will also create a Transaction to account for the returned funds. This transfer must first have a `status` of `submitted`.
   */
  returnASandboxAchTransfer(
    req: operations.ReturnASandboxAchTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReturnASandboxAchTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReturnASandboxAchTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/ach_transfers/{ach_transfer_id}/return",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "returnASandboxAchTransferParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReturnASandboxAchTransferResponse =
        new operations.ReturnASandboxAchTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AchTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a Sandbox Check Deposit
   *
   * @remarks
   * Simulates the return of a [Check Deposit](#check-deposits). This Check Deposit must first have a `status` of `submitted`.
   */
  returnASandboxCheckDeposit(
    req: operations.ReturnASandboxCheckDepositRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReturnASandboxCheckDepositResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReturnASandboxCheckDepositRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/check_deposits/{check_deposit_id}/return",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReturnASandboxCheckDepositResponse =
        new operations.ReturnASandboxCheckDepositResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkDeposit = utils.objectToClass(
              httpRes?.data,
              shared.CheckDeposit
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reverse a Sandbox Wire Transfer
   *
   * @remarks
   * Simulates the reversal of a [Wire Transfer](#wire-transfers) by the Federal Reserve due to error conditions. This will also create a [Transaction](#transaction) to account for the returned funds. This Wire Transfer must first have a `status` of `complete`.'
   */
  reverseASandboxWireTransfer(
    req: operations.ReverseASandboxWireTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ReverseASandboxWireTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReverseASandboxWireTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/wire_transfers/{wire_transfer_id}/reverse",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReverseASandboxWireTransferResponse =
        new operations.ReverseASandboxWireTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransfer = utils.objectToClass(
              httpRes?.data,
              shared.WireTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate a Real Time Payments Transfer to your account
   *
   * @remarks
   * Simulates an inbound Real Time Payments transfer to your account. Real Time Payments are a beta feature.
   */
  simulateARealTimePaymentsTransferToYourAccount(
    req: shared.SimulateARealTimePaymentsTransferToYourAccountParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateARealTimePaymentsTransferToYourAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateARealTimePaymentsTransferToYourAccountParameters(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/simulations/inbound_real_time_payments_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateARealTimePaymentsTransferToYourAccountResponse =
        new operations.SimulateARealTimePaymentsTransferToYourAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundRealTimePaymentsTransferSimulationResult =
              utils.objectToClass(
                httpRes?.data,
                shared.InboundRealTimePaymentsTransferSimulationResult
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate a refund on a card
   *
   * @remarks
   * Simulates refunding a card transaction. The full value of the original sandbox transaction is refunded.
   */
  simulateARefundOnACard(
    req: shared.SimulateARefundOnACardParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateARefundOnACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateARefundOnACardParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/card_refunds";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateARefundOnACardResponse =
        new operations.SimulateARefundOnACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transaction = utils.objectToClass(
              httpRes?.data,
              shared.Transaction
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate a tax document being created
   *
   * @remarks
   * Simulates an tax document being created for an account.
   */
  simulateATaxDocumentBeingCreated(
    req: shared.SimulateATaxDocumentBeingCreatedParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateATaxDocumentBeingCreatedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateATaxDocumentBeingCreatedParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/simulations/documents";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateATaxDocumentBeingCreatedResponse =
        new operations.SimulateATaxDocumentBeingCreatedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.document = utils.objectToClass(httpRes?.data, shared.Document);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate a Wire Transfer to your account
   *
   * @remarks
   * Simulates an inbound Wire Transfer to your account.
   */
  simulateAWireTransferToYourAccount(
    req: shared.SimulateAWireTransferToYourAccountParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateAWireTransferToYourAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateAWireTransferToYourAccountParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/inbound_wire_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateAWireTransferToYourAccountResponse =
        new operations.SimulateAWireTransferToYourAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundWireTransferSimulationResult = utils.objectToClass(
              httpRes?.data,
              shared.InboundWireTransferSimulationResult
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate an Account Statement being created
   *
   * @remarks
   * Simulates an [Account Statement](#account-statements) being created for an account. In production, Account Statements are generated once per month.
   */
  simulateAnAccountStatementBeingCreated(
    req: shared.SimulateAnAccountStatementBeingCreatedParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateAnAccountStatementBeingCreatedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateAnAccountStatementBeingCreatedParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/account_statements";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateAnAccountStatementBeingCreatedResponse =
        new operations.SimulateAnAccountStatementBeingCreatedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountStatement = utils.objectToClass(
              httpRes?.data,
              shared.AccountStatement
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate an ACH Transfer to your account
   *
   * @remarks
   * Simulates an inbound ACH transfer to your account. This imitates initiating a transaction to an Increase account from a different financial institution. The transfer may be either a credit or a debit depending on if the `amount` is positive or negative. The result of calling this API will be either a [Transaction](#transactions) or a [Declined Transaction](#declined-transactions) depending on whether or not the transfer is allowed.
   */
  simulateAnAchTransferToYourAccount(
    req: shared.SimulateAnAchTransferToYourAccountParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateAnAchTransferToYourAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateAnAchTransferToYourAccountParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/inbound_ach_transfers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateAnAchTransferToYourAccountResponse =
        new operations.SimulateAnAchTransferToYourAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundAchTransferSimulationResult = utils.objectToClass(
              httpRes?.data,
              shared.InboundAchTransferSimulationResult
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate an authorization on a Card
   *
   * @remarks
   * Simulates a purchase authorization on a [Card](#cards). Depending on the balance available to the card and the `amount` submitted, the authorization activity will result in a [Pending Transaction](#pending-transactions) of type `card_authorization` or a [Declined Transaction](#declined-transactions) of type `card_decline`. You can pass either a Card id or a [Digital Wallet Token](#digital-wallet-tokens) id to simulate the two different ways purchases can be made.
   */
  simulateAnAuthorizationOnACard(
    req: shared.SimulateAnAuthorizationOnACardParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateAnAuthorizationOnACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateAnAuthorizationOnACardParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/card_authorizations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateAnAuthorizationOnACardResponse =
        new operations.SimulateAnAuthorizationOnACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundCardAuthorizationSimulationResult = utils.objectToClass(
              httpRes?.data,
              shared.InboundCardAuthorizationSimulationResult
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate an Inbound Wire Drawdown request being created
   *
   * @remarks
   * Simulates the receival of an [Inbound Wire Drawdown Request](#inbound-wire-drawdown-requests).
   */
  simulateAnInboundWireDrawdownRequestBeingCreated(
    req: shared.SimulateAnInboundWireDrawdownRequestBeingCreatedParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateAnInboundWireDrawdownRequestBeingCreatedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new shared.SimulateAnInboundWireDrawdownRequestBeingCreatedParameters(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/simulations/inbound_wire_drawdown_requests";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateAnInboundWireDrawdownRequestBeingCreatedResponse =
        new operations.SimulateAnInboundWireDrawdownRequestBeingCreatedResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundWireDrawdownRequest = utils.objectToClass(
              httpRes?.data,
              shared.InboundWireDrawdownRequest
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate digital wallet provisioning for a card
   *
   * @remarks
   * Simulates a user attempting add a [Card](#cards) to a digital wallet such as Apple Pay.
   */
  simulateDigitalWalletProvisioningForACard(
    req: shared.SimulateDigitalWalletProvisioningForACardParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateDigitalWalletProvisioningForACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateDigitalWalletProvisioningForACardParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/digital_wallet_token_requests";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateDigitalWalletProvisioningForACardResponse =
        new operations.SimulateDigitalWalletProvisioningForACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.inboundDigitalWalletTokenRequestSimulationResult =
              utils.objectToClass(
                httpRes?.data,
                shared.InboundDigitalWalletTokenRequestSimulationResult
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulate settling a card authorization
   *
   * @remarks
   * Simulates the settlement of an authorization by a card acquirer. After a card authorization is created, the merchant will eventually send a settlement. This simulates that event, which may occur many days after the purchase in production. The amount settled can be different from the amount originally authorized, for example, when adding a tip to a restaurant bill.
   */
  simulateSettlingACardAuthorization(
    req: shared.SimulateSettlingACardAuthorizationParameters,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulateSettlingACardAuthorizationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SimulateSettlingACardAuthorizationParameters(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/simulations/card_settlements";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulateSettlingACardAuthorizationResponse =
        new operations.SimulateSettlingACardAuthorizationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transaction = utils.objectToClass(
              httpRes?.data,
              shared.Transaction
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Simulates advancing the state of a card dispute
   *
   * @remarks
   * After a [Card Dispute](#card-disputes) is created in production, the dispute will be reviewed. Since no review happens in sandbox, this endpoint simulates moving a Card Dispute into a rejected or accepted state. A Card Dispute can only be actioned one time and must have a status of `pending_reviewing`.
   */
  simulatesAdvancingTheStateOfACardDispute(
    req: operations.SimulatesAdvancingTheStateOfACardDisputeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SimulatesAdvancingTheStateOfACardDisputeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SimulatesAdvancingTheStateOfACardDisputeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/card_disputes/{card_dispute_id}/action",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "simulatesAdvancingTheStateOfACardDisputeParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SimulatesAdvancingTheStateOfACardDisputeResponse =
        new operations.SimulatesAdvancingTheStateOfACardDisputeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cardDispute = utils.objectToClass(
              httpRes?.data,
              shared.CardDispute
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Submit a Sandbox ACH Transfer
   *
   * @remarks
   * Simulates the submission of an [ACH Transfer](#ach-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_submission`. In production, Increase submits ACH Transfers to the Federal Reserve three times per day on weekdays. Since sandbox ACH Transfers are not submitted to the Federal Reserve, this endpoint allows you to skip that delay and transition the ACH Transfer to a status of `submitted`.
   */
  submitASandboxAchTransfer(
    req: operations.SubmitASandboxAchTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SubmitASandboxAchTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SubmitASandboxAchTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/ach_transfers/{ach_transfer_id}/submit",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SubmitASandboxAchTransferResponse =
        new operations.SubmitASandboxAchTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.achTransfer = utils.objectToClass(
              httpRes?.data,
              shared.AchTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Submit a Sandbox Check Deposit
   *
   * @remarks
   * Simulates the submission of a [Check Deposit](#check-deposits) to the Federal Reserve. This Check Deposit must first have a `status` of `pending`.
   */
  submitASandboxCheckDeposit(
    req: operations.SubmitASandboxCheckDepositRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SubmitASandboxCheckDepositResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SubmitASandboxCheckDepositRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/check_deposits/{check_deposit_id}/submit",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SubmitASandboxCheckDepositResponse =
        new operations.SubmitASandboxCheckDepositResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkDeposit = utils.objectToClass(
              httpRes?.data,
              shared.CheckDeposit
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Submit a Sandbox Wire Transfer
   *
   * @remarks
   * Simulates the submission of a [Wire Transfer](#wire-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_creating`.
   */
  submitASandboxWireTransfer(
    req: operations.SubmitASandboxWireTransferRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SubmitASandboxWireTransferResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SubmitASandboxWireTransferRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/simulations/wire_transfers/{wire_transfer_id}/submit",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SubmitASandboxWireTransferResponse =
        new operations.SubmitASandboxWireTransferResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.wireTransfer = utils.objectToClass(
              httpRes?.data,
              shared.WireTransfer
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Card
   */
  updateACard(
    req: operations.UpdateACardRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateACardResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateACardRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/cards/{card_id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateACardParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateACardResponse =
        new operations.UpdateACardResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.card = utils.objectToClass(httpRes?.data, shared.Card);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Limit
   */
  updateALimit(
    req: operations.UpdateALimitRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateALimitResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateALimitRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/limits/{limit_id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateALimitParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateALimitResponse =
        new operations.UpdateALimitResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.limit = utils.objectToClass(httpRes?.data, shared.Limit);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Account
   */
  updateAnAccount(
    req: operations.UpdateAnAccountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAnAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAnAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{account_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateAnAccountParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAnAccountResponse =
        new operations.UpdateAnAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Account Number
   */
  updateAnAccountNumber(
    req: operations.UpdateAnAccountNumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAnAccountNumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAnAccountNumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account_numbers/{account_number_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateAnAccountNumberParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAnAccountNumberResponse =
        new operations.UpdateAnAccountNumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accountNumber = utils.objectToClass(
              httpRes?.data,
              shared.AccountNumber
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Event Subscription
   */
  updateAnEventSubscription(
    req: operations.UpdateAnEventSubscriptionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAnEventSubscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAnEventSubscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/event_subscriptions/{event_subscription_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateAnEventSubscriptionParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAnEventSubscriptionResponse =
        new operations.UpdateAnEventSubscriptionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eventSubscription = utils.objectToClass(
              httpRes?.data,
              shared.EventSubscription
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an External Account
   */
  updateAnExternalAccount(
    req: operations.UpdateAnExternalAccountRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAnExternalAccountResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAnExternalAccountRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/external_accounts/{external_account_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateAnExternalAccountParameters",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAnExternalAccountResponse =
        new operations.UpdateAnExternalAccountResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.externalAccount = utils.objectToClass(
              httpRes?.data,
              shared.ExternalAccount
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
