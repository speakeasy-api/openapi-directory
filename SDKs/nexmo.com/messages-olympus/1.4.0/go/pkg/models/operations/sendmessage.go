// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

type SendMessageSecurity struct {
	BasicAuth  *shared.SchemeBasicAuth  `security:"scheme,type=http,subtype=basic"`
	BearerAuth *shared.SchemeBearerAuth `security:"scheme,type=http,subtype=bearer"`
}

// SendMessageRequestBodyViberFileChannelEnum - The channel to send to. You must provide `viber_service` in this field
type SendMessageRequestBodyViberFileChannelEnum string

const (
	SendMessageRequestBodyViberFileChannelEnumViberService SendMessageRequestBodyViberFileChannelEnum = "viber_service"
)

func (e *SendMessageRequestBodyViberFileChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "viber_service":
		*e = SendMessageRequestBodyViberFileChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberFileChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyViberFileFile struct {
	URL string `json:"url"`
}

// SendMessageRequestBodyViberFileMessageTypeEnum - The type of message to send. You must provide `file` in this field
type SendMessageRequestBodyViberFileMessageTypeEnum string

const (
	SendMessageRequestBodyViberFileMessageTypeEnumFile SendMessageRequestBodyViberFileMessageTypeEnum = "file"
)

func (e *SendMessageRequestBodyViberFileMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "file":
		*e = SendMessageRequestBodyViberFileMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberFileMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyViberFileViberServiceCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
type SendMessageRequestBodyViberFileViberServiceCategoryEnum string

const (
	SendMessageRequestBodyViberFileViberServiceCategoryEnumTransaction SendMessageRequestBodyViberFileViberServiceCategoryEnum = "transaction"
	SendMessageRequestBodyViberFileViberServiceCategoryEnumPromotion   SendMessageRequestBodyViberFileViberServiceCategoryEnum = "promotion"
)

func (e *SendMessageRequestBodyViberFileViberServiceCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "transaction":
		fallthrough
	case "promotion":
		*e = SendMessageRequestBodyViberFileViberServiceCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberFileViberServiceCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyViberFileViberService struct {
	// The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
	Category *SendMessageRequestBodyViberFileViberServiceCategoryEnum `json:"category,omitempty"`
	// Set the time-to-live of message to be delivered in seconds. i.e. if the message is not delivered in 600 seconds then delete the message.
	TTL *int64 `json:"ttl,omitempty"`
	// Viber-specific type definition. To use "template", please contact your Vonage Account Manager to setup your templates. To find out more please visit the [product page](https://www.vonage.com/communications-apis/messages/)
	Type *string `json:"type,omitempty"`
}

type SendMessageRequestBodyViberFile struct {
	// The channel to send to. You must provide `viber_service` in this field
	Channel SendMessageRequestBodyViberFileChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string                             `json:"client_ref,omitempty"`
	File      SendMessageRequestBodyViberFileFile `json:"file"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `file` in this field
	MessageType SendMessageRequestBodyViberFileMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To           string                                       `json:"to"`
	ViberService *SendMessageRequestBodyViberFileViberService `json:"viber_service,omitempty"`
}

// SendMessageRequestBodyViberVideoChannelEnum - The channel to send to. You must provide `viber_service` in this field
type SendMessageRequestBodyViberVideoChannelEnum string

const (
	SendMessageRequestBodyViberVideoChannelEnumViberService SendMessageRequestBodyViberVideoChannelEnum = "viber_service"
)

func (e *SendMessageRequestBodyViberVideoChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "viber_service":
		*e = SendMessageRequestBodyViberVideoChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberVideoChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyViberVideoMessageTypeEnum - The type of message to send. You must provide `video` in this field
type SendMessageRequestBodyViberVideoMessageTypeEnum string

const (
	SendMessageRequestBodyViberVideoMessageTypeEnumVideo SendMessageRequestBodyViberVideoMessageTypeEnum = "video"
)

func (e *SendMessageRequestBodyViberVideoMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "video":
		*e = SendMessageRequestBodyViberVideoMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberVideoMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyViberVideoViberServiceCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
type SendMessageRequestBodyViberVideoViberServiceCategoryEnum string

const (
	SendMessageRequestBodyViberVideoViberServiceCategoryEnumTransaction SendMessageRequestBodyViberVideoViberServiceCategoryEnum = "transaction"
	SendMessageRequestBodyViberVideoViberServiceCategoryEnumPromotion   SendMessageRequestBodyViberVideoViberServiceCategoryEnum = "promotion"
)

func (e *SendMessageRequestBodyViberVideoViberServiceCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "transaction":
		fallthrough
	case "promotion":
		*e = SendMessageRequestBodyViberVideoViberServiceCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberVideoViberServiceCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyViberVideoViberService struct {
	// The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
	Category *SendMessageRequestBodyViberVideoViberServiceCategoryEnum `json:"category,omitempty"`
	// The duration of the video in seconds.
	Duration *string `json:"duration,omitempty"`
	// The file size of the video in MB.
	FileSize *string `json:"file_size,omitempty"`
	// Set the time-to-live of message to be delivered in seconds. i.e. if the message is not delivered in 600 seconds then delete the message.
	TTL *int64 `json:"ttl,omitempty"`
	// Viber-specific type definition. To use "template", please contact your Vonage Account Manager to setup your templates. To find out more please visit the [product page](https://www.vonage.com/communications-apis/messages/)
	Type *string `json:"type,omitempty"`
}

type SendMessageRequestBodyViberVideoVideo struct {
	// Publicly accessible URL of the video attachment. Supports file types .mp4 and .3gpp
	// > Note: Only supports video codec H.264 and audio codec AAC
	//
	URL string `json:"url"`
}

type SendMessageRequestBodyViberVideo struct {
	// The channel to send to. You must provide `viber_service` in this field
	Channel SendMessageRequestBodyViberVideoChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `video` in this field
	MessageType SendMessageRequestBodyViberVideoMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To           string                                        `json:"to"`
	ViberService *SendMessageRequestBodyViberVideoViberService `json:"viber_service,omitempty"`
	Video        SendMessageRequestBodyViberVideoVideo         `json:"video"`
}

// SendMessageRequestBodyViberImageChannelEnum - The channel to send to. You must provide `viber_service` in this field
type SendMessageRequestBodyViberImageChannelEnum string

const (
	SendMessageRequestBodyViberImageChannelEnumViberService SendMessageRequestBodyViberImageChannelEnum = "viber_service"
)

func (e *SendMessageRequestBodyViberImageChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "viber_service":
		*e = SendMessageRequestBodyViberImageChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberImageChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyViberImageImage struct {
	// The publicly accessible URL of the image attachment. The image file is available for 48 hours after it is created. Supported types are .jpg, .jpeg, and .png
	URL string `json:"url"`
}

// SendMessageRequestBodyViberImageMessageTypeEnum - The type of message to send. You must provide `image` in this field
type SendMessageRequestBodyViberImageMessageTypeEnum string

const (
	SendMessageRequestBodyViberImageMessageTypeEnumImage SendMessageRequestBodyViberImageMessageTypeEnum = "image"
)

func (e *SendMessageRequestBodyViberImageMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "image":
		*e = SendMessageRequestBodyViberImageMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberImageMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyViberImageViberServiceAction - Node for Viber action buttons.
type SendMessageRequestBodyViberImageViberServiceAction struct {
	// Text which is rendered on the action button.
	Text *string `json:"text,omitempty"`
	// A URL which is requested when the action button is clicked.
	URL *string `json:"url,omitempty"`
}

// SendMessageRequestBodyViberImageViberServiceCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
type SendMessageRequestBodyViberImageViberServiceCategoryEnum string

const (
	SendMessageRequestBodyViberImageViberServiceCategoryEnumTransaction SendMessageRequestBodyViberImageViberServiceCategoryEnum = "transaction"
	SendMessageRequestBodyViberImageViberServiceCategoryEnumPromotion   SendMessageRequestBodyViberImageViberServiceCategoryEnum = "promotion"
)

func (e *SendMessageRequestBodyViberImageViberServiceCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "transaction":
		fallthrough
	case "promotion":
		*e = SendMessageRequestBodyViberImageViberServiceCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberImageViberServiceCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyViberImageViberService struct {
	// Node for Viber action buttons.
	Action *SendMessageRequestBodyViberImageViberServiceAction `json:"action,omitempty"`
	// The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
	Category *SendMessageRequestBodyViberImageViberServiceCategoryEnum `json:"category,omitempty"`
	// Set the time-to-live of message to be delivered in seconds. i.e. if the message is not delivered in 600 seconds then delete the message.
	TTL *int64 `json:"ttl,omitempty"`
	// Viber-specific type definition. To use "template", please contact your Vonage Account Manager to setup your templates. To find out more please visit the [product page](https://www.vonage.com/communications-apis/messages/)
	Type *string `json:"type,omitempty"`
}

type SendMessageRequestBodyViberImage struct {
	// The channel to send to. You must provide `viber_service` in this field
	Channel SendMessageRequestBodyViberImageChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From  string                                `json:"from"`
	Image SendMessageRequestBodyViberImageImage `json:"image"`
	// The type of message to send. You must provide `image` in this field
	MessageType SendMessageRequestBodyViberImageMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To           string                                        `json:"to"`
	ViberService *SendMessageRequestBodyViberImageViberService `json:"viber_service,omitempty"`
}

// SendMessageRequestBodyViberTextChannelEnum - The channel to send to. You must provide `viber_service` in this field
type SendMessageRequestBodyViberTextChannelEnum string

const (
	SendMessageRequestBodyViberTextChannelEnumViberService SendMessageRequestBodyViberTextChannelEnum = "viber_service"
)

func (e *SendMessageRequestBodyViberTextChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "viber_service":
		*e = SendMessageRequestBodyViberTextChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberTextChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyViberTextMessageTypeEnum - The type of message to send. You must provide `text` in this field
type SendMessageRequestBodyViberTextMessageTypeEnum string

const (
	SendMessageRequestBodyViberTextMessageTypeEnumText SendMessageRequestBodyViberTextMessageTypeEnum = "text"
)

func (e *SendMessageRequestBodyViberTextMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "text":
		*e = SendMessageRequestBodyViberTextMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberTextMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyViberTextViberServiceAction - Node for Viber action buttons.
type SendMessageRequestBodyViberTextViberServiceAction struct {
	// Text which is rendered on the action button.
	Text *string `json:"text,omitempty"`
	// A URL which is requested when the action button is clicked.
	URL *string `json:"url,omitempty"`
}

// SendMessageRequestBodyViberTextViberServiceCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
type SendMessageRequestBodyViberTextViberServiceCategoryEnum string

const (
	SendMessageRequestBodyViberTextViberServiceCategoryEnumTransaction SendMessageRequestBodyViberTextViberServiceCategoryEnum = "transaction"
	SendMessageRequestBodyViberTextViberServiceCategoryEnumPromotion   SendMessageRequestBodyViberTextViberServiceCategoryEnum = "promotion"
)

func (e *SendMessageRequestBodyViberTextViberServiceCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "transaction":
		fallthrough
	case "promotion":
		*e = SendMessageRequestBodyViberTextViberServiceCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyViberTextViberServiceCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyViberTextViberService struct {
	// Node for Viber action buttons.
	Action *SendMessageRequestBodyViberTextViberServiceAction `json:"action,omitempty"`
	// The use of different category tags enables the business to send messages for different use cases. For Viber Business Messages the first message sent from a business to a user must be personal, informative & a targeted message - not promotional. By default Vonage sends the `transaction` category to Viber Business Messages.
	Category *SendMessageRequestBodyViberTextViberServiceCategoryEnum `json:"category,omitempty"`
	// Set the time-to-live of message to be delivered in seconds. i.e. if the message is not delivered in 600 seconds then delete the message.
	TTL *int64 `json:"ttl,omitempty"`
	// Viber-specific type definition. To use "template", please contact your Vonage Account Manager to setup your templates. To find out more please visit the [product page](https://www.vonage.com/communications-apis/messages/)
	Type *string `json:"type,omitempty"`
}

// SendMessageRequestBodyViberText - The text of message to send.
type SendMessageRequestBodyViberText struct {
	// The channel to send to. You must provide `viber_service` in this field
	Channel SendMessageRequestBodyViberTextChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `text` in this field
	MessageType SendMessageRequestBodyViberTextMessageTypeEnum `json:"message_type"`
	Text        string                                         `json:"text"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To           string                                       `json:"to"`
	ViberService *SendMessageRequestBodyViberTextViberService `json:"viber_service,omitempty"`
}

type SendMessageRequestBodyViberType string

const (
	SendMessageRequestBodyViberTypeSendMessageRequestBodyViberText  SendMessageRequestBodyViberType = "SendMessage_requestBody_Viber_Text"
	SendMessageRequestBodyViberTypeSendMessageRequestBodyViberImage SendMessageRequestBodyViberType = "SendMessage_requestBody_Viber_Image"
	SendMessageRequestBodyViberTypeSendMessageRequestBodyViberVideo SendMessageRequestBodyViberType = "SendMessage_requestBody_Viber_Video"
	SendMessageRequestBodyViberTypeSendMessageRequestBodyViberFile  SendMessageRequestBodyViberType = "SendMessage_requestBody_Viber_File"
)

type SendMessageRequestBodyViber struct {
	SendMessageRequestBodyViberText  *SendMessageRequestBodyViberText
	SendMessageRequestBodyViberImage *SendMessageRequestBodyViberImage
	SendMessageRequestBodyViberVideo *SendMessageRequestBodyViberVideo
	SendMessageRequestBodyViberFile  *SendMessageRequestBodyViberFile

	Type SendMessageRequestBodyViberType
}

func CreateSendMessageRequestBodyViberSendMessageRequestBodyViberText(sendMessageRequestBodyViberText SendMessageRequestBodyViberText) SendMessageRequestBodyViber {
	typ := SendMessageRequestBodyViberTypeSendMessageRequestBodyViberText

	return SendMessageRequestBodyViber{
		SendMessageRequestBodyViberText: &sendMessageRequestBodyViberText,
		Type:                            typ,
	}
}

func CreateSendMessageRequestBodyViberSendMessageRequestBodyViberImage(sendMessageRequestBodyViberImage SendMessageRequestBodyViberImage) SendMessageRequestBodyViber {
	typ := SendMessageRequestBodyViberTypeSendMessageRequestBodyViberImage

	return SendMessageRequestBodyViber{
		SendMessageRequestBodyViberImage: &sendMessageRequestBodyViberImage,
		Type:                             typ,
	}
}

func CreateSendMessageRequestBodyViberSendMessageRequestBodyViberVideo(sendMessageRequestBodyViberVideo SendMessageRequestBodyViberVideo) SendMessageRequestBodyViber {
	typ := SendMessageRequestBodyViberTypeSendMessageRequestBodyViberVideo

	return SendMessageRequestBodyViber{
		SendMessageRequestBodyViberVideo: &sendMessageRequestBodyViberVideo,
		Type:                             typ,
	}
}

func CreateSendMessageRequestBodyViberSendMessageRequestBodyViberFile(sendMessageRequestBodyViberFile SendMessageRequestBodyViberFile) SendMessageRequestBodyViber {
	typ := SendMessageRequestBodyViberTypeSendMessageRequestBodyViberFile

	return SendMessageRequestBodyViber{
		SendMessageRequestBodyViberFile: &sendMessageRequestBodyViberFile,
		Type:                            typ,
	}
}

func (u *SendMessageRequestBodyViber) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessageRequestBodyViberText := new(SendMessageRequestBodyViberText)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyViberText); err == nil {
		u.SendMessageRequestBodyViberText = sendMessageRequestBodyViberText
		u.Type = SendMessageRequestBodyViberTypeSendMessageRequestBodyViberText
		return nil
	}

	sendMessageRequestBodyViberImage := new(SendMessageRequestBodyViberImage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyViberImage); err == nil {
		u.SendMessageRequestBodyViberImage = sendMessageRequestBodyViberImage
		u.Type = SendMessageRequestBodyViberTypeSendMessageRequestBodyViberImage
		return nil
	}

	sendMessageRequestBodyViberVideo := new(SendMessageRequestBodyViberVideo)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyViberVideo); err == nil {
		u.SendMessageRequestBodyViberVideo = sendMessageRequestBodyViberVideo
		u.Type = SendMessageRequestBodyViberTypeSendMessageRequestBodyViberVideo
		return nil
	}

	sendMessageRequestBodyViberFile := new(SendMessageRequestBodyViberFile)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyViberFile); err == nil {
		u.SendMessageRequestBodyViberFile = sendMessageRequestBodyViberFile
		u.Type = SendMessageRequestBodyViberTypeSendMessageRequestBodyViberFile
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessageRequestBodyViber) MarshalJSON() ([]byte, error) {
	if u.SendMessageRequestBodyViberText != nil {
		return json.Marshal(u.SendMessageRequestBodyViberText)
	}

	if u.SendMessageRequestBodyViberImage != nil {
		return json.Marshal(u.SendMessageRequestBodyViberImage)
	}

	if u.SendMessageRequestBodyViberVideo != nil {
		return json.Marshal(u.SendMessageRequestBodyViberVideo)
	}

	if u.SendMessageRequestBodyViberFile != nil {
		return json.Marshal(u.SendMessageRequestBodyViberFile)
	}

	return nil, nil
}

// SendMessageRequestBodyMessengerFileChannelEnum - The channel to send to. You must provide `messenger` in this field
type SendMessageRequestBodyMessengerFileChannelEnum string

const (
	SendMessageRequestBodyMessengerFileChannelEnumMessenger SendMessageRequestBodyMessengerFileChannelEnum = "messenger"
)

func (e *SendMessageRequestBodyMessengerFileChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "messenger":
		*e = SendMessageRequestBodyMessengerFileChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerFileChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerFileFile struct {
	URL string `json:"url"`
}

// SendMessageRequestBodyMessengerFileMessageTypeEnum - The type of message to send. You must provide `file` in this field
type SendMessageRequestBodyMessengerFileMessageTypeEnum string

const (
	SendMessageRequestBodyMessengerFileMessageTypeEnumFile SendMessageRequestBodyMessengerFileMessageTypeEnum = "file"
)

func (e *SendMessageRequestBodyMessengerFileMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "file":
		*e = SendMessageRequestBodyMessengerFileMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerFileMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerFileMessengerCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
type SendMessageRequestBodyMessengerFileMessengerCategoryEnum string

const (
	SendMessageRequestBodyMessengerFileMessengerCategoryEnumResponse   SendMessageRequestBodyMessengerFileMessengerCategoryEnum = "response"
	SendMessageRequestBodyMessengerFileMessengerCategoryEnumUpdate     SendMessageRequestBodyMessengerFileMessengerCategoryEnum = "update"
	SendMessageRequestBodyMessengerFileMessengerCategoryEnumMessageTag SendMessageRequestBodyMessengerFileMessengerCategoryEnum = "message_tag"
)

func (e *SendMessageRequestBodyMessengerFileMessengerCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "response":
		fallthrough
	case "update":
		fallthrough
	case "message_tag":
		*e = SendMessageRequestBodyMessengerFileMessengerCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerFileMessengerCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerFileMessenger struct {
	// The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
	Category *SendMessageRequestBodyMessengerFileMessengerCategoryEnum `json:"category,omitempty"`
	// A tag describing the type and relevance of the 1:1 communication between your app and the end user. A full list of available tags is available [here](https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags)
	Tag *string `json:"tag,omitempty"`
}

type SendMessageRequestBodyMessengerFile struct {
	// The channel to send to. You must provide `messenger` in this field
	Channel SendMessageRequestBodyMessengerFileChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string                                 `json:"client_ref,omitempty"`
	File      SendMessageRequestBodyMessengerFileFile `json:"file"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `file` in this field
	MessageType SendMessageRequestBodyMessengerFileMessageTypeEnum `json:"message_type"`
	Messenger   *SendMessageRequestBodyMessengerFileMessenger      `json:"messenger,omitempty"`
	// The ID of the message recipient
	//
	To string `json:"to"`
}

// SendMessageRequestBodyMessengerVideoChannelEnum - The channel to send to. You must provide `messenger` in this field
type SendMessageRequestBodyMessengerVideoChannelEnum string

const (
	SendMessageRequestBodyMessengerVideoChannelEnumMessenger SendMessageRequestBodyMessengerVideoChannelEnum = "messenger"
)

func (e *SendMessageRequestBodyMessengerVideoChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "messenger":
		*e = SendMessageRequestBodyMessengerVideoChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerVideoChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerVideoMessageTypeEnum - The type of message to send. You must provide `video` in this field
type SendMessageRequestBodyMessengerVideoMessageTypeEnum string

const (
	SendMessageRequestBodyMessengerVideoMessageTypeEnumVideo SendMessageRequestBodyMessengerVideoMessageTypeEnum = "video"
)

func (e *SendMessageRequestBodyMessengerVideoMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "video":
		*e = SendMessageRequestBodyMessengerVideoMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerVideoMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerVideoMessengerCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
type SendMessageRequestBodyMessengerVideoMessengerCategoryEnum string

const (
	SendMessageRequestBodyMessengerVideoMessengerCategoryEnumResponse   SendMessageRequestBodyMessengerVideoMessengerCategoryEnum = "response"
	SendMessageRequestBodyMessengerVideoMessengerCategoryEnumUpdate     SendMessageRequestBodyMessengerVideoMessengerCategoryEnum = "update"
	SendMessageRequestBodyMessengerVideoMessengerCategoryEnumMessageTag SendMessageRequestBodyMessengerVideoMessengerCategoryEnum = "message_tag"
)

func (e *SendMessageRequestBodyMessengerVideoMessengerCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "response":
		fallthrough
	case "update":
		fallthrough
	case "message_tag":
		*e = SendMessageRequestBodyMessengerVideoMessengerCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerVideoMessengerCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerVideoMessenger struct {
	// The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
	Category *SendMessageRequestBodyMessengerVideoMessengerCategoryEnum `json:"category,omitempty"`
	// A tag describing the type and relevance of the 1:1 communication between your app and the end user. A full list of available tags is available [here](https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags)
	Tag *string `json:"tag,omitempty"`
}

type SendMessageRequestBodyMessengerVideoVideo struct {
	// Publicly accessible URL of the video attachment. Supports file types .mp4 and .3gpp
	// > Note: Only supports video codec H.264 and audio codec AAC
	//
	URL string `json:"url"`
}

type SendMessageRequestBodyMessengerVideo struct {
	// The channel to send to. You must provide `messenger` in this field
	Channel SendMessageRequestBodyMessengerVideoChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `video` in this field
	MessageType SendMessageRequestBodyMessengerVideoMessageTypeEnum `json:"message_type"`
	Messenger   *SendMessageRequestBodyMessengerVideoMessenger      `json:"messenger,omitempty"`
	// The ID of the message recipient
	//
	To    string                                    `json:"to"`
	Video SendMessageRequestBodyMessengerVideoVideo `json:"video"`
}

type SendMessageRequestBodyMessengerAudioAudio struct {
	URL string `json:"url"`
}

// SendMessageRequestBodyMessengerAudioChannelEnum - The channel to send to. You must provide `messenger` in this field
type SendMessageRequestBodyMessengerAudioChannelEnum string

const (
	SendMessageRequestBodyMessengerAudioChannelEnumMessenger SendMessageRequestBodyMessengerAudioChannelEnum = "messenger"
)

func (e *SendMessageRequestBodyMessengerAudioChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "messenger":
		*e = SendMessageRequestBodyMessengerAudioChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerAudioChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerAudioMessageTypeEnum - The type of message to send. You must provide `audio` in this field
type SendMessageRequestBodyMessengerAudioMessageTypeEnum string

const (
	SendMessageRequestBodyMessengerAudioMessageTypeEnumAudio SendMessageRequestBodyMessengerAudioMessageTypeEnum = "audio"
)

func (e *SendMessageRequestBodyMessengerAudioMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "audio":
		*e = SendMessageRequestBodyMessengerAudioMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerAudioMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerAudioMessengerCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
type SendMessageRequestBodyMessengerAudioMessengerCategoryEnum string

const (
	SendMessageRequestBodyMessengerAudioMessengerCategoryEnumResponse   SendMessageRequestBodyMessengerAudioMessengerCategoryEnum = "response"
	SendMessageRequestBodyMessengerAudioMessengerCategoryEnumUpdate     SendMessageRequestBodyMessengerAudioMessengerCategoryEnum = "update"
	SendMessageRequestBodyMessengerAudioMessengerCategoryEnumMessageTag SendMessageRequestBodyMessengerAudioMessengerCategoryEnum = "message_tag"
)

func (e *SendMessageRequestBodyMessengerAudioMessengerCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "response":
		fallthrough
	case "update":
		fallthrough
	case "message_tag":
		*e = SendMessageRequestBodyMessengerAudioMessengerCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerAudioMessengerCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerAudioMessenger struct {
	// The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
	Category *SendMessageRequestBodyMessengerAudioMessengerCategoryEnum `json:"category,omitempty"`
	// A tag describing the type and relevance of the 1:1 communication between your app and the end user. A full list of available tags is available [here](https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags)
	Tag *string `json:"tag,omitempty"`
}

type SendMessageRequestBodyMessengerAudio struct {
	Audio SendMessageRequestBodyMessengerAudioAudio `json:"audio"`
	// The channel to send to. You must provide `messenger` in this field
	Channel SendMessageRequestBodyMessengerAudioChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `audio` in this field
	MessageType SendMessageRequestBodyMessengerAudioMessageTypeEnum `json:"message_type"`
	Messenger   *SendMessageRequestBodyMessengerAudioMessenger      `json:"messenger,omitempty"`
	// The ID of the message recipient
	//
	To string `json:"to"`
}

// SendMessageRequestBodyMessengerImageChannelEnum - The channel to send to. You must provide `messenger` in this field
type SendMessageRequestBodyMessengerImageChannelEnum string

const (
	SendMessageRequestBodyMessengerImageChannelEnumMessenger SendMessageRequestBodyMessengerImageChannelEnum = "messenger"
)

func (e *SendMessageRequestBodyMessengerImageChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "messenger":
		*e = SendMessageRequestBodyMessengerImageChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerImageChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerImageImage struct {
	// The publicly accessible URL of the image attachment. The image file is available for 48 hours after it is created. Supported types are .jpg, .jpeg, and .png
	URL string `json:"url"`
}

// SendMessageRequestBodyMessengerImageMessageTypeEnum - The type of message to send. You must provide `image` in this field
type SendMessageRequestBodyMessengerImageMessageTypeEnum string

const (
	SendMessageRequestBodyMessengerImageMessageTypeEnumImage SendMessageRequestBodyMessengerImageMessageTypeEnum = "image"
)

func (e *SendMessageRequestBodyMessengerImageMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "image":
		*e = SendMessageRequestBodyMessengerImageMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerImageMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerImageMessengerCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
type SendMessageRequestBodyMessengerImageMessengerCategoryEnum string

const (
	SendMessageRequestBodyMessengerImageMessengerCategoryEnumResponse   SendMessageRequestBodyMessengerImageMessengerCategoryEnum = "response"
	SendMessageRequestBodyMessengerImageMessengerCategoryEnumUpdate     SendMessageRequestBodyMessengerImageMessengerCategoryEnum = "update"
	SendMessageRequestBodyMessengerImageMessengerCategoryEnumMessageTag SendMessageRequestBodyMessengerImageMessengerCategoryEnum = "message_tag"
)

func (e *SendMessageRequestBodyMessengerImageMessengerCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "response":
		fallthrough
	case "update":
		fallthrough
	case "message_tag":
		*e = SendMessageRequestBodyMessengerImageMessengerCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerImageMessengerCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerImageMessenger struct {
	// The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
	Category *SendMessageRequestBodyMessengerImageMessengerCategoryEnum `json:"category,omitempty"`
	// A tag describing the type and relevance of the 1:1 communication between your app and the end user. A full list of available tags is available [here](https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags)
	Tag *string `json:"tag,omitempty"`
}

type SendMessageRequestBodyMessengerImage struct {
	// The channel to send to. You must provide `messenger` in this field
	Channel SendMessageRequestBodyMessengerImageChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From  string                                    `json:"from"`
	Image SendMessageRequestBodyMessengerImageImage `json:"image"`
	// The type of message to send. You must provide `image` in this field
	MessageType SendMessageRequestBodyMessengerImageMessageTypeEnum `json:"message_type"`
	Messenger   *SendMessageRequestBodyMessengerImageMessenger      `json:"messenger,omitempty"`
	// The ID of the message recipient
	//
	To string `json:"to"`
}

// SendMessageRequestBodyMessengerTextChannelEnum - The channel to send to. You must provide `messenger` in this field
type SendMessageRequestBodyMessengerTextChannelEnum string

const (
	SendMessageRequestBodyMessengerTextChannelEnumMessenger SendMessageRequestBodyMessengerTextChannelEnum = "messenger"
)

func (e *SendMessageRequestBodyMessengerTextChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "messenger":
		*e = SendMessageRequestBodyMessengerTextChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerTextChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerTextMessageTypeEnum - The type of message to send. You must provide `text` in this field
type SendMessageRequestBodyMessengerTextMessageTypeEnum string

const (
	SendMessageRequestBodyMessengerTextMessageTypeEnumText SendMessageRequestBodyMessengerTextMessageTypeEnum = "text"
)

func (e *SendMessageRequestBodyMessengerTextMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "text":
		*e = SendMessageRequestBodyMessengerTextMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerTextMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyMessengerTextMessengerCategoryEnum - The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
type SendMessageRequestBodyMessengerTextMessengerCategoryEnum string

const (
	SendMessageRequestBodyMessengerTextMessengerCategoryEnumResponse   SendMessageRequestBodyMessengerTextMessengerCategoryEnum = "response"
	SendMessageRequestBodyMessengerTextMessengerCategoryEnumUpdate     SendMessageRequestBodyMessengerTextMessengerCategoryEnum = "update"
	SendMessageRequestBodyMessengerTextMessengerCategoryEnumMessageTag SendMessageRequestBodyMessengerTextMessengerCategoryEnum = "message_tag"
)

func (e *SendMessageRequestBodyMessengerTextMessengerCategoryEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "response":
		fallthrough
	case "update":
		fallthrough
	case "message_tag":
		*e = SendMessageRequestBodyMessengerTextMessengerCategoryEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMessengerTextMessengerCategoryEnum: %s", s)
	}
}

type SendMessageRequestBodyMessengerTextMessenger struct {
	// The use of different category tags enables the business to send messages for different use cases. For Facebook Messenger they need to comply with their [Messaging Types policy](https://developers.facebook.com/docs/messenger-platform/send-messages#messaging_types). Vonage maps our `category` to their `messaging_type`. If `message_tag` is used, then an additional `tag` for that type is mandatory. By default Vonage sends the `response` category to Facebook Messenger.
	Category *SendMessageRequestBodyMessengerTextMessengerCategoryEnum `json:"category,omitempty"`
	// A tag describing the type and relevance of the 1:1 communication between your app and the end user. A full list of available tags is available [here](https://developers.facebook.com/docs/messenger-platform/send-messages/message-tags)
	Tag *string `json:"tag,omitempty"`
}

// SendMessageRequestBodyMessengerText - The text of message to send.
type SendMessageRequestBodyMessengerText struct {
	// The channel to send to. You must provide `messenger` in this field
	Channel SendMessageRequestBodyMessengerTextChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The ID of the message sender
	//
	From string `json:"from"`
	// The type of message to send. You must provide `text` in this field
	MessageType SendMessageRequestBodyMessengerTextMessageTypeEnum `json:"message_type"`
	Messenger   *SendMessageRequestBodyMessengerTextMessenger      `json:"messenger,omitempty"`
	Text        string                                             `json:"text"`
	// The ID of the message recipient
	//
	To string `json:"to"`
}

type SendMessageRequestBodyMessengerType string

const (
	SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerText  SendMessageRequestBodyMessengerType = "SendMessage_requestBody_Messenger_Text"
	SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerImage SendMessageRequestBodyMessengerType = "SendMessage_requestBody_Messenger_Image"
	SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerAudio SendMessageRequestBodyMessengerType = "SendMessage_requestBody_Messenger_Audio"
	SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerVideo SendMessageRequestBodyMessengerType = "SendMessage_requestBody_Messenger_Video"
	SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerFile  SendMessageRequestBodyMessengerType = "SendMessage_requestBody_Messenger_File"
)

type SendMessageRequestBodyMessenger struct {
	SendMessageRequestBodyMessengerText  *SendMessageRequestBodyMessengerText
	SendMessageRequestBodyMessengerImage *SendMessageRequestBodyMessengerImage
	SendMessageRequestBodyMessengerAudio *SendMessageRequestBodyMessengerAudio
	SendMessageRequestBodyMessengerVideo *SendMessageRequestBodyMessengerVideo
	SendMessageRequestBodyMessengerFile  *SendMessageRequestBodyMessengerFile

	Type SendMessageRequestBodyMessengerType
}

func CreateSendMessageRequestBodyMessengerSendMessageRequestBodyMessengerText(sendMessageRequestBodyMessengerText SendMessageRequestBodyMessengerText) SendMessageRequestBodyMessenger {
	typ := SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerText

	return SendMessageRequestBodyMessenger{
		SendMessageRequestBodyMessengerText: &sendMessageRequestBodyMessengerText,
		Type:                                typ,
	}
}

func CreateSendMessageRequestBodyMessengerSendMessageRequestBodyMessengerImage(sendMessageRequestBodyMessengerImage SendMessageRequestBodyMessengerImage) SendMessageRequestBodyMessenger {
	typ := SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerImage

	return SendMessageRequestBodyMessenger{
		SendMessageRequestBodyMessengerImage: &sendMessageRequestBodyMessengerImage,
		Type:                                 typ,
	}
}

func CreateSendMessageRequestBodyMessengerSendMessageRequestBodyMessengerAudio(sendMessageRequestBodyMessengerAudio SendMessageRequestBodyMessengerAudio) SendMessageRequestBodyMessenger {
	typ := SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerAudio

	return SendMessageRequestBodyMessenger{
		SendMessageRequestBodyMessengerAudio: &sendMessageRequestBodyMessengerAudio,
		Type:                                 typ,
	}
}

func CreateSendMessageRequestBodyMessengerSendMessageRequestBodyMessengerVideo(sendMessageRequestBodyMessengerVideo SendMessageRequestBodyMessengerVideo) SendMessageRequestBodyMessenger {
	typ := SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerVideo

	return SendMessageRequestBodyMessenger{
		SendMessageRequestBodyMessengerVideo: &sendMessageRequestBodyMessengerVideo,
		Type:                                 typ,
	}
}

func CreateSendMessageRequestBodyMessengerSendMessageRequestBodyMessengerFile(sendMessageRequestBodyMessengerFile SendMessageRequestBodyMessengerFile) SendMessageRequestBodyMessenger {
	typ := SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerFile

	return SendMessageRequestBodyMessenger{
		SendMessageRequestBodyMessengerFile: &sendMessageRequestBodyMessengerFile,
		Type:                                typ,
	}
}

func (u *SendMessageRequestBodyMessenger) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessageRequestBodyMessengerText := new(SendMessageRequestBodyMessengerText)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMessengerText); err == nil {
		u.SendMessageRequestBodyMessengerText = sendMessageRequestBodyMessengerText
		u.Type = SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerText
		return nil
	}

	sendMessageRequestBodyMessengerImage := new(SendMessageRequestBodyMessengerImage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMessengerImage); err == nil {
		u.SendMessageRequestBodyMessengerImage = sendMessageRequestBodyMessengerImage
		u.Type = SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerImage
		return nil
	}

	sendMessageRequestBodyMessengerAudio := new(SendMessageRequestBodyMessengerAudio)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMessengerAudio); err == nil {
		u.SendMessageRequestBodyMessengerAudio = sendMessageRequestBodyMessengerAudio
		u.Type = SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerAudio
		return nil
	}

	sendMessageRequestBodyMessengerVideo := new(SendMessageRequestBodyMessengerVideo)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMessengerVideo); err == nil {
		u.SendMessageRequestBodyMessengerVideo = sendMessageRequestBodyMessengerVideo
		u.Type = SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerVideo
		return nil
	}

	sendMessageRequestBodyMessengerFile := new(SendMessageRequestBodyMessengerFile)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMessengerFile); err == nil {
		u.SendMessageRequestBodyMessengerFile = sendMessageRequestBodyMessengerFile
		u.Type = SendMessageRequestBodyMessengerTypeSendMessageRequestBodyMessengerFile
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessageRequestBodyMessenger) MarshalJSON() ([]byte, error) {
	if u.SendMessageRequestBodyMessengerText != nil {
		return json.Marshal(u.SendMessageRequestBodyMessengerText)
	}

	if u.SendMessageRequestBodyMessengerImage != nil {
		return json.Marshal(u.SendMessageRequestBodyMessengerImage)
	}

	if u.SendMessageRequestBodyMessengerAudio != nil {
		return json.Marshal(u.SendMessageRequestBodyMessengerAudio)
	}

	if u.SendMessageRequestBodyMessengerVideo != nil {
		return json.Marshal(u.SendMessageRequestBodyMessengerVideo)
	}

	if u.SendMessageRequestBodyMessengerFile != nil {
		return json.Marshal(u.SendMessageRequestBodyMessengerFile)
	}

	return nil, nil
}

// SendMessageRequestBodyWhatsAppCustomChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppCustomChannelEnum string

const (
	SendMessageRequestBodyWhatsAppCustomChannelEnumWhatsapp SendMessageRequestBodyWhatsAppCustomChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppCustomChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppCustomChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppCustomChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyWhatsAppCustomMessageTypeEnum - The type of message to send. You must provide `custom` in this field
type SendMessageRequestBodyWhatsAppCustomMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppCustomMessageTypeEnumCustom SendMessageRequestBodyWhatsAppCustomMessageTypeEnum = "custom"
)

func (e *SendMessageRequestBodyWhatsAppCustomMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "custom":
		*e = SendMessageRequestBodyWhatsAppCustomMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppCustomMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppCustom struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppCustomChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// A custom payload, which is passed directly to WhatsApp for certain features such as templates and interactive messages. The schema of a custom object can vary widely. [Read more about Custom Objects](https://developer.vonage.com/messages/concepts/custom-objects).
	Custom map[string]interface{} `json:"custom,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `custom` in this field
	MessageType SendMessageRequestBodyWhatsAppCustomMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

// SendMessageRequestBodyWhatsAppTemplateChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppTemplateChannelEnum string

const (
	SendMessageRequestBodyWhatsAppTemplateChannelEnumWhatsapp SendMessageRequestBodyWhatsAppTemplateChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppTemplateChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppTemplateChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppTemplateChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum - The type of message to send. You must provide `template` in this field
type SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppTemplateMessageTypeEnumTemplate SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum = "template"
)

func (e *SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "template":
		*e = SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppTemplateTemplate struct {
	// The name of the template. For WhatsApp use your WhatsApp namespace (available via Facebook Business Manager), followed by a colon : and the name of the template to use.
	Name string `json:"name"`
	// The parameters are an array of strings, with the first string being used for {{1}} in the template, with the second being {{2}} etc. Only required if the template specified by `name` contains parameters.
	Parameters []string `json:"parameters,omitempty"`
}

// SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum - Policy for resolving what language template to use. As of right now the only valid choice is `deterministic`.
type SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum string

const (
	SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnumDeterministic SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum = "deterministic"
)

func (e *SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "deterministic":
		*e = SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppTemplateWhatsapp struct {
	// The [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) language of the template. See [the WhatsApp documentation](https://developers.facebook.com/docs/whatsapp/api/messages/message-templates#supported-languages-) for supported languages.
	Locale string `json:"locale"`
	// Policy for resolving what language template to use. As of right now the only valid choice is `deterministic`.
	Policy *SendMessageRequestBodyWhatsAppTemplateWhatsappPolicyEnum `json:"policy,omitempty"`
}

type SendMessageRequestBodyWhatsAppTemplate struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppTemplateChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `template` in this field
	MessageType SendMessageRequestBodyWhatsAppTemplateMessageTypeEnum `json:"message_type"`
	Template    SendMessageRequestBodyWhatsAppTemplateTemplate        `json:"template"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To       string                                         `json:"to"`
	Whatsapp SendMessageRequestBodyWhatsAppTemplateWhatsapp `json:"whatsapp"`
}

// SendMessageRequestBodyWhatsAppFileChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppFileChannelEnum string

const (
	SendMessageRequestBodyWhatsAppFileChannelEnumWhatsapp SendMessageRequestBodyWhatsAppFileChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppFileChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppFileChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppFileChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppFileFile struct {
	URL string `json:"url"`
}

// SendMessageRequestBodyWhatsAppFileMessageTypeEnum - The type of message to send. You must provide `file` in this field
type SendMessageRequestBodyWhatsAppFileMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppFileMessageTypeEnumFile SendMessageRequestBodyWhatsAppFileMessageTypeEnum = "file"
)

func (e *SendMessageRequestBodyWhatsAppFileMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "file":
		*e = SendMessageRequestBodyWhatsAppFileMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppFileMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppFile struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppFileChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string                                `json:"client_ref,omitempty"`
	File      SendMessageRequestBodyWhatsAppFileFile `json:"file"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `file` in this field
	MessageType SendMessageRequestBodyWhatsAppFileMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

// SendMessageRequestBodyWhatsAppVideoChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppVideoChannelEnum string

const (
	SendMessageRequestBodyWhatsAppVideoChannelEnumWhatsapp SendMessageRequestBodyWhatsAppVideoChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppVideoChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppVideoChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppVideoChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyWhatsAppVideoMessageTypeEnum - The type of message to send. You must provide `video` in this field
type SendMessageRequestBodyWhatsAppVideoMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppVideoMessageTypeEnumVideo SendMessageRequestBodyWhatsAppVideoMessageTypeEnum = "video"
)

func (e *SendMessageRequestBodyWhatsAppVideoMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "video":
		*e = SendMessageRequestBodyWhatsAppVideoMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppVideoMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppVideoVideo struct {
	// Publicly accessible URL of the video attachment. Supports file types .mp4 and .3gpp
	// > Note: Only supports video codec H.264 and audio codec AAC
	//
	URL string `json:"url"`
}

type SendMessageRequestBodyWhatsAppVideo struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppVideoChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `video` in this field
	MessageType SendMessageRequestBodyWhatsAppVideoMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To    string                                   `json:"to"`
	Video SendMessageRequestBodyWhatsAppVideoVideo `json:"video"`
}

type SendMessageRequestBodyWhatsAppAudioAudio struct {
	URL string `json:"url"`
}

// SendMessageRequestBodyWhatsAppAudioChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppAudioChannelEnum string

const (
	SendMessageRequestBodyWhatsAppAudioChannelEnumWhatsapp SendMessageRequestBodyWhatsAppAudioChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppAudioChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppAudioChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppAudioChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyWhatsAppAudioMessageTypeEnum - The type of message to send. You must provide `audio` in this field
type SendMessageRequestBodyWhatsAppAudioMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppAudioMessageTypeEnumAudio SendMessageRequestBodyWhatsAppAudioMessageTypeEnum = "audio"
)

func (e *SendMessageRequestBodyWhatsAppAudioMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "audio":
		*e = SendMessageRequestBodyWhatsAppAudioMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppAudioMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppAudio struct {
	Audio SendMessageRequestBodyWhatsAppAudioAudio `json:"audio"`
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppAudioChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `audio` in this field
	MessageType SendMessageRequestBodyWhatsAppAudioMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

// SendMessageRequestBodyWhatsAppImageChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppImageChannelEnum string

const (
	SendMessageRequestBodyWhatsAppImageChannelEnumWhatsapp SendMessageRequestBodyWhatsAppImageChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppImageChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppImageChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppImageChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppImageImage struct {
	// The publicly accessible URL of the image attachment. The image file is available for 48 hours after it is created. Supported types are .jpg, .jpeg, and .png
	URL string `json:"url"`
}

// SendMessageRequestBodyWhatsAppImageMessageTypeEnum - The type of message to send. You must provide `image` in this field
type SendMessageRequestBodyWhatsAppImageMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppImageMessageTypeEnumImage SendMessageRequestBodyWhatsAppImageMessageTypeEnum = "image"
)

func (e *SendMessageRequestBodyWhatsAppImageMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "image":
		*e = SendMessageRequestBodyWhatsAppImageMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppImageMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppImage struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppImageChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From  string                                   `json:"from"`
	Image SendMessageRequestBodyWhatsAppImageImage `json:"image"`
	// The type of message to send. You must provide `image` in this field
	MessageType SendMessageRequestBodyWhatsAppImageMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

// SendMessageRequestBodyWhatsAppLocationChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppLocationChannelEnum string

const (
	SendMessageRequestBodyWhatsAppLocationChannelEnumWhatsapp SendMessageRequestBodyWhatsAppLocationChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppLocationChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppLocationChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppLocationChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppLocationLocation struct {
	// Address of the location. Only displayed if `name` is present.
	Address *string `json:"address,omitempty"`
	// Latitude of the location.
	Lat float64 `json:"lat"`
	// Longitude of the location.
	Long float64 `json:"long"`
	// Name of the location.
	Name *string `json:"name,omitempty"`
}

// SendMessageRequestBodyWhatsAppLocationMessageTypeEnum - The type of message to send. You must provide `location` in this field
type SendMessageRequestBodyWhatsAppLocationMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppLocationMessageTypeEnumLocation SendMessageRequestBodyWhatsAppLocationMessageTypeEnum = "location"
)

func (e *SendMessageRequestBodyWhatsAppLocationMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "location":
		*e = SendMessageRequestBodyWhatsAppLocationMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppLocationMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyWhatsAppLocation struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppLocationChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From     string                                         `json:"from"`
	Location SendMessageRequestBodyWhatsAppLocationLocation `json:"location"`
	// The type of message to send. You must provide `location` in this field
	MessageType SendMessageRequestBodyWhatsAppLocationMessageTypeEnum `json:"message_type"`
	// The location to be sent in the message.
	//
	Text interface{} `json:"text,omitempty"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

// SendMessageRequestBodyWhatsAppTextChannelEnum - The channel to send to. You must provide `whatsapp` in this field
type SendMessageRequestBodyWhatsAppTextChannelEnum string

const (
	SendMessageRequestBodyWhatsAppTextChannelEnumWhatsapp SendMessageRequestBodyWhatsAppTextChannelEnum = "whatsapp"
)

func (e *SendMessageRequestBodyWhatsAppTextChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "whatsapp":
		*e = SendMessageRequestBodyWhatsAppTextChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppTextChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyWhatsAppTextMessageTypeEnum - The type of message to send. You must provide `text` in this field
type SendMessageRequestBodyWhatsAppTextMessageTypeEnum string

const (
	SendMessageRequestBodyWhatsAppTextMessageTypeEnumText SendMessageRequestBodyWhatsAppTextMessageTypeEnum = "text"
)

func (e *SendMessageRequestBodyWhatsAppTextMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "text":
		*e = SendMessageRequestBodyWhatsAppTextMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyWhatsAppTextMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodyWhatsAppText - The text of message to send.
type SendMessageRequestBodyWhatsAppText struct {
	// The channel to send to. You must provide `whatsapp` in this field
	Channel SendMessageRequestBodyWhatsAppTextChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `text` in this field
	MessageType SendMessageRequestBodyWhatsAppTextMessageTypeEnum `json:"message_type"`
	Text        string                                            `json:"text"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

type SendMessageRequestBodyWhatsAppType string

const (
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppText     SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Text"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppLocation SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Location"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppImage    SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Image"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppAudio    SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Audio"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppVideo    SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Video"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppFile     SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_File"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppTemplate SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Template"
	SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppCustom   SendMessageRequestBodyWhatsAppType = "SendMessage_requestBody_WhatsApp_Custom"
)

type SendMessageRequestBodyWhatsApp struct {
	SendMessageRequestBodyWhatsAppText     *SendMessageRequestBodyWhatsAppText
	SendMessageRequestBodyWhatsAppLocation *SendMessageRequestBodyWhatsAppLocation
	SendMessageRequestBodyWhatsAppImage    *SendMessageRequestBodyWhatsAppImage
	SendMessageRequestBodyWhatsAppAudio    *SendMessageRequestBodyWhatsAppAudio
	SendMessageRequestBodyWhatsAppVideo    *SendMessageRequestBodyWhatsAppVideo
	SendMessageRequestBodyWhatsAppFile     *SendMessageRequestBodyWhatsAppFile
	SendMessageRequestBodyWhatsAppTemplate *SendMessageRequestBodyWhatsAppTemplate
	SendMessageRequestBodyWhatsAppCustom   *SendMessageRequestBodyWhatsAppCustom

	Type SendMessageRequestBodyWhatsAppType
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppText(sendMessageRequestBodyWhatsAppText SendMessageRequestBodyWhatsAppText) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppText

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppText: &sendMessageRequestBodyWhatsAppText,
		Type:                               typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppLocation(sendMessageRequestBodyWhatsAppLocation SendMessageRequestBodyWhatsAppLocation) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppLocation

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppLocation: &sendMessageRequestBodyWhatsAppLocation,
		Type:                                   typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppImage(sendMessageRequestBodyWhatsAppImage SendMessageRequestBodyWhatsAppImage) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppImage

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppImage: &sendMessageRequestBodyWhatsAppImage,
		Type:                                typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppAudio(sendMessageRequestBodyWhatsAppAudio SendMessageRequestBodyWhatsAppAudio) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppAudio

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppAudio: &sendMessageRequestBodyWhatsAppAudio,
		Type:                                typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppVideo(sendMessageRequestBodyWhatsAppVideo SendMessageRequestBodyWhatsAppVideo) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppVideo

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppVideo: &sendMessageRequestBodyWhatsAppVideo,
		Type:                                typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppFile(sendMessageRequestBodyWhatsAppFile SendMessageRequestBodyWhatsAppFile) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppFile

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppFile: &sendMessageRequestBodyWhatsAppFile,
		Type:                               typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppTemplate(sendMessageRequestBodyWhatsAppTemplate SendMessageRequestBodyWhatsAppTemplate) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppTemplate

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppTemplate: &sendMessageRequestBodyWhatsAppTemplate,
		Type:                                   typ,
	}
}

func CreateSendMessageRequestBodyWhatsAppSendMessageRequestBodyWhatsAppCustom(sendMessageRequestBodyWhatsAppCustom SendMessageRequestBodyWhatsAppCustom) SendMessageRequestBodyWhatsApp {
	typ := SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppCustom

	return SendMessageRequestBodyWhatsApp{
		SendMessageRequestBodyWhatsAppCustom: &sendMessageRequestBodyWhatsAppCustom,
		Type:                                 typ,
	}
}

func (u *SendMessageRequestBodyWhatsApp) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessageRequestBodyWhatsAppText := new(SendMessageRequestBodyWhatsAppText)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppText); err == nil {
		u.SendMessageRequestBodyWhatsAppText = sendMessageRequestBodyWhatsAppText
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppText
		return nil
	}

	sendMessageRequestBodyWhatsAppLocation := new(SendMessageRequestBodyWhatsAppLocation)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppLocation); err == nil {
		u.SendMessageRequestBodyWhatsAppLocation = sendMessageRequestBodyWhatsAppLocation
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppLocation
		return nil
	}

	sendMessageRequestBodyWhatsAppImage := new(SendMessageRequestBodyWhatsAppImage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppImage); err == nil {
		u.SendMessageRequestBodyWhatsAppImage = sendMessageRequestBodyWhatsAppImage
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppImage
		return nil
	}

	sendMessageRequestBodyWhatsAppAudio := new(SendMessageRequestBodyWhatsAppAudio)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppAudio); err == nil {
		u.SendMessageRequestBodyWhatsAppAudio = sendMessageRequestBodyWhatsAppAudio
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppAudio
		return nil
	}

	sendMessageRequestBodyWhatsAppVideo := new(SendMessageRequestBodyWhatsAppVideo)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppVideo); err == nil {
		u.SendMessageRequestBodyWhatsAppVideo = sendMessageRequestBodyWhatsAppVideo
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppVideo
		return nil
	}

	sendMessageRequestBodyWhatsAppFile := new(SendMessageRequestBodyWhatsAppFile)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppFile); err == nil {
		u.SendMessageRequestBodyWhatsAppFile = sendMessageRequestBodyWhatsAppFile
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppFile
		return nil
	}

	sendMessageRequestBodyWhatsAppTemplate := new(SendMessageRequestBodyWhatsAppTemplate)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppTemplate); err == nil {
		u.SendMessageRequestBodyWhatsAppTemplate = sendMessageRequestBodyWhatsAppTemplate
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppTemplate
		return nil
	}

	sendMessageRequestBodyWhatsAppCustom := new(SendMessageRequestBodyWhatsAppCustom)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsAppCustom); err == nil {
		u.SendMessageRequestBodyWhatsAppCustom = sendMessageRequestBodyWhatsAppCustom
		u.Type = SendMessageRequestBodyWhatsAppTypeSendMessageRequestBodyWhatsAppCustom
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessageRequestBodyWhatsApp) MarshalJSON() ([]byte, error) {
	if u.SendMessageRequestBodyWhatsAppText != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppText)
	}

	if u.SendMessageRequestBodyWhatsAppLocation != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppLocation)
	}

	if u.SendMessageRequestBodyWhatsAppImage != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppImage)
	}

	if u.SendMessageRequestBodyWhatsAppAudio != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppAudio)
	}

	if u.SendMessageRequestBodyWhatsAppVideo != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppVideo)
	}

	if u.SendMessageRequestBodyWhatsAppFile != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppFile)
	}

	if u.SendMessageRequestBodyWhatsAppTemplate != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppTemplate)
	}

	if u.SendMessageRequestBodyWhatsAppCustom != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsAppCustom)
	}

	return nil, nil
}

// SendMessageRequestBodyMMSVideoChannelEnum - The channel to send to. You must provide `mms` in this field
type SendMessageRequestBodyMMSVideoChannelEnum string

const (
	SendMessageRequestBodyMMSVideoChannelEnumMms SendMessageRequestBodyMMSVideoChannelEnum = "mms"
)

func (e *SendMessageRequestBodyMMSVideoChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "mms":
		*e = SendMessageRequestBodyMMSVideoChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSVideoChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyMMSVideoMessageTypeEnum - The type of message to send. You must provide `video` in this field
type SendMessageRequestBodyMMSVideoMessageTypeEnum string

const (
	SendMessageRequestBodyMMSVideoMessageTypeEnumVideo SendMessageRequestBodyMMSVideoMessageTypeEnum = "video"
)

func (e *SendMessageRequestBodyMMSVideoMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "video":
		*e = SendMessageRequestBodyMMSVideoMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSVideoMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyMMSVideoVideo struct {
	// Publicly accessible URL of the video attachment. Supports file types .mp4 and .3gpp
	// > Note: Only supports video codec H.264 and audio codec AAC
	//
	URL string `json:"url"`
}

type SendMessageRequestBodyMMSVideo struct {
	// The channel to send to. You must provide `mms` in this field
	Channel SendMessageRequestBodyMMSVideoChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `video` in this field
	MessageType SendMessageRequestBodyMMSVideoMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To    string                              `json:"to"`
	Video SendMessageRequestBodyMMSVideoVideo `json:"video"`
}

type SendMessageRequestBodyMMSAudioAudio struct {
	URL string `json:"url"`
}

// SendMessageRequestBodyMMSAudioChannelEnum - The channel to send to. You must provide `mms` in this field
type SendMessageRequestBodyMMSAudioChannelEnum string

const (
	SendMessageRequestBodyMMSAudioChannelEnumMms SendMessageRequestBodyMMSAudioChannelEnum = "mms"
)

func (e *SendMessageRequestBodyMMSAudioChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "mms":
		*e = SendMessageRequestBodyMMSAudioChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSAudioChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyMMSAudioMessageTypeEnum - The type of message to send. You must provide `audio` in this field
type SendMessageRequestBodyMMSAudioMessageTypeEnum string

const (
	SendMessageRequestBodyMMSAudioMessageTypeEnumAudio SendMessageRequestBodyMMSAudioMessageTypeEnum = "audio"
)

func (e *SendMessageRequestBodyMMSAudioMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "audio":
		*e = SendMessageRequestBodyMMSAudioMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSAudioMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyMMSAudio struct {
	Audio SendMessageRequestBodyMMSAudioAudio `json:"audio"`
	// The channel to send to. You must provide `mms` in this field
	Channel SendMessageRequestBodyMMSAudioChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `audio` in this field
	MessageType SendMessageRequestBodyMMSAudioMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

// SendMessageRequestBodyMMSVCardChannelEnum - The channel to send to. You must provide `mms` in this field
type SendMessageRequestBodyMMSVCardChannelEnum string

const (
	SendMessageRequestBodyMMSVCardChannelEnumMms SendMessageRequestBodyMMSVCardChannelEnum = "mms"
)

func (e *SendMessageRequestBodyMMSVCardChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "mms":
		*e = SendMessageRequestBodyMMSVCardChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSVCardChannelEnum: %s", s)
	}
}

// SendMessageRequestBodyMMSVCardMessageTypeEnum - The type of message to send. You must provide `vcard` in this field
type SendMessageRequestBodyMMSVCardMessageTypeEnum string

const (
	SendMessageRequestBodyMMSVCardMessageTypeEnumVcard SendMessageRequestBodyMMSVCardMessageTypeEnum = "vcard"
)

func (e *SendMessageRequestBodyMMSVCardMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "vcard":
		*e = SendMessageRequestBodyMMSVCardMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSVCardMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyMMSVCardVcard struct {
	// The publicly accessible URL of the vCard attachment. Supported types are .vcf only
	URL string `json:"url"`
}

type SendMessageRequestBodyMMSVCard struct {
	// The channel to send to. You must provide `mms` in this field
	Channel SendMessageRequestBodyMMSVCardChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `vcard` in this field
	MessageType SendMessageRequestBodyMMSVCardMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To    string                              `json:"to"`
	Vcard SendMessageRequestBodyMMSVCardVcard `json:"vcard"`
}

// SendMessageRequestBodyMMSImageChannelEnum - The channel to send to. You must provide `mms` in this field
type SendMessageRequestBodyMMSImageChannelEnum string

const (
	SendMessageRequestBodyMMSImageChannelEnumMms SendMessageRequestBodyMMSImageChannelEnum = "mms"
)

func (e *SendMessageRequestBodyMMSImageChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "mms":
		*e = SendMessageRequestBodyMMSImageChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSImageChannelEnum: %s", s)
	}
}

type SendMessageRequestBodyMMSImageImage struct {
	// The publicly accessible URL of the image attachment. The image file is available for 48 hours after it is created. Supported types are .jpg, .jpeg, and .png
	URL string `json:"url"`
}

// SendMessageRequestBodyMMSImageMessageTypeEnum - The type of message to send. You must provide `image` in this field
type SendMessageRequestBodyMMSImageMessageTypeEnum string

const (
	SendMessageRequestBodyMMSImageMessageTypeEnumImage SendMessageRequestBodyMMSImageMessageTypeEnum = "image"
)

func (e *SendMessageRequestBodyMMSImageMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "image":
		*e = SendMessageRequestBodyMMSImageMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodyMMSImageMessageTypeEnum: %s", s)
	}
}

type SendMessageRequestBodyMMSImage struct {
	// The channel to send to. You must provide `mms` in this field
	Channel SendMessageRequestBodyMMSImageChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From  string                              `json:"from"`
	Image SendMessageRequestBodyMMSImageImage `json:"image"`
	// The type of message to send. You must provide `image` in this field
	MessageType SendMessageRequestBodyMMSImageMessageTypeEnum `json:"message_type"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

type SendMessageRequestBodyMMSType string

const (
	SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSImage SendMessageRequestBodyMMSType = "SendMessage_requestBody_MMS_Image"
	SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSVCard SendMessageRequestBodyMMSType = "SendMessage_requestBody_MMS_vCard"
	SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSAudio SendMessageRequestBodyMMSType = "SendMessage_requestBody_MMS_Audio"
	SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSVideo SendMessageRequestBodyMMSType = "SendMessage_requestBody_MMS_Video"
)

type SendMessageRequestBodyMMS struct {
	SendMessageRequestBodyMMSImage *SendMessageRequestBodyMMSImage
	SendMessageRequestBodyMMSVCard *SendMessageRequestBodyMMSVCard
	SendMessageRequestBodyMMSAudio *SendMessageRequestBodyMMSAudio
	SendMessageRequestBodyMMSVideo *SendMessageRequestBodyMMSVideo

	Type SendMessageRequestBodyMMSType
}

func CreateSendMessageRequestBodyMMSSendMessageRequestBodyMMSImage(sendMessageRequestBodyMMSImage SendMessageRequestBodyMMSImage) SendMessageRequestBodyMMS {
	typ := SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSImage

	return SendMessageRequestBodyMMS{
		SendMessageRequestBodyMMSImage: &sendMessageRequestBodyMMSImage,
		Type:                           typ,
	}
}

func CreateSendMessageRequestBodyMMSSendMessageRequestBodyMMSVCard(sendMessageRequestBodyMMSVCard SendMessageRequestBodyMMSVCard) SendMessageRequestBodyMMS {
	typ := SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSVCard

	return SendMessageRequestBodyMMS{
		SendMessageRequestBodyMMSVCard: &sendMessageRequestBodyMMSVCard,
		Type:                           typ,
	}
}

func CreateSendMessageRequestBodyMMSSendMessageRequestBodyMMSAudio(sendMessageRequestBodyMMSAudio SendMessageRequestBodyMMSAudio) SendMessageRequestBodyMMS {
	typ := SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSAudio

	return SendMessageRequestBodyMMS{
		SendMessageRequestBodyMMSAudio: &sendMessageRequestBodyMMSAudio,
		Type:                           typ,
	}
}

func CreateSendMessageRequestBodyMMSSendMessageRequestBodyMMSVideo(sendMessageRequestBodyMMSVideo SendMessageRequestBodyMMSVideo) SendMessageRequestBodyMMS {
	typ := SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSVideo

	return SendMessageRequestBodyMMS{
		SendMessageRequestBodyMMSVideo: &sendMessageRequestBodyMMSVideo,
		Type:                           typ,
	}
}

func (u *SendMessageRequestBodyMMS) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessageRequestBodyMMSImage := new(SendMessageRequestBodyMMSImage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMMSImage); err == nil {
		u.SendMessageRequestBodyMMSImage = sendMessageRequestBodyMMSImage
		u.Type = SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSImage
		return nil
	}

	sendMessageRequestBodyMMSVCard := new(SendMessageRequestBodyMMSVCard)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMMSVCard); err == nil {
		u.SendMessageRequestBodyMMSVCard = sendMessageRequestBodyMMSVCard
		u.Type = SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSVCard
		return nil
	}

	sendMessageRequestBodyMMSAudio := new(SendMessageRequestBodyMMSAudio)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMMSAudio); err == nil {
		u.SendMessageRequestBodyMMSAudio = sendMessageRequestBodyMMSAudio
		u.Type = SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSAudio
		return nil
	}

	sendMessageRequestBodyMMSVideo := new(SendMessageRequestBodyMMSVideo)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMMSVideo); err == nil {
		u.SendMessageRequestBodyMMSVideo = sendMessageRequestBodyMMSVideo
		u.Type = SendMessageRequestBodyMMSTypeSendMessageRequestBodyMMSVideo
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessageRequestBodyMMS) MarshalJSON() ([]byte, error) {
	if u.SendMessageRequestBodyMMSImage != nil {
		return json.Marshal(u.SendMessageRequestBodyMMSImage)
	}

	if u.SendMessageRequestBodyMMSVCard != nil {
		return json.Marshal(u.SendMessageRequestBodyMMSVCard)
	}

	if u.SendMessageRequestBodyMMSAudio != nil {
		return json.Marshal(u.SendMessageRequestBodyMMSAudio)
	}

	if u.SendMessageRequestBodyMMSVideo != nil {
		return json.Marshal(u.SendMessageRequestBodyMMSVideo)
	}

	return nil, nil
}

// SendMessageRequestBodySMSTextChannelEnum - The channel to send to. You must provide `sms` in this field
type SendMessageRequestBodySMSTextChannelEnum string

const (
	SendMessageRequestBodySMSTextChannelEnumSms SendMessageRequestBodySMSTextChannelEnum = "sms"
)

func (e *SendMessageRequestBodySMSTextChannelEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "sms":
		*e = SendMessageRequestBodySMSTextChannelEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodySMSTextChannelEnum: %s", s)
	}
}

// SendMessageRequestBodySMSTextMessageTypeEnum - The type of message to send. You must provide `text` in this field
type SendMessageRequestBodySMSTextMessageTypeEnum string

const (
	SendMessageRequestBodySMSTextMessageTypeEnumText SendMessageRequestBodySMSTextMessageTypeEnum = "text"
)

func (e *SendMessageRequestBodySMSTextMessageTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "text":
		*e = SendMessageRequestBodySMSTextMessageTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SendMessageRequestBodySMSTextMessageTypeEnum: %s", s)
	}
}

// SendMessageRequestBodySMSText - The text of message to send.
type SendMessageRequestBodySMSText struct {
	// The channel to send to. You must provide `sms` in this field
	Channel SendMessageRequestBodySMSTextChannelEnum `json:"channel"`
	// Client reference of up to 100 characters. The reference will be present in every message status.
	ClientRef *string `json:"client_ref,omitempty"`
	// The phone number of the message **sender** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000. For SMS in certain localities alpha-numeric sender id's will work as well, see [Global Messaging](https://developer.nexmo.com/messaging/sms/guides/country-specific-features#country-specific-features) for more details
	//
	From string `json:"from"`
	// The type of message to send. You must provide `text` in this field
	MessageType SendMessageRequestBodySMSTextMessageTypeEnum `json:"message_type"`
	Text        string                                       `json:"text"`
	// The phone number of the message **recipient** in the [E.164](https://en.wikipedia.org/wiki/E.164) format. Don't use a leading + or 00 when entering a phone number, start with the country code, for example, 447700900000.
	//
	To string `json:"to"`
}

type SendMessageRequestBodySMSType string

const (
	SendMessageRequestBodySMSTypeSendMessageRequestBodySMSText SendMessageRequestBodySMSType = "SendMessage_requestBody_SMS_Text"
)

type SendMessageRequestBodySMS struct {
	SendMessageRequestBodySMSText *SendMessageRequestBodySMSText

	Type SendMessageRequestBodySMSType
}

func CreateSendMessageRequestBodySMSSendMessageRequestBodySMSText(sendMessageRequestBodySMSText SendMessageRequestBodySMSText) SendMessageRequestBodySMS {
	typ := SendMessageRequestBodySMSTypeSendMessageRequestBodySMSText

	return SendMessageRequestBodySMS{
		SendMessageRequestBodySMSText: &sendMessageRequestBodySMSText,
		Type:                          typ,
	}
}

func (u *SendMessageRequestBodySMS) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessageRequestBodySMSText := new(SendMessageRequestBodySMSText)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodySMSText); err == nil {
		u.SendMessageRequestBodySMSText = sendMessageRequestBodySMSText
		u.Type = SendMessageRequestBodySMSTypeSendMessageRequestBodySMSText
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessageRequestBodySMS) MarshalJSON() ([]byte, error) {
	if u.SendMessageRequestBodySMSText != nil {
		return json.Marshal(u.SendMessageRequestBodySMSText)
	}

	return nil, nil
}

type SendMessageRequestBodyType string

const (
	SendMessageRequestBodyTypeSendMessageRequestBodySMS       SendMessageRequestBodyType = "SendMessage_requestBody_SMS"
	SendMessageRequestBodyTypeSendMessageRequestBodyMMS       SendMessageRequestBodyType = "SendMessage_requestBody_MMS"
	SendMessageRequestBodyTypeSendMessageRequestBodyWhatsApp  SendMessageRequestBodyType = "SendMessage_requestBody_WhatsApp"
	SendMessageRequestBodyTypeSendMessageRequestBodyMessenger SendMessageRequestBodyType = "SendMessage_requestBody_Messenger"
	SendMessageRequestBodyTypeSendMessageRequestBodyViber     SendMessageRequestBodyType = "SendMessage_requestBody_Viber"
)

type SendMessageRequestBody struct {
	SendMessageRequestBodySMS       *SendMessageRequestBodySMS
	SendMessageRequestBodyMMS       *SendMessageRequestBodyMMS
	SendMessageRequestBodyWhatsApp  *SendMessageRequestBodyWhatsApp
	SendMessageRequestBodyMessenger *SendMessageRequestBodyMessenger
	SendMessageRequestBodyViber     *SendMessageRequestBodyViber

	Type SendMessageRequestBodyType
}

func CreateSendMessageRequestBodySendMessageRequestBodySMS(sendMessageRequestBodySMS SendMessageRequestBodySMS) SendMessageRequestBody {
	typ := SendMessageRequestBodyTypeSendMessageRequestBodySMS

	return SendMessageRequestBody{
		SendMessageRequestBodySMS: &sendMessageRequestBodySMS,
		Type:                      typ,
	}
}

func CreateSendMessageRequestBodySendMessageRequestBodyMMS(sendMessageRequestBodyMMS SendMessageRequestBodyMMS) SendMessageRequestBody {
	typ := SendMessageRequestBodyTypeSendMessageRequestBodyMMS

	return SendMessageRequestBody{
		SendMessageRequestBodyMMS: &sendMessageRequestBodyMMS,
		Type:                      typ,
	}
}

func CreateSendMessageRequestBodySendMessageRequestBodyWhatsApp(sendMessageRequestBodyWhatsApp SendMessageRequestBodyWhatsApp) SendMessageRequestBody {
	typ := SendMessageRequestBodyTypeSendMessageRequestBodyWhatsApp

	return SendMessageRequestBody{
		SendMessageRequestBodyWhatsApp: &sendMessageRequestBodyWhatsApp,
		Type:                           typ,
	}
}

func CreateSendMessageRequestBodySendMessageRequestBodyMessenger(sendMessageRequestBodyMessenger SendMessageRequestBodyMessenger) SendMessageRequestBody {
	typ := SendMessageRequestBodyTypeSendMessageRequestBodyMessenger

	return SendMessageRequestBody{
		SendMessageRequestBodyMessenger: &sendMessageRequestBodyMessenger,
		Type:                            typ,
	}
}

func CreateSendMessageRequestBodySendMessageRequestBodyViber(sendMessageRequestBodyViber SendMessageRequestBodyViber) SendMessageRequestBody {
	typ := SendMessageRequestBodyTypeSendMessageRequestBodyViber

	return SendMessageRequestBody{
		SendMessageRequestBodyViber: &sendMessageRequestBodyViber,
		Type:                        typ,
	}
}

func (u *SendMessageRequestBody) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessageRequestBodySMS := new(SendMessageRequestBodySMS)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodySMS); err == nil {
		u.SendMessageRequestBodySMS = sendMessageRequestBodySMS
		u.Type = SendMessageRequestBodyTypeSendMessageRequestBodySMS
		return nil
	}

	sendMessageRequestBodyMMS := new(SendMessageRequestBodyMMS)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMMS); err == nil {
		u.SendMessageRequestBodyMMS = sendMessageRequestBodyMMS
		u.Type = SendMessageRequestBodyTypeSendMessageRequestBodyMMS
		return nil
	}

	sendMessageRequestBodyWhatsApp := new(SendMessageRequestBodyWhatsApp)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyWhatsApp); err == nil {
		u.SendMessageRequestBodyWhatsApp = sendMessageRequestBodyWhatsApp
		u.Type = SendMessageRequestBodyTypeSendMessageRequestBodyWhatsApp
		return nil
	}

	sendMessageRequestBodyMessenger := new(SendMessageRequestBodyMessenger)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyMessenger); err == nil {
		u.SendMessageRequestBodyMessenger = sendMessageRequestBodyMessenger
		u.Type = SendMessageRequestBodyTypeSendMessageRequestBodyMessenger
		return nil
	}

	sendMessageRequestBodyViber := new(SendMessageRequestBodyViber)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessageRequestBodyViber); err == nil {
		u.SendMessageRequestBodyViber = sendMessageRequestBodyViber
		u.Type = SendMessageRequestBodyTypeSendMessageRequestBodyViber
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessageRequestBody) MarshalJSON() ([]byte, error) {
	if u.SendMessageRequestBodySMS != nil {
		return json.Marshal(u.SendMessageRequestBodySMS)
	}

	if u.SendMessageRequestBodyMMS != nil {
		return json.Marshal(u.SendMessageRequestBodyMMS)
	}

	if u.SendMessageRequestBodyWhatsApp != nil {
		return json.Marshal(u.SendMessageRequestBodyWhatsApp)
	}

	if u.SendMessageRequestBodyMessenger != nil {
		return json.Marshal(u.SendMessageRequestBodyMessenger)
	}

	if u.SendMessageRequestBodyViber != nil {
		return json.Marshal(u.SendMessageRequestBodyViber)
	}

	return nil, nil
}

type SendMessageRequest struct {
	// Send a Message.
	Request  SendMessageRequestBody `request:"mediaType=application/json"`
	Security SendMessageSecurity
}

type SendMessage422ApplicationJSONType string

const (
	SendMessage422ApplicationJSONTypeErrorInvalidJSON     SendMessage422ApplicationJSONType = "ErrorInvalidJson"
	SendMessage422ApplicationJSONTypeErrorChannel         SendMessage422ApplicationJSONType = "ErrorChannel"
	SendMessage422ApplicationJSONTypeErrorChannelParams   SendMessage422ApplicationJSONType = "ErrorChannelParams"
	SendMessage422ApplicationJSONTypeErrorSender          SendMessage422ApplicationJSONType = "ErrorSender"
	SendMessage422ApplicationJSONTypeErrorRecipient       SendMessage422ApplicationJSONType = "ErrorRecipient"
	SendMessage422ApplicationJSONTypeErrorMessageType     SendMessage422ApplicationJSONType = "ErrorMessageType"
	SendMessage422ApplicationJSONTypeErrorMessageParams   SendMessage422ApplicationJSONType = "ErrorMessageParams"
	SendMessage422ApplicationJSONTypeErrorClientReference SendMessage422ApplicationJSONType = "ErrorClientReference"
)

type SendMessage422ApplicationJSON struct {
	ErrorInvalidJSON     *shared.ErrorInvalidJSON
	ErrorChannel         *shared.ErrorChannel
	ErrorChannelParams   *shared.ErrorChannelParams
	ErrorSender          *shared.ErrorSender
	ErrorRecipient       *shared.ErrorRecipient
	ErrorMessageType     *shared.ErrorMessageType
	ErrorMessageParams   *shared.ErrorMessageParams
	ErrorClientReference *shared.ErrorClientReference

	Type SendMessage422ApplicationJSONType
}

func CreateSendMessage422ApplicationJSONErrorInvalidJSON(errorInvalidJSON shared.ErrorInvalidJSON) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorInvalidJSON

	return SendMessage422ApplicationJSON{
		ErrorInvalidJSON: &errorInvalidJSON,
		Type:             typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorChannel(errorChannel shared.ErrorChannel) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorChannel

	return SendMessage422ApplicationJSON{
		ErrorChannel: &errorChannel,
		Type:         typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorChannelParams(errorChannelParams shared.ErrorChannelParams) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorChannelParams

	return SendMessage422ApplicationJSON{
		ErrorChannelParams: &errorChannelParams,
		Type:               typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorSender(errorSender shared.ErrorSender) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorSender

	return SendMessage422ApplicationJSON{
		ErrorSender: &errorSender,
		Type:        typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorRecipient(errorRecipient shared.ErrorRecipient) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorRecipient

	return SendMessage422ApplicationJSON{
		ErrorRecipient: &errorRecipient,
		Type:           typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorMessageType(errorMessageType shared.ErrorMessageType) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorMessageType

	return SendMessage422ApplicationJSON{
		ErrorMessageType: &errorMessageType,
		Type:             typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorMessageParams(errorMessageParams shared.ErrorMessageParams) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorMessageParams

	return SendMessage422ApplicationJSON{
		ErrorMessageParams: &errorMessageParams,
		Type:               typ,
	}
}

func CreateSendMessage422ApplicationJSONErrorClientReference(errorClientReference shared.ErrorClientReference) SendMessage422ApplicationJSON {
	typ := SendMessage422ApplicationJSONTypeErrorClientReference

	return SendMessage422ApplicationJSON{
		ErrorClientReference: &errorClientReference,
		Type:                 typ,
	}
}

func (u *SendMessage422ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	errorInvalidJSON := new(shared.ErrorInvalidJSON)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorInvalidJSON); err == nil {
		u.ErrorInvalidJSON = errorInvalidJSON
		u.Type = SendMessage422ApplicationJSONTypeErrorInvalidJSON
		return nil
	}

	errorChannel := new(shared.ErrorChannel)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorChannel); err == nil {
		u.ErrorChannel = errorChannel
		u.Type = SendMessage422ApplicationJSONTypeErrorChannel
		return nil
	}

	errorChannelParams := new(shared.ErrorChannelParams)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorChannelParams); err == nil {
		u.ErrorChannelParams = errorChannelParams
		u.Type = SendMessage422ApplicationJSONTypeErrorChannelParams
		return nil
	}

	errorSender := new(shared.ErrorSender)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorSender); err == nil {
		u.ErrorSender = errorSender
		u.Type = SendMessage422ApplicationJSONTypeErrorSender
		return nil
	}

	errorRecipient := new(shared.ErrorRecipient)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorRecipient); err == nil {
		u.ErrorRecipient = errorRecipient
		u.Type = SendMessage422ApplicationJSONTypeErrorRecipient
		return nil
	}

	errorMessageType := new(shared.ErrorMessageType)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorMessageType); err == nil {
		u.ErrorMessageType = errorMessageType
		u.Type = SendMessage422ApplicationJSONTypeErrorMessageType
		return nil
	}

	errorMessageParams := new(shared.ErrorMessageParams)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorMessageParams); err == nil {
		u.ErrorMessageParams = errorMessageParams
		u.Type = SendMessage422ApplicationJSONTypeErrorMessageParams
		return nil
	}

	errorClientReference := new(shared.ErrorClientReference)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorClientReference); err == nil {
		u.ErrorClientReference = errorClientReference
		u.Type = SendMessage422ApplicationJSONTypeErrorClientReference
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessage422ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ErrorInvalidJSON != nil {
		return json.Marshal(u.ErrorInvalidJSON)
	}

	if u.ErrorChannel != nil {
		return json.Marshal(u.ErrorChannel)
	}

	if u.ErrorChannelParams != nil {
		return json.Marshal(u.ErrorChannelParams)
	}

	if u.ErrorSender != nil {
		return json.Marshal(u.ErrorSender)
	}

	if u.ErrorRecipient != nil {
		return json.Marshal(u.ErrorRecipient)
	}

	if u.ErrorMessageType != nil {
		return json.Marshal(u.ErrorMessageType)
	}

	if u.ErrorMessageParams != nil {
		return json.Marshal(u.ErrorMessageParams)
	}

	if u.ErrorClientReference != nil {
		return json.Marshal(u.ErrorClientReference)
	}

	return nil, nil
}

type SendMessage401ApplicationJSONType string

const (
	SendMessage401ApplicationJSONTypeErrorUnauthorizedMissingCredentials SendMessage401ApplicationJSONType = "ErrorUnauthorizedMissingCredentials"
	SendMessage401ApplicationJSONTypeErrorUnauthorizedInvalidApplication SendMessage401ApplicationJSONType = "ErrorUnauthorizedInvalidApplication"
)

type SendMessage401ApplicationJSON struct {
	ErrorUnauthorizedMissingCredentials *shared.ErrorUnauthorizedMissingCredentials
	ErrorUnauthorizedInvalidApplication *shared.ErrorUnauthorizedInvalidApplication

	Type SendMessage401ApplicationJSONType
}

func CreateSendMessage401ApplicationJSONErrorUnauthorizedMissingCredentials(errorUnauthorizedMissingCredentials shared.ErrorUnauthorizedMissingCredentials) SendMessage401ApplicationJSON {
	typ := SendMessage401ApplicationJSONTypeErrorUnauthorizedMissingCredentials

	return SendMessage401ApplicationJSON{
		ErrorUnauthorizedMissingCredentials: &errorUnauthorizedMissingCredentials,
		Type:                                typ,
	}
}

func CreateSendMessage401ApplicationJSONErrorUnauthorizedInvalidApplication(errorUnauthorizedInvalidApplication shared.ErrorUnauthorizedInvalidApplication) SendMessage401ApplicationJSON {
	typ := SendMessage401ApplicationJSONTypeErrorUnauthorizedInvalidApplication

	return SendMessage401ApplicationJSON{
		ErrorUnauthorizedInvalidApplication: &errorUnauthorizedInvalidApplication,
		Type:                                typ,
	}
}

func (u *SendMessage401ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	errorUnauthorizedMissingCredentials := new(shared.ErrorUnauthorizedMissingCredentials)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorUnauthorizedMissingCredentials); err == nil {
		u.ErrorUnauthorizedMissingCredentials = errorUnauthorizedMissingCredentials
		u.Type = SendMessage401ApplicationJSONTypeErrorUnauthorizedMissingCredentials
		return nil
	}

	errorUnauthorizedInvalidApplication := new(shared.ErrorUnauthorizedInvalidApplication)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&errorUnauthorizedInvalidApplication); err == nil {
		u.ErrorUnauthorizedInvalidApplication = errorUnauthorizedInvalidApplication
		u.Type = SendMessage401ApplicationJSONTypeErrorUnauthorizedInvalidApplication
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessage401ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.ErrorUnauthorizedMissingCredentials != nil {
		return json.Marshal(u.ErrorUnauthorizedMissingCredentials)
	}

	if u.ErrorUnauthorizedInvalidApplication != nil {
		return json.Marshal(u.ErrorUnauthorizedInvalidApplication)
	}

	return nil, nil
}

// SendMessage202ApplicationJSON5 - Viber
type SendMessage202ApplicationJSON5 struct {
	// The UUID of the message
	MessageUUID *string `json:"message_uuid,omitempty"`
}

// SendMessage202ApplicationJSON4 - Messenger
type SendMessage202ApplicationJSON4 struct {
	// The UUID of the message
	MessageUUID *string `json:"message_uuid,omitempty"`
}

// SendMessage202ApplicationJSON3 - WhatsApp
type SendMessage202ApplicationJSON3 struct {
	// The UUID of the message
	MessageUUID *string `json:"message_uuid,omitempty"`
}

// SendMessage202ApplicationJSON2 - MMS
type SendMessage202ApplicationJSON2 struct {
	// The UUID of the message
	MessageUUID *string `json:"message_uuid,omitempty"`
}

// SendMessage202ApplicationJSON1 - SMS
type SendMessage202ApplicationJSON1 struct {
	// The UUID of the message
	MessageUUID *string `json:"message_uuid,omitempty"`
}

type SendMessage202ApplicationJSONType string

const (
	SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON1 SendMessage202ApplicationJSONType = "SendMessage_202ApplicationJSON_1"
	SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON2 SendMessage202ApplicationJSONType = "SendMessage_202ApplicationJSON_2"
	SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON3 SendMessage202ApplicationJSONType = "SendMessage_202ApplicationJSON_3"
	SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON4 SendMessage202ApplicationJSONType = "SendMessage_202ApplicationJSON_4"
	SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON5 SendMessage202ApplicationJSONType = "SendMessage_202ApplicationJSON_5"
)

type SendMessage202ApplicationJSON struct {
	SendMessage202ApplicationJSON1 *SendMessage202ApplicationJSON1
	SendMessage202ApplicationJSON2 *SendMessage202ApplicationJSON2
	SendMessage202ApplicationJSON3 *SendMessage202ApplicationJSON3
	SendMessage202ApplicationJSON4 *SendMessage202ApplicationJSON4
	SendMessage202ApplicationJSON5 *SendMessage202ApplicationJSON5

	Type SendMessage202ApplicationJSONType
}

func CreateSendMessage202ApplicationJSONSendMessage202ApplicationJSON1(sendMessage202ApplicationJSON1 SendMessage202ApplicationJSON1) SendMessage202ApplicationJSON {
	typ := SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON1

	return SendMessage202ApplicationJSON{
		SendMessage202ApplicationJSON1: &sendMessage202ApplicationJSON1,
		Type:                           typ,
	}
}

func CreateSendMessage202ApplicationJSONSendMessage202ApplicationJSON2(sendMessage202ApplicationJSON2 SendMessage202ApplicationJSON2) SendMessage202ApplicationJSON {
	typ := SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON2

	return SendMessage202ApplicationJSON{
		SendMessage202ApplicationJSON2: &sendMessage202ApplicationJSON2,
		Type:                           typ,
	}
}

func CreateSendMessage202ApplicationJSONSendMessage202ApplicationJSON3(sendMessage202ApplicationJSON3 SendMessage202ApplicationJSON3) SendMessage202ApplicationJSON {
	typ := SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON3

	return SendMessage202ApplicationJSON{
		SendMessage202ApplicationJSON3: &sendMessage202ApplicationJSON3,
		Type:                           typ,
	}
}

func CreateSendMessage202ApplicationJSONSendMessage202ApplicationJSON4(sendMessage202ApplicationJSON4 SendMessage202ApplicationJSON4) SendMessage202ApplicationJSON {
	typ := SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON4

	return SendMessage202ApplicationJSON{
		SendMessage202ApplicationJSON4: &sendMessage202ApplicationJSON4,
		Type:                           typ,
	}
}

func CreateSendMessage202ApplicationJSONSendMessage202ApplicationJSON5(sendMessage202ApplicationJSON5 SendMessage202ApplicationJSON5) SendMessage202ApplicationJSON {
	typ := SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON5

	return SendMessage202ApplicationJSON{
		SendMessage202ApplicationJSON5: &sendMessage202ApplicationJSON5,
		Type:                           typ,
	}
}

func (u *SendMessage202ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	sendMessage202ApplicationJSON1 := new(SendMessage202ApplicationJSON1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessage202ApplicationJSON1); err == nil {
		u.SendMessage202ApplicationJSON1 = sendMessage202ApplicationJSON1
		u.Type = SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON1
		return nil
	}

	sendMessage202ApplicationJSON2 := new(SendMessage202ApplicationJSON2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessage202ApplicationJSON2); err == nil {
		u.SendMessage202ApplicationJSON2 = sendMessage202ApplicationJSON2
		u.Type = SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON2
		return nil
	}

	sendMessage202ApplicationJSON3 := new(SendMessage202ApplicationJSON3)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessage202ApplicationJSON3); err == nil {
		u.SendMessage202ApplicationJSON3 = sendMessage202ApplicationJSON3
		u.Type = SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON3
		return nil
	}

	sendMessage202ApplicationJSON4 := new(SendMessage202ApplicationJSON4)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessage202ApplicationJSON4); err == nil {
		u.SendMessage202ApplicationJSON4 = sendMessage202ApplicationJSON4
		u.Type = SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON4
		return nil
	}

	sendMessage202ApplicationJSON5 := new(SendMessage202ApplicationJSON5)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&sendMessage202ApplicationJSON5); err == nil {
		u.SendMessage202ApplicationJSON5 = sendMessage202ApplicationJSON5
		u.Type = SendMessage202ApplicationJSONTypeSendMessage202ApplicationJSON5
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SendMessage202ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.SendMessage202ApplicationJSON1 != nil {
		return json.Marshal(u.SendMessage202ApplicationJSON1)
	}

	if u.SendMessage202ApplicationJSON2 != nil {
		return json.Marshal(u.SendMessage202ApplicationJSON2)
	}

	if u.SendMessage202ApplicationJSON3 != nil {
		return json.Marshal(u.SendMessage202ApplicationJSON3)
	}

	if u.SendMessage202ApplicationJSON4 != nil {
		return json.Marshal(u.SendMessage202ApplicationJSON4)
	}

	if u.SendMessage202ApplicationJSON5 != nil {
		return json.Marshal(u.SendMessage202ApplicationJSON5)
	}

	return nil, nil
}

type SendMessageResponse struct {
	ContentType string
	// Internal error
	ErrorInternal *shared.ErrorInternal
	// Payment Required
	ErrorPaymentRequired *shared.ErrorPaymentRequired
	// Too Many Requests
	ErrorThrottled *shared.ErrorThrottled
	// Accepted.
	SendMessage202ApplicationJSONObject *SendMessage202ApplicationJSON
	// Authentication failure
	SendMessage401ApplicationJSONOneOf *SendMessage401ApplicationJSON
	StatusCode                         int
	RawResponse                        *http.Response
	// Unprocessable Entity
	SendMessage422ApplicationJSONOneOf *SendMessage422ApplicationJSON
}
