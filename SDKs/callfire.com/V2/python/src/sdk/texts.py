"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Texts:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def add_text_broadcast_batch(self, request: operations.AddTextBroadcastBatchRequest, security: operations.AddTextBroadcastBatchSecurity) -> operations.AddTextBroadcastBatchResponse:
        r"""Add batches to a text broadcast
        Allows adding an extra batches to an already created text broadcast campaign. The batches which being  added pass the CallFire validation process (unlike in the recipients version of this API). That is why using of a scrubDuplicates flag remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddTextBroadcastBatchRequest, base_url, '/texts/broadcasts/{id}/batches', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "batch_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.AddTextBroadcastBatchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddTextBroadcastBatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResourceID])
                res.resource_id = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def add_text_broadcast_recipients(self, request: operations.AddTextBroadcastRecipientsRequest, security: operations.AddTextBroadcastRecipientsSecurity) -> operations.AddTextBroadcastRecipientsResponse:
        r"""Add recipients to a text broadcast
        Use this API to add recipients to a text broadcast which is already created. Post a list of Recipient objects to be immediately added to the text broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.AddTextBroadcastRecipientsRequest, base_url, '/texts/broadcasts/{id}/recipients', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.AddTextBroadcastRecipientsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddTextBroadcastRecipientsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextList])
                res.text_list = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def archive_text_broadcast(self, request: operations.ArchiveTextBroadcastRequest, security: operations.ArchiveTextBroadcastSecurity) -> operations.ArchiveTextBroadcastResponse:
        r"""Archive text broadcast
        Archives a text broadcast (and hides it in the search results)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ArchiveTextBroadcastRequest, base_url, '/texts/broadcasts/{id}/archive', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ArchiveTextBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def create_text_auto_reply(self, request: shared.TextAutoReply, security: operations.CreateTextAutoReplySecurity) -> operations.CreateTextAutoReplyResponse:
        r"""Create an auto reply
        CallFire gives you possibility to set up auto reply messages for your numbers and keywords. You can set a general auto reply for anyone who texts your number, keyword, and/or include a text to match, so that the auto reply would be sent only to those who text the matched text
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/texts/auto-replys'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateTextAutoReplyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResourceID])
                res.resource_id = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def create_text_broadcast(self, request: operations.CreateTextBroadcastRequest, security: operations.CreateTextBroadcastSecurity) -> operations.CreateTextBroadcastResponse:
        r"""Create a text broadcast
        Creates a text broadcast campaign using the Text Broadcast API. Send a TextBroadcast object in the message body to detail a text broadcast campaign. A campaign can be created without contacts and with bare minimum configuration, but contacts have to be added further on to use the campaign. It supports scheduling, retry logic, pattern-based messages.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/texts/broadcasts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "text_broadcast_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.CreateTextBroadcastRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateTextBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ResourceID])
                res.resource_id = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def delete_text_auto_reply(self, request: operations.DeleteTextAutoReplyRequest, security: operations.DeleteTextAutoReplySecurity) -> operations.DeleteTextAutoReplyResponse:
        r"""Delete an auto reply
        Deletes a text auto reply and removes the configuration. Can not delete a TextAutoReply which is currently active for a campaign
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteTextAutoReplyRequest, base_url, '/texts/auto-replys/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteTextAutoReplyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def find_text_auto_replys(self, request: operations.FindTextAutoReplysRequest, security: operations.FindTextAutoReplysSecurity) -> operations.FindTextAutoReplysResponse:
        r"""Find auto replies
        Find all text autoreplies created by user. Returns a paged list of TextAutoReply
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/texts/auto-replys'
        
        query_params = utils.get_query_params(operations.FindTextAutoReplysRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindTextAutoReplysResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextAutoReplyPage])
                res.text_auto_reply_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def find_text_broadcasts(self, request: operations.FindTextBroadcastsRequest, security: operations.FindTextBroadcastsSecurity) -> operations.FindTextBroadcastsResponse:
        r"""Find text broadcasts
        Searches for all text broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of text broadcasts
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/texts/broadcasts'
        
        query_params = utils.get_query_params(operations.FindTextBroadcastsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindTextBroadcastsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextBroadcastPage])
                res.text_broadcast_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def find_texts(self, request: operations.FindTextsRequest, security: operations.FindTextsSecurity) -> operations.FindTextsResponse:
        r"""Find texts
        Searches for texts sent or received by user. Use \"campaignId=0\" parameter to query for all texts sent through the POST /texts API. See [call states and results](https://developers.callfire.com/results-responses-errors.html)
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/texts'
        
        query_params = utils.get_query_params(operations.FindTextsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindTextsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextPage])
                res.text_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_text(self, request: operations.GetTextRequest, security: operations.GetTextSecurity) -> operations.GetTextResponse:
        r"""Find a specific text
        Returns a single Text instance for a given text id
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTextRequest, base_url, '/texts/{id}', request)
        
        query_params = utils.get_query_params(operations.GetTextRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Text])
                res.text = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_text_auto_reply(self, request: operations.GetTextAutoReplyRequest, security: operations.GetTextAutoReplySecurity) -> operations.GetTextAutoReplyResponse:
        r"""Find a specific auto reply
        Returns a single TextAutoReply instance for a given text auto reply id
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTextAutoReplyRequest, base_url, '/texts/auto-replys/{id}', request)
        
        query_params = utils.get_query_params(operations.GetTextAutoReplyRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTextAutoReplyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextAutoReply])
                res.text_auto_reply = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_text_broadcast(self, request: operations.GetTextBroadcastRequest, security: operations.GetTextBroadcastSecurity) -> operations.GetTextBroadcastResponse:
        r"""Find a specific text broadcast
        Returns a single TextBroadcast instance for a given text broadcast id
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTextBroadcastRequest, base_url, '/texts/broadcasts/{id}', request)
        
        query_params = utils.get_query_params(operations.GetTextBroadcastRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTextBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextBroadcast])
                res.text_broadcast = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_text_broadcast_batches(self, request: operations.GetTextBroadcastBatchesRequest, security: operations.GetTextBroadcastBatchesSecurity) -> operations.GetTextBroadcastBatchesResponse:
        r"""Find batches in a text broadcast
        This endpoint will enable the user to page through all of the batches for a particular text broadcast campaign
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTextBroadcastBatchesRequest, base_url, '/texts/broadcasts/{id}/batches', request)
        
        query_params = utils.get_query_params(operations.GetTextBroadcastBatchesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTextBroadcastBatchesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BatchPage])
                res.batch_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_text_broadcast_stats(self, request: operations.GetTextBroadcastStatsRequest, security: operations.GetTextBroadcastStatsSecurity) -> operations.GetTextBroadcastStatsResponse:
        r"""Get statistics on text broadcast
        Returns the broadcast statistics. Example: total number of the sent/received actions, total cost, number of remaining outbound actions, error count, etc
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTextBroadcastStatsRequest, base_url, '/texts/broadcasts/{id}/stats', request)
        
        query_params = utils.get_query_params(operations.GetTextBroadcastStatsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTextBroadcastStatsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextBroadcastStatsDto])
                res.text_broadcast_stats_dto = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_text_broadcast_texts(self, request: operations.GetTextBroadcastTextsRequest, security: operations.GetTextBroadcastTextsSecurity) -> operations.GetTextBroadcastTextsResponse:
        r"""Find texts in a text broadcast
        This endpoint will enable the user to page through all of the texts for a particular text broadcast campaign
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetTextBroadcastTextsRequest, base_url, '/texts/broadcasts/{id}/texts', request)
        
        query_params = utils.get_query_params(operations.GetTextBroadcastTextsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetTextBroadcastTextsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextPage])
                res.text_page = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def send_texts(self, request: operations.SendTextsRequest, security: operations.SendTextsSecurity) -> operations.SendTextsResponse:
        r"""Send texts
        Use the /texts API to send individual texts quickly. By default all texts are going out from CallFire's dedicated short code. Example: 67076, 818818 etc
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/texts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.SendTextsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SendTextsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextList])
                res.text_list = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def start_text_broadcast(self, request: operations.StartTextBroadcastRequest, security: operations.StartTextBroadcastSecurity) -> operations.StartTextBroadcastResponse:
        r"""Start text broadcast
        Starts a text broadcast
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.StartTextBroadcastRequest, base_url, '/texts/broadcasts/{id}/start', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StartTextBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def stop_text_broadcast(self, request: operations.StopTextBroadcastRequest, security: operations.StopTextBroadcastSecurity) -> operations.StopTextBroadcastResponse:
        r"""Stop text broadcast
        Stops a text broadcast
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopTextBroadcastRequest, base_url, '/texts/broadcasts/{id}/stop', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopTextBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def toggle_text_broadcast_recipients_status(self, request: operations.ToggleTextBroadcastRecipientsStatusRequest, security: operations.ToggleTextBroadcastRecipientsStatusSecurity) -> operations.ToggleTextBroadcastRecipientsStatusResponse:
        r"""Disable/enable undialed recipients in broadcast
        This operation lets the user to disable/enable undialed contacts in created broadcast
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ToggleTextBroadcastRecipientsStatusRequest, base_url, '/texts/broadcasts/{id}/toggleRecipientsStatus', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.ToggleTextBroadcastRecipientsStatusRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ToggleTextBroadcastRecipientsStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def update_text_broadcast(self, request: operations.UpdateTextBroadcastRequest, security: operations.UpdateTextBroadcastSecurity) -> operations.UpdateTextBroadcastResponse:
        r"""Update a text broadcast
        Allows modifying the configuration of existing text broadcast campaign. See TextBroadcast for more information on what can/can't be updated on this API
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateTextBroadcastRequest, base_url, '/texts/broadcasts/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "text_broadcast_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.UpdateTextBroadcastRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateTextBroadcastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TextBroadcastCreateResponse])
                res.text_broadcast_create_response = out
        elif http_res.status_code in [400, 401, 403, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    