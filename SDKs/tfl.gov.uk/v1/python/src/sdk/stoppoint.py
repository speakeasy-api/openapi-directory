"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class StopPoint:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def stop_point_arrival_departures(self, request: operations.StopPointArrivalDeparturesRequest) -> operations.StopPointArrivalDeparturesResponse:
        r"""Gets the list of arrival and departure predictions for the given stop point id (overground, Elizabeth line and thameslink only)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointArrivalDeparturesRequest, base_url, '/StopPoint/{id}/ArrivalDepartures', request)
        
        query_params = utils.get_query_params(operations.StopPointArrivalDeparturesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointArrivalDeparturesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesArrivalDeparture]])
                res.tfl_api_presentation_entities_arrival_departures = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesArrivalDeparture]])
                res.tfl_api_presentation_entities_arrival_departures = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_arrivals(self, request: operations.StopPointArrivalsRequest) -> operations.StopPointArrivalsResponse:
        r"""Gets the list of arrival predictions for the given stop point id"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointArrivalsRequest, base_url, '/StopPoint/{id}/Arrivals', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointArrivalsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPrediction]])
                res.tfl_api_presentation_entities_predictions = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPrediction]])
                res.tfl_api_presentation_entities_predictions = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_crowding(self, request: operations.StopPointCrowdingRequest) -> operations.StopPointCrowdingResponse:
        r"""Gets all the Crowding data (static) for the StopPointId, plus crowding data for a given line and optionally a particular direction."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointCrowdingRequest, base_url, '/StopPoint/{id}/Crowding/{line}', request)
        
        query_params = utils.get_query_params(operations.StopPointCrowdingRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointCrowdingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_direction(self, request: operations.StopPointDirectionRequest) -> operations.StopPointDirectionResponse:
        r"""Returns the canonical direction, \\"inbound\\" or \\"outbound\\", for a given pair of stop point Ids in the direction from -&gt; to."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointDirectionRequest, base_url, '/StopPoint/{id}/DirectionTo/{toStopPointId}', request)
        
        query_params = utils.get_query_params(operations.StopPointDirectionRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointDirectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                res.stop_point_direction_200_application_json_string = http_res.content
            if utils.match_content_type(content_type, 'application/xml'):
                res.stop_point_direction_200_application_xml_string = http_res.content
            if utils.match_content_type(content_type, 'text/json'):
                res.stop_point_direction_200_text_json_string = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.stop_point_direction_200_text_xml_string = http_res.content

        return res

    def stop_point_disruption(self, request: operations.StopPointDisruptionRequest) -> operations.StopPointDisruptionResponse:
        r"""Gets all disruptions for the specified StopPointId, plus disruptions for any child Naptan records it may have."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointDisruptionRequest, base_url, '/StopPoint/{ids}/Disruption', request)
        
        query_params = utils.get_query_params(operations.StopPointDisruptionRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointDisruptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruptedPoint]])
                res.tfl_api_presentation_entities_disrupted_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruptedPoint]])
                res.tfl_api_presentation_entities_disrupted_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_disruption_by_mode(self, request: operations.StopPointDisruptionByModeRequest) -> operations.StopPointDisruptionByModeResponse:
        r"""Gets a distinct list of disrupted stop points for the given modes"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointDisruptionByModeRequest, base_url, '/StopPoint/Mode/{modes}/Disruption', request)
        
        query_params = utils.get_query_params(operations.StopPointDisruptionByModeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointDisruptionByModeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruptedPoint]])
                res.tfl_api_presentation_entities_disrupted_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruptedPoint]])
                res.tfl_api_presentation_entities_disrupted_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get(self, request: operations.StopPointGetRequest) -> operations.StopPointGetResponse:
        r"""Gets a list of StopPoints corresponding to the given list of stop ids."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetRequest, base_url, '/StopPoint/{ids}', request)
        
        query_params = utils.get_query_params(operations.StopPointGetRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_by_geo_point(self, request: operations.StopPointGetByGeoPointRequest) -> operations.StopPointGetByGeoPointResponse:
        r"""Gets a list of StopPoints within {radius} by the specified criteria"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/StopPoint'
        
        query_params = utils.get_query_params(operations.StopPointGetByGeoPointRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetByGeoPointResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesStopPointsResponse])
                res.tfl_api_presentation_entities_stop_points_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesStopPointsResponse])
                res.tfl_api_presentation_entities_stop_points_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_by_mode(self, request: operations.StopPointGetByModeRequest) -> operations.StopPointGetByModeResponse:
        r"""Gets a list of StopPoints filtered by the modes available at that StopPoint."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetByModeRequest, base_url, '/StopPoint/Mode/{modes}', request)
        
        query_params = utils.get_query_params(operations.StopPointGetByModeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetByModeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesStopPointsResponse])
                res.tfl_api_presentation_entities_stop_points_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesStopPointsResponse])
                res.tfl_api_presentation_entities_stop_points_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_by_sms(self, request: operations.StopPointGetBySmsRequest) -> operations.StopPointGetBySmsResponse:
        r"""Gets a StopPoint for a given sms code."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetBySmsRequest, base_url, '/StopPoint/Sms/{id}', request)
        
        query_params = utils.get_query_params(operations.StopPointGetBySmsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetBySmsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.system_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_by_type(self, request: operations.StopPointGetByTypeRequest) -> operations.StopPointGetByTypeResponse:
        r"""Gets all stop points of a given type"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetByTypeRequest, base_url, '/StopPoint/Type/{types}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetByTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_by_type_with_pagination(self, request: operations.StopPointGetByTypeWithPaginationRequest) -> operations.StopPointGetByTypeWithPaginationResponse:
        r"""Gets all the stop points of given type(s) with a page number"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetByTypeWithPaginationRequest, base_url, '/StopPoint/Type/{types}/page/{page}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetByTypeWithPaginationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_car_parks_by_id(self, request: operations.StopPointGetCarParksByIDRequest) -> operations.StopPointGetCarParksByIDResponse:
        r"""Get car parks corresponding to the given stop point id."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetCarParksByIDRequest, base_url, '/StopPoint/{stopPointId}/CarParks', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetCarParksByIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_service_types(self, request: operations.StopPointGetServiceTypesRequest) -> operations.StopPointGetServiceTypesResponse:
        r"""Gets the service types for a given stoppoint"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/StopPoint/ServiceTypes'
        
        query_params = utils.get_query_params(operations.StopPointGetServiceTypesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetServiceTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLineServiceType]])
                res.tfl_api_presentation_entities_line_service_types = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLineServiceType]])
                res.tfl_api_presentation_entities_line_service_types = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_get_taxi_ranks_by_ids(self, request: operations.StopPointGetTaxiRanksByIdsRequest) -> operations.StopPointGetTaxiRanksByIdsResponse:
        r"""Gets a list of taxi ranks corresponding to the given stop point id."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointGetTaxiRanksByIdsRequest, base_url, '/StopPoint/{stopPointId}/TaxiRanks', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointGetTaxiRanksByIdsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_meta_categories(self) -> operations.StopPointMetaCategoriesResponse:
        r"""Gets the list of available StopPoint additional information categories"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/StopPoint/Meta/Categories'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointMetaCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPointCategory]])
                res.tfl_api_presentation_entities_stop_point_categories = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPointCategory]])
                res.tfl_api_presentation_entities_stop_point_categories = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_meta_modes(self) -> operations.StopPointMetaModesResponse:
        r"""Gets the list of available StopPoint modes"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/StopPoint/Meta/Modes'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointMetaModesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesMode]])
                res.tfl_api_presentation_entities_modes = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesMode]])
                res.tfl_api_presentation_entities_modes = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_meta_stop_types(self) -> operations.StopPointMetaStopTypesResponse:
        r"""Gets the list of available StopPoint types"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/StopPoint/Meta/StopTypes'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointMetaStopTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.stop_point_meta_stop_types_200_application_json_strings = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.stop_point_meta_stop_types_200_text_json_strings = out

        return res

    def stop_point_reachable_from(self, request: operations.StopPointReachableFromRequest) -> operations.StopPointReachableFromResponse:
        r"""Gets Stopoints that are reachable from a station/line combination."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointReachableFromRequest, base_url, '/StopPoint/{id}/CanReachOnLine/{lineId}', request)
        
        query_params = utils.get_query_params(operations.StopPointReachableFromRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointReachableFromResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_route(self, request: operations.StopPointRouteRequest) -> operations.StopPointRouteResponse:
        r"""Returns the route sections for all the lines that service the given stop point ids"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointRouteRequest, base_url, '/StopPoint/{id}/Route', request)
        
        query_params = utils.get_query_params(operations.StopPointRouteRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointRouteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPointRouteSection]])
                res.tfl_api_presentation_entities_stop_point_route_sections = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPointRouteSection]])
                res.tfl_api_presentation_entities_stop_point_route_sections = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def stop_point_search(self, request: operations.StopPointSearchRequest) -> operations.StopPointSearchResponse:
        r"""Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.StopPointSearchRequest, base_url, '/StopPoint/Search/{query}', request)
        
        query_params = utils.get_query_params(operations.StopPointSearchRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.StopPointSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesSearchResponse])
                res.tfl_api_presentation_entities_search_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesSearchResponse])
                res.tfl_api_presentation_entities_search_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_stop_point_search(self, request: operations.GetStopPointSearchRequest) -> operations.GetStopPointSearchResponse:
        r"""Search StopPoints by their common name, or their 5-digit Countdown Bus Stop Code."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/StopPoint/Search'
        
        query_params = utils.get_query_params(operations.GetStopPointSearchRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetStopPointSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesSearchResponse])
                res.tfl_api_presentation_entities_search_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesSearchResponse])
                res.tfl_api_presentation_entities_search_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def get_stop_point_id_place_types(self, request: operations.GetStopPointIDPlaceTypesRequest) -> operations.GetStopPointIDPlaceTypesResponse:
        r"""Get a list of places corresponding to a given id and place types."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetStopPointIDPlaceTypesRequest, base_url, '/StopPoint/{id}/placeTypes', request)
        
        query_params = utils.get_query_params(operations.GetStopPointIDPlaceTypesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetStopPointIDPlaceTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPlace]])
                res.tfl_api_presentation_entities_places = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    