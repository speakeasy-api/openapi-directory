/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * TrainingOptions - Options used in model training.
 */
public class TrainingOptions {
    /**
     * If true, detect step changes and make data adjustment in the input time series.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("adjustStepChanges")
    public Boolean adjustStepChanges;
    public TrainingOptions withAdjustStepChanges(Boolean adjustStepChanges) {
        this.adjustStepChanges = adjustStepChanges;
        return this;
    }
    
    /**
     * Whether to enable auto ARIMA or not.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autoArima")
    public Boolean autoArima;
    public TrainingOptions withAutoArima(Boolean autoArima) {
        this.autoArima = autoArima;
        return this;
    }
    
    /**
     * The max value of non-seasonal p and q.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("autoArimaMaxOrder")
    public String autoArimaMaxOrder;
    public TrainingOptions withAutoArimaMaxOrder(String autoArimaMaxOrder) {
        this.autoArimaMaxOrder = autoArimaMaxOrder;
        return this;
    }
    
    /**
     * Batch size for dnn models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("batchSize")
    public String batchSize;
    public TrainingOptions withBatchSize(String batchSize) {
        this.batchSize = batchSize;
        return this;
    }
    
    /**
     * Booster type for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("boosterType")
    public TrainingOptionsBoosterTypeEnum boosterType;
    public TrainingOptions withBoosterType(TrainingOptionsBoosterTypeEnum boosterType) {
        this.boosterType = boosterType;
        return this;
    }
    
    /**
     * Whether or not p-value test should be computed for this model. Only available for linear and logistic regression models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("calculatePValues")
    public Boolean calculatePValues;
    public TrainingOptions withCalculatePValues(Boolean calculatePValues) {
        this.calculatePValues = calculatePValues;
        return this;
    }
    
    /**
     * If true, clean spikes and dips in the input time series.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("cleanSpikesAndDips")
    public Boolean cleanSpikesAndDips;
    public TrainingOptions withCleanSpikesAndDips(Boolean cleanSpikesAndDips) {
        this.cleanSpikesAndDips = cleanSpikesAndDips;
        return this;
    }
    
    /**
     * Enums for color space, used for processing images in Object Table. See more details at https://www.tensorflow.org/io/tutorials/colorspace.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colorSpace")
    public TrainingOptionsColorSpaceEnum colorSpace;
    public TrainingOptions withColorSpace(TrainingOptionsColorSpaceEnum colorSpace) {
        this.colorSpace = colorSpace;
        return this;
    }
    
    /**
     * Subsample ratio of columns for each level for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colsampleBylevel")
    public Double colsampleBylevel;
    public TrainingOptions withColsampleBylevel(Double colsampleBylevel) {
        this.colsampleBylevel = colsampleBylevel;
        return this;
    }
    
    /**
     * Subsample ratio of columns for each node(split) for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colsampleBynode")
    public Double colsampleBynode;
    public TrainingOptions withColsampleBynode(Double colsampleBynode) {
        this.colsampleBynode = colsampleBynode;
        return this;
    }
    
    /**
     * Subsample ratio of columns when constructing each tree for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("colsampleBytree")
    public Double colsampleBytree;
    public TrainingOptions withColsampleBytree(Double colsampleBytree) {
        this.colsampleBytree = colsampleBytree;
        return this;
    }
    
    /**
     * Type of normalization algorithm for boosted tree models using dart booster.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dartNormalizeType")
    public TrainingOptionsDartNormalizeTypeEnum dartNormalizeType;
    public TrainingOptions withDartNormalizeType(TrainingOptionsDartNormalizeTypeEnum dartNormalizeType) {
        this.dartNormalizeType = dartNormalizeType;
        return this;
    }
    
    /**
     * The data frequency of a time series.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dataFrequency")
    public TrainingOptionsDataFrequencyEnum dataFrequency;
    public TrainingOptions withDataFrequency(TrainingOptionsDataFrequencyEnum dataFrequency) {
        this.dataFrequency = dataFrequency;
        return this;
    }
    
    /**
     * The column to split data with. This column won't be used as a feature. 1. When data_split_method is CUSTOM, the corresponding column should be boolean. The rows with true value tag are eval data, and the false are training data. 2. When data_split_method is SEQ, the first DATA_SPLIT_EVAL_FRACTION rows (from smallest to largest) in the corresponding column are used as training data, and the rest are eval data. It respects the order in Orderable data types: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#data-type-properties
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dataSplitColumn")
    public String dataSplitColumn;
    public TrainingOptions withDataSplitColumn(String dataSplitColumn) {
        this.dataSplitColumn = dataSplitColumn;
        return this;
    }
    
    /**
     * The fraction of evaluation data over the whole input data. The rest of data will be used as training data. The format should be double. Accurate to two decimal places. Default value is 0.2.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dataSplitEvalFraction")
    public Double dataSplitEvalFraction;
    public TrainingOptions withDataSplitEvalFraction(Double dataSplitEvalFraction) {
        this.dataSplitEvalFraction = dataSplitEvalFraction;
        return this;
    }
    
    /**
     * The data split type for training and evaluation, e.g. RANDOM.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dataSplitMethod")
    public TrainingOptionsDataSplitMethodEnum dataSplitMethod;
    public TrainingOptions withDataSplitMethod(TrainingOptionsDataSplitMethodEnum dataSplitMethod) {
        this.dataSplitMethod = dataSplitMethod;
        return this;
    }
    
    /**
     * If true, perform decompose time series and save the results.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("decomposeTimeSeries")
    public Boolean decomposeTimeSeries;
    public TrainingOptions withDecomposeTimeSeries(Boolean decomposeTimeSeries) {
        this.decomposeTimeSeries = decomposeTimeSeries;
        return this;
    }
    
    /**
     * Distance type for clustering models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("distanceType")
    public TrainingOptionsDistanceTypeEnum distanceType;
    public TrainingOptions withDistanceType(TrainingOptionsDistanceTypeEnum distanceType) {
        this.distanceType = distanceType;
        return this;
    }
    
    /**
     * Dropout probability for dnn models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dropout")
    public Double dropout;
    public TrainingOptions withDropout(Double dropout) {
        this.dropout = dropout;
        return this;
    }
    
    /**
     * Whether to stop early when the loss doesn't improve significantly any more (compared to min_relative_progress). Used only for iterative training algorithms.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("earlyStop")
    public Boolean earlyStop;
    public TrainingOptions withEarlyStop(Boolean earlyStop) {
        this.earlyStop = earlyStop;
        return this;
    }
    
    /**
     * If true, enable global explanation during training.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("enableGlobalExplain")
    public Boolean enableGlobalExplain;
    public TrainingOptions withEnableGlobalExplain(Boolean enableGlobalExplain) {
        this.enableGlobalExplain = enableGlobalExplain;
        return this;
    }
    
    /**
     * Feedback type that specifies which algorithm to run for matrix factorization.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("feedbackType")
    public TrainingOptionsFeedbackTypeEnum feedbackType;
    public TrainingOptions withFeedbackType(TrainingOptionsFeedbackTypeEnum feedbackType) {
        this.feedbackType = feedbackType;
        return this;
    }
    
    /**
     * Hidden units for dnn models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hiddenUnits")
    public String[] hiddenUnits;
    public TrainingOptions withHiddenUnits(String[] hiddenUnits) {
        this.hiddenUnits = hiddenUnits;
        return this;
    }
    
    /**
     * The geographical region based on which the holidays are considered in time series modeling. If a valid value is specified, then holiday effects modeling is enabled.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("holidayRegion")
    public TrainingOptionsHolidayRegionEnum holidayRegion;
    public TrainingOptions withHolidayRegion(TrainingOptionsHolidayRegionEnum holidayRegion) {
        this.holidayRegion = holidayRegion;
        return this;
    }
    
    /**
     * The number of periods ahead that need to be forecasted.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("horizon")
    public String horizon;
    public TrainingOptions withHorizon(String horizon) {
        this.horizon = horizon;
        return this;
    }
    
    /**
     * The target evaluation metrics to optimize the hyperparameters for.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("hparamTuningObjectives")
    public TrainingOptionsHparamTuningObjectivesEnum[] hparamTuningObjectives;
    public TrainingOptions withHparamTuningObjectives(TrainingOptionsHparamTuningObjectivesEnum[] hparamTuningObjectives) {
        this.hparamTuningObjectives = hparamTuningObjectives;
        return this;
    }
    
    /**
     * Include drift when fitting an ARIMA model.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("includeDrift")
    public Boolean includeDrift;
    public TrainingOptions withIncludeDrift(Boolean includeDrift) {
        this.includeDrift = includeDrift;
        return this;
    }
    
    /**
     * Specifies the initial learning rate for the line search learn rate strategy.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("initialLearnRate")
    public Double initialLearnRate;
    public TrainingOptions withInitialLearnRate(Double initialLearnRate) {
        this.initialLearnRate = initialLearnRate;
        return this;
    }
    
    /**
     * Name of input label columns in training data.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("inputLabelColumns")
    public String[] inputLabelColumns;
    public TrainingOptions withInputLabelColumns(String[] inputLabelColumns) {
        this.inputLabelColumns = inputLabelColumns;
        return this;
    }
    
    /**
     * Number of integral steps for the integrated gradients explain method.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("integratedGradientsNumSteps")
    public String integratedGradientsNumSteps;
    public TrainingOptions withIntegratedGradientsNumSteps(String integratedGradientsNumSteps) {
        this.integratedGradientsNumSteps = integratedGradientsNumSteps;
        return this;
    }
    
    /**
     * Item column specified for matrix factorization models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("itemColumn")
    public String itemColumn;
    public TrainingOptions withItemColumn(String itemColumn) {
        this.itemColumn = itemColumn;
        return this;
    }
    
    /**
     * The column used to provide the initial centroids for kmeans algorithm when kmeans_initialization_method is CUSTOM.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kmeansInitializationColumn")
    public String kmeansInitializationColumn;
    public TrainingOptions withKmeansInitializationColumn(String kmeansInitializationColumn) {
        this.kmeansInitializationColumn = kmeansInitializationColumn;
        return this;
    }
    
    /**
     * The method used to initialize the centroids for kmeans algorithm.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("kmeansInitializationMethod")
    public TrainingOptionsKmeansInitializationMethodEnum kmeansInitializationMethod;
    public TrainingOptions withKmeansInitializationMethod(TrainingOptionsKmeansInitializationMethodEnum kmeansInitializationMethod) {
        this.kmeansInitializationMethod = kmeansInitializationMethod;
        return this;
    }
    
    /**
     * L1 regularization coefficient.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("l1Regularization")
    public Double l1Regularization;
    public TrainingOptions withL1Regularization(Double l1Regularization) {
        this.l1Regularization = l1Regularization;
        return this;
    }
    
    /**
     * L2 regularization coefficient.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("l2Regularization")
    public Double l2Regularization;
    public TrainingOptions withL2Regularization(Double l2Regularization) {
        this.l2Regularization = l2Regularization;
        return this;
    }
    
    /**
     * Weights associated with each label class, for rebalancing the training data. Only applicable for classification models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("labelClassWeights")
    public java.util.Map<String, Double> labelClassWeights;
    public TrainingOptions withLabelClassWeights(java.util.Map<String, Double> labelClassWeights) {
        this.labelClassWeights = labelClassWeights;
        return this;
    }
    
    /**
     * Learning rate in training. Used only for iterative training algorithms.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("learnRate")
    public Double learnRate;
    public TrainingOptions withLearnRate(Double learnRate) {
        this.learnRate = learnRate;
        return this;
    }
    
    /**
     * The strategy to determine learn rate for the current iteration.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("learnRateStrategy")
    public TrainingOptionsLearnRateStrategyEnum learnRateStrategy;
    public TrainingOptions withLearnRateStrategy(TrainingOptionsLearnRateStrategyEnum learnRateStrategy) {
        this.learnRateStrategy = learnRateStrategy;
        return this;
    }
    
    /**
     * Type of loss function used during training run.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("lossType")
    public TrainingOptionsLossTypeEnum lossType;
    public TrainingOptions withLossType(TrainingOptionsLossTypeEnum lossType) {
        this.lossType = lossType;
        return this;
    }
    
    /**
     * The maximum number of iterations in training. Used only for iterative training algorithms.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxIterations")
    public String maxIterations;
    public TrainingOptions withMaxIterations(String maxIterations) {
        this.maxIterations = maxIterations;
        return this;
    }
    
    /**
     * Maximum number of trials to run in parallel.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxParallelTrials")
    public String maxParallelTrials;
    public TrainingOptions withMaxParallelTrials(String maxParallelTrials) {
        this.maxParallelTrials = maxParallelTrials;
        return this;
    }
    
    /**
     * Get truncated length by last n points in time series. Use separately from time_series_length_fraction and min_time_series_length.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxTimeSeriesLength")
    public String maxTimeSeriesLength;
    public TrainingOptions withMaxTimeSeriesLength(String maxTimeSeriesLength) {
        this.maxTimeSeriesLength = maxTimeSeriesLength;
        return this;
    }
    
    /**
     * Maximum depth of a tree for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxTreeDepth")
    public String maxTreeDepth;
    public TrainingOptions withMaxTreeDepth(String maxTreeDepth) {
        this.maxTreeDepth = maxTreeDepth;
        return this;
    }
    
    /**
     * When early_stop is true, stops training when accuracy improvement is less than 'min_relative_progress'. Used only for iterative training algorithms.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("minRelativeProgress")
    public Double minRelativeProgress;
    public TrainingOptions withMinRelativeProgress(Double minRelativeProgress) {
        this.minRelativeProgress = minRelativeProgress;
        return this;
    }
    
    /**
     * Minimum split loss for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("minSplitLoss")
    public Double minSplitLoss;
    public TrainingOptions withMinSplitLoss(Double minSplitLoss) {
        this.minSplitLoss = minSplitLoss;
        return this;
    }
    
    /**
     * Set fast trend ARIMA_PLUS model minimum training length. Use in pair with time_series_length_fraction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("minTimeSeriesLength")
    public String minTimeSeriesLength;
    public TrainingOptions withMinTimeSeriesLength(String minTimeSeriesLength) {
        this.minTimeSeriesLength = minTimeSeriesLength;
        return this;
    }
    
    /**
     * Minimum sum of instance weight needed in a child for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("minTreeChildWeight")
    public String minTreeChildWeight;
    public TrainingOptions withMinTreeChildWeight(String minTreeChildWeight) {
        this.minTreeChildWeight = minTreeChildWeight;
        return this;
    }
    
    /**
     * Google Cloud Storage URI from which the model was imported. Only applicable for imported models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("modelUri")
    public String modelUri;
    public TrainingOptions withModelUri(String modelUri) {
        this.modelUri = modelUri;
        return this;
    }
    
    /**
     * Arima order, can be used for both non-seasonal and seasonal parts.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nonSeasonalOrder")
    public ArimaOrder nonSeasonalOrder;
    public TrainingOptions withNonSeasonalOrder(ArimaOrder nonSeasonalOrder) {
        this.nonSeasonalOrder = nonSeasonalOrder;
        return this;
    }
    
    /**
     * Number of clusters for clustering models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("numClusters")
    public String numClusters;
    public TrainingOptions withNumClusters(String numClusters) {
        this.numClusters = numClusters;
        return this;
    }
    
    /**
     * Num factors specified for matrix factorization models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("numFactors")
    public String numFactors;
    public TrainingOptions withNumFactors(String numFactors) {
        this.numFactors = numFactors;
        return this;
    }
    
    /**
     * Number of parallel trees constructed during each iteration for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("numParallelTree")
    public String numParallelTree;
    public TrainingOptions withNumParallelTree(String numParallelTree) {
        this.numParallelTree = numParallelTree;
        return this;
    }
    
    /**
     * Number of trials to run this hyperparameter tuning job.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("numTrials")
    public String numTrials;
    public TrainingOptions withNumTrials(String numTrials) {
        this.numTrials = numTrials;
        return this;
    }
    
    /**
     * Optimization strategy for training linear regression models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimizationStrategy")
    public TrainingOptionsOptimizationStrategyEnum optimizationStrategy;
    public TrainingOptions withOptimizationStrategy(TrainingOptionsOptimizationStrategyEnum optimizationStrategy) {
        this.optimizationStrategy = optimizationStrategy;
        return this;
    }
    
    /**
     * Whether to preserve the input structs in output feature names. Suppose there is a struct A with field b. When false (default), the output feature name is A_b. When true, the output feature name is A.b.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("preserveInputStructs")
    public Boolean preserveInputStructs;
    public TrainingOptions withPreserveInputStructs(Boolean preserveInputStructs) {
        this.preserveInputStructs = preserveInputStructs;
        return this;
    }
    
    /**
     * Number of paths for the sampled Shapley explain method.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sampledShapleyNumPaths")
    public String sampledShapleyNumPaths;
    public TrainingOptions withSampledShapleyNumPaths(String sampledShapleyNumPaths) {
        this.sampledShapleyNumPaths = sampledShapleyNumPaths;
        return this;
    }
    
    /**
     * Subsample fraction of the training data to grow tree to prevent overfitting for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subsample")
    public Double subsample;
    public TrainingOptions withSubsample(Double subsample) {
        this.subsample = subsample;
        return this;
    }
    
    /**
     * Column to be designated as time series data for ARIMA model.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeSeriesDataColumn")
    public String timeSeriesDataColumn;
    public TrainingOptions withTimeSeriesDataColumn(String timeSeriesDataColumn) {
        this.timeSeriesDataColumn = timeSeriesDataColumn;
        return this;
    }
    
    /**
     * The time series id column that was used during ARIMA model training.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeSeriesIdColumn")
    public String timeSeriesIdColumn;
    public TrainingOptions withTimeSeriesIdColumn(String timeSeriesIdColumn) {
        this.timeSeriesIdColumn = timeSeriesIdColumn;
        return this;
    }
    
    /**
     * The time series id columns that were used during ARIMA model training.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeSeriesIdColumns")
    public String[] timeSeriesIdColumns;
    public TrainingOptions withTimeSeriesIdColumns(String[] timeSeriesIdColumns) {
        this.timeSeriesIdColumns = timeSeriesIdColumns;
        return this;
    }
    
    /**
     * Get truncated length by fraction in time series.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeSeriesLengthFraction")
    public Double timeSeriesLengthFraction;
    public TrainingOptions withTimeSeriesLengthFraction(Double timeSeriesLengthFraction) {
        this.timeSeriesLengthFraction = timeSeriesLengthFraction;
        return this;
    }
    
    /**
     * Column to be designated as time series timestamp for ARIMA model.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timeSeriesTimestampColumn")
    public String timeSeriesTimestampColumn;
    public TrainingOptions withTimeSeriesTimestampColumn(String timeSeriesTimestampColumn) {
        this.timeSeriesTimestampColumn = timeSeriesTimestampColumn;
        return this;
    }
    
    /**
     * Tree construction algorithm for boosted tree models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("treeMethod")
    public TrainingOptionsTreeMethodEnum treeMethod;
    public TrainingOptions withTreeMethod(TrainingOptionsTreeMethodEnum treeMethod) {
        this.treeMethod = treeMethod;
        return this;
    }
    
    /**
     * The smoothing window size for the trend component of the time series.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("trendSmoothingWindowSize")
    public String trendSmoothingWindowSize;
    public TrainingOptions withTrendSmoothingWindowSize(String trendSmoothingWindowSize) {
        this.trendSmoothingWindowSize = trendSmoothingWindowSize;
        return this;
    }
    
    /**
     * User column specified for matrix factorization models.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userColumn")
    public String userColumn;
    public TrainingOptions withUserColumn(String userColumn) {
        this.userColumn = userColumn;
        return this;
    }
    
    /**
     * Hyperparameter for matrix factoration when implicit feedback type is specified.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("walsAlpha")
    public Double walsAlpha;
    public TrainingOptions withWalsAlpha(Double walsAlpha) {
        this.walsAlpha = walsAlpha;
        return this;
    }
    
    /**
     * Whether to train a model from the last checkpoint.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("warmStart")
    public Boolean warmStart;
    public TrainingOptions withWarmStart(Boolean warmStart) {
        this.warmStart = warmStart;
        return this;
    }
    
}
