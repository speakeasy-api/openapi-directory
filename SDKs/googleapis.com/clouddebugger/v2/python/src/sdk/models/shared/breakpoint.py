"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import sourcelocation as shared_sourcelocation
from ..shared import stackframe as shared_stackframe
from ..shared import statusmessage as shared_statusmessage
from ..shared import variable as shared_variable
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class BreakpointActionEnum(str, Enum):
    r"""Action that the agent should perform when the code at the breakpoint location is hit."""
    CAPTURE = 'CAPTURE'
    LOG = 'LOG'

class BreakpointLogLevelEnum(str, Enum):
    r"""Indicates the severity of the log. Only relevant when action is `LOG`."""
    INFO = 'INFO'
    WARNING = 'WARNING'
    ERROR = 'ERROR'

class BreakpointStateEnum(str, Enum):
    r"""The current state of the breakpoint."""
    STATE_UNSPECIFIED = 'STATE_UNSPECIFIED'
    STATE_CANARY_PENDING_AGENTS = 'STATE_CANARY_PENDING_AGENTS'
    STATE_CANARY_ACTIVE = 'STATE_CANARY_ACTIVE'
    STATE_ROLLING_TO_ALL = 'STATE_ROLLING_TO_ALL'
    STATE_IS_FINAL = 'STATE_IS_FINAL'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Breakpoint:
    r"""------------------------------------------------------------------------------ ## Breakpoint (the resource) Represents the breakpoint specification, status and results."""
    
    action: Optional[BreakpointActionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('action'), 'exclude': lambda f: f is None }})
    r"""Action that the agent should perform when the code at the breakpoint location is hit."""  
    canary_expire_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('canaryExpireTime'), 'exclude': lambda f: f is None }})
    r"""The deadline for the breakpoint to stay in CANARY_ACTIVE state. The value is meaningless when the breakpoint is not in CANARY_ACTIVE state."""  
    condition: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('condition'), 'exclude': lambda f: f is None }})
    r"""Condition that triggers the breakpoint. The condition is a compound boolean expression composed using expressions in a programming language at the source location."""  
    create_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createTime'), 'exclude': lambda f: f is None }})
    r"""Time this breakpoint was created by the server in seconds resolution."""  
    evaluated_expressions: Optional[list[shared_variable.Variable]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('evaluatedExpressions'), 'exclude': lambda f: f is None }})
    r"""Values of evaluated expressions at breakpoint time. The evaluated expressions appear in exactly the same order they are listed in the `expressions` field. The `name` field holds the original expression text, the `value` or `members` field holds the result of the evaluated expression. If the expression cannot be evaluated, the `status` inside the `Variable` will indicate an error and contain the error text."""  
    expressions: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expressions'), 'exclude': lambda f: f is None }})
    r"""List of read-only expressions to evaluate at the breakpoint location. The expressions are composed using expressions in the programming language at the source location. If the breakpoint action is `LOG`, the evaluated expressions are included in log statements."""  
    final_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('finalTime'), 'exclude': lambda f: f is None }})
    r"""Time this breakpoint was finalized as seen by the server in seconds resolution."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Breakpoint identifier, unique in the scope of the debuggee."""  
    is_final_state: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isFinalState'), 'exclude': lambda f: f is None }})
    r"""When true, indicates that this is a final result and the breakpoint state will not change from here on."""  
    labels: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""A set of custom breakpoint properties, populated by the agent, to be displayed to the user."""  
    location: Optional[shared_sourcelocation.SourceLocation] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('location'), 'exclude': lambda f: f is None }})
    r"""Represents a location in the source code."""  
    log_level: Optional[BreakpointLogLevelEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logLevel'), 'exclude': lambda f: f is None }})
    r"""Indicates the severity of the log. Only relevant when action is `LOG`."""  
    log_message_format: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logMessageFormat'), 'exclude': lambda f: f is None }})
    r"""Only relevant when action is `LOG`. Defines the message to log when the breakpoint hits. The message may include parameter placeholders `$0`, `$1`, etc. These placeholders are replaced with the evaluated value of the appropriate expression. Expressions not referenced in `log_message_format` are not logged. Example: `Message received, id = $0, count = $1` with `expressions` = `[ message.id, message.count ]`."""  
    stack_frames: Optional[list[shared_stackframe.StackFrame]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('stackFrames'), 'exclude': lambda f: f is None }})
    r"""The stack at breakpoint time, where stack_frames[0] represents the most recently entered function."""  
    state: Optional[BreakpointStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('state'), 'exclude': lambda f: f is None }})
    r"""The current state of the breakpoint."""  
    status: Optional[shared_statusmessage.StatusMessage] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""Represents a contextual status message. The message can indicate an error or informational status, and refer to specific parts of the containing object. For example, the `Breakpoint.status` field can indicate an error referring to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`."""  
    user_email: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userEmail'), 'exclude': lambda f: f is None }})
    r"""E-mail address of the user that created this breakpoint"""  
    variable_table: Optional[list[shared_variable.Variable]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('variableTable'), 'exclude': lambda f: f is None }})
    r"""The `variable_table` exists to aid with computation, memory and network traffic optimization. It enables storing a variable once and reference it from multiple variables, including variables stored in the `variable_table` itself. For example, the same `this` object, which may appear at many levels of the stack, can have all of its data stored once in this table. The stack frame variables then would hold only a reference to it. The variable `var_table_index` field is an index into this repeated field. The stored objects are nameless and get their name from the referencing variable. The effective variable is a merge of the referencing variable and the referenced variable."""  
    