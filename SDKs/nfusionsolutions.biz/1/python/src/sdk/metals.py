"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Metals:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def metals_benchmark_history_get(self, request: operations.MetalsBenchmarkHistoryGETRequest) -> operations.MetalsBenchmarkHistoryGETResponse:
        r"""Get historical benchmark prices for requested metals
        Historical OHLC data for the specified period and interval size
        
        The combination of the interval parameter and start and end dates can result in results
        being truncated to conform to result size limits. See comments on interval parameter for details on valid interval values.
        
        The historicalfx flag is used to determine whether to apply today's fx rates to a historical period, or to apply the historical rates from that same time frame.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/benchmark/history'
        
        query_params = utils.get_query_params(operations.MetalsBenchmarkHistoryGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsBenchmarkHistoryGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IntervalCollectionResponse]])
                res.interval_collection_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_benchmark_summary_get(self, request: operations.MetalsBenchmarkSummaryGETRequest) -> operations.MetalsBenchmarkSummaryGETResponse:
        r"""Get latest Benchmark prices for requested metals
        Benchmark price information
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/benchmark/summary'
        
        query_params = utils.get_query_params(operations.MetalsBenchmarkSummaryGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsBenchmarkSummaryGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.SummaryResponse]])
                res.summary_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_benchmark_supported_metals_get(self, request: operations.MetalsBenchmarkSupportedMetalsGETRequest) -> operations.MetalsBenchmarkSupportedMetalsGETResponse:
        r"""Get list of symbols supported by the benchmark endpoints"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/benchmark/supported'
        
        query_params = utils.get_query_params(operations.MetalsBenchmarkSupportedMetalsGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsBenchmarkSupportedMetalsGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.metals_benchmark_supported_metals_get_200_application_json_strings = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_annual_historical_performance_get(self, request: operations.MetalsSpotAnnualHistoricalPerformanceGETRequest) -> operations.MetalsSpotAnnualHistoricalPerformanceGETResponse:
        r"""Get Historical Annual Performance for requested metals
        Annual Historical Performance information
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/performance/annual'
        
        query_params = utils.get_query_params(operations.MetalsSpotAnnualHistoricalPerformanceGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotAnnualHistoricalPerformanceGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IntervalCollectionResponse]])
                res.interval_collection_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_historical_performance_get(self, request: operations.MetalsSpotHistoricalPerformanceGETRequest) -> operations.MetalsSpotHistoricalPerformanceGETResponse:
        r"""Get Historical Performance for requested metals
        Historical Performance information
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/performance'
        
        query_params = utils.get_query_params(operations.MetalsSpotHistoricalPerformanceGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotHistoricalPerformanceGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IntervalCollectionResponse]])
                res.interval_collection_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_history_get(self, request: operations.MetalsSpotHistoryGETRequest) -> operations.MetalsSpotHistoryGETResponse:
        r"""Get historical Spot prices for requested metals
        Historical OHLC data for the specified period and interval size
        
        The combination of the interval parameter and start and end dates can result in results
        being truncated to conform to result size limits. See comments on interval parameter for details on valid interval values.
        
        The historicalfx flag is used to determine whether to apply today's fx rates to a historical period, or to apply the historical rates from that same time frame.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/history'
        
        query_params = utils.get_query_params(operations.MetalsSpotHistoryGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotHistoryGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IntervalCollectionResponse]])
                res.interval_collection_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_ratio_history_get(self, request: operations.MetalsSpotRatioHistoryGETRequest) -> operations.MetalsSpotRatioHistoryGETResponse:
        r"""Get historical Spot Ratio prices for requested metals
        Historical data for the specified period and interval size
        
        The combination of the interval parameter and start and end dates can result in results
        being truncated to conform to result size limits. See comments on interval parameter for details on valid interval values.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/ratio/history'
        
        query_params = utils.get_query_params(operations.MetalsSpotRatioHistoryGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotRatioHistoryGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.IntervalCollectionResponse]])
                res.interval_collection_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_ratio_summary_get(self, request: operations.MetalsSpotRatioSummaryGETRequest) -> operations.MetalsSpotRatioSummaryGETResponse:
        r"""Get latest Spot Summary for requested metal ratios
        Ratios between prices of two metals
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/ratio/summary'
        
        query_params = utils.get_query_params(operations.MetalsSpotRatioSummaryGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotRatioSummaryGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.SummaryResponse]])
                res.summary_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_summary_get(self, request: operations.MetalsSpotSummaryGETRequest) -> operations.MetalsSpotSummaryGETResponse:
        r"""Get latest Spot Summary for requested metals
        Current and daily summary information combined into a single quote
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/summary'
        
        query_params = utils.get_query_params(operations.MetalsSpotSummaryGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotSummaryGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.SummaryResponse]])
                res.summary_responses = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_spot_supported_metals_get(self, request: operations.MetalsSpotSupportedMetalsGETRequest) -> operations.MetalsSpotSupportedMetalsGETResponse:
        r"""Get list of symbols supported by the spot endpoints"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/spot/supported'
        
        query_params = utils.get_query_params(operations.MetalsSpotSupportedMetalsGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSpotSupportedMetalsGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.metals_spot_supported_metals_get_200_application_json_strings = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    def metals_supported_currencies_metals_get(self, request: operations.MetalsSupportedCurrenciesMetalsGETRequest) -> operations.MetalsSupportedCurrenciesMetalsGETResponse:
        r"""Get list of currencies supported by metals endpoints for currency conversion"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/Metals/supported/currency'
        
        query_params = utils.get_query_params(operations.MetalsSupportedCurrenciesMetalsGETRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MetalsSupportedCurrenciesMetalsGETResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.metals_supported_currencies_metals_get_200_application_json_strings = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
        elif http_res.status_code in [400, 401]:
            pass

        return res

    