<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Daemon 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Add a new timer script to be executed at specified interval (in msec) with the specified argument.
     * 
     * Add a new timer script to be executed at specified interval (in msec) with the specified argument.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AddDaemonTimerScriptRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddDaemonTimerScriptResponse
     */
	public function addDaemonTimerScript(
        \OpenAPI\OpenAPI\Models\Operations\AddDaemonTimerScriptRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddDaemonTimerScriptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/timer/script/add/{script}/{interval}/{arg}', \OpenAPI\OpenAPI\Models\Operations\AddDaemonTimerScriptRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddDaemonTimerScriptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->addDaemonTimerScript200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Load the lab configuration file file.
     * 
     * Load agents in cfgFile from firstAgentNum to lastAgentNum on startAgentNum of current configuration
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CfgLoadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CfgLoadResponse
     */
	public function cfgLoad(
        \OpenAPI\OpenAPI\Models\Operations\CfgLoadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CfgLoadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/load/{cfgFile}/{firstAgentNum}/{lastAgentNum}/{startAgentNum}', \OpenAPI\OpenAPI\Models\Operations\CfgLoadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CfgLoadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cfgLoad200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Clear the lab configuration.
     * 
     * Clear the lab configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CfgNewRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CfgNewResponse
     */
	public function cfgNew(
        \OpenAPI\OpenAPI\Models\Operations\CfgNewRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CfgNewResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/clear/{firstAgentNum}/{lastAgentNum}', \OpenAPI\OpenAPI\Models\Operations\CfgNewRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CfgNewResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cfgNew200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Save the lab configuration.
     * 
     * Save the lab configuration.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\CfgSaveResponse
     */
	public function cfgSave(
    ): \OpenAPI\OpenAPI\Models\Operations\CfgSaveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/save');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CfgSaveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cfgSave200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Save the lab configuration in file.
     * 
     * Save the lab configuration in file.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CfgSaveasRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CfgSaveasResponse
     */
	public function cfgSaveas(
        \OpenAPI\OpenAPI\Models\Operations\CfgSaveasRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CfgSaveasResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/saveas/{cfgFile}/{firstAgentNum}/{lastAgentNum}', \OpenAPI\OpenAPI\Models\Operations\CfgSaveasRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CfgSaveasResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->cfgSaveas200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove a timer script from the execution list.
     * 
     * The first scheduled script that matches the script name, and optionally the interval and argument will be deleted.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DelDaemonTimerScriptRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DelDaemonTimerScriptResponse
     */
	public function delDaemonTimerScript(
        \OpenAPI\OpenAPI\Models\Operations\DelDaemonTimerScriptRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DelDaemonTimerScriptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/timer/script/delete/{script}/{interval}/{arg}', \OpenAPI\OpenAPI\Models\Operations\DelDaemonTimerScriptRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DelDaemonTimerScriptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->delDaemonTimerScript200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * The list of {agentnum {statistics}} for agents that are currently active and whose statistics have changed since the last invocation of this command.
     * 
     * This list is guaranteed to be sorted into increasing order.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetActiveDataListResponse
     */
	public function getActiveDataList(
    ): \OpenAPI\OpenAPI\Models\Operations\GetActiveDataListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/active_data_list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetActiveDataListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getActiveDataList200ApplicationJSONInt32Integers = $serializer->deserialize((string)$httpResponse->getBody(), 'array<int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The list of {agentnum} that are currently active (running or paused).
     * 
     * This list is guaranteed to be sorted into increasing order.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetActiveListResponse
     */
	public function getActiveList(
    ): \OpenAPI\OpenAPI\Models\Operations\GetActiveListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/active_list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetActiveListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getActiveList200ApplicationJSONInt32Integers = $serializer->deserialize((string)$httpResponse->getBody(), 'array<int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * This predicate indicates if the currently loaded agent configuration file has changed.
     * 
     * Whether the loaded agent configuration file has changed since the last time this predicate was queried. This allows for a client to detect agent configuration changes and to synchronize those changes from the MIMIC daemon.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCfgFileChangedResponse
     */
	public function getCfgFileChanged(
    ): \OpenAPI\OpenAPI\Models\Operations\GetCfgFileChangedResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/cfgfile_changed');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCfgFileChangedResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getCfgFileChanged200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The currently loaded lab configuration file for the particular user.
     * 
     * In the case of multi-user access this command returns a different configuration file loaded for each user.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCfgfileResponse
     */
	public function getCfgfile(
    ): \OpenAPI\OpenAPI\Models\Operations\GetCfgfileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/cfgfile');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCfgfileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getCfgfile200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The list of {agentnum} for which a configurable parameter changed.
     * 
     * This list contains at most 5000 agent(s), and is guaranteed to be sorted into increasing order.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetChangedConfigListResponse
     */
	public function getChangedConfigList(
    ): \OpenAPI\OpenAPI\Models\Operations\GetChangedConfigListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/changed_config_list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetChangedConfigListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getChangedConfigList200ApplicationJSONInt32Integers = $serializer->deserialize((string)$httpResponse->getBody(), 'array<int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The list of {agentnum state} for which the state changed.
     * 
     * This list contains at most 5000 agent(s), and is guaranteed to be sorted into increasing order.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetChangedStateListResponse
     */
	public function getChangedStateList(
    ): \OpenAPI\OpenAPI\Models\Operations\GetChangedStateListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/changed_state_list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetChangedStateListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->agentStates = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\AgentState>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The number of clients currently connected to the daemon.
     * 
     * The number of clients currently connected to the daemon.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetClientsResponse
     */
	public function getClients(
    ): \OpenAPI\OpenAPI\Models\Operations\GetClientsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/clients');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetClientsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getClients200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The list of {agentnum} that are currently configured.
     * 
     * This list is guaranteed to be sorted into increasing order.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetConfiguredListResponse
     */
	public function getConfiguredList(
    ): \OpenAPI\OpenAPI\Models\Operations\GetConfiguredListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/configured_list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetConfiguredListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getConfiguredList200ApplicationJSONInt32Integers = $serializer->deserialize((string)$httpResponse->getBody(), 'array<int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The set of protocols supported by the Simulator.
     * 
     * The set of protocols supported by the Simulator.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDaemonProtocolsResponse
     */
	public function getDaemonProtocols(
    ): \OpenAPI\OpenAPI\Models\Operations\GetDaemonProtocolsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/protocols');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDaemonProtocolsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getDaemonProtocols200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The set of network interfaces that can be used for simulations.
     * 
     * The set of network interfaces that can be used for simulations.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetInterfacesResponse
     */
	public function getInterfaces(
    ): \OpenAPI\OpenAPI\Models\Operations\GetInterfacesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/interfaces');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetInterfacesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getInterfaces200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The last configured agent instance.
     * 
     * The last configured agent instance.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLastResponse
     */
	public function getLast(
    ): \OpenAPI\OpenAPI\Models\Operations\GetLastResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/last');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLastResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getLast200ApplicationJSONInt32Integer = $serializer->deserialize((string)$httpResponse->getBody(), 'int', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The current log file for the Simulator.
     * 
     * The current log file for the Simulator.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLogResponse
     */
	public function getLog(
    ): \OpenAPI\OpenAPI\Models\Operations\GetLogResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/log');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLogResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getLog200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The maximum number of agent instances.
     * 
     * The maximum number of agent instances.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMaxResponse
     */
	public function getMax(
    ): \OpenAPI\OpenAPI\Models\Operations\GetMaxResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/max');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMaxResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getMax200ApplicationJSONInt32Integer = $serializer->deserialize((string)$httpResponse->getBody(), 'int', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The network address of the host where the MIMIC simulator is running.
     * 
     * The network address of the host where the MIMIC simulator is running.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetaddrResponse
     */
	public function getNetaddr(
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetaddrResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/netaddr');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetaddrResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetaddr200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The default network device to be used for agent addresses.
     * 
     * The default network device to be used for agent addresses if the interface is not explicitly specified for an agent.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetdevResponse
     */
	public function getNetdev(
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetdevResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/netdev');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetdevResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetdev200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The product number that is licensed.
     * 
     * The product number that is licensed.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetProductResponse
     */
	public function getProduct(
    ): \OpenAPI\OpenAPI\Models\Operations\GetProductResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/product');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetProductResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getProduct200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The return mode.
     * 
     * The OpenAPI daemon operates in two modes, nocatch, where error returns from MIMIC operations return error; or catch, where the TCL catch semantics are used (these are similar to C++ exceptions)
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetReturnResponse
     */
	public function getReturn(
    ): \OpenAPI\OpenAPI\Models\Operations\GetReturnResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/return');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetReturnResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getReturn200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * The version of the MIMIC command interface.
     * 
     * The version of the MIMIC command interface.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetVersionResponse
     */
	public function getVersion(
    ): \OpenAPI\OpenAPI\Models\Operations\GetVersionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/get/version');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetVersionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->getVersion200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * List the timer scripts currently running along with the their intervals.
     * 
     * The command mimic timer script list lists global timer scripts, the command /mimic/timer/script/{agentNum}/list is the per-agent equivalent NOTE Global timer scripts run globally but within them you can address individual agents using {agentNum}. To schedule timerscripts for an individual agent, use /mimic/timer/script/{agentNum}.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\ListDaemonTimerScriptsResponse
     */
	public function listDaemonTimerScripts(
    ): \OpenAPI\OpenAPI\Models\Operations\ListDaemonTimerScriptsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/timer/script/list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListDaemonTimerScriptsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->timerScripts = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\TimerScript>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Get multiple sets of information about MIMIC, where infoArray is one of the parameters defined in the mimic get command.
     * 
     * Get multiple sets of information about MIMIC, where infoArray is one of the parameters defined in the mimic get command.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MgetInfoRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MgetInfoResponse
     */
	public function mgetInfo(
        \OpenAPI\OpenAPI\Models\Operations\MgetInfoRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MgetInfoResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/mget/{infoArray}', \OpenAPI\OpenAPI\Models\Operations\MgetInfoRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MgetInfoResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mgetInfo200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * The current log file for the Simulator.
     * 
     * The current log file for the Simulator.
     * 
     * @param string $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetLogResponse
     */
	public function setLog(
        string $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetLogResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/set/log');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "string");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetLogResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->setLog200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * The network address of the host where the MIMIC simulator is running.
     * 
     * The network address of the host where the MIMIC simulator is running.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\SetNetdevResponse
     */
	public function setNetdev(
    ): \OpenAPI\OpenAPI\Models\Operations\SetNetdevResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/set/netdev');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetNetdevResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->setNetdev200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Start MIMIC.
     * 
     * Start MIMIC.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\StartAllAgentsResponse
     */
	public function startAllAgents(
    ): \OpenAPI\OpenAPI\Models\Operations\StartAllAgentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/start');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StartAllAgentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->startAllAgents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Stop MIMIC.
     * 
     * Stop MIMIC.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\StopAllAgentsResponse
     */
	public function stopAllAgents(
    ): \OpenAPI\OpenAPI\Models\Operations\StopAllAgentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/stop');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StopAllAgentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->stopAllAgents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * This command can be used as a predicate to ascertain the existence of a given variable.
     * 
     * It returns "1" if the variable exists, else "0".
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StoreExistsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreExistsResponse
     */
	public function storeExists(
        \OpenAPI\OpenAPI\Models\Operations\StoreExistsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StoreExistsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/exists/{var}', \OpenAPI\OpenAPI\Models\Operations\StoreExistsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreExistsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->storeExists200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Fetches the value associated with a variable.
     * 
     * The value will be returned as a string (like all Tcl values).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StoreGetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreGetResponse
     */
	public function storeGet(
        \OpenAPI\OpenAPI\Models\Operations\StoreGetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StoreGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/get/{var}', \OpenAPI\OpenAPI\Models\Operations\StoreGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->storeGet200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * This command will return the list of variables in the said scope.
     * 
     * The list will be a Tcl format list with curly braces "{}" around each list element. These elements in turn are space separated.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreListResponse
     */
	public function storeList(
    ): \OpenAPI\OpenAPI\Models\Operations\StoreListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/list');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->storeList200ApplicationJSONStrings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * These commands treat the variable as a list, and allow to replace an entry in the list at the specified index with the specified value. The variable has to already exist.
     * 
     * These commands treat the variable as a list, and allow to replace an entry in the list at the specified index with the specified value. The variable has to already exist.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StoreLreplaceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreLreplaceResponse
     */
	public function storeLreplace(
        \OpenAPI\OpenAPI\Models\Operations\StoreLreplaceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StoreLreplaceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/lreplace/{var}/{index}', \OpenAPI\OpenAPI\Models\Operations\StoreLreplaceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "string");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreLreplaceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->storeLreplace200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * This command can be used as a predicate to ascertain the persistence of a given variable.
     * 
     * It returns "1" if the variable is persistent, else "0".
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StorePersistsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StorePersistsResponse
     */
	public function storePersists(
        \OpenAPI\OpenAPI\Models\Operations\StorePersistsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StorePersistsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/persists/{var}', \OpenAPI\OpenAPI\Models\Operations\StorePersistsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StorePersistsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->storePersists200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * This operation flushes all global objects which need to be made persistent to disk.
     * 
     * The MIMIC daemon caches persistent objects and their changes, and writes them to disk at program termination. If it were to crash, these changes would be lost. This operation allows to checkpoint the cache, ie. write changes to persistent objects to disk. To save the lab configuration with per-agent persistent information the mimic save operation needs to be used.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreSaveResponse
     */
	public function storeSave(
    ): \OpenAPI\OpenAPI\Models\Operations\StoreSaveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/set/persistent');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreSaveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->storeSave200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set the variable store for the global storage
     * 
     * Persist 1 means persistent , 0 means non-persistent
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StoreSetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreSetResponse
     */
	public function storeSet(
        \OpenAPI\OpenAPI\Models\Operations\StoreSetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StoreSetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/set/{var}/{persist}', \OpenAPI\OpenAPI\Models\Operations\StoreSetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "string");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreSetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->storeSet200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Deletes a variable which is currently defined.
     * 
     * This will cleanup persistent variables if needed
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\StoreUnsetRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\StoreUnsetResponse
     */
	public function storeUnset(
        \OpenAPI\OpenAPI\Models\Operations\StoreUnsetRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\StoreUnsetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/store/unset/{var}', \OpenAPI\OpenAPI\Models\Operations\StoreUnsetRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\StoreUnsetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->storeUnset200ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400) {
        }

        return $response;
    }
	
    /**
     * Terminate the MIMIC daemon.
     * 
     * Terminate the MIMIC daemon.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\TerminateResponse
     */
	public function terminate(
    ): \OpenAPI\OpenAPI\Models\Operations\TerminateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mimic/terminate');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TerminateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->terminate200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, int>', 'json');
            }
        }

        return $response;
    }
}