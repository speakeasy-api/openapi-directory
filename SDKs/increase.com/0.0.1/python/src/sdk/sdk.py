"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

SERVERS = [
    "https://api.increase.com",
    "https://sandbox.increase.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 security: shared.Security = None,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param security: The security details required for authentication
        :type security: shared.Security
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = utils.configure_security_client(self._client, security)
        

        
    
    
    def action_a_real_time_decision(self, request: operations.ActionARealTimeDecisionRequest) -> operations.ActionARealTimeDecisionResponse:
        r"""Action a Real-Time Decision"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ActionARealTimeDecisionRequest, base_url, '/real_time_decisions/{real_time_decision_id}/action', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "action_a_real_time_decision_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ActionARealTimeDecisionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RealTimeDecision])
                res.real_time_decision = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def approve_a_check_transfer(self, request: operations.ApproveACheckTransferRequest) -> operations.ApproveACheckTransferResponse:
        r"""Approve a Check Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ApproveACheckTransferRequest, base_url, '/check_transfers/{check_transfer_id}/approve', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ApproveACheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def approve_a_wire_transfer(self, request: operations.ApproveAWireTransferRequest) -> operations.ApproveAWireTransferResponse:
        r"""Approve a Wire Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ApproveAWireTransferRequest, base_url, '/wire_transfers/{wire_transfer_id}/approve', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ApproveAWireTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransfer])
                res.wire_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def approve_an_account_transfer(self, request: operations.ApproveAnAccountTransferRequest) -> operations.ApproveAnAccountTransferResponse:
        r"""Approve an Account Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ApproveAnAccountTransferRequest, base_url, '/account_transfers/{account_transfer_id}/approve', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ApproveAnAccountTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountTransfer])
                res.account_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def approve_an_ach_transfer(self, request: operations.ApproveAnAchTransferRequest) -> operations.ApproveAnAchTransferResponse:
        r"""Approve an ACH Transfer
        Approves an ACH Transfer in a pending_approval state.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ApproveAnAchTransferRequest, base_url, '/ach_transfers/{ach_transfer_id}/approve', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ApproveAnAchTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransfer])
                res.ach_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def cancel_a_pending_ach_transfer(self, request: operations.CancelAPendingAchTransferRequest) -> operations.CancelAPendingAchTransferResponse:
        r"""Cancel a pending ACH Transfer
        Cancels an ACH Transfer in a pending_approval state.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelAPendingAchTransferRequest, base_url, '/ach_transfers/{ach_transfer_id}/cancel', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelAPendingAchTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransfer])
                res.ach_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def cancel_a_pending_check_transfer(self, request: operations.CancelAPendingCheckTransferRequest) -> operations.CancelAPendingCheckTransferResponse:
        r"""Cancel a pending Check Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelAPendingCheckTransferRequest, base_url, '/check_transfers/{check_transfer_id}/cancel', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelAPendingCheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def cancel_a_pending_wire_transfer(self, request: operations.CancelAPendingWireTransferRequest) -> operations.CancelAPendingWireTransferResponse:
        r"""Cancel a pending Wire Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelAPendingWireTransferRequest, base_url, '/wire_transfers/{wire_transfer_id}/cancel', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelAPendingWireTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransfer])
                res.wire_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def cancel_an_account_transfer(self, request: operations.CancelAnAccountTransferRequest) -> operations.CancelAnAccountTransferResponse:
        r"""Cancel an Account Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelAnAccountTransferRequest, base_url, '/account_transfers/{account_transfer_id}/cancel', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelAnAccountTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountTransfer])
                res.account_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def close_an_account(self, request: operations.CloseAnAccountRequest) -> operations.CloseAnAccountResponse:
        r"""Close an Account"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CloseAnAccountRequest, base_url, '/accounts/{account_id}/close', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CloseAnAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def complete_a_sandbox_account_transfer(self, request: operations.CompleteASandboxAccountTransferRequest) -> operations.CompleteASandboxAccountTransferResponse:
        r"""Complete a Sandbox Account Transfer
        If your account is configured to require approval for each transfer, this endpoint simulates the approval of an [Account Transfer](#account-transfers). You can also approve sandbox Account Transfers in the dashboard. This transfer must first have a `status` of `pending_approval`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CompleteASandboxAccountTransferRequest, base_url, '/simulations/account_transfers/{account_transfer_id}/complete', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CompleteASandboxAccountTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountTransfer])
                res.account_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_card(self, request: shared.CreateACardParameters) -> operations.CreateACardResponse:
        r"""Create a Card"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/cards'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Card])
                res.card = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_card_dispute(self, request: shared.CreateACardDisputeParameters) -> operations.CreateACardDisputeResponse:
        r"""Create a Card Dispute"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/card_disputes'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateACardDisputeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardDispute])
                res.card_dispute = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_card_profile(self, request: shared.CreateACardProfileParameters) -> operations.CreateACardProfileResponse:
        r"""Create a Card Profile"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/card_profiles'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateACardProfileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardProfile])
                res.card_profile = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_check_deposit(self, request: shared.CreateACheckDepositParameters) -> operations.CreateACheckDepositResponse:
        r"""Create a Check Deposit"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/check_deposits'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateACheckDepositResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckDeposit])
                res.check_deposit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_check_transfer(self, request: shared.CreateACheckTransferParameters) -> operations.CreateACheckTransferResponse:
        r"""Create a Check Transfer"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/check_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateACheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_file(self, request: shared.CreateAFileParameters) -> operations.CreateAFileResponse:
        r"""Create a File
        To upload a file to Increase, you'll need to send a request of Content-Type `multipart/form-data`. The request should contain the file you would like to upload, as well as the parameters for creating a file.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/files'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAFileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.File])
                res.file = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_limit(self, request: shared.CreateALimitParameters) -> operations.CreateALimitResponse:
        r"""Create a Limit"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/limits'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateALimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Limit])
                res.limit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_supplemental_document_for_an_entity(self, request: operations.CreateASupplementalDocumentForAnEntityRequest) -> operations.CreateASupplementalDocumentForAnEntityResponse:
        r"""Create a supplemental document for an Entity"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateASupplementalDocumentForAnEntityRequest, base_url, '/entities/{entity_id}/supplemental_documents', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "create_a_supplemental_document_for_an_entity_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateASupplementalDocumentForAnEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Entity])
                res.entity = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_wire_drawdown_request(self, request: shared.CreateAWireDrawdownRequestParameters) -> operations.CreateAWireDrawdownRequestResponse:
        r"""Create a Wire Drawdown Request"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/wire_drawdown_requests'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAWireDrawdownRequestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireDrawdownRequest])
                res.wire_drawdown_request = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_a_wire_transfer(self, request: shared.CreateAWireTransferParameters) -> operations.CreateAWireTransferResponse:
        r"""Create a Wire Transfer"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/wire_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAWireTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransfer])
                res.wire_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_account(self, request: shared.CreateAnAccountParameters) -> operations.CreateAnAccountResponse:
        r"""Create an Account"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/accounts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_account_number(self, request: shared.CreateAnAccountNumberParameters) -> operations.CreateAnAccountNumberResponse:
        r"""Create an Account Number"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account_numbers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnAccountNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountNumber])
                res.account_number = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_account_transfer(self, request: shared.CreateAnAccountTransferParameters) -> operations.CreateAnAccountTransferResponse:
        r"""Create an Account Transfer"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnAccountTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountTransfer])
                res.account_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_ach_prenotification(self, request: shared.CreateAnAchPrenotificationParameters) -> operations.CreateAnAchPrenotificationResponse:
        r"""Create an ACH Prenotification"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ach_prenotifications'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnAchPrenotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchPrenotification])
                res.ach_prenotification = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_ach_return(self, request: shared.CreateAnAchReturnParameters) -> operations.CreateAnAchReturnResponse:
        r"""Create an ACH Return"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/inbound_ach_transfer_returns'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnAchReturnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundAchTransferReturn])
                res.inbound_ach_transfer_return = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_ach_transfer(self, request: shared.CreateAnAchTransferParameters) -> operations.CreateAnAchTransferResponse:
        r"""Create an ACH Transfer"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ach_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnAchTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransfer])
                res.ach_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_entity(self, request: shared.CreateAnEntityParameters) -> operations.CreateAnEntityResponse:
        r"""Create an Entity"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/entities'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Entity])
                res.entity = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_event_subscription(self, request: shared.CreateAnEventSubscriptionParameters) -> operations.CreateAnEventSubscriptionResponse:
        r"""Create an Event Subscription"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/event_subscriptions'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnEventSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EventSubscription])
                res.event_subscription = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def create_an_external_account(self, request: shared.CreateAnExternalAccountParameters) -> operations.CreateAnExternalAccountResponse:
        r"""Create an External Account"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/external_accounts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAnExternalAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ExternalAccount])
                res.external_account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def deposit_a_sandbox_check_transfer(self, request: operations.DepositASandboxCheckTransferRequest) -> operations.DepositASandboxCheckTransferResponse:
        r"""Deposit a Sandbox Check Transfer
        Simulates a [Check Transfer](#check-transfers) being deposited at a bank. This transfer must first have a `status` of `mailed`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DepositASandboxCheckTransferRequest, base_url, '/simulations/check_transfers/{check_transfer_id}/deposit', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DepositASandboxCheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_account_numbers(self, request: operations.ListAccountNumbersRequest) -> operations.ListAccountNumbersResponse:
        r"""List Account Numbers"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account_numbers'
        
        query_params = utils.get_query_params(operations.ListAccountNumbersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAccountNumbersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountNumberList])
                res.account_number_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_account_statements(self, request: operations.ListAccountStatementsRequest) -> operations.ListAccountStatementsResponse:
        r"""List Account Statements"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account_statements'
        
        query_params = utils.get_query_params(operations.ListAccountStatementsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAccountStatementsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountStatementList])
                res.account_statement_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_account_transfers(self, request: operations.ListAccountTransfersRequest) -> operations.ListAccountTransfersResponse:
        r"""List Account Transfers"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account_transfers'
        
        query_params = utils.get_query_params(operations.ListAccountTransfersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAccountTransfersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountTransferList])
                res.account_transfer_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_accounts(self, request: operations.ListAccountsRequest) -> operations.ListAccountsResponse:
        r"""List Accounts"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/accounts'
        
        query_params = utils.get_query_params(operations.ListAccountsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountList])
                res.account_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_ach_prenotifications(self, request: operations.ListAchPrenotificationsRequest) -> operations.ListAchPrenotificationsResponse:
        r"""List ACH Prenotifications"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ach_prenotifications'
        
        query_params = utils.get_query_params(operations.ListAchPrenotificationsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAchPrenotificationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchPrenotificationList])
                res.ach_prenotification_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_ach_transfers(self, request: operations.ListAchTransfersRequest) -> operations.ListAchTransfersResponse:
        r"""List ACH Transfers"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/ach_transfers'
        
        query_params = utils.get_query_params(operations.ListAchTransfersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAchTransfersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransferList])
                res.ach_transfer_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_card_disputes(self, request: operations.ListCardDisputesRequest) -> operations.ListCardDisputesResponse:
        r"""List Card Disputes"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/card_disputes'
        
        query_params = utils.get_query_params(operations.ListCardDisputesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCardDisputesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardDisputeList])
                res.card_dispute_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_card_profiles(self, request: operations.ListCardProfilesRequest) -> operations.ListCardProfilesResponse:
        r"""List Card Profiles"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/card_profiles'
        
        query_params = utils.get_query_params(operations.ListCardProfilesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCardProfilesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardProfileList])
                res.card_profile_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_cards(self, request: operations.ListCardsRequest) -> operations.ListCardsResponse:
        r"""List Cards"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/cards'
        
        query_params = utils.get_query_params(operations.ListCardsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCardsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardList])
                res.card_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_check_deposits(self, request: operations.ListCheckDepositsRequest) -> operations.ListCheckDepositsResponse:
        r"""List Check Deposits"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/check_deposits'
        
        query_params = utils.get_query_params(operations.ListCheckDepositsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCheckDepositsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckDepositList])
                res.check_deposit_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_check_transfers(self, request: operations.ListCheckTransfersRequest) -> operations.ListCheckTransfersResponse:
        r"""List Check Transfers"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/check_transfers'
        
        query_params = utils.get_query_params(operations.ListCheckTransfersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListCheckTransfersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransferList])
                res.check_transfer_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_declined_transactions(self, request: operations.ListDeclinedTransactionsRequest) -> operations.ListDeclinedTransactionsResponse:
        r"""List Declined Transactions"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/declined_transactions'
        
        query_params = utils.get_query_params(operations.ListDeclinedTransactionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeclinedTransactionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeclinedTransactionList])
                res.declined_transaction_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_digital_wallet_tokens(self, request: operations.ListDigitalWalletTokensRequest) -> operations.ListDigitalWalletTokensResponse:
        r"""List Digital Wallet Tokens"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/digital_wallet_tokens'
        
        query_params = utils.get_query_params(operations.ListDigitalWalletTokensRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDigitalWalletTokensResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DigitalWalletTokenList])
                res.digital_wallet_token_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_documents(self, request: operations.ListDocumentsRequest) -> operations.ListDocumentsResponse:
        r"""List Documents"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/documents'
        
        query_params = utils.get_query_params(operations.ListDocumentsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDocumentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DocumentList])
                res.document_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_entities(self, request: operations.ListEntitiesRequest) -> operations.ListEntitiesResponse:
        r"""List Entities"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/entities'
        
        query_params = utils.get_query_params(operations.ListEntitiesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEntitiesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EntityList])
                res.entity_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_event_subscriptions(self, request: operations.ListEventSubscriptionsRequest) -> operations.ListEventSubscriptionsResponse:
        r"""List Event Subscriptions"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/event_subscriptions'
        
        query_params = utils.get_query_params(operations.ListEventSubscriptionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEventSubscriptionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EventSubscriptionList])
                res.event_subscription_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_events(self, request: operations.ListEventsRequest) -> operations.ListEventsResponse:
        r"""List Events"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/events'
        
        query_params = utils.get_query_params(operations.ListEventsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEventsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EventList])
                res.event_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_external_accounts(self, request: operations.ListExternalAccountsRequest) -> operations.ListExternalAccountsResponse:
        r"""List External Accounts"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/external_accounts'
        
        query_params = utils.get_query_params(operations.ListExternalAccountsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListExternalAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ExternalAccountList])
                res.external_account_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_files(self, request: operations.ListFilesRequest) -> operations.ListFilesResponse:
        r"""List Files"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/files'
        
        query_params = utils.get_query_params(operations.ListFilesRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFilesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FileList])
                res.file_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_inbound_ach_transfer_returns(self, request: operations.ListInboundAchTransferReturnsRequest) -> operations.ListInboundAchTransferReturnsResponse:
        r"""List Inbound ACH Transfer Returns"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/inbound_ach_transfer_returns'
        
        query_params = utils.get_query_params(operations.ListInboundAchTransferReturnsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInboundAchTransferReturnsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundAchTransferReturnList])
                res.inbound_ach_transfer_return_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_inbound_wire_drawdown_requests(self, request: operations.ListInboundWireDrawdownRequestsRequest) -> operations.ListInboundWireDrawdownRequestsResponse:
        r"""List Inbound Wire Drawdown Requests"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/inbound_wire_drawdown_requests'
        
        query_params = utils.get_query_params(operations.ListInboundWireDrawdownRequestsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInboundWireDrawdownRequestsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundWireDrawdownRequestList])
                res.inbound_wire_drawdown_request_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_limits(self, request: operations.ListLimitsRequest) -> operations.ListLimitsResponse:
        r"""List Limits"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/limits'
        
        query_params = utils.get_query_params(operations.ListLimitsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListLimitsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.LimitList])
                res.limit_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_oauth_connections(self, request: operations.ListOauthConnectionsRequest) -> operations.ListOauthConnectionsResponse:
        r"""List OAuth Connections"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/oauth_connections'
        
        query_params = utils.get_query_params(operations.ListOauthConnectionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListOauthConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OauthConnectionList])
                res.oauth_connection_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_pending_transactions(self, request: operations.ListPendingTransactionsRequest) -> operations.ListPendingTransactionsResponse:
        r"""List Pending Transactions"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/pending_transactions'
        
        query_params = utils.get_query_params(operations.ListPendingTransactionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListPendingTransactionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PendingTransactionList])
                res.pending_transaction_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_routing_numbers(self, request: operations.ListRoutingNumbersRequest) -> operations.ListRoutingNumbersResponse:
        r"""List Routing Numbers
        You can use this API to confirm if a routing number is valid, such as when a user is providing you with bank account details. Since routing numbers uniquely identify a bank, this will always return 0 or 1 entry. In Sandbox, the only valid routing number for this method is 110000000.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/routing_numbers'
        
        query_params = utils.get_query_params(operations.ListRoutingNumbersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListRoutingNumbersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RoutingNumberList])
                res.routing_number_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_transactions(self, request: operations.ListTransactionsRequest) -> operations.ListTransactionsResponse:
        r"""List Transactions"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/transactions'
        
        query_params = utils.get_query_params(operations.ListTransactionsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListTransactionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionList])
                res.transaction_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_wire_drawdown_requests(self, request: operations.ListWireDrawdownRequestsRequest) -> operations.ListWireDrawdownRequestsResponse:
        r"""List Wire Drawdown Requests"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/wire_drawdown_requests'
        
        query_params = utils.get_query_params(operations.ListWireDrawdownRequestsRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWireDrawdownRequestsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireDrawdownRequestList])
                res.wire_drawdown_request_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def list_wire_transfers(self, request: operations.ListWireTransfersRequest) -> operations.ListWireTransfersResponse:
        r"""List Wire Transfers"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/wire_transfers'
        
        query_params = utils.get_query_params(operations.ListWireTransfersRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWireTransfersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransferList])
                res.wire_transfer_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def mail_a_sandbox_check_transfer(self, request: operations.MailASandboxCheckTransferRequest) -> operations.MailASandboxCheckTransferResponse:
        r"""Mail a Sandbox Check Transfer
        Simulates the mailing of a [Check Transfer](#check-transfers), which happens once per weekday in production but can be sped up in sandbox. This transfer must first have a `status` of `pending_approval` or `pending_submission`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.MailASandboxCheckTransferRequest, base_url, '/simulations/check_transfers/{check_transfer_id}/mail', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.MailASandboxCheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def reject_a_sandbox_check_deposit(self, request: operations.RejectASandboxCheckDepositRequest) -> operations.RejectASandboxCheckDepositResponse:
        r"""Reject a Sandbox Check Deposit
        Simulates the rejection of a [Check Deposit](#check-deposits) by Increase due to factors like poor image quality. This Check Deposit must first have a `status` of `pending`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.RejectASandboxCheckDepositRequest, base_url, '/simulations/check_deposits/{check_deposit_id}/reject', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RejectASandboxCheckDepositResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckDeposit])
                res.check_deposit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def request_a_stop_payment_on_a_check_transfer(self, request: operations.RequestAStopPaymentOnACheckTransferRequest) -> operations.RequestAStopPaymentOnACheckTransferResponse:
        r"""Request a stop payment on a Check Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RequestAStopPaymentOnACheckTransferRequest, base_url, '/check_transfers/{check_transfer_id}/stop_payment', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RequestAStopPaymentOnACheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_card(self, request: operations.RetrieveACardRequest) -> operations.RetrieveACardResponse:
        r"""Retrieve a Card"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveACardRequest, base_url, '/cards/{card_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Card])
                res.card = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_card_dispute(self, request: operations.RetrieveACardDisputeRequest) -> operations.RetrieveACardDisputeResponse:
        r"""Retrieve a Card Dispute"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveACardDisputeRequest, base_url, '/card_disputes/{card_dispute_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveACardDisputeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardDispute])
                res.card_dispute = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_card_profile(self, request: operations.RetrieveACardProfileRequest) -> operations.RetrieveACardProfileResponse:
        r"""Retrieve a Card Profile"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveACardProfileRequest, base_url, '/card_profiles/{card_profile_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveACardProfileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardProfile])
                res.card_profile = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_check_deposit(self, request: operations.RetrieveACheckDepositRequest) -> operations.RetrieveACheckDepositResponse:
        r"""Retrieve a Check Deposit"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveACheckDepositRequest, base_url, '/check_deposits/{check_deposit_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveACheckDepositResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckDeposit])
                res.check_deposit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_check_transfer(self, request: operations.RetrieveACheckTransferRequest) -> operations.RetrieveACheckTransferResponse:
        r"""Retrieve a Check Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveACheckTransferRequest, base_url, '/check_transfers/{check_transfer_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveACheckTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckTransfer])
                res.check_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_declined_transaction(self, request: operations.RetrieveADeclinedTransactionRequest) -> operations.RetrieveADeclinedTransactionResponse:
        r"""Retrieve a Declined Transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveADeclinedTransactionRequest, base_url, '/declined_transactions/{declined_transaction_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveADeclinedTransactionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeclinedTransaction])
                res.declined_transaction = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_digital_wallet_token(self, request: operations.RetrieveADigitalWalletTokenRequest) -> operations.RetrieveADigitalWalletTokenResponse:
        r"""Retrieve a Digital Wallet Token"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveADigitalWalletTokenRequest, base_url, '/digital_wallet_tokens/{digital_wallet_token_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveADigitalWalletTokenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DigitalWalletToken])
                res.digital_wallet_token = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_document(self, request: operations.RetrieveADocumentRequest) -> operations.RetrieveADocumentResponse:
        r"""Retrieve a Document"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveADocumentRequest, base_url, '/documents/{document_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveADocumentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Document])
                res.document = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_file(self, request: operations.RetrieveAFileRequest) -> operations.RetrieveAFileResponse:
        r"""Retrieve a File"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAFileRequest, base_url, '/files/{file_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAFileResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.File])
                res.file = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_limit(self, request: operations.RetrieveALimitRequest) -> operations.RetrieveALimitResponse:
        r"""Retrieve a Limit"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveALimitRequest, base_url, '/limits/{limit_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveALimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Limit])
                res.limit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_pending_transaction(self, request: operations.RetrieveAPendingTransactionRequest) -> operations.RetrieveAPendingTransactionResponse:
        r"""Retrieve a Pending Transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAPendingTransactionRequest, base_url, '/pending_transactions/{pending_transaction_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAPendingTransactionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PendingTransaction])
                res.pending_transaction = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_real_time_decision(self, request: operations.RetrieveARealTimeDecisionRequest) -> operations.RetrieveARealTimeDecisionResponse:
        r"""Retrieve a Real-Time Decision"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveARealTimeDecisionRequest, base_url, '/real_time_decisions/{real_time_decision_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveARealTimeDecisionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RealTimeDecision])
                res.real_time_decision = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_transaction(self, request: operations.RetrieveATransactionRequest) -> operations.RetrieveATransactionResponse:
        r"""Retrieve a Transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveATransactionRequest, base_url, '/transactions/{transaction_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveATransactionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Transaction])
                res.transaction = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_wire_drawdown_request(self, request: operations.RetrieveAWireDrawdownRequestRequest) -> operations.RetrieveAWireDrawdownRequestResponse:
        r"""Retrieve a Wire Drawdown Request"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAWireDrawdownRequestRequest, base_url, '/wire_drawdown_requests/{wire_drawdown_request_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAWireDrawdownRequestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireDrawdownRequest])
                res.wire_drawdown_request = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_a_wire_transfer(self, request: operations.RetrieveAWireTransferRequest) -> operations.RetrieveAWireTransferResponse:
        r"""Retrieve a Wire Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAWireTransferRequest, base_url, '/wire_transfers/{wire_transfer_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAWireTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransfer])
                res.wire_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_account(self, request: operations.RetrieveAnAccountRequest) -> operations.RetrieveAnAccountResponse:
        r"""Retrieve an Account"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnAccountRequest, base_url, '/accounts/{account_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_account_number(self, request: operations.RetrieveAnAccountNumberRequest) -> operations.RetrieveAnAccountNumberResponse:
        r"""Retrieve an Account Number"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnAccountNumberRequest, base_url, '/account_numbers/{account_number_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnAccountNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountNumber])
                res.account_number = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_account_statement(self, request: operations.RetrieveAnAccountStatementRequest) -> operations.RetrieveAnAccountStatementResponse:
        r"""Retrieve an Account Statement"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnAccountStatementRequest, base_url, '/account_statements/{account_statement_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnAccountStatementResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountStatement])
                res.account_statement = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_account_transfer(self, request: operations.RetrieveAnAccountTransferRequest) -> operations.RetrieveAnAccountTransferResponse:
        r"""Retrieve an Account Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnAccountTransferRequest, base_url, '/account_transfers/{account_transfer_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnAccountTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountTransfer])
                res.account_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_ach_prenotification(self, request: operations.RetrieveAnAchPrenotificationRequest) -> operations.RetrieveAnAchPrenotificationResponse:
        r"""Retrieve an ACH Prenotification"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnAchPrenotificationRequest, base_url, '/ach_prenotifications/{ach_prenotification_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnAchPrenotificationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchPrenotification])
                res.ach_prenotification = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_ach_transfer(self, request: operations.RetrieveAnAchTransferRequest) -> operations.RetrieveAnAchTransferResponse:
        r"""Retrieve an ACH Transfer"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnAchTransferRequest, base_url, '/ach_transfers/{ach_transfer_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnAchTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransfer])
                res.ach_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_entity(self, request: operations.RetrieveAnEntityRequest) -> operations.RetrieveAnEntityResponse:
        r"""Retrieve an Entity"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnEntityRequest, base_url, '/entities/{entity_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnEntityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Entity])
                res.entity = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_event(self, request: operations.RetrieveAnEventRequest) -> operations.RetrieveAnEventResponse:
        r"""Retrieve an Event"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnEventRequest, base_url, '/events/{event_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnEventResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Event])
                res.event = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_event_subscription(self, request: operations.RetrieveAnEventSubscriptionRequest) -> operations.RetrieveAnEventSubscriptionResponse:
        r"""Retrieve an Event Subscription"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnEventSubscriptionRequest, base_url, '/event_subscriptions/{event_subscription_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnEventSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EventSubscription])
                res.event_subscription = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_external_account(self, request: operations.RetrieveAnExternalAccountRequest) -> operations.RetrieveAnExternalAccountResponse:
        r"""Retrieve an External Account"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnExternalAccountRequest, base_url, '/external_accounts/{external_account_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnExternalAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ExternalAccount])
                res.external_account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_inbound_ach_transfer_return(self, request: operations.RetrieveAnInboundAchTransferReturnRequest) -> operations.RetrieveAnInboundAchTransferReturnResponse:
        r"""Retrieve an Inbound ACH Transfer Return"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnInboundAchTransferReturnRequest, base_url, '/inbound_ach_transfer_returns/{inbound_ach_transfer_return_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnInboundAchTransferReturnResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundAchTransferReturn])
                res.inbound_ach_transfer_return = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_inbound_wire_drawdown_request(self, request: operations.RetrieveAnInboundWireDrawdownRequestRequest) -> operations.RetrieveAnInboundWireDrawdownRequestResponse:
        r"""Retrieve an Inbound Wire Drawdown Request"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnInboundWireDrawdownRequestRequest, base_url, '/inbound_wire_drawdown_requests/{inbound_wire_drawdown_request_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnInboundWireDrawdownRequestResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundWireDrawdownRequest])
                res.inbound_wire_drawdown_request = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_an_oauth_connection(self, request: operations.RetrieveAnOauthConnectionRequest) -> operations.RetrieveAnOauthConnectionResponse:
        r"""Retrieve an OAuth Connection"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveAnOauthConnectionRequest, base_url, '/oauth_connections/{oauth_connection_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveAnOauthConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.OauthConnection])
                res.oauth_connection = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_group_details(self) -> operations.RetrieveGroupDetailsResponse:
        r"""Retrieve Group details
        Returns details for the currently authenticated Group.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/groups/current'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveGroupDetailsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Group])
                res.group = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def retrieve_sensitive_details_for_a_card(self, request: operations.RetrieveSensitiveDetailsForACardRequest) -> operations.RetrieveSensitiveDetailsForACardResponse:
        r"""Retrieve sensitive details for a Card"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.RetrieveSensitiveDetailsForACardRequest, base_url, '/cards/{card_id}/details', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RetrieveSensitiveDetailsForACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardDetails])
                res.card_details = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def return_a_sandbox_ach_transfer(self, request: operations.ReturnASandboxAchTransferRequest) -> operations.ReturnASandboxAchTransferResponse:
        r"""Return a Sandbox ACH Transfer
        Simulates the return of an [ACH Transfer](#ach-transfers) by the Federal Reserve due to an error condition. This will also create a Transaction to account for the returned funds. This transfer must first have a `status` of `submitted`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReturnASandboxAchTransferRequest, base_url, '/simulations/ach_transfers/{ach_transfer_id}/return', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "return_a_sandbox_ach_transfer_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReturnASandboxAchTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransfer])
                res.ach_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def return_a_sandbox_check_deposit(self, request: operations.ReturnASandboxCheckDepositRequest) -> operations.ReturnASandboxCheckDepositResponse:
        r"""Return a Sandbox Check Deposit
        Simulates the return of a [Check Deposit](#check-deposits). This Check Deposit must first have a `status` of `submitted`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReturnASandboxCheckDepositRequest, base_url, '/simulations/check_deposits/{check_deposit_id}/return', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReturnASandboxCheckDepositResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckDeposit])
                res.check_deposit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def reverse_a_sandbox_wire_transfer(self, request: operations.ReverseASandboxWireTransferRequest) -> operations.ReverseASandboxWireTransferResponse:
        r"""Reverse a Sandbox Wire Transfer
        Simulates the reversal of a [Wire Transfer](#wire-transfers) by the Federal Reserve due to error conditions. This will also create a [Transaction](#transaction) to account for the returned funds. This Wire Transfer must first have a `status` of `complete`.'
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReverseASandboxWireTransferRequest, base_url, '/simulations/wire_transfers/{wire_transfer_id}/reverse', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReverseASandboxWireTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransfer])
                res.wire_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_a_real_time_payments_transfer_to_your_account(self, request: shared.SimulateARealTimePaymentsTransferToYourAccountParameters) -> operations.SimulateARealTimePaymentsTransferToYourAccountResponse:
        r"""Simulate a Real Time Payments Transfer to your account
        Simulates an inbound Real Time Payments transfer to your account. Real Time Payments are a beta feature.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/inbound_real_time_payments_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateARealTimePaymentsTransferToYourAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundRealTimePaymentsTransferSimulationResult])
                res.inbound_real_time_payments_transfer_simulation_result = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_a_refund_on_a_card(self, request: shared.SimulateARefundOnACardParameters) -> operations.SimulateARefundOnACardResponse:
        r"""Simulate a refund on a card
        Simulates refunding a card transaction. The full value of the original sandbox transaction is refunded.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/card_refunds'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateARefundOnACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Transaction])
                res.transaction = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_a_tax_document_being_created(self, request: shared.SimulateATaxDocumentBeingCreatedParameters) -> operations.SimulateATaxDocumentBeingCreatedResponse:
        r"""Simulate a tax document being created
        Simulates an tax document being created for an account.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/documents'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateATaxDocumentBeingCreatedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Document])
                res.document = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_a_wire_transfer_to_your_account(self, request: shared.SimulateAWireTransferToYourAccountParameters) -> operations.SimulateAWireTransferToYourAccountResponse:
        r"""Simulate a Wire Transfer to your account
        Simulates an inbound Wire Transfer to your account.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/inbound_wire_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateAWireTransferToYourAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundWireTransferSimulationResult])
                res.inbound_wire_transfer_simulation_result = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_an_account_statement_being_created(self, request: shared.SimulateAnAccountStatementBeingCreatedParameters) -> operations.SimulateAnAccountStatementBeingCreatedResponse:
        r"""Simulate an Account Statement being created
        Simulates an [Account Statement](#account-statements) being created for an account. In production, Account Statements are generated once per month.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/account_statements'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateAnAccountStatementBeingCreatedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountStatement])
                res.account_statement = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_an_ach_transfer_to_your_account(self, request: shared.SimulateAnAchTransferToYourAccountParameters) -> operations.SimulateAnAchTransferToYourAccountResponse:
        r"""Simulate an ACH Transfer to your account
        Simulates an inbound ACH transfer to your account. This imitates initiating a transaction to an Increase account from a different financial institution. The transfer may be either a credit or a debit depending on if the `amount` is positive or negative. The result of calling this API will be either a [Transaction](#transactions) or a [Declined Transaction](#declined-transactions) depending on whether or not the transfer is allowed.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/inbound_ach_transfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateAnAchTransferToYourAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundAchTransferSimulationResult])
                res.inbound_ach_transfer_simulation_result = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_an_authorization_on_a_card(self, request: shared.SimulateAnAuthorizationOnACardParameters) -> operations.SimulateAnAuthorizationOnACardResponse:
        r"""Simulate an authorization on a Card
        Simulates a purchase authorization on a [Card](#cards). Depending on the balance available to the card and the `amount` submitted, the authorization activity will result in a [Pending Transaction](#pending-transactions) of type `card_authorization` or a [Declined Transaction](#declined-transactions) of type `card_decline`. You can pass either a Card id or a [Digital Wallet Token](#digital-wallet-tokens) id to simulate the two different ways purchases can be made.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/card_authorizations'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateAnAuthorizationOnACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundCardAuthorizationSimulationResult])
                res.inbound_card_authorization_simulation_result = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_an_inbound_wire_drawdown_request_being_created(self, request: shared.SimulateAnInboundWireDrawdownRequestBeingCreatedParameters) -> operations.SimulateAnInboundWireDrawdownRequestBeingCreatedResponse:
        r"""Simulate an Inbound Wire Drawdown request being created
        Simulates the receival of an [Inbound Wire Drawdown Request](#inbound-wire-drawdown-requests).
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/inbound_wire_drawdown_requests'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateAnInboundWireDrawdownRequestBeingCreatedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundWireDrawdownRequest])
                res.inbound_wire_drawdown_request = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_digital_wallet_provisioning_for_a_card(self, request: shared.SimulateDigitalWalletProvisioningForACardParameters) -> operations.SimulateDigitalWalletProvisioningForACardResponse:
        r"""Simulate digital wallet provisioning for a card
        Simulates a user attempting add a [Card](#cards) to a digital wallet such as Apple Pay.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/digital_wallet_token_requests'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateDigitalWalletProvisioningForACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InboundDigitalWalletTokenRequestSimulationResult])
                res.inbound_digital_wallet_token_request_simulation_result = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulate_settling_a_card_authorization(self, request: shared.SimulateSettlingACardAuthorizationParameters) -> operations.SimulateSettlingACardAuthorizationResponse:
        r"""Simulate settling a card authorization
        Simulates the settlement of an authorization by a card acquirer. After a card authorization is created, the merchant will eventually send a settlement. This simulates that event, which may occur many days after the purchase in production. The amount settled can be different from the amount originally authorized, for example, when adding a tip to a restaurant bill.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/simulations/card_settlements'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulateSettlingACardAuthorizationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Transaction])
                res.transaction = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def simulates_advancing_the_state_of_a_card_dispute(self, request: operations.SimulatesAdvancingTheStateOfACardDisputeRequest) -> operations.SimulatesAdvancingTheStateOfACardDisputeResponse:
        r"""Simulates advancing the state of a card dispute
        After a [Card Dispute](#card-disputes) is created in production, the dispute will be reviewed. Since no review happens in sandbox, this endpoint simulates moving a Card Dispute into a rejected or accepted state. A Card Dispute can only be actioned one time and must have a status of `pending_reviewing`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SimulatesAdvancingTheStateOfACardDisputeRequest, base_url, '/simulations/card_disputes/{card_dispute_id}/action', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "simulates_advancing_the_state_of_a_card_dispute_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SimulatesAdvancingTheStateOfACardDisputeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CardDispute])
                res.card_dispute = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def submit_a_sandbox_ach_transfer(self, request: operations.SubmitASandboxAchTransferRequest) -> operations.SubmitASandboxAchTransferResponse:
        r"""Submit a Sandbox ACH Transfer
        Simulates the submission of an [ACH Transfer](#ach-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_submission`. In production, Increase submits ACH Transfers to the Federal Reserve three times per day on weekdays. Since sandbox ACH Transfers are not submitted to the Federal Reserve, this endpoint allows you to skip that delay and transition the ACH Transfer to a status of `submitted`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SubmitASandboxAchTransferRequest, base_url, '/simulations/ach_transfers/{ach_transfer_id}/submit', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SubmitASandboxAchTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AchTransfer])
                res.ach_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def submit_a_sandbox_check_deposit(self, request: operations.SubmitASandboxCheckDepositRequest) -> operations.SubmitASandboxCheckDepositResponse:
        r"""Submit a Sandbox Check Deposit
        Simulates the submission of a [Check Deposit](#check-deposits) to the Federal Reserve. This Check Deposit must first have a `status` of `pending`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SubmitASandboxCheckDepositRequest, base_url, '/simulations/check_deposits/{check_deposit_id}/submit', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SubmitASandboxCheckDepositResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CheckDeposit])
                res.check_deposit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def submit_a_sandbox_wire_transfer(self, request: operations.SubmitASandboxWireTransferRequest) -> operations.SubmitASandboxWireTransferResponse:
        r"""Submit a Sandbox Wire Transfer
        Simulates the submission of a [Wire Transfer](#wire-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_creating`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SubmitASandboxWireTransferRequest, base_url, '/simulations/wire_transfers/{wire_transfer_id}/submit', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SubmitASandboxWireTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WireTransfer])
                res.wire_transfer = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def update_a_card(self, request: operations.UpdateACardRequest) -> operations.UpdateACardResponse:
        r"""Update a Card"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateACardRequest, base_url, '/cards/{card_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_a_card_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateACardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Card])
                res.card = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def update_a_limit(self, request: operations.UpdateALimitRequest) -> operations.UpdateALimitResponse:
        r"""Update a Limit"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateALimitRequest, base_url, '/limits/{limit_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_a_limit_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateALimitResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Limit])
                res.limit = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def update_an_account(self, request: operations.UpdateAnAccountRequest) -> operations.UpdateAnAccountResponse:
        r"""Update an Account"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateAnAccountRequest, base_url, '/accounts/{account_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_an_account_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAnAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def update_an_account_number(self, request: operations.UpdateAnAccountNumberRequest) -> operations.UpdateAnAccountNumberResponse:
        r"""Update an Account Number"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateAnAccountNumberRequest, base_url, '/account_numbers/{account_number_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_an_account_number_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAnAccountNumberResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountNumber])
                res.account_number = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def update_an_event_subscription(self, request: operations.UpdateAnEventSubscriptionRequest) -> operations.UpdateAnEventSubscriptionResponse:
        r"""Update an Event Subscription"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateAnEventSubscriptionRequest, base_url, '/event_subscriptions/{event_subscription_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_an_event_subscription_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAnEventSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.EventSubscription])
                res.event_subscription = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    def update_an_external_account(self, request: operations.UpdateAnExternalAccountRequest) -> operations.UpdateAnExternalAccountResponse:
        r"""Update an External Account"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateAnExternalAccountRequest, base_url, '/external_accounts/{external_account_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_an_external_account_parameters", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAnExternalAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ExternalAccount])
                res.external_account = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.error = out

        return res

    