// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// CreateCallRequestAnswerURLAnswerMethodEnum - The HTTP method used to send event information to answer_url.
type CreateCallRequestAnswerURLAnswerMethodEnum string

const (
	CreateCallRequestAnswerURLAnswerMethodEnumPost CreateCallRequestAnswerURLAnswerMethodEnum = "POST"
	CreateCallRequestAnswerURLAnswerMethodEnumGet  CreateCallRequestAnswerURLAnswerMethodEnum = "GET"
)

func (e *CreateCallRequestAnswerURLAnswerMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "POST":
		fallthrough
	case "GET":
		*e = CreateCallRequestAnswerURLAnswerMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCallRequestAnswerURLAnswerMethodEnum: %s", s)
	}
}

// CreateCallRequestAnswerURLEventMethodEnum - The HTTP method used to send event information to `event_url`.
type CreateCallRequestAnswerURLEventMethodEnum string

const (
	CreateCallRequestAnswerURLEventMethodEnumPost CreateCallRequestAnswerURLEventMethodEnum = "POST"
	CreateCallRequestAnswerURLEventMethodEnumGet  CreateCallRequestAnswerURLEventMethodEnum = "GET"
)

func (e *CreateCallRequestAnswerURLEventMethodEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "POST":
		fallthrough
	case "GET":
		*e = CreateCallRequestAnswerURLEventMethodEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCallRequestAnswerURLEventMethodEnum: %s", s)
	}
}

// CreateCallRequestAnswerURLMachineDetectionEnum - Configure the behavior when Vonage detects that the call is answered by voicemail. If `continue`, Vonage sends an HTTP request to `event_url` with the Call event machine. If `hangup`, Vonage ends the call.
type CreateCallRequestAnswerURLMachineDetectionEnum string

const (
	CreateCallRequestAnswerURLMachineDetectionEnumContinue CreateCallRequestAnswerURLMachineDetectionEnum = "continue"
	CreateCallRequestAnswerURLMachineDetectionEnumHangup   CreateCallRequestAnswerURLMachineDetectionEnum = "hangup"
)

func (e *CreateCallRequestAnswerURLMachineDetectionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "continue":
		fallthrough
	case "hangup":
		*e = CreateCallRequestAnswerURLMachineDetectionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateCallRequestAnswerURLMachineDetectionEnum: %s", s)
	}
}

type CreateCallRequestAnswerURLToType string

const (
	CreateCallRequestAnswerURLToTypeEndpointPhoneTo      CreateCallRequestAnswerURLToType = "EndpointPhoneTo"
	CreateCallRequestAnswerURLToTypeEndpointSip          CreateCallRequestAnswerURLToType = "EndpointSip"
	CreateCallRequestAnswerURLToTypeEndpointWebsocket    CreateCallRequestAnswerURLToType = "EndpointWebsocket"
	CreateCallRequestAnswerURLToTypeEndpointVBCExtension CreateCallRequestAnswerURLToType = "EndpointVBCExtension"
)

type CreateCallRequestAnswerURLTo struct {
	EndpointPhoneTo      *EndpointPhoneTo
	EndpointSip          *EndpointSip
	EndpointWebsocket    *EndpointWebsocket
	EndpointVBCExtension *EndpointVBCExtension

	Type CreateCallRequestAnswerURLToType
}

func CreateCreateCallRequestAnswerURLToEndpointPhoneTo(endpointPhoneTo EndpointPhoneTo) CreateCallRequestAnswerURLTo {
	typ := CreateCallRequestAnswerURLToTypeEndpointPhoneTo

	return CreateCallRequestAnswerURLTo{
		EndpointPhoneTo: &endpointPhoneTo,
		Type:            typ,
	}
}

func CreateCreateCallRequestAnswerURLToEndpointSip(endpointSip EndpointSip) CreateCallRequestAnswerURLTo {
	typ := CreateCallRequestAnswerURLToTypeEndpointSip

	return CreateCallRequestAnswerURLTo{
		EndpointSip: &endpointSip,
		Type:        typ,
	}
}

func CreateCreateCallRequestAnswerURLToEndpointWebsocket(endpointWebsocket EndpointWebsocket) CreateCallRequestAnswerURLTo {
	typ := CreateCallRequestAnswerURLToTypeEndpointWebsocket

	return CreateCallRequestAnswerURLTo{
		EndpointWebsocket: &endpointWebsocket,
		Type:              typ,
	}
}

func CreateCreateCallRequestAnswerURLToEndpointVBCExtension(endpointVBCExtension EndpointVBCExtension) CreateCallRequestAnswerURLTo {
	typ := CreateCallRequestAnswerURLToTypeEndpointVBCExtension

	return CreateCallRequestAnswerURLTo{
		EndpointVBCExtension: &endpointVBCExtension,
		Type:                 typ,
	}
}

func (u *CreateCallRequestAnswerURLTo) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	endpointPhoneTo := new(EndpointPhoneTo)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointPhoneTo); err == nil {
		u.EndpointPhoneTo = endpointPhoneTo
		u.Type = CreateCallRequestAnswerURLToTypeEndpointPhoneTo
		return nil
	}

	endpointSip := new(EndpointSip)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointSip); err == nil {
		u.EndpointSip = endpointSip
		u.Type = CreateCallRequestAnswerURLToTypeEndpointSip
		return nil
	}

	endpointWebsocket := new(EndpointWebsocket)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointWebsocket); err == nil {
		u.EndpointWebsocket = endpointWebsocket
		u.Type = CreateCallRequestAnswerURLToTypeEndpointWebsocket
		return nil
	}

	endpointVBCExtension := new(EndpointVBCExtension)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&endpointVBCExtension); err == nil {
		u.EndpointVBCExtension = endpointVBCExtension
		u.Type = CreateCallRequestAnswerURLToTypeEndpointVBCExtension
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u CreateCallRequestAnswerURLTo) MarshalJSON() ([]byte, error) {
	if u.EndpointPhoneTo != nil {
		return json.Marshal(u.EndpointPhoneTo)
	}

	if u.EndpointSip != nil {
		return json.Marshal(u.EndpointSip)
	}

	if u.EndpointWebsocket != nil {
		return json.Marshal(u.EndpointWebsocket)
	}

	if u.EndpointVBCExtension != nil {
		return json.Marshal(u.EndpointVBCExtension)
	}

	return nil, nil
}

type CreateCallRequestAnswerURL struct {
	// The HTTP method used to send event information to answer_url.
	AnswerMethod *CreateCallRequestAnswerURLAnswerMethodEnum `json:"answer_method,omitempty"`
	// The webhook endpoint where you provide the [Nexmo Call Control Object](/voice/voice-api/ncco-reference) that governs this call.
	//
	AnswerURL []string `json:"answer_url"`
	// The HTTP method used to send event information to `event_url`.
	EventMethod *CreateCallRequestAnswerURLEventMethodEnum `json:"event_method,omitempty"`
	// **Required** unless `event_url` is configured at the application
	// level, see [Create an Application](/api/application.v2#createApplication)
	//
	// The webhook endpoint where call progress events are
	// sent to. For more information about the values sent, see
	// [Event webhook](/voice/voice-api/webhook-reference#event-webhook).
	//
	EventURL []string `json:"event_url,omitempty"`
	// Connect to a Phone (PSTN) number
	From EndpointPhoneFrom `json:"from"`
	// Set the number of seconds that elapse before Vonage hangs up after the call state changes to answered.
	LengthTimer *int64 `json:"length_timer,omitempty"`
	// Configure the behavior when Vonage detects that the call is answered by voicemail. If `continue`, Vonage sends an HTTP request to `event_url` with the Call event machine. If `hangup`, Vonage ends the call.
	MachineDetection *CreateCallRequestAnswerURLMachineDetectionEnum `json:"machine_detection,omitempty"`
	// Set to `true` to use random phone number as `from`. The number will be selected from the list of the numbers assigned to the current application. `random_from_number: true` cannot be used together with `from`.
	RandomFromNumber *bool `json:"random_from_number,omitempty"`
	// Set the number of seconds that elapse before Vonage hangs up after the call state changes to ‘ringing’.
	RingingTimer *int64                         `json:"ringing_timer,omitempty"`
	To           []CreateCallRequestAnswerURLTo `json:"to"`
}
