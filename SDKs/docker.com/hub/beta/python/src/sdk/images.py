"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Images:
    r"""The Advanced Image Management API endpoints allow you to manage Docker
    images across all repositories.
    
    For more information, see [Advanced Image Management dashboard](https://docs.docker.com/docker-hub/image-management/).
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def get_namespaces_repositories_images(self, request: operations.GetNamespacesRepositoriesImagesRequest) -> operations.GetNamespacesRepositoriesImagesResponse:
        r"""Get details of repository's images
        Gets details on the images in a repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetNamespacesRepositoriesImagesRequest, base_url, '/v2/namespaces/{namespace}/repositories/{repository}/images', request)
        
        query_params = utils.get_query_params(operations.GetNamespacesRepositoriesImagesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetNamespacesRepositoriesImagesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetNamespaceRepositoryImagesResponse])
                res.get_namespace_repository_images_response = out
        elif http_res.status_code in [401, 403]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_namespaces_repositories_images_summary(self, request: operations.GetNamespacesRepositoriesImagesSummaryRequest) -> operations.GetNamespacesRepositoriesImagesSummaryResponse:
        r"""Get summary of repository's images
        Gets the number of images in a repository and the number of images
        counted as active and inactive.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetNamespacesRepositoriesImagesSummaryRequest, base_url, '/v2/namespaces/{namespace}/repositories/{repository}/images-summary', request)
        
        query_params = utils.get_query_params(operations.GetNamespacesRepositoriesImagesSummaryRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetNamespacesRepositoriesImagesSummaryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetNamespaceRepositoryImagesSummaryResponse])
                res.get_namespace_repository_images_summary_response = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_namespaces_repositories_images_tags(self, request: operations.GetNamespacesRepositoriesImagesTagsRequest) -> operations.GetNamespacesRepositoriesImagesTagsResponse:
        r"""Get image's tags
        Gets current and historical tags for an image.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetNamespacesRepositoriesImagesTagsRequest, base_url, '/v2/namespaces/{namespace}/repositories/{repository}/images/{digest}/tags', request)
        
        query_params = utils.get_query_params(operations.GetNamespacesRepositoriesImagesTagsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetNamespacesRepositoriesImagesTagsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetNamespaceRepositoryImagesTagsResponse])
                res.get_namespace_repository_images_tags_response = out
        elif http_res.status_code in [401, 403]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def post_namespaces_delete_images(self, request: operations.PostNamespacesDeleteImagesRequest) -> operations.PostNamespacesDeleteImagesResponse:
        r"""Delete images
        Deletes one or more images within a namespace. This is currently limited to a single 
        repository.
        
        If you attempt to delete images that are marked as active or are currently tagged, the deletion does not happen and it displays the warnings.
        To continue with the deletion, you must ignore these warnings by putting them in the `ignore_warnings` property.
        
        Deleting a currently tagged image deletes the tag from the repository.
        
        You cannot ignore errors. It is not possible to directly delete children of multi-arch images.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostNamespacesDeleteImagesRequest, base_url, '/v2/namespaces/{namespace}/delete-images', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "post_namespaces_delete_images_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostNamespacesDeleteImagesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PostNamespacesDeleteImagesResponseSuccess])
                res.post_namespaces_delete_images_response_success = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PostNamespacesDeleteImagesResponseError])
                res.post_namespaces_delete_images_response_error = out
        elif http_res.status_code == 403:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    