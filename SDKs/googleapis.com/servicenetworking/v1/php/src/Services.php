<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Services 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * For service producers, provisions a new subnet in a peered service's shared VPC network in the requested region and with the requested size that's expressed as a CIDR range (number of leading bits of ipV4 network mask). The method checks against the assigned allocated ranges to find a non-conflicting IP address range. The method will reuse a subnet if subsequent calls contain the same subnet name, region, and prefix length. This method will make producer's tenant project to be a shared VPC service project as needed.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkResponse
     */
	public function servicenetworkingServicesAddSubnetwork(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:addSubnetwork', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addSubnetworkRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesAddSubnetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a private connection that establishes a VPC Network Peering connection to a VPC network in the service producer's organization. The administrator of the service consumer's VPC network invokes this method. The administrator must assign one or more allocated IP ranges for provisioning subnetworks in the service producer's VPC network. This connection is used for all supported services in the service producer's organization, so it only needs to be invoked once.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateResponse
     */
	public function servicenetworkingServicesConnectionsCreate(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/connections', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "connectionInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes a private service access connection.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionResponse
     */
	public function servicenetworkingServicesConnectionsDeleteConnection(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "deleteConnectionRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsDeleteConnectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the private connections that are configured in a service consumer's VPC network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListResponse
     */
	public function servicenetworkingServicesConnectionsList(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/connections', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listConnectionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListConnectionsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates the allocated ranges that are assigned to a connection.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchResponse
     */
	public function servicenetworkingServicesConnectionsPatch(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "connectionInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesConnectionsPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Disables VPC service controls for a connection.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsResponse
     */
	public function servicenetworkingServicesDisableVpcServiceControls(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:disableVpcServiceControls', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "disableVpcServiceControlsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDisableVpcServiceControlsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to add DNS record sets to private DNS zones in the shared producer host project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddResponse
     */
	public function servicenetworkingServicesDnsRecordSetsAdd(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/dnsRecordSets:add', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addDnsRecordSetRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsAddResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to remove DNS record sets from private DNS zones in the shared producer host project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveResponse
     */
	public function servicenetworkingServicesDnsRecordSetsRemove(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/dnsRecordSets:remove', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "removeDnsRecordSetRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsRemoveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to update DNS record sets from private DNS zones in the shared producer host project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateResponse
     */
	public function servicenetworkingServicesDnsRecordSetsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/dnsRecordSets:update', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateDnsRecordSetRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsRecordSetsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to add private DNS zones in the shared producer host project and matching peering zones in the consumer project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddResponse
     */
	public function servicenetworkingServicesDnsZonesAdd(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/dnsZones:add', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addDnsZoneRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesAddResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to remove private DNS zones in the shared producer host project and matching peering zones in the consumer project.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveResponse
     */
	public function servicenetworkingServicesDnsZonesRemove(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/dnsZones:remove', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "removeDnsZoneRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesDnsZonesRemoveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Enables VPC service controls for a connection.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsResponse
     */
	public function servicenetworkingServicesEnableVpcServiceControls(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:enableVpcServiceControls', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "enableVpcServiceControlsRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesEnableVpcServiceControlsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers use this method to get the configuration of their connection including the import/export of custom routes and subnetwork routes with public IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetResponse
     */
	public function servicenetworkingServicesProjectsGlobalNetworksGet(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->consumerConfig = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConsumerConfig', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a peered DNS domain which sends requests for records in given namespace originating in the service producer VPC network to the consumer VPC network to be resolved.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateResponse
     */
	public function servicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreate(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/peeredDnsDomains', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "peeredDnsDomain", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes a peered DNS domain.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteResponse
     */
	public function servicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDelete(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{name}', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists peered DNS domains for a connection.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListResponse
     */
	public function servicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsList(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/peeredDnsDomains', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksPeeredDnsDomainsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listPeeredDnsDomainsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListPeeredDnsDomainsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers use this method to update the configuration of their connection including the import/export of custom routes and subnetwork routes with public IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigResponse
     */
	public function servicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfig(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:updateConsumerConfig', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateConsumerConfigRequestInput", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesProjectsGlobalNetworksUpdateConsumerConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to add roles in the shared VPC host project. Each role is bound to the provided member. Each role must be selected from within an allowlisted set of roles. Each role is applied at only the granularity specified in the allowlist.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddResponse
     */
	public function servicenetworkingServicesRolesAdd(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}/roles:add', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "addRolesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesRolesAddResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers can use this method to find a currently unused range within consumer allocated ranges. This returned range is not reserved, and not guaranteed to remain unused. It will validate previously provided allocated ranges, find non-conflicting sub-range of requested size (expressed in number of leading bits of ipv4 network mask, as in CIDR range notation).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeResponse
     */
	public function servicenetworkingServicesSearchRange(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:searchRange', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "searchRangeRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesSearchRangeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->operation = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Operation', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Service producers use this method to validate if the consumer provided network, project and requested range are valid. This allows them to use a fail-fast mechanism for consumer requests, and not have to wait for AddSubnetwork operation completion to determine if user request is invalid.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateResponse
     */
	public function servicenetworkingServicesValidate(
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/{parent}:validate', \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "validateConsumerConfigRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ServicenetworkingServicesValidateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->validateConsumerConfigResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ValidateConsumerConfigResponse', 'json');
            }
        }

        return $response;
    }
}