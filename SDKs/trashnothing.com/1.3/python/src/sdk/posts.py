"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Posts:
    r"""Retrieve and update posts."""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def bookmark_post(self, request: operations.BookmarkPostRequest) -> operations.BookmarkPostResponse:
        r"""Bookmark a post"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.BookmarkPostRequest, base_url, '/posts/{post_id}/bookmark', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.BookmarkPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_bookmark(self, request: operations.DeleteBookmarkRequest) -> operations.DeleteBookmarkResponse:
        r"""Delete a post bookmark"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteBookmarkRequest, base_url, '/posts/{post_id}/bookmark', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteBookmarkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_post(self, request: operations.DeletePostRequest) -> operations.DeletePostResponse:
        r"""Delete a post
        Users can delete posts they have made that have been satisfied or withdrawn or that have expired. Deleting posts isn't intended to be a normal part of the posting process since it makes reposting and viewing old posts harder.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeletePostRequest, base_url, '/posts/{post_id}', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeletePostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_all_posts(self, request: operations.GetAllPostsRequest, security: operations.GetAllPostsSecurity) -> operations.GetAllPostsResponse:
        r"""List all posts
        This endpoint provides an easy way to get a feed of all the publicly published posts on trash nothing. It provides access to all publicly published offer and wanted posts from the last 30 days. The posts are sorted by date (newest first). <br /><br /> There are fewer options for filtering, sorting and searching posts with this endpoint but there is no 1,000 post limit and posts that are crossposted to multiple groups are not merged together in the response.  In most cases, crossposted posts are easy to detect because they have the same user_id, title and content.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/posts/all'
        
        query_params = utils.get_query_params(operations.GetAllPostsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAllPostsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetAllPosts200ApplicationJSON])
                res.get_all_posts_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def get_all_posts_changes(self, request: operations.GetAllPostsChangesRequest, security: operations.GetAllPostsChangesSecurity) -> operations.GetAllPostsChangesResponse:
        r"""List all post changes
        This endpoint provides an easy way to get a feed of all the changes that have been made to publicly published posts on trash nothing.  Similar to the /posts/all endpoint, only data from the last 30 days is available and the changes are sorted by date (newest first).  Every change includes the date of the change, the post_id of the post that was changed and the type of change. <br /><br /> The different types of changes that are returned are listed below. <br /><br /> - deleted<br /> - undeleted<br /> - satisfied<br /> - promised<br /> - unpromised<br /> - withdrawn<br /> - edited<br /> <br /> For edited changes, clients can use the retrieve post API endpoint to get the edits that have been made to the post.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/posts/all/changes'
        
        query_params = utils.get_query_params(operations.GetAllPostsChangesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAllPostsChangesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetAllPostsChanges200ApplicationJSON])
                res.get_all_posts_changes_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def get_post(self, request: operations.GetPostRequest, security: operations.GetPostSecurity) -> operations.GetPostResponse:
        r"""Retrieve a post"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPostRequest, base_url, '/posts/{post_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Post])
                res.post = out
        elif http_res.status_code in [403, 404]:
            pass

        return res

    def get_post_and_related_data(self, request: operations.GetPostAndRelatedDataRequest, security: operations.GetPostAndRelatedDataSecurity) -> operations.GetPostAndRelatedDataResponse:
        r"""Retrieve post display data
        Retrieve a post and other data related to the post that is useful for displaying the post such as data about the user who posted the post and the groups the post was posted on.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPostAndRelatedDataRequest, base_url, '/posts/{post_id}/display', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPostAndRelatedDataResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetPostAndRelatedData200ApplicationJSON])
                res.get_post_and_related_data_200_application_json_object = out
        elif http_res.status_code in [403, 404]:
            pass

        return res

    def get_posts(self, request: operations.GetPostsRequest, security: operations.GetPostsSecurity) -> operations.GetPostsResponse:
        r"""List posts
        NOTE: When paging through the posts returned by this endpoint, there will be at most 1,000 posts that can be returned (eg. 50 pages worth of posts with the default per_page value of 20).  In areas where there are more than 1,000 posts, clients can use more specific query parameters to adjust which posts are returned.
        NOTE: Passing the latitude, longitude and radius parameters filters all posts by their location and so these parameters will temporarily override the current users' location preferences. When latitude, longitude and radius are not specified, public posts will be filtered by the current users' location preferences.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/posts'
        
        query_params = utils.get_query_params(operations.GetPostsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPostsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetPosts200ApplicationJSON])
                res.get_posts_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def get_posts_by_ids(self, request: operations.GetPostsByIdsRequest, security: operations.GetPostsByIdsSecurity) -> operations.GetPostsByIdsResponse:
        r"""Retrieve multiple posts"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/posts/multiple'
        
        query_params = utils.get_query_params(operations.GetPostsByIdsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPostsByIdsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetPostsByIds200ApplicationJSON])
                res.get_posts_by_ids_200_application_json_object = out

        return res

    def promise_post(self, request: operations.PromisePostRequest) -> operations.PromisePostResponse:
        r"""Promise an offer post
        Mark an offer by the current user as promised to someone. This helps people viewing the post know that the items being offered may soon be given away as long as the person who was promised the items picks them up.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PromisePostRequest, base_url, '/posts/{post_id}/promise', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PromisePostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Post])
                res.post = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    def reply_to_post(self, request: operations.ReplyToPostRequest) -> operations.ReplyToPostResponse:
        r"""Reply to a post
        Send a reply to a post from the current user to the post author.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReplyToPostRequest, base_url, '/posts/{post_id}/reply', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReplyToPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def report_post(self, request: operations.ReportPostRequest) -> operations.ReportPostResponse:
        r"""Report a post
        Reports a post to be reviewed by the moderators.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReportPostRequest, base_url, '/posts/{post_id}/report', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReportPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def satisfy_post(self, request: operations.SatisfyPostRequest) -> operations.SatisfyPostResponse:
        r"""Satisfy a post
        Mark an offer or wanted post by the current user as satisfied (eg. an offer has been taken or a wanted has been received).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SatisfyPostRequest, base_url, '/posts/{post_id}/satisfy', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SatisfyPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Post])
                res.post = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    def search_posts(self, request: operations.SearchPostsRequest, security: operations.SearchPostsSecurity) -> operations.SearchPostsResponse:
        r"""Search posts
        Searching posts takes the same arguments as listing posts except for the addition of the search and sort_by parameters.
        NOTE: When paging through the posts returned by this endpoint, there will be at most 1,000 posts that can be returned (eg. 50 pages worth of posts with the default per_page value of 20).  In areas where there are more than 1,000 posts, clients can use more specific query parameters to adjust which posts are returned.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/posts/search'
        
        query_params = utils.get_query_params(operations.SearchPostsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchPostsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.SearchPosts200ApplicationJSON])
                res.search_posts_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def share_post(self, request: operations.SharePostRequest) -> operations.SharePostResponse:
        r"""Share a post
        Forwards a copy of the post to the current user so that they can forward it to friends.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.SharePostRequest, base_url, '/posts/{post_id}/share', request)
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SharePostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def submit_post(self, request: operations.SubmitPostRequestBody) -> operations.SubmitPostResponse:
        r"""Submit a post
        Submits a new post.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/posts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SubmitPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.SubmitPost200ApplicationJSON])
                res.submit_post_200_application_json_object = out
        elif http_res.status_code == 400:
            pass

        return res

    def unpromise_post(self, request: operations.UnpromisePostRequest) -> operations.UnpromisePostResponse:
        r"""Unpromise an offer post
        Mark an offer by the current user as unpromised.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UnpromisePostRequest, base_url, '/posts/{post_id}/unpromise', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UnpromisePostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Post])
                res.post = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    def update_post(self, request: operations.UpdatePostRequest) -> operations.UpdatePostResponse:
        r"""Update a post
        Users can update posts to fix mistakes with their post, add photos, or add more details about the items. Updates should not be used to say that items in a post have been taken or received since the post satisfy endpoint is designed to do that.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdatePostRequest, base_url, '/posts/{post_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdatePostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UpdatePost200ApplicationJSON])
                res.update_post_200_application_json_object = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    def withdraw_post(self, request: operations.WithdrawPostRequest) -> operations.WithdrawPostResponse:
        r"""Withdraw a post
        Mark an offer or wanted post by the current user as withdrawn.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.WithdrawPostRequest, base_url, '/posts/{post_id}/withdraw', request)
        
        
        client = self._security_client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WithdrawPostResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Post])
                res.post = out
        elif http_res.status_code in [400, 403, 404]:
            pass

        return res

    