// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"time"
)

// SiteEntityBundleActivityNotificationsEnum - Do Bundle owners receive activity notifications?
type SiteEntityBundleActivityNotificationsEnum string

const (
	SiteEntityBundleActivityNotificationsEnumNever            SiteEntityBundleActivityNotificationsEnum = "never"
	SiteEntityBundleActivityNotificationsEnumAlways           SiteEntityBundleActivityNotificationsEnum = "always"
	SiteEntityBundleActivityNotificationsEnumPerBundleSetting SiteEntityBundleActivityNotificationsEnum = "per_bundle_setting"
)

func (e SiteEntityBundleActivityNotificationsEnum) ToPointer() *SiteEntityBundleActivityNotificationsEnum {
	return &e
}

func (e *SiteEntityBundleActivityNotificationsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "never":
		fallthrough
	case "always":
		fallthrough
	case "per_bundle_setting":
		*e = SiteEntityBundleActivityNotificationsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityBundleActivityNotificationsEnum: %v", v)
	}
}

// SiteEntityBundleRegistrationNotificationsEnum - Do Bundle owners receive registration notification?
type SiteEntityBundleRegistrationNotificationsEnum string

const (
	SiteEntityBundleRegistrationNotificationsEnumNever            SiteEntityBundleRegistrationNotificationsEnum = "never"
	SiteEntityBundleRegistrationNotificationsEnumAlways           SiteEntityBundleRegistrationNotificationsEnum = "always"
	SiteEntityBundleRegistrationNotificationsEnumPerBundleSetting SiteEntityBundleRegistrationNotificationsEnum = "per_bundle_setting"
)

func (e SiteEntityBundleRegistrationNotificationsEnum) ToPointer() *SiteEntityBundleRegistrationNotificationsEnum {
	return &e
}

func (e *SiteEntityBundleRegistrationNotificationsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "never":
		fallthrough
	case "always":
		fallthrough
	case "per_bundle_setting":
		*e = SiteEntityBundleRegistrationNotificationsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityBundleRegistrationNotificationsEnum: %v", v)
	}
}

// SiteEntityBundleUploadReceiptNotificationsEnum - Do Bundle uploaders receive upload confirmation notifications?
type SiteEntityBundleUploadReceiptNotificationsEnum string

const (
	SiteEntityBundleUploadReceiptNotificationsEnumNever            SiteEntityBundleUploadReceiptNotificationsEnum = "never"
	SiteEntityBundleUploadReceiptNotificationsEnumAlways           SiteEntityBundleUploadReceiptNotificationsEnum = "always"
	SiteEntityBundleUploadReceiptNotificationsEnumPerBundleSetting SiteEntityBundleUploadReceiptNotificationsEnum = "per_bundle_setting"
)

func (e SiteEntityBundleUploadReceiptNotificationsEnum) ToPointer() *SiteEntityBundleUploadReceiptNotificationsEnum {
	return &e
}

func (e *SiteEntityBundleUploadReceiptNotificationsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "never":
		fallthrough
	case "always":
		fallthrough
	case "per_bundle_setting":
		*e = SiteEntityBundleUploadReceiptNotificationsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityBundleUploadReceiptNotificationsEnum: %v", v)
	}
}

// SiteEntityDomainLetsencryptChainEnum - Letsencrypt chain to use when registering SSL Certificate for domain.
type SiteEntityDomainLetsencryptChainEnum string

const (
	SiteEntityDomainLetsencryptChainEnumDefault     SiteEntityDomainLetsencryptChainEnum = "default"
	SiteEntityDomainLetsencryptChainEnumIsrgRootX1  SiteEntityDomainLetsencryptChainEnum = "isrg_root_x1"
	SiteEntityDomainLetsencryptChainEnumDstRootCaX3 SiteEntityDomainLetsencryptChainEnum = "dst_root_ca_x3"
)

func (e SiteEntityDomainLetsencryptChainEnum) ToPointer() *SiteEntityDomainLetsencryptChainEnum {
	return &e
}

func (e *SiteEntityDomainLetsencryptChainEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "default":
		fallthrough
	case "isrg_root_x1":
		fallthrough
	case "dst_root_ca_x3":
		*e = SiteEntityDomainLetsencryptChainEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityDomainLetsencryptChainEnum: %v", v)
	}
}

// SiteEntityOfficeIntegrationTypeEnum - Office integration application used to edit and view the MS Office documents
type SiteEntityOfficeIntegrationTypeEnum string

const (
	SiteEntityOfficeIntegrationTypeEnumOnlyOffice SiteEntityOfficeIntegrationTypeEnum = "only_office"
	SiteEntityOfficeIntegrationTypeEnumOffice365  SiteEntityOfficeIntegrationTypeEnum = "office_365"
	SiteEntityOfficeIntegrationTypeEnumDisabled   SiteEntityOfficeIntegrationTypeEnum = "disabled"
)

func (e SiteEntityOfficeIntegrationTypeEnum) ToPointer() *SiteEntityOfficeIntegrationTypeEnum {
	return &e
}

func (e *SiteEntityOfficeIntegrationTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "only_office":
		fallthrough
	case "office_365":
		fallthrough
	case "disabled":
		*e = SiteEntityOfficeIntegrationTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityOfficeIntegrationTypeEnum: %v", v)
	}
}

// SiteEntityRequire2faUserTypeEnum - What type of user is required to use two-factor authentication (when require_2fa is set to `true` for this site)?
type SiteEntityRequire2faUserTypeEnum string

const (
	SiteEntityRequire2faUserTypeEnumAll                 SiteEntityRequire2faUserTypeEnum = "all"
	SiteEntityRequire2faUserTypeEnumFolderAndSiteAdmins SiteEntityRequire2faUserTypeEnum = "folder_and_site_admins"
	SiteEntityRequire2faUserTypeEnumSiteAdmins          SiteEntityRequire2faUserTypeEnum = "site_admins"
)

func (e SiteEntityRequire2faUserTypeEnum) ToPointer() *SiteEntityRequire2faUserTypeEnum {
	return &e
}

func (e *SiteEntityRequire2faUserTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		fallthrough
	case "folder_and_site_admins":
		fallthrough
	case "site_admins":
		*e = SiteEntityRequire2faUserTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityRequire2faUserTypeEnum: %v", v)
	}
}

// SiteEntitySftpHostKeyTypeEnum - Sftp Host Key Type
type SiteEntitySftpHostKeyTypeEnum string

const (
	SiteEntitySftpHostKeyTypeEnumDefault  SiteEntitySftpHostKeyTypeEnum = "default"
	SiteEntitySftpHostKeyTypeEnumExavault SiteEntitySftpHostKeyTypeEnum = "exavault"
	SiteEntitySftpHostKeyTypeEnumCustom   SiteEntitySftpHostKeyTypeEnum = "custom"
)

func (e SiteEntitySftpHostKeyTypeEnum) ToPointer() *SiteEntitySftpHostKeyTypeEnum {
	return &e
}

func (e *SiteEntitySftpHostKeyTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "default":
		fallthrough
	case "exavault":
		fallthrough
	case "custom":
		*e = SiteEntitySftpHostKeyTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntitySftpHostKeyTypeEnum: %v", v)
	}
}

// SiteEntityWelcomeScreenEnum - Does the welcome screen appear?
type SiteEntityWelcomeScreenEnum string

const (
	SiteEntityWelcomeScreenEnumEnabled  SiteEntityWelcomeScreenEnum = "enabled"
	SiteEntityWelcomeScreenEnumHidden   SiteEntityWelcomeScreenEnum = "hidden"
	SiteEntityWelcomeScreenEnumDisabled SiteEntityWelcomeScreenEnum = "disabled"
)

func (e SiteEntityWelcomeScreenEnum) ToPointer() *SiteEntityWelcomeScreenEnum {
	return &e
}

func (e *SiteEntityWelcomeScreenEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "hidden":
		fallthrough
	case "disabled":
		*e = SiteEntityWelcomeScreenEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SiteEntityWelcomeScreenEnum: %v", v)
	}
}

// SiteEntity - Show site settings
type SiteEntity struct {
	// Id of the currently selected custom SFTP Host Key
	ActiveSftpHostKeyID *int `json:"active_sftp_host_key_id,omitempty"`
	// User ID for the main site administrator
	AdminUserID *int `json:"admin_user_id,omitempty"`
	// Are manual Bundle names allowed?
	AllowBundleNames *bool `json:"allow_bundle_names,omitempty"`
	// Are users allowed to configure their two factor authentication to be bypassed for FTP/SFTP/WebDAV?
	Allowed2faMethodBypassForFtpSftpDav *bool `json:"allowed_2fa_method_bypass_for_ftp_sftp_dav,omitempty"`
	// Is SMS two factor authentication allowed?
	Allowed2faMethodSms *bool `json:"allowed_2fa_method_sms,omitempty"`
	// Is TOTP two factor authentication allowed?
	Allowed2faMethodTotp *bool `json:"allowed_2fa_method_totp,omitempty"`
	// Is U2F two factor authentication allowed?
	Allowed2faMethodU2f *bool `json:"allowed_2fa_method_u2f,omitempty"`
	// Is WebAuthn two factor authentication allowed?
	Allowed2faMethodWebauthn *bool `json:"allowed_2fa_method_webauthn,omitempty"`
	// Is yubikey two factor authentication allowed?
	Allowed2faMethodYubi *bool `json:"allowed_2fa_method_yubi,omitempty"`
	// Comma seperated list of allowed Country codes
	AllowedCountries *string `json:"allowed_countries,omitempty"`
	// List of allowed IP addresses
	AllowedIps *string `json:"allowed_ips,omitempty"`
	// If false, rename conflicting files instead of asking for overwrite confirmation.  Only applies to web interface.
	AskAboutOverwrites *bool `json:"ask_about_overwrites,omitempty"`
	// Do Bundle owners receive activity notifications?
	BundleActivityNotifications *SiteEntityBundleActivityNotificationsEnum `json:"bundle_activity_notifications,omitempty"`
	// Site-wide Bundle expiration in days
	BundleExpiration *int `json:"bundle_expiration,omitempty"`
	// Do Bundles require password protection?
	BundlePasswordRequired *bool `json:"bundle_password_required,omitempty"`
	// Do Bundle owners receive registration notification?
	BundleRegistrationNotifications *SiteEntityBundleRegistrationNotificationsEnum `json:"bundle_registration_notifications,omitempty"`
	// Do Bundles require recipients for sharing?
	BundleRequireShareRecipient *bool `json:"bundle_require_share_recipient,omitempty"`
	// Do Bundle uploaders receive upload confirmation notifications?
	BundleUploadReceiptNotifications *SiteEntityBundleUploadReceiptNotificationsEnum `json:"bundle_upload_receipt_notifications,omitempty"`
	BundleWatermarkAttachment        *ImageEntity                                    `json:"bundle_watermark_attachment,omitempty"`
	// Preview watermark settings applied to all bundle items. Uses the same keys as Behavior.value
	BundleWatermarkValue map[string]interface{} `json:"bundle_watermark_value,omitempty"`
	// Page link and button color
	Color2Left *string `json:"color2_left,omitempty"`
	// Top bar link color
	Color2Link *string `json:"color2_link,omitempty"`
	// Page link and button color
	Color2Text *string `json:"color2_text,omitempty"`
	// Top bar background color
	Color2Top *string `json:"color2_top,omitempty"`
	// Top bar text color
	Color2TopText *string `json:"color2_top_text,omitempty"`
	// Site main contact name
	ContactName *string `json:"contact_name,omitempty"`
	// Time this site was created
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// Preferred currency
	Currency *string `json:"currency,omitempty"`
	// Is this site using a custom namespace for users?
	CustomNamespace *bool `json:"custom_namespace,omitempty"`
	// Number of days to keep deleted files
	DaysToRetainBackups *int `json:"days_to_retain_backups,omitempty"`
	// Site default time zone
	DefaultTimeZone *string `json:"default_time_zone,omitempty"`
	// Is the desktop app enabled?
	DesktopApp *bool `json:"desktop_app,omitempty"`
	// Is desktop app session IP pinning enabled?
	DesktopAppSessionIPPinning *bool `json:"desktop_app_session_ip_pinning,omitempty"`
	// Desktop app session lifetime (in hours)
	DesktopAppSessionLifetime *int `json:"desktop_app_session_lifetime,omitempty"`
	// If set, Files.com will not set the CAA records required to generate future SSL certificates for this domain.
	DisableFilesCertificateGeneration *bool `json:"disable_files_certificate_generation,omitempty"`
	// Are notifications disabled?
	DisableNotifications *bool `json:"disable_notifications,omitempty"`
	// Is password reset disabled?
	DisablePasswordReset *bool `json:"disable_password_reset,omitempty"`
	// If greater than zero, users will unable to login if they do not show activity within this number of days.
	DisableUsersFromInactivityPeriodDays *int `json:"disable_users_from_inactivity_period_days,omitempty"`
	// Comma seperated list of disallowed Country codes
	DisallowedCountries *string `json:"disallowed_countries,omitempty"`
	// Custom domain
	Domain *string `json:"domain,omitempty"`
	// Send HSTS (HTTP Strict Transport Security) header when visitors access the site via a custom domain?
	DomainHstsHeader *bool `json:"domain_hsts_header,omitempty"`
	// Letsencrypt chain to use when registering SSL Certificate for domain.
	DomainLetsencryptChain *SiteEntityDomainLetsencryptChainEnum `json:"domain_letsencrypt_chain,omitempty"`
	// Main email for this site
	Email *string `json:"email,omitempty"`
	// If true, permissions for this site must be bound to a group (not a user). Otherwise, permissions must be bound to a user.
	FolderPermissionsGroupsOnly *bool `json:"folder_permissions_groups_only,omitempty"`
	// Is FTP enabled?
	FtpEnabled *bool `json:"ftp_enabled,omitempty"`
	// Is there a signed HIPAA BAA between Files.com and this site?
	Hipaa   *bool        `json:"hipaa,omitempty"`
	Icon128 *ImageEntity `json:"icon128,omitempty"`
	Icon16  *ImageEntity `json:"icon16,omitempty"`
	Icon32  *ImageEntity `json:"icon32,omitempty"`
	Icon48  *ImageEntity `json:"icon48,omitempty"`
	// Can files be modified?
	ImmutableFilesSetAt *time.Time `json:"immutable_files_set_at,omitempty"`
	// Include password in emails to new users?
	IncludePasswordInWelcomeEmail *bool `json:"include_password_in_welcome_email,omitempty"`
	// Site default language
	Language *string `json:"language,omitempty"`
	// Base DN for looking up users in LDAP server
	LdapBaseDn *string `json:"ldap_base_dn,omitempty"`
	// Domain name that will be appended to usernames
	LdapDomain *string `json:"ldap_domain,omitempty"`
	// Main LDAP setting: is LDAP enabled?
	LdapEnabled *bool `json:"ldap_enabled,omitempty"`
	// Should we sync groups from LDAP server?
	LdapGroupAction *string `json:"ldap_group_action,omitempty"`
	// Comma or newline separated list of group names (with optional wildcards) to exclude when syncing.
	LdapGroupExclusion *string `json:"ldap_group_exclusion,omitempty"`
	// Comma or newline separated list of group names (with optional wildcards) to include when syncing.
	LdapGroupInclusion *string `json:"ldap_group_inclusion,omitempty"`
	// LDAP host
	LdapHost *string `json:"ldap_host,omitempty"`
	// LDAP backup host
	LdapHost2 *string `json:"ldap_host_2,omitempty"`
	// LDAP backup host
	LdapHost3 *string `json:"ldap_host_3,omitempty"`
	// LDAP port
	LdapPort *int `json:"ldap_port,omitempty"`
	// Use secure LDAP?
	LdapSecure *bool `json:"ldap_secure,omitempty"`
	// LDAP type
	LdapType *string `json:"ldap_type,omitempty"`
	// Should we sync users from LDAP server?
	LdapUserAction *string `json:"ldap_user_action,omitempty"`
	// Comma or newline separated list of group names (with optional wildcards) - if provided, only users in these groups will be added or synced.
	LdapUserIncludeGroups *string `json:"ldap_user_include_groups,omitempty"`
	// Username for signing in to LDAP server.
	LdapUsername *string `json:"ldap_username,omitempty"`
	// LDAP username field
	LdapUsernameField *string `json:"ldap_username_field,omitempty"`
	// Login help text
	LoginHelpText *string      `json:"login_help_text,omitempty"`
	Logo          *ImageEntity `json:"logo,omitempty"`
	// Number of prior passwords to disallow
	MaxPriorPasswords *int `json:"max_prior_passwords,omitempty"`
	// Is the mobile app enabled?
	MobileApp *bool `json:"mobile_app,omitempty"`
	// Is mobile app session IP pinning enabled?
	MobileAppSessionIPPinning *bool `json:"mobile_app_session_ip_pinning,omitempty"`
	// Mobile app session lifetime (in hours)
	MobileAppSessionLifetime *int `json:"mobile_app_session_lifetime,omitempty"`
	// A message to show users when they connect via FTP or SFTP.
	MotdText *string `json:"motd_text,omitempty"`
	// Show message to users connecting via FTP
	MotdUseForFtp *bool `json:"motd_use_for_ftp,omitempty"`
	// Show message to users connecting via SFTP
	MotdUseForSftp *bool `json:"motd_use_for_sftp,omitempty"`
	// Site name
	Name *string `json:"name,omitempty"`
	// Next billing amount
	NextBillingAmount *float64 `json:"next_billing_amount,omitempty"`
	// Next billing date
	NextBillingDate *string `json:"next_billing_date,omitempty"`
	// If true, groups can be manually created / modified / deleted by Site Admins. Otherwise, groups can only be managed via your SSO provider.
	NonSsoGroupsAllowed *bool `json:"non_sso_groups_allowed,omitempty"`
	// If true, users can be manually created / modified / deleted by Site Admins. Otherwise, users can only be managed via your SSO provider.
	NonSsoUsersAllowed *bool `json:"non_sso_users_allowed,omitempty"`
	// Allow users to use Office for the web?
	OfficeIntegrationAvailable *bool `json:"office_integration_available,omitempty"`
	// Office integration application used to edit and view the MS Office documents
	OfficeIntegrationType *SiteEntityOfficeIntegrationTypeEnum `json:"office_integration_type,omitempty"`
	// Link to scheduling a meeting with our Sales team
	OncehubLink *string `json:"oncehub_link,omitempty"`
	// Use servers in the USA only?
	OptOutGlobal *bool `json:"opt_out_global,omitempty"`
	// Is this site's billing overdue?
	Overdue *bool `json:"overdue,omitempty"`
	// Shortest password length for users
	PasswordMinLength *int `json:"password_min_length,omitempty"`
	// Require a letter in passwords?
	PasswordRequireLetter *bool `json:"password_require_letter,omitempty"`
	// Require lower and upper case letters in passwords?
	PasswordRequireMixed *bool `json:"password_require_mixed,omitempty"`
	// Require a number in passwords?
	PasswordRequireNumber *bool `json:"password_require_number,omitempty"`
	// Require special characters in password?
	PasswordRequireSpecial *bool `json:"password_require_special,omitempty"`
	// Require passwords that have not been previously breached? (see https://haveibeenpwned.com/)
	PasswordRequireUnbreached *bool `json:"password_require_unbreached,omitempty"`
	// Require bundles' passwords, and passwords for other items (inboxes, public shares, etc.) to conform to the same requirements as users' passwords?
	PasswordRequirementsApplyToBundles *bool `json:"password_requirements_apply_to_bundles,omitempty"`
	// Number of days password is valid
	PasswordValidityDays *int `json:"password_validity_days,omitempty"`
	// Site phone number
	Phone *string `json:"phone,omitempty"`
	// If true, we will ensure that all internal communications with any remote server are made through the primary region of the site. This setting overrides individual remote server settings.
	PinAllRemoteServersToSiteRegion *bool `json:"pin_all_remote_servers_to_site_region,omitempty"`
	// Reply-to email for this site
	ReplyToEmail *string `json:"reply_to_email,omitempty"`
	// Require two-factor authentication for all users?
	Require2fa *bool `json:"require_2fa,omitempty"`
	// If set, requirement for two-factor authentication has been scheduled to end on this date-time.
	Require2faStopTime *time.Time `json:"require_2fa_stop_time,omitempty"`
	// What type of user is required to use two-factor authentication (when require_2fa is set to `true` for this site)?
	Require2faUserType *SiteEntityRequire2faUserTypeEnum `json:"require_2fa_user_type,omitempty"`
	// Create user session (log in)
	Session *SessionEntity `json:"session,omitempty"`
	// Session expiry in hours
	SessionExpiry *float64 `json:"session_expiry,omitempty"`
	// Session expiry in minutes
	SessionExpiryMinutes *int `json:"session_expiry_minutes,omitempty"`
	// Are sessions locked to the same IP? (i.e. do users need to log in again if they change IPs?)
	SessionPinnedByIP *bool `json:"session_pinned_by_ip,omitempty"`
	// Is SFTP enabled?
	SftpEnabled *bool `json:"sftp_enabled,omitempty"`
	// Sftp Host Key Type
	SftpHostKeyType *SiteEntitySftpHostKeyTypeEnum `json:"sftp_host_key_type,omitempty"`
	// Are Insecure Ciphers allowed for SFTP?  Note:  Settting TLS Disabled -> True will always allow insecure ciphers for SFTP as well.  Enabling this is insecure.
	SftpInsecureCiphers *bool `json:"sftp_insecure_ciphers,omitempty"`
	// Use user FTP roots also for SFTP?
	SftpUserRootEnabled *bool `json:"sftp_user_root_enabled,omitempty"`
	// Allow bundle creation
	SharingEnabled *bool `json:"sharing_enabled,omitempty"`
	// Show request access link for users without access?  Currently unused.
	ShowRequestAccessLink *bool `json:"show_request_access_link,omitempty"`
	// Custom site footer text
	SiteFooter *string `json:"site_footer,omitempty"`
	// Custom site header text
	SiteHeader *string `json:"site_header,omitempty"`
	// SMTP server hostname or IP
	SMTPAddress *string `json:"smtp_address,omitempty"`
	// SMTP server authentication type
	SMTPAuthentication *string `json:"smtp_authentication,omitempty"`
	// From address to use when mailing through custom SMTP
	SMTPFrom *string `json:"smtp_from,omitempty"`
	// SMTP server port
	SMTPPort *int `json:"smtp_port,omitempty"`
	// SMTP server username
	SMTPUsername *string `json:"smtp_username,omitempty"`
	// Is SSL required?  Disabling this is insecure.
	SslRequired *bool `json:"ssl_required,omitempty"`
	// Site subdomain
	Subdomain *string `json:"subdomain,omitempty"`
	// If switching plans, when does the new plan take effect?
	SwitchToPlanDate *time.Time `json:"switch_to_plan_date,omitempty"`
	// Are Insecure TLS and SFTP Ciphers allowed?  Enabling this is insecure.
	TLSDisabled *bool `json:"tls_disabled,omitempty"`
	// Number of days left in trial
	TrialDaysLeft *int `json:"trial_days_left,omitempty"`
	// When does this Site trial expire?
	TrialUntil *time.Time `json:"trial_until,omitempty"`
	// Last time this Site was updated
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	// Do incoming emails in the Inboxes require checking for SPF/DKIM/DMARC?
	UploadsViaEmailAuthentication *bool `json:"uploads_via_email_authentication,omitempty"`
	// Allow uploaders to set `provided_modified_at` for uploaded files?
	UseProvidedModifiedAt *bool `json:"use_provided_modified_at,omitempty"`
	// Create User
	User *UserEntity `json:"user,omitempty"`
	// Will users be locked out after incorrect login attempts?
	UserLockout *bool `json:"user_lockout,omitempty"`
	// How many hours to lock user out for failed password?
	UserLockoutLockPeriod *int `json:"user_lockout_lock_period,omitempty"`
	// Number of login tries within `user_lockout_within` hours before users are locked out
	UserLockoutTries *int `json:"user_lockout_tries,omitempty"`
	// Number of hours for user lockout window
	UserLockoutWithin *int `json:"user_lockout_within,omitempty"`
	// Enable User Requests feature
	UserRequestsEnabled *bool `json:"user_requests_enabled,omitempty"`
	// Send email to site admins when a user request is received?
	UserRequestsNotifyAdmins *bool `json:"user_requests_notify_admins,omitempty"`
	// Custom text send in user welcome email
	WelcomeCustomText *string `json:"welcome_custom_text,omitempty"`
	// Include this email in welcome emails if enabled
	WelcomeEmailCc *string `json:"welcome_email_cc,omitempty"`
	// Will the welcome email be sent to new users?
	WelcomeEmailEnabled *bool `json:"welcome_email_enabled,omitempty"`
	// Include this email subject in welcome emails if enabled
	WelcomeEmailSubject *string `json:"welcome_email_subject,omitempty"`
	// Does the welcome screen appear?
	WelcomeScreen *SiteEntityWelcomeScreenEnum `json:"welcome_screen,omitempty"`
	// Does FTP user Windows emulation mode?
	WindowsModeFtp *bool `json:"windows_mode_ftp,omitempty"`
}
