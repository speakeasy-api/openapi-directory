/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

public class RouteRequest {
    /**
     * Rather than looking for the shortest or fastest path, this lets you solve two different problems related to routing:
     * With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
     * a bike trip), so we will add some randomness. This requires `ch.disable=true`.
     * With `alternative_route`, we give you not one but several routes that are close to optimal, but
     * not too similar to each other. You can control both of these features with additional parameters, see below.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("algorithm")
    public RouteRequestAlgorithmEnum algorithm;
    public RouteRequest withAlgorithm(RouteRequestAlgorithmEnum algorithm) {
        this.algorithm = algorithm;
        return this;
    }
    
    /**
     * If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("alternative_route.max_paths")
    public Integer alternativeRouteMaxPaths;
    public RouteRequest withAlternativeRouteMaxPaths(Integer alternativeRouteMaxPaths) {
        this.alternativeRouteMaxPaths = alternativeRouteMaxPaths;
        return this;
    }
    
    /**
     * If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("alternative_route.max_share_factor")
    public Double alternativeRouteMaxShareFactor;
    public RouteRequest withAlternativeRouteMaxShareFactor(Double alternativeRouteMaxShareFactor) {
        this.alternativeRouteMaxShareFactor = alternativeRouteMaxShareFactor;
        return this;
    }
    
    /**
     * If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("alternative_route.max_weight_factor")
    public Double alternativeRouteMaxWeightFactor;
    public RouteRequest withAlternativeRouteMaxWeightFactor(Double alternativeRouteMaxWeightFactor) {
        this.alternativeRouteMaxWeightFactor = alternativeRouteMaxWeightFactor;
        return this;
    }
    
    /**
     * Specify which road classes and environments you would like to avoid.
     * Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
     * Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("avoid")
    public String avoid;
    public RouteRequest withAvoid(String avoid) {
        this.avoid = avoid;
        return this;
    }
    
    /**
     * Block road access via a point with the format `latitude,longitude`
     * or an area defined by a circle `lat,lon,radius` or a rectangle `lat1,lon1,lat2,lon2`.
     * Separate several values with `;`. Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("block_area")
    public String blockArea;
    public RouteRequest withBlockArea(String blockArea) {
        this.blockArea = blockArea;
        return this;
    }
    
    /**
     * If the points for the route should be calculated at all.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("calc_points")
    public Boolean calcPoints;
    public RouteRequest withCalcPoints(Boolean calcPoints) {
        this.calcPoints = calcPoints;
        return this;
    }
    
    /**
     * Use this parameter in combination with one or more parameters from below.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ch.disable")
    public Boolean chDisable;
    public RouteRequest withChDisable(Boolean chDisable) {
        this.chDisable = chDisable;
        return this;
    }
    
    /**
     * Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("curbsides")
    public RouteRequestCurbsidesEnum[] curbsides;
    public RouteRequest withCurbsides(RouteRequestCurbsidesEnum[] curbsides) {
        this.curbsides = curbsides;
        return this;
    }
    
    /**
     * If `true`, the output will be formatted.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("debug")
    public Boolean debug;
    public RouteRequest withDebug(Boolean debug) {
        this.debug = debug;
        return this;
    }
    
    /**
     * Optional parameter to retrieve path details. You can request additional details for the route: `street_name`,
     * `time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("details")
    public String[] details;
    public RouteRequest withDetails(String[] details) {
        this.details = details;
        return this;
    }
    
    /**
     * If `true`, a third coordinate, the altitude, is included with all positions in the response.
     * This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
     * encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
     * client side that can handle three-dimensional coordinates.
     * A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("elevation")
    public Boolean elevation;
    public RouteRequest withElevation(Boolean elevation) {
        this.elevation = elevation;
        return this;
    }
    
    /**
     * Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("heading_penalty")
    public Integer headingPenalty;
    public RouteRequest withHeadingPenalty(Integer headingPenalty) {
        this.headingPenalty = headingPenalty;
        return this;
    }
    
    /**
     * Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
     * In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
     * This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("headings")
    public Integer[] headings;
    public RouteRequest withHeadings(Integer[] headings) {
        this.headings = headings;
        return this;
    }
    
    /**
     * If instructions should be calculated and returned
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("instructions")
    public Boolean instructions;
    public RouteRequest withInstructions(Boolean instructions) {
        this.instructions = instructions;
        return this;
    }
    
    /**
     * The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locale")
    public String locale;
    public RouteRequest withLocale(String locale) {
        this.locale = locale;
        return this;
    }
    
    /**
     * Normally, the calculated route will visit the points in the order you specified them.
     * If you have more than two points, you can set this parameter to `"true"` and the points may be re-ordered to minimize the total travel time.
     * Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("optimize")
    public String optimize;
    public RouteRequest withOptimize(String optimize) {
        this.optimize = optimize;
        return this;
    }
    
    /**
     * If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("pass_through")
    public Boolean passThrough;
    public RouteRequest withPassThrough(Boolean passThrough) {
        this.passThrough = passThrough;
        return this;
    }
    
    /**
     * Optional parameter. Specifies a hint for each point in the `points` array to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("point_hints")
    public String[] pointHints;
    public RouteRequest withPointHints(String[] pointHints) {
        this.pointHints = pointHints;
        return this;
    }
    
    /**
     * The points for the route in an array of `[longitude,latitude]`. For instance, if you want to calculate a route from point A to B to C
     * then you specify `points: [ [A_longitude, A_latitude], [B_longitude, B_latitude], [C_longitude, C_latitude]]
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("points")
    public Double[][] points;
    public RouteRequest withPoints(Double[][] points) {
        this.points = points;
        return this;
    }
    
    /**
     * Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
     * but requires special client code to unpack. (We provide it in our JavaScript client library!)
     * Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
     * See the description of the response format for more information.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("points_encoded")
    public Boolean pointsEncoded;
    public RouteRequest withPointsEncoded(Boolean pointsEncoded) {
        this.pointsEncoded = pointsEncoded;
        return this;
    }
    
    /**
     * If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("round_trip.distance")
    public Integer roundTripDistance;
    public RouteRequest withRoundTripDistance(Integer roundTripDistance) {
        this.roundTripDistance = roundTripDistance;
        return this;
    }
    
    /**
     * If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("round_trip.seed")
    public Long roundTripSeed;
    public RouteRequest withRoundTripSeed(Long roundTripSeed) {
        this.roundTripSeed = roundTripSeed;
        return this;
    }
    
    /**
     * Optional parameter to avoid snapping to a certain road class or road environment. Current supported values `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("snap_preventions")
    public String[] snapPreventions;
    public RouteRequest withSnapPreventions(String[] snapPreventions) {
        this.snapPreventions = snapPreventions;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("vehicle")
    public RouteRequestVehicleEnum vehicle;
    public RouteRequest withVehicle(RouteRequestVehicleEnum vehicle) {
        this.vehicle = vehicle;
        return this;
    }
    
    /**
     * Determines the way the ''best'' route is calculated. Default is `fastest`. Other options are `shortest` (e.g. for `vehicle=foot` or `bike`) and `short_fastest` which finds a reasonable balance between `shortest` and `fastest`. Requires `ch.disable=true`.
     * 
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("weighting")
    public String weighting;
    public RouteRequest withWeighting(String weighting) {
        this.weighting = weighting;
        return this;
    }
    
}
