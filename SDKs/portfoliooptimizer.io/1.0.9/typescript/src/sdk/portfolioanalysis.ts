/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class PortfolioAnalysis {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Alpha
   *
   * @remarks
   * Compute the Jensenâ€™s alpha of one or several portfolio(s) in the Capital Asset Pricing Model (CAPM).
   *
   * References
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   *
   */
  postPortfolioAnalysisAlpha(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisAlphaResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/alpha";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisAlphaResponse =
        new operations.PostPortfolioAnalysisAlphaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisAlpha200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisAlpha200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Beta
   *
   * @remarks
   * Compute the beta of one or several portfolio(s) in the Capital Asset Pricing Model (CAPM).
   *
   * References
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   *
   */
  postPortfolioAnalysisBeta(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisBetaResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/portfolio/analysis/beta";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisBetaResponse =
        new operations.PostPortfolioAnalysisBetaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisBeta200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisBeta200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Conditional Value At Risk
   *
   * @remarks
   * Compute the conditional value at risk of one or several portfolio(s) from portfolio values.
   *
   * References
   * * [Wikipedia, Value at risk](https://en.wikipedia.org/wiki/Value_at_risk)
   * * [Acerbi, C. and Tasche, D. (2002), Expected Shortfall: A Natural Coherent Alternative to Value at Risk. Economic Notes, 31: 379-388](https://onlinelibrary.wiley.com/doi/abs/10.1111/1468-0300.00091)
   *
   */
  postPortfolioAnalysisConditionalValueAtRisk(
    req: operations.PostPortfolioAnalysisConditionalValueAtRiskRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisConditionalValueAtRiskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostPortfolioAnalysisConditionalValueAtRiskRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/portfolio/analysis/conditional-value-at-risk";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisConditionalValueAtRiskResponse =
        new operations.PostPortfolioAnalysisConditionalValueAtRiskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisConditionalValueAtRisk200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisConditionalValueAtRisk200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return Contributions
   *
   * @remarks
   * Perform a return contribution analysis of one or several portfolio(s), optionally using groups of assets.
   *
   * References
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   *
   */
  postPortfolioAnalysisContributionsReturn(
    req: operations.PostPortfolioAnalysisContributionsReturnRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisContributionsReturnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisContributionsReturnRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/contributions/return";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisContributionsReturnResponse =
        new operations.PostPortfolioAnalysisContributionsReturnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisContributionsReturn200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisContributionsReturn200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Risk Contributions
   *
   * @remarks
   * Perform a risk contribution analysis of one or several portfolio(s), optionally using groups of assets.
   *
   * References
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   *
   */
  postPortfolioAnalysisContributionsRisk(
    req: operations.PostPortfolioAnalysisContributionsRiskRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisContributionsRiskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisContributionsRiskRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/contributions/risk";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisContributionsRiskResponse =
        new operations.PostPortfolioAnalysisContributionsRiskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisContributionsRisk200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisContributionsRisk200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Correlation Spectrum
   *
   * @remarks
   * Compute the correlation spectrum of one or several portfolio(s).
   *
   * References
   * * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
   *
   */
  postPortfolioAnalysisCorrelationSpectrum(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisCorrelationSpectrumResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/correlation-spectrum";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisCorrelationSpectrumResponse =
        new operations.PostPortfolioAnalysisCorrelationSpectrumResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisCorrelationSpectrum200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisCorrelationSpectrum200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Diversification Ratio
   *
   * @remarks
   * Compute the diversification ratio of one or several portfolio(s).
   *
   * References
   * * [Yves Choueifaty and Yves Coignard, Toward Maximum Diversification, The Journal of Portfolio Management Fall 2008, 35 (1) 40-51](https://doi.org/10.3905/JPM.2008.35.1.40)
   * * [Tristan Froidure, Khalid Jalalzai and Yves Choueifaty, Portfolio Rho-Representativity, International Journal of Theoretical and Applied FinanceVol. 22, No. 07, 1950034 (2019)](https://www.worldscientific.com/doi/10.1142/S0219024919500341)
   *
   */
  postPortfolioAnalysisDiversificationRatio(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisDiversificationRatioResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/diversification-ratio";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisDiversificationRatioResponse =
        new operations.PostPortfolioAnalysisDiversificationRatioResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisDiversificationRatio200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisDiversificationRatio200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Drawdowns
   *
   * @remarks
   * Compute the drawdown function - also called the underwater equity curve -, as well as the worst 10 drawdowns of one or several portfolio(s).
   *
   * References
   * * [Wikipedia, Drawdown](https://en.wikipedia.org/wiki/Drawdown_(economics))
   *
   */
  postPortfolioAnalysisDrawdowns(
    req: operations.PostPortfolioAnalysisDrawdownsRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisDrawdownsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisDrawdownsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/drawdowns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisDrawdownsResponse =
        new operations.PostPortfolioAnalysisDrawdownsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisDrawdowns200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisDrawdowns200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Effective Number of Bets
   *
   * @remarks
   * Compute the effective number of bets of one or several portfolio(s).
   *
   * References
   * * [Meucci, Attilio and Santangelo, Alberto and Deguest, Romain, Risk Budgeting and Diversification Based on Optimized Uncorrelated Factors (November 10, 2015)](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2276632)
   *
   */
  postPortfolioAnalysisEffectiveNumberOfBets(
    req: operations.PostPortfolioAnalysisEffectiveNumberOfBetsRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisEffectiveNumberOfBetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostPortfolioAnalysisEffectiveNumberOfBetsRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/portfolio/analysis/effective-number-of-bets";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisEffectiveNumberOfBetsResponse =
        new operations.PostPortfolioAnalysisEffectiveNumberOfBetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisEffectiveNumberOfBets200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisEffectiveNumberOfBets200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Factor Exposures
   *
   * @remarks
   * Compute the exposures of one or several portfolio(s) to a set of factors, using a returns-based linear regression analysis.
   *
   * References
   * * [Measuring Factor Exposures: Uses and Abuses, Ronen Israel and Adrienne Ross, The Journal of Alternative Investments Summer 2017, 20 (1) 10-25](https://jai.pm-research.com/content/20/1/10.short)
   *
   */
  postPortfolioAnalysisFactorsExposures(
    req: operations.PostPortfolioAnalysisFactorsExposuresRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisFactorsExposuresResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisFactorsExposuresRequestBody(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/factors/exposures";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisFactorsExposuresResponse =
        new operations.PostPortfolioAnalysisFactorsExposuresResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisFactorsExposures200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisFactorsExposures200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Mean-Variance Efficient Frontier
   *
   * @remarks
   * Compute the discretized mean-variance efficient frontier associated to a list of assets, optionally subject to:
   * * Minimum and maximum weights constraints
   * * Maximum group weights constraints
   * * Minimum and maximum portfolio exposure constraint
   *
   * References
   *  * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
   *
   */
  postPortfolioAnalysisMeanVarianceEfficientFrontier(
    req: operations.PostPortfolioAnalysisMeanVarianceEfficientFrontierRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisMeanVarianceEfficientFrontierResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostPortfolioAnalysisMeanVarianceEfficientFrontierRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/portfolio/analysis/mean-variance/efficient-frontier";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisMeanVarianceEfficientFrontierResponse =
        new operations.PostPortfolioAnalysisMeanVarianceEfficientFrontierResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisMeanVarianceEfficientFrontier200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisMeanVarianceEfficientFrontier200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Mean-Variance Minimum Variance Frontier
   *
   * @remarks
   * Compute the discretized mean-variance minimum variance frontier associated to a list of assets, optionally subject to:
   * * Minimum and maximum weights constraints
   * * Maximum group weights constraints
   * * Minimum and maximum portfolio exposure constraint
   *
   * > This endpoint is similar to the endpoint [`/portfolio/analysis/mean-variance/efficient-frontier`](#post-/portfolio/analysis/mean-variance/efficient-frontier), because the mean-variance efficient frontier is the "top" portion of the mean-variance minimum variance frontier.
   *
   * References
   *  * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
   *
   */
  postPortfolioAnalysisMeanVarianceMinimumVarianceFrontier(
    req: operations.PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/portfolio/analysis/mean-variance/minimum-variance-frontier";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierResponse =
        new operations.PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontierResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisMeanVarianceMinimumVarianceFrontier200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisMeanVarianceMinimumVarianceFrontier200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Arithmetic Return
   *
   * @remarks
   * Compute the arithmetic return of one or several portfolio(s) from either:
   * * Portfolio assets arithmetic returns
   * * Portfolio values
   *
   * References
   * * [Wikipedia, Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Return)
   * * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
   *
   */
  postPortfolioAnalysisReturn(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisReturnResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/return";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisReturnResponse =
        new operations.PostPortfolioAnalysisReturnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisReturn200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisReturn200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Arithmetic Average Return
   *
   * @remarks
   * Compute the arithmetic average of the arithmetic return(s) of one or several portfolio(s).
   *
   * References
   * * [Wikipedia, Arithmetic Average Rate of Return](https://en.wikipedia.org/wiki/Rate_of_return#Arithmetic_average_rate_of_return)
   *
   */
  postPortfolioAnalysisReturnsAverage(
    req: operations.PostPortfolioAnalysisReturnsAverageRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisReturnsAverageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisReturnsAverageRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/returns/average";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisReturnsAverageResponse =
        new operations.PostPortfolioAnalysisReturnsAverageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisReturnsAverage200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisReturnsAverage200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Tracking Error
   *
   * @remarks
   * Compute the tracking error between a benchmark and one or several portfolio(s).
   *
   * References
   * * [Wikipedia, Tracking error](https://en.wikipedia.org/wiki/Tracking_error)
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   *
   */
  postPortfolioAnalysisTrackingError(
    req: operations.PostPortfolioAnalysisTrackingErrorRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisTrackingErrorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisTrackingErrorRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/tracking-error";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisTrackingErrorResponse =
        new operations.PostPortfolioAnalysisTrackingErrorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisTrackingError200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisTrackingError200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Ulcer Index
   *
   * @remarks
   * Compute the Ulcer Index of one or several portfolio(s).
   *
   * References
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   * * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
   *
   */
  postPortfolioAnalysisUlcerIndex(
    req: operations.PostPortfolioAnalysisUlcerIndexRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisUlcerIndexResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisUlcerIndexRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/ulcer-index";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisUlcerIndexResponse =
        new operations.PostPortfolioAnalysisUlcerIndexResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisUlcerIndex200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisUlcerIndex200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Ulcer Performance Index
   *
   * @remarks
   * Compute the Ulcer Performance Index of one or several portfolio(s).
   *
   * References
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   * * [Peter G. Martin, Ulcer Index, An Alternative Approach to the Measurement of Investment Risk & Risk-Adjusted Performance](http://www.tangotools.com/ui/ui.htm)
   *
   */
  postPortfolioAnalysisUlcerPerformanceIndex(
    req: operations.PostPortfolioAnalysisUlcerPerformanceIndexRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisUlcerPerformanceIndexResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostPortfolioAnalysisUlcerPerformanceIndexRequestBody(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/portfolio/analysis/ulcer-performance-index";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisUlcerPerformanceIndexResponse =
        new operations.PostPortfolioAnalysisUlcerPerformanceIndexResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisUlcerPerformanceIndex200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisUlcerPerformanceIndex200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Value At Risk
   *
   * @remarks
   * Compute the value at risk of one or several portfolio(s) from portfolio values.
   *
   * References
   * * [Wikipedia, Value at risk](https://en.wikipedia.org/wiki/Value_at_risk)
   * * [Acerbi, C. and Tasche, D. (2002), Expected Shortfall: A Natural Coherent Alternative to Value at Risk. Economic Notes, 31: 379-388](https://onlinelibrary.wiley.com/doi/abs/10.1111/1468-0300.00091)
   *
   */
  postPortfolioAnalysisValueAtRisk(
    req: operations.PostPortfolioAnalysisValueAtRiskRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisValueAtRiskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostPortfolioAnalysisValueAtRiskRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/value-at-risk";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisValueAtRiskResponse =
        new operations.PostPortfolioAnalysisValueAtRiskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisValueAtRisk200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisValueAtRisk200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Volatility
   *
   * @remarks
   * Compute the volatility (i.e., standard deviation) of one or several portfolio(s) from either:
   * * Portfolio assets covariance matrix
   * * Portfolio values
   *
   * References
   * * [Wikipedia, Standard Deviation](https://en.wikipedia.org/wiki/Standard_deviation#Finance)
   * * Carl R. Bacon, Practical Portfolio Performance Measurement and Attribution
   * * Harry M. Markowitz, Portfolio Selection, Efficient Diversification of Investments, Second edition, Blackwell Publishers Inc.
   *
   */
  postPortfolioAnalysisVolatility(
    req: any,
    config?: AxiosRequestConfig
  ): Promise<operations.PostPortfolioAnalysisVolatilityResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/portfolio/analysis/volatility";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostPortfolioAnalysisVolatilityResponse =
        new operations.PostPortfolioAnalysisVolatilityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postPortfolioAnalysisVolatility200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostPortfolioAnalysisVolatility200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
