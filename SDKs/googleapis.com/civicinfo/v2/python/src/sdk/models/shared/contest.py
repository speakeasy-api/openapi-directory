"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import candidate as shared_candidate
from ..shared import electoraldistrict as shared_electoraldistrict
from ..shared import source as shared_source
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class ContestLevelEnum(str, Enum):
    INTERNATIONAL = 'international'
    COUNTRY = 'country'
    ADMINISTRATIVE_AREA1 = 'administrativeArea1'
    REGIONAL = 'regional'
    ADMINISTRATIVE_AREA2 = 'administrativeArea2'
    LOCALITY = 'locality'
    SUB_LOCALITY1 = 'subLocality1'
    SUB_LOCALITY2 = 'subLocality2'
    SPECIAL = 'special'

class ContestRolesEnum(str, Enum):
    HEAD_OF_STATE = 'headOfState'
    HEAD_OF_GOVERNMENT = 'headOfGovernment'
    DEPUTY_HEAD_OF_GOVERNMENT = 'deputyHeadOfGovernment'
    GOVERNMENT_OFFICER = 'governmentOfficer'
    EXECUTIVE_COUNCIL = 'executiveCouncil'
    LEGISLATOR_UPPER_BODY = 'legislatorUpperBody'
    LEGISLATOR_LOWER_BODY = 'legislatorLowerBody'
    HIGHEST_COURT_JUDGE = 'highestCourtJudge'
    JUDGE = 'judge'
    SCHOOL_BOARD = 'schoolBoard'
    SPECIAL_PURPOSE_OFFICER = 'specialPurposeOfficer'
    OTHER_ROLE = 'otherRole'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Contest:
    r"""Information about a contest that appears on a voter's ballot."""
    
    ballot_placement: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ballotPlacement'), 'exclude': lambda f: f is None }})
    r"""A number specifying the position of this contest on the voter's ballot."""  
    ballot_title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ballotTitle'), 'exclude': lambda f: f is None }})
    r"""The official title on the ballot for this contest, only where available."""  
    candidates: Optional[list[shared_candidate.Candidate]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('candidates'), 'exclude': lambda f: f is None }})
    r"""The candidate choices for this contest."""  
    district: Optional[shared_electoraldistrict.ElectoralDistrict] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('district'), 'exclude': lambda f: f is None }})
    r"""Describes the geographic scope of a contest."""  
    electorate_specifications: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('electorateSpecifications'), 'exclude': lambda f: f is None }})
    r"""A description of any additional eligibility requirements for voting in this contest."""  
    level: Optional[list[ContestLevelEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('level'), 'exclude': lambda f: f is None }})
    r"""The levels of government of the office for this contest. There may be more than one in cases where a jurisdiction effectively acts at two different levels of government; for example, the mayor of the District of Columbia acts at \\"locality\\" level, but also effectively at both \\"administrative-area-2\\" and \\"administrative-area-1\\"."""  
    number_elected: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numberElected'), 'exclude': lambda f: f is None }})
    r"""The number of candidates that will be elected to office in this contest."""  
    number_voting_for: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numberVotingFor'), 'exclude': lambda f: f is None }})
    r"""The number of candidates that a voter may vote for in this contest."""  
    office: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('office'), 'exclude': lambda f: f is None }})
    r"""The name of the office for this contest."""  
    primary_parties: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('primaryParties'), 'exclude': lambda f: f is None }})
    r"""If this is a partisan election, the name of the party/parties it is for."""  
    referendum_ballot_responses: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumBallotResponses'), 'exclude': lambda f: f is None }})
    r"""The set of ballot responses for the referendum. A ballot response represents a line on the ballot. Common examples might include \\"yes\\" or \\"no\\" for referenda. This field is only populated for contests of type 'Referendum'."""  
    referendum_brief: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumBrief'), 'exclude': lambda f: f is None }})
    r"""Specifies a short summary of the referendum that is typically on the ballot below the title but above the text. This field is only populated for contests of type 'Referendum'."""  
    referendum_con_statement: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumConStatement'), 'exclude': lambda f: f is None }})
    r"""A statement in opposition to the referendum. It does not necessarily appear on the ballot. This field is only populated for contests of type 'Referendum'."""  
    referendum_effect_of_abstain: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumEffectOfAbstain'), 'exclude': lambda f: f is None }})
    r"""Specifies what effect abstaining (not voting) on the proposition will have (i.e. whether abstaining is considered a vote against it). This field is only populated for contests of type 'Referendum'."""  
    referendum_passage_threshold: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumPassageThreshold'), 'exclude': lambda f: f is None }})
    r"""The threshold of votes that the referendum needs in order to pass, e.g. \\"two-thirds\\". This field is only populated for contests of type 'Referendum'."""  
    referendum_pro_statement: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumProStatement'), 'exclude': lambda f: f is None }})
    r"""A statement in favor of the referendum. It does not necessarily appear on the ballot. This field is only populated for contests of type 'Referendum'."""  
    referendum_subtitle: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumSubtitle'), 'exclude': lambda f: f is None }})
    r"""A brief description of the referendum. This field is only populated for contests of type 'Referendum'."""  
    referendum_text: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumText'), 'exclude': lambda f: f is None }})
    r"""The full text of the referendum. This field is only populated for contests of type 'Referendum'."""  
    referendum_title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumTitle'), 'exclude': lambda f: f is None }})
    r"""The title of the referendum (e.g. 'Proposition 42'). This field is only populated for contests of type 'Referendum'."""  
    referendum_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('referendumUrl'), 'exclude': lambda f: f is None }})
    r"""A link to the referendum. This field is only populated for contests of type 'Referendum'."""  
    roles: Optional[list[ContestRolesEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('roles'), 'exclude': lambda f: f is None }})
    r"""The roles which this office fulfills."""  
    sources: Optional[list[shared_source.Source]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sources'), 'exclude': lambda f: f is None }})
    r"""A list of sources for this contest. If multiple sources are listed, the data has been aggregated from those sources."""  
    special: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('special'), 'exclude': lambda f: f is None }})
    r"""\\"Yes\\" or \\"No\\" depending on whether this a contest being held outside the normal election cycle."""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of contest. Usually this will be 'General', 'Primary', or 'Run-off' for contests with candidates. For referenda this will be 'Referendum'. For Retention contests this will typically be 'Retention'."""  
    