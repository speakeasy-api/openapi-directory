"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class CustomObjectRecords:
    r"""With Custom Objects service, you can create, update, delete and find custom object records.
    
    If you use Postman, you can import the custom objects endpoints as a collection into your Postman app and try out different requests to learn how the API works. Click the following button to get started:
    
    [![Run in Postman](https://run.pstmn.io/button.svg)](https://www.getpostman.com/run-collection/1f068ba43651bf63c0d4)
    
    You can sign up for a free account on the [Postman website](https://identity.getpostman.com/signup) and download the app in case you do not use Postman yet.
    
    Note that the Custom Object Records API is versioned by `Zuora-Version` in the request header. The response may be different for the same request with a different API version. Specify `Zuora-Version` in the request header if you expect a specific response schema.
    
    ### Error handling      
    If the Custom Objects API call fails, an error code will be returned in the response body. See [Custom Objects API error code](https://knowledgecenter.zuora.com/Central_Platform/Custom_Objects/Z_Custom_Objects_API#Custom_Objects_API_error_code) for details.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_custom_object_record_by_id(self, request: operations.DeleteCustomObjectRecordByIDRequest) -> operations.DeleteCustomObjectRecordByIDResponse:
        r"""Delete a custom object record
        Deletes a custom object record of the given type and ID.
        
        Note that 200 response will be returned under either of the following conditions:
        * The record is identified and successfully deleted
        * The record could not be found
        
        Note thatÂ the record is deleted immediately and, therefore, will not be retained upon successful deletion.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteCustomObjectRecordByIDRequest, base_url, '/objects/records/default/{object}/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCustomObjectRecordByIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                res.delete_custom_object_record_by_id_200_application_json_uri_string = http_res.content

        return res

    def get_all_records_for_custom_object_type(self, request: operations.GETAllRecordsForCustomObjectTypeRequest) -> operations.GETAllRecordsForCustomObjectTypeResponse:
        r"""List records for a custom object
        Lists all object records of the given type. You can also use the `q` query parameter to filter the output records.
        
        ## Limitations 
        
        This call has the following limitations:
        * When a record is created, there will be a delay before it is available for search. For example, if you create 5 records and perform a query that these 5 records satisfy the query conditions, there will be a delay between when the 5 records are created, and when all the 5 records can be returned in the query result.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GETAllRecordsForCustomObjectTypeRequest, base_url, '/objects/records/default/{object}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETAllRecordsForCustomObjectTypeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETAllRecordsForCustomObjectTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.QueryCustomObjectRecordsResponse])
                res.query_custom_object_records_response = out

        return res

    def get_custom_object_record_by_id(self, request: operations.GETCustomObjectRecordByIDRequest) -> operations.GETCustomObjectRecordByIDResponse:
        r"""Retrieve a custom object record
        Retrieves a record of a given type by ID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GETCustomObjectRecordByIDRequest, base_url, '/objects/records/default/{object}/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETCustomObjectRecordByIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordWithAllFields])
                res.custom_object_record_with_all_fields = out
        elif http_res.status_code == 404:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CommonErrorResponse])
                res.common_error_response = out

        return res

    def post_custom_object_records(self, request: operations.POSTCustomObjectRecordsRequest) -> operations.POSTCustomObjectRecordsResponse:
        r"""Create custom object records
        Creates custom object records with the given type. 
        
        Upon creating records of a custom object type, the 200 response contains a list of records that have been successfully processed and stored.
        
        
        ## Limitations 
        
        This call has the following limitations:
        * The maximum number of records that you can create by one call is 1,000.
        * The storage of empty strings in records is not supported.
        * Null values must be formatted as the following example: 
          ```
          {
            \"records\": [
              {
                \"fieldName__c\": null
              }
            ]
          }
          ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.POSTCustomObjectRecordsRequest, base_url, '/objects/records/default/{object}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "post_custom_object_records_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTCustomObjectRecordsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PostCustomObjectRecordsResponse])
                res.post_custom_object_records_response = out
        elif http_res.status_code == 400:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordsErrorResponse])
                res.custom_object_records_error_response = out
        elif http_res.status_code == 401:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse401Record])
                res.error_response401_record = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordsThrottledResponse])
                res.custom_object_records_throttled_response = out

        return res

    def post_custom_object_records_batch_update_or_delete(self, request: operations.POSTCustomObjectRecordsBatchUpdateOrDeleteRequest) -> operations.POSTCustomObjectRecordsBatchUpdateOrDeleteResponse:
        r"""Update or delete custom object records
        Makes a batch update or delete of custom object records.
        ## Limitations 
        
        This call has the following limitations:
        * The maximum number of records that you can update by one call is 1,000.
        * The maximum number of records that you can delete by one call is 1,000.
        * The storage of empty strings in records is not supported.
        * Null values must be formatted as the following example: 
          ```
          {
              \"action\": {
                  \"type\": \"update\",
                  \"records\": {
                      \"64edb2a5-2796-4e95-9559-846f8636a01b\": {
                          \"fieldName__c\": null
                    }
                  }
              }
          }
          ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.POSTCustomObjectRecordsBatchUpdateOrDeleteRequest, base_url, '/objects/batch/default/{object}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "custom_object_record_batch_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTCustomObjectRecordsBatchUpdateOrDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordsBatchUpdatePartialSuccessResponse])
                res.custom_object_records_batch_update_partial_success_response = out
        elif http_res.status_code == 400:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordsErrorResponse])
                res.custom_object_records_error_response = out
        elif http_res.status_code == 401:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse401Record])
                res.error_response401_record = out
        elif http_res.status_code == 500:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordsThrottledResponse])
                res.custom_object_records_throttled_response = out

        return res

    def put_custom_object_record(self, request: operations.PUTCustomObjectRecordRequest) -> operations.PUTCustomObjectRecordResponse:
        r"""Update a custom object record
        Updates a record of the given type and ID.
        
        ## Limitations 
        
        * The storage of empty strings in records is not supported.
        * Null values must be formatted as the following example: 
          ```
          {
            \"records\": [
              {
                \"fieldName__c\": null
              }
            ]
          }
          ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PUTCustomObjectRecordRequest, base_url, '/objects/records/default/{object}/{id}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PUTCustomObjectRecordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordWithAllFields])
                res.custom_object_record_with_all_fields = out
        elif http_res.status_code == 404:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CommonErrorResponse])
                res.common_error_response = out

        return res

    def patch_partial_update_custom_object_record(self, request: operations.PatchPartialUpdateCustomObjectRecordRequest) -> operations.PatchPartialUpdateCustomObjectRecordResponse:
        r"""Partially update a custom object record
        Updates one or many fields of a custom object record. Patch update uses JSON Merge Patch as specified in [RFC 7386](https://tools.ietf.org/html/rfc7386).
        
        ## Limitations 
        
        * The storage of empty strings in records is not supported.
        * Null values must be formatted as the following example: 
          ```
          {
            \"records\": [
              {
                \"fieldName__c\": null
              }
            ]
          }
          ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PatchPartialUpdateCustomObjectRecordRequest, base_url, '/objects/records/default/{object}/{id}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PatchPartialUpdateCustomObjectRecordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomObjectRecordWithAllFields])
                res.custom_object_record_with_all_fields = out
        elif http_res.status_code == 404:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CommonErrorResponse])
                res.common_error_response = out

        return res

    