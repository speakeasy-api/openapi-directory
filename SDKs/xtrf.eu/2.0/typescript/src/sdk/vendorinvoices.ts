/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class VendorInvoices {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a new payment on the vendor account and assigns the payment to the invoice.
   *
   * @remarks
   * Creates a new payment on the vendor account and assigns the payment to the invoice.
   */
  createPayment1(
    req: operations.CreatePayment1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePayment1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePayment1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}/payments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "paymentDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePayment1Response =
        new operations.CreatePayment1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new invoice.
   *
   * @remarks
   * Creates a new invoice from jobs. Jobs are grouped by provider and currency, therefore multiple invoices can be created.If any of the jobs cannot be invoiced (ie. it is already invoiced) then an error is reported.
   */
  create4(
    req: shared.ProviderInvoiceCreateDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.Create4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ProviderInvoiceCreateDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/providers/invoices";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Create4Response = new operations.Create4Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.providerInvoiceCreateResultDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProviderInvoiceCreateResultDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a provider invoice.
   *
   * @remarks
   * Removes a provider invoice.
   */
  delete6(
    req: operations.Delete6Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete6Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete6Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete6Response = new operations.Delete6Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a provider payment.
   *
   * @remarks
   * Removes a provider payment.
   */
  delete7(
    req: operations.Delete7Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete7Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete7Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/payments/{paymentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete7Response = new operations.Delete7Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Returns vendor invoices' internal identifiers.
   *
   * @remarks
   * Returns vendor invoices' internal identifiers.
   */
  getAllIds3(
    req: operations.GetAllIds3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIds3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIds3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/providers/invoices/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIds3Response =
        new operations.GetAllIds3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getAllIds3DefaultApplicationVndXtrfV1PlusJsonInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all vendor invoices in all statuses (including not ready and drafts) that have been updated since a specific date.
   *
   * @remarks
   * Lists all vendor invoices in all statuses (including not ready and drafts) that have been updated since a specific date.
   */
  getAll2(
    req: operations.GetAll2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAll2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAll2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/accounting/providers/invoices";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAll2Response = new operations.GetAll2Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.providerInvoiceDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.providerInvoiceDTOS = utils.objectToClass(
              httpRes?.data,
              shared.ProviderInvoiceDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns provider invoice details.
   *
   * @remarks
   * Returns provider invoice details.
   */
  getById3(
    req: operations.GetById3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById3Response = new operations.GetById3Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.providerInvoiceDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProviderInvoiceDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Generates provider invoice document (PDF).
   *
   * @remarks
   * Generates provider invoice document (PDF).
   */
  getDocument1(
    req: operations.GetDocument1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDocument1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDocument1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}/document",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDocument1Response =
        new operations.GetDocument1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.urlResultDTO = utils.objectToClass(
              httpRes?.data,
              shared.UrlResultDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all payments for the vendor invoice.
   *
   * @remarks
   * Returns all payments for the vendor invoice.
   */
  getPayments1(
    req: operations.GetPayments1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPayments1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPayments1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}/payments",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPayments1Response =
        new operations.GetPayments1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.paymentDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.paymentDTOS = utils.objectToClass(
              httpRes?.data,
              shared.PaymentDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends a provider invoice.
   *
   * @remarks
   * Sends a provider invoice.
   */
  send(
    req: operations.SendRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SendRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}/send",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendResponse = new operations.SendResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Changes invoice status to given status.
   *
   * @remarks
   * Changes invoice status to given status.
   */
  setStatus(
    req: operations.SetStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SetStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SetStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounting/providers/invoices/{invoiceId}/status",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "statusRequestDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SetStatusResponse =
        new operations.SetStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }
}
