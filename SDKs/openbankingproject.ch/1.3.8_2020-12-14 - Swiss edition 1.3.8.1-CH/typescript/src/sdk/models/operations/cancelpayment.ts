/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import * as shared from "../shared";
import { AxiosResponse } from "axios";

export class CancelPaymentSecurity extends SpeakeasyBase {
  @SpeakeasyMetadata({
    data: "security, scheme=true;type=http;subtype=bearer;name=Authorization",
  })
  bearerAuthOAuth?: string;
}

export class CancelPaymentRequest extends SpeakeasyBase {
  /**
   * Is contained if and only if the "Signature" element is contained in the header of the request.
   */
  @SpeakeasyMetadata({ data: "header, style=simple;explode=false;name=Digest" })
  digest?: string;

  /**
   * The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Accept",
  })
  psuAccept?: string;

  /**
   * The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Accept-Charset",
  })
  psuAcceptCharset?: string;

  /**
   * The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Accept-Encoding",
  })
  psuAcceptEncoding?: string;

  /**
   * The forwarded IP Accept header fields consist of the corresponding HTTP request Accept header fields between PSU and TPP, if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Accept-Language",
  })
  psuAcceptLanguage?: string;

  /**
   * UUID (Universally Unique Identifier) for a device, which is used by the PSU, if available.
   *
   * @remarks
   * UUID identifies either a device or a device dependant application installation.
   * In case of an installation identification this ID needs to be unaltered until removal from device.
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Device-ID",
  })
  psuDeviceID?: string;

  /**
   * The forwarded Geo Location of the corresponding http request between PSU and TPP if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Geo-Location",
  })
  psuGeoLocation?: string;

  /**
   * HTTP method used at the PSU ? TPP interface, if available.
   *
   * @remarks
   * Valid values are:
   * * GET
   * * POST
   * * PUT
   * * PATCH
   * * DELETE
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-Http-Method",
  })
  psuHttpMethod?: shared.PSUHttpMethodEnum;

  /**
   * The forwarded IP Address header field consists of the corresponding http request IP Address field between PSU and TPP.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-IP-Address",
  })
  psuIPAddress?: string;

  /**
   * The forwarded IP Port header field consists of the corresponding HTTP request IP Port field between PSU and TPP, if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-IP-Port",
  })
  psuIPPort?: string;

  /**
   * The forwarded Agent header field of the HTTP request between PSU and TPP, if available.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=PSU-User-Agent",
  })
  psuUserAgent?: string;

  /**
   * A signature of the request by the TPP on application level. This might be mandated by ASPSP.
   *
   * @remarks
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=Signature",
  })
  signature?: string;

  /**
   * If it equals "true", the TPP prefers to start the authorisation process separately,
   *
   * @remarks
   * e.g. because of the usage of a signing basket.
   * This preference might be ignored by the ASPSP, if a signing basket is not supported as functionality.
   *
   * If it equals "false" or if the parameter is not used, there is no preference of the TPP.
   * This especially indicates that the TPP assumes a direct authorisation of the transaction in the next step,
   * without using a signing basket.
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=TPP-Explicit-Authorisation-Preferred",
  })
  tppExplicitAuthorisationPreferred?: boolean;

  /**
   * If this URI is contained, the TPP is asking to redirect the transaction flow to this address instead of the TPP-Redirect-URI in case
   *
   * @remarks
   * of a negative result of the redirect SCA method. This might be ignored by the ASPSP.
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=TPP-Nok-Redirect-URI",
  })
  tppNokRedirectURI?: string;

  /**
   * If it equals "true", the TPP prefers a redirect over an embedded SCA approach.
   *
   * @remarks
   * If it equals "false", the TPP prefers not to be redirected for SCA. The ASPSP will then choose between the Embedded or the Decoupled
   * SCA approach, depending on the choice of the SCA procedure by the TPP/PSU.
   * If the parameter is not used, the ASPSP will choose the SCA approach to be applied depending on the SCA method chosen by the
   * TPP/PSU.
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=TPP-Redirect-Preferred",
  })
  tppRedirectPreferred?: boolean;

  /**
   * URI of the TPP, where the transaction flow shall be redirected to after a Redirect.
   *
   * @remarks
   *
   * Mandated for the Redirect SCA Approach, specifically
   * when TPP-Redirect-Preferred equals "true".
   * It is recommended to always use this header field.
   *
   * **Remark for Future:**
   * This field might be changed to mandatory in the next version of the specification.
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=TPP-Redirect-URI",
  })
  tppRedirectURI?: string;

  /**
   * The certificate used for signing the request, in base64 encoding.
   *
   * @remarks
   * Must be contained if a signature is contained.
   *
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=TPP-Signature-Certificate",
  })
  tppSignatureCertificate?: string;

  /**
   * ID of the request, unique to the call, as determined by the initiating party.
   */
  @SpeakeasyMetadata({
    data: "header, style=simple;explode=false;name=X-Request-ID",
  })
  xRequestID: string;

  /**
   * The addressed payment product endpoint, e.g. for SEPA Credit Transfers (SCT).
   *
   * @remarks
   * The ASPSP will publish which of the payment products/endpoints will be supported.
   *
   * The following payment products are supported:
   *   - domestic-swiss-credit-transfers-isr
   *   - domestic-swiss-credit-transfers
   *   - domestic-swiss-credit-transfers-qr
   *   - domestic-swiss-foreign-credit-transfers
   *   - swiss-sepa-credit-transfers
   *   - swiss-cross-border-credit-transfers
   *   - pain.001-sepa-credit-transfers
   *   - pain.001-cross-border-credit-transfers
   *   - pain.001-swiss-six-credit-transfers
   *
   * **Remark:** For all SEPA Credit Transfer based endpoints which accept XML encoding,
   * the XML pain.001 schemes provided by EPC are supported by the ASPSP as a minimum for the body content.
   * Further XML schemes might be supported by some communities.
   *
   * **Remark:** For cross-border and TARGET-2 payments only community wide pain.001 schemes do exist.
   * There are plenty of country specificic scheme variants.
   *
   */
  @SpeakeasyMetadata({
    data: "pathParam, style=simple;explode=false;name=payment-product",
  })
  paymentProduct: shared.PaymentProductEnum;

  /**
   * Payment service:
   *
   * @remarks
   *
   * Possible values are:
   * * payments
   * * bulk-payments
   * * periodic-payments
   *
   */
  @SpeakeasyMetadata({
    data: "pathParam, style=simple;explode=false;name=payment-service",
  })
  paymentService: shared.PaymentServiceEnum;

  /**
   * Resource identification of the generated payment initiation resource.
   */
  @SpeakeasyMetadata({
    data: "pathParam, style=simple;explode=false;name=paymentId",
  })
  paymentId: string;
}

export class CancelPaymentResponse extends SpeakeasyBase {
  @SpeakeasyMetadata()
  contentType: string;

  /**
   * Bad Request
   */
  @SpeakeasyMetadata()
  error400NGPIS?: shared.Error400NGPIS;

  /**
   * Bad Request
   */
  @SpeakeasyMetadata()
  error400PIS?: shared.Error400PIS;

  /**
   * Unauthorized
   */
  @SpeakeasyMetadata()
  error401NGPIS?: shared.Error401NGPIS;

  /**
   * Unauthorized
   */
  @SpeakeasyMetadata()
  error401PIS?: shared.Error401PIS;

  /**
   * Forbidden
   */
  @SpeakeasyMetadata()
  error403NGPIS?: shared.Error403NGPIS;

  /**
   * Forbidden
   */
  @SpeakeasyMetadata()
  error403PIS?: shared.Error403PIS;

  /**
   * Not found
   */
  @SpeakeasyMetadata()
  error404NGPIS?: shared.Error404NGPIS;

  /**
   * Not found
   */
  @SpeakeasyMetadata()
  error404PIS?: shared.Error404PIS;

  /**
   * Method Not Allowed
   */
  @SpeakeasyMetadata()
  error405NGPISCANC?: shared.Error405NGPISCANC;

  /**
   * Method Not Allowed
   */
  @SpeakeasyMetadata()
  error405PISCANC?: shared.Error405PISCANC;

  /**
   * Conflict
   */
  @SpeakeasyMetadata()
  error409NGPIS?: shared.Error409NGPIS;

  /**
   * Conflict
   */
  @SpeakeasyMetadata()
  error409PIS?: shared.Error409PIS;

  @SpeakeasyMetadata()
  headers?: Record<string, string[]>;

  @SpeakeasyMetadata()
  statusCode: number;

  @SpeakeasyMetadata()
  rawResponse?: AxiosResponse;

  /**
   * Received
   */
  @SpeakeasyMetadata()
  paymentInitiationCancelResponse202?: shared.PaymentInitiationCancelResponse202;
}
