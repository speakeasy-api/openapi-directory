/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * General data retrieval endpoints.
 */
export class Layers {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Retrieve a list of application activities
   *
   * @remarks
   * Retrieve a list of application activities. The id in the response is used for  GET /v4/layers/asApplied/{activityId}/contents.
   */
  getV4LayersAsApplied(
    req: operations.GetV4LayersAsAppliedRequest,
    security: operations.GetV4LayersAsAppliedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersAsAppliedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersAsAppliedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/layers/asApplied";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetV4LayersAsAppliedSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersAsAppliedResponse =
        new operations.GetV4LayersAsAppliedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.applicationActivities = utils.objectToClass(
              httpRes?.data,
              shared.ApplicationActivities
            );
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the raw application activity
   *
   * @remarks
   * Retrieve an individual application activity by id.  Ids are retrieved via the  /layers/asApplied route. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB`  (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`). The data is compressed using .zip format.
   */
  getV4LayersAsAppliedActivityIdContents(
    req: operations.GetV4LayersAsAppliedActivityIdContentsRequest,
    security: operations.GetV4LayersAsAppliedActivityIdContentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersAsAppliedActivityIdContentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersAsAppliedActivityIdContentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/layers/asApplied/{activityId}/contents",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetV4LayersAsAppliedActivityIdContentsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersAsAppliedActivityIdContentsResponse =
        new operations.GetV4LayersAsAppliedActivityIdContentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 401, 403, 404, 416, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of harvest activities
   *
   * @remarks
   * Retrieve a list of harvest activities. The id in the response is used for  GET /v4/layers/asHarvested/{activityId}/contents.
   */
  getV4LayersAsHarvested(
    req: operations.GetV4LayersAsHarvestedRequest,
    security: operations.GetV4LayersAsHarvestedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersAsHarvestedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersAsHarvestedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/layers/asHarvested";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetV4LayersAsHarvestedSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersAsHarvestedResponse =
        new operations.GetV4LayersAsHarvestedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.harvestActivities = utils.objectToClass(
              httpRes?.data,
              shared.HarvestActivities
            );
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the raw harvest activity
   *
   * @remarks
   * Retrieve an individual harvest activity by id.  Ids are retrieved via the  /layers/asHarvested route. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB`  (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`). The data is compressed using .zip format.
   */
  getV4LayersAsHarvestedActivityIdContents(
    req: operations.GetV4LayersAsHarvestedActivityIdContentsRequest,
    security: operations.GetV4LayersAsHarvestedActivityIdContentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersAsHarvestedActivityIdContentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersAsHarvestedActivityIdContentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/layers/asHarvested/{activityId}/contents",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetV4LayersAsHarvestedActivityIdContentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersAsHarvestedActivityIdContentsResponse =
        new operations.GetV4LayersAsHarvestedActivityIdContentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 401, 403, 404, 416, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of planting activities
   *
   * @remarks
   * Retrieve a list of planting activities. The id in the response is used for  GET /v4/layers/asPlanted/{activityId}/contents.
   */
  getV4LayersAsPlanted(
    req: operations.GetV4LayersAsPlantedRequest,
    security: operations.GetV4LayersAsPlantedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersAsPlantedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersAsPlantedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/layers/asPlanted";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetV4LayersAsPlantedSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersAsPlantedResponse =
        new operations.GetV4LayersAsPlantedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.plantingActivities = utils.objectToClass(
              httpRes?.data,
              shared.PlantingActivities
            );
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the raw planting activity
   *
   * @remarks
   * Retrieve an individual planting activity by id.  Ids are retrieved via the  /layers/asPlanted route. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB`  (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`).  The data is compressed using .zip format.
   */
  getV4LayersAsPlantedActivityIdContents(
    req: operations.GetV4LayersAsPlantedActivityIdContentsRequest,
    security: operations.GetV4LayersAsPlantedActivityIdContentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersAsPlantedActivityIdContentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersAsPlantedActivityIdContentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/layers/asPlanted/{activityId}/contents",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetV4LayersAsPlantedActivityIdContentsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersAsPlantedActivityIdContentsResponse =
        new operations.GetV4LayersAsPlantedActivityIdContentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/octet-stream`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 401, 403, 404, 416, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of scouting observations
   *
   * @remarks
   * Retrieve a list of scouting observations created or updated by the user identified by the Authorization header.
   */
  getV4LayersScoutingObservations(
    req: operations.GetV4LayersScoutingObservationsRequest,
    security: operations.GetV4LayersScoutingObservationsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersScoutingObservationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetV4LayersScoutingObservationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/layers/scoutingObservations";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetV4LayersScoutingObservationsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersScoutingObservationsResponse =
        new operations.GetV4LayersScoutingObservationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case [200, 206].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scoutingObservations = utils.objectToClass(
              httpRes?.data,
              shared.ScoutingObservations
            );
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve individual scouting observation
   *
   * @remarks
   * Retrieve an individual scouting observation by id.  Ids are retrieved via the /layers/scoutingObservations route.
   */
  getV4LayersScoutingObservationsScoutingObservationId(
    req: operations.GetV4LayersScoutingObservationsScoutingObservationIdRequest,
    security: operations.GetV4LayersScoutingObservationsScoutingObservationIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersScoutingObservationsScoutingObservationIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/layers/scoutingObservations/{scoutingObservationId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersScoutingObservationsScoutingObservationIdResponse =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scoutingObservation = utils.objectToClass(
              httpRes?.data,
              shared.ScoutingObservation
            );
          }
          break;
        case [400, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve attachments associated with a given scouting observation.
   *
   * @remarks
   * Retrieve attachments associated with a given scouting observation. Photos added to scouting notes in the FieldView app are capped to 20MB, and we won’t store photos larger than that in a scouting note.
   */
  getV4LayersScoutingObservationsScoutingObservationIdAttachments(
    req: operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsRequest,
    security: operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/layers/scoutingObservations/{scoutingObservationId}/attachments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsResponse =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scoutingObservationAttachments = utils.objectToClass(
              httpRes?.data,
              shared.ScoutingObservationAttachments
            );
          }
          break;
        case httpRes?.status == 206:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scoutingObservationAttachments = utils.objectToClass(
              httpRes?.data,
              shared.ScoutingObservationAttachments
            );
          }
          break;
        case httpRes?.status == 304:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
        case [400, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the binary contents of a scouting observation’s attachment.
   *
   * @remarks
   * Photos added to scouting notes in the FieldView app are capped to `20MiB` (`20971520 bytes`), and we won’t store photos larger than that in a scouting note. Downloads larger than `5MiB` (`5242880 bytes`) in size, must be downloaded in chunks no larger than `5MiB` (`5242880 bytes`) and no smaller than `1MiB` (`1048576 bytes`). The last chunk could be less than `1MiB` (`1048576 bytes`).
   */
  getV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContents(
    req: operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsRequest,
    security: operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/layers/scoutingObservations/{scoutingObservationId}/attachments/{attachmentId}/contents",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsResponse =
        new operations.GetV4LayersScoutingObservationsScoutingObservationIdAttachmentsAttachmentIdContentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `image/jpeg`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `image/png`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case httpRes?.status == 206:
          if (utils.matchContentType(contentType, `image/jpeg`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [400, 401, 403, 404, 416, 500, 503].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }
}
