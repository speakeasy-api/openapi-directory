"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import startingposition_enum as shared_startingposition_enum
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class KinesisStreamingSourceOptions:
    r"""Additional options for the Amazon Kinesis streaming data source."""
    
    add_idle_time_between_reads: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AddIdleTimeBetweenReads'), 'exclude': lambda f: f is None }})  
    add_record_timestamp: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AddRecordTimestamp'), 'exclude': lambda f: f is None }})  
    avoid_empty_batches: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AvoidEmptyBatches'), 'exclude': lambda f: f is None }})  
    classification: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Classification'), 'exclude': lambda f: f is None }})  
    delimiter: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Delimiter'), 'exclude': lambda f: f is None }})  
    describe_shard_interval: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DescribeShardInterval'), 'exclude': lambda f: f is None }})  
    emit_consumer_lag_metrics: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EmitConsumerLagMetrics'), 'exclude': lambda f: f is None }})  
    endpoint_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EndpointUrl'), 'exclude': lambda f: f is None }})  
    idle_time_between_reads_in_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('IdleTimeBetweenReadsInMs'), 'exclude': lambda f: f is None }})  
    max_fetch_records_per_shard: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxFetchRecordsPerShard'), 'exclude': lambda f: f is None }})  
    max_fetch_time_in_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxFetchTimeInMs'), 'exclude': lambda f: f is None }})  
    max_record_per_read: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxRecordPerRead'), 'exclude': lambda f: f is None }})  
    max_retry_interval_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxRetryIntervalMs'), 'exclude': lambda f: f is None }})  
    num_retries: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('NumRetries'), 'exclude': lambda f: f is None }})  
    retry_interval_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RetryIntervalMs'), 'exclude': lambda f: f is None }})  
    role_arn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RoleArn'), 'exclude': lambda f: f is None }})  
    role_session_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RoleSessionName'), 'exclude': lambda f: f is None }})  
    starting_position: Optional[shared_startingposition_enum.StartingPositionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartingPosition'), 'exclude': lambda f: f is None }})  
    stream_arn: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StreamArn'), 'exclude': lambda f: f is None }})  
    stream_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StreamName'), 'exclude': lambda f: f is None }})  
    