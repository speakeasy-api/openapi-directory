"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import firstlastnameout as shared_firstlastnameout
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class PersonalNameParsedOutNameParserTypeEnum(str, Enum):
    r"""Name parsing is addressed as a classification problem, for example FN1LN1 means a first then last name order."""
    FN1_LN1 = 'FN1LN1'
    LN1_FN1 = 'LN1FN1'
    FN1_LN2 = 'FN1LN2'
    LN2_FN1 = 'LN2FN1'
    FN1_L_NX = 'FN1LNx'
    L_NX_FN1 = 'LNxFN1'
    FN2_LN1 = 'FN2LN1'
    LN1_FN2 = 'LN1FN2'
    FN2_LN2 = 'FN2LN2'
    LN2_FN2 = 'LN2FN2'
    FN2_L_NX = 'FN2LNx'
    L_NX_FN2 = 'LNxFN2'
    F_NX_LN1 = 'FNxLN1'
    LN1_F_NX = 'LN1FNx'
    F_NX_LN2 = 'FNxLN2'
    LN2_F_NX = 'LN2FNx'
    F_NX_L_NX = 'FNxLNx'
    L_NX_F_NX = 'LNxFNx'

class PersonalNameParsedOutNameParserTypeAltEnum(str, Enum):
    r"""Second best alternative parsing. Name parsing is addressed as a classification problem, for example FN1LN1 means a first then last name order."""
    FN1_LN1 = 'FN1LN1'
    LN1_FN1 = 'LN1FN1'
    FN1_LN2 = 'FN1LN2'
    LN2_FN1 = 'LN2FN1'
    FN1_L_NX = 'FN1LNx'
    L_NX_FN1 = 'LNxFN1'
    FN2_LN1 = 'FN2LN1'
    LN1_FN2 = 'LN1FN2'
    FN2_LN2 = 'FN2LN2'
    LN2_FN2 = 'LN2FN2'
    FN2_L_NX = 'FN2LNx'
    L_NX_FN2 = 'LNxFN2'
    F_NX_LN1 = 'FNxLN1'
    LN1_F_NX = 'LN1FNx'
    F_NX_LN2 = 'FNxLN2'
    LN2_F_NX = 'LN2FNx'
    F_NX_L_NX = 'FNxLNx'
    L_NX_F_NX = 'LNxFNx'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class PersonalNameParsedOut:
    r"""A origined name."""
    
    first_last_name: Optional[shared_firstlastnameout.FirstLastNameOut] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firstLastName'), 'exclude': lambda f: f is None }})
    r"""First / last name structure corresponding to the most likely parsing."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The input name"""  
    name_parser_type: Optional[PersonalNameParsedOutNameParserTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nameParserType'), 'exclude': lambda f: f is None }})
    r"""Name parsing is addressed as a classification problem, for example FN1LN1 means a first then last name order."""  
    name_parser_type_alt: Optional[PersonalNameParsedOutNameParserTypeAltEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nameParserTypeAlt'), 'exclude': lambda f: f is None }})
    r"""Second best alternative parsing. Name parsing is addressed as a classification problem, for example FN1LN1 means a first then last name order."""  
    score: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('score'), 'exclude': lambda f: f is None }})
    r"""Higher score is better, but score is not normalized. Use calibratedProbability if available."""  
    script: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('script'), 'exclude': lambda f: f is None }})  
    