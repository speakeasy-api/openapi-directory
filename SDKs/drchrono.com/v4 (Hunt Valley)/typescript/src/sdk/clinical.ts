/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Create and manage clinical resources
 */
export class Clinical {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create patient allergy
   */
  allergiesCreate(
    req: operations.AllergiesCreateRequest,
    security: operations.AllergiesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AllergiesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AllergiesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/allergies";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AllergiesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AllergiesCreateResponse =
        new operations.AllergiesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientAllergy = utils.objectToClass(
              httpRes?.data,
              shared.PatientAllergy
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient allergies
   */
  allergiesList(
    req: operations.AllergiesListRequest,
    security: operations.AllergiesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AllergiesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AllergiesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/allergies";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AllergiesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AllergiesListResponse =
        new operations.AllergiesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.allergiesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AllergiesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient allergy
   */
  allergiesPartialUpdate(
    req: operations.AllergiesPartialUpdateRequest,
    security: operations.AllergiesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AllergiesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AllergiesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/allergies/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AllergiesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AllergiesPartialUpdateResponse =
        new operations.AllergiesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient allergy
   */
  allergiesRead(
    req: operations.AllergiesReadRequest,
    security: operations.AllergiesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AllergiesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AllergiesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/allergies/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AllergiesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AllergiesReadResponse =
        new operations.AllergiesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientAllergy = utils.objectToClass(
              httpRes?.data,
              shared.PatientAllergy
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient allergy
   */
  allergiesUpdate(
    req: operations.AllergiesUpdateRequest,
    security: operations.AllergiesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AllergiesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AllergiesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/allergies/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AllergiesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AllergiesUpdateResponse =
        new operations.AllergiesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient amendments to a patient's clinical records
   */
  amendmentsCreate(
    req: operations.AmendmentsCreateRequest,
    security: operations.AmendmentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AmendmentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AmendmentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/amendments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AmendmentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AmendmentsCreateResponse =
        new operations.AmendmentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientAmendment = utils.objectToClass(
              httpRes?.data,
              shared.PatientAmendment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing patient amendment, you can only interact with amendments created by your API application
   */
  amendmentsDelete(
    req: operations.AmendmentsDeleteRequest,
    security: operations.AmendmentsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AmendmentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AmendmentsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/amendments/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AmendmentsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AmendmentsDeleteResponse =
        new operations.AmendmentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient amendments. You can only interact with amendments created by your API application
   */
  amendmentsList(
    req: operations.AmendmentsListRequest,
    security: operations.AmendmentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AmendmentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AmendmentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/amendments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AmendmentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AmendmentsListResponse =
        new operations.AmendmentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.amendmentsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AmendmentsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient amendment, you can only interact with amendments created by your API application
   */
  amendmentsPartialUpdate(
    req: operations.AmendmentsPartialUpdateRequest,
    security: operations.AmendmentsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AmendmentsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AmendmentsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/amendments/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AmendmentsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AmendmentsPartialUpdateResponse =
        new operations.AmendmentsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient amendment, you can only interact with amendments created by your API application
   */
  amendmentsRead(
    req: operations.AmendmentsReadRequest,
    security: operations.AmendmentsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AmendmentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AmendmentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/amendments/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AmendmentsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AmendmentsReadResponse =
        new operations.AmendmentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientAmendment = utils.objectToClass(
              httpRes?.data,
              shared.PatientAmendment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient amendment, you can only interact with amendments created by your API application
   */
  amendmentsUpdate(
    req: operations.AmendmentsUpdateRequest,
    security: operations.AmendmentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AmendmentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AmendmentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/amendments/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AmendmentsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AmendmentsUpdateResponse =
        new operations.AmendmentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create appointment profiles for a doctor's calendar
   */
  appointmentProfilesCreate(
    req: operations.AppointmentProfilesCreateRequest,
    security: operations.AppointmentProfilesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentProfilesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentProfilesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/appointment_profiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentProfilesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentProfilesCreateResponse =
        new operations.AppointmentProfilesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentProfile = utils.objectToClass(
              httpRes?.data,
              shared.AppointmentProfile
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing appointment profile
   */
  appointmentProfilesDelete(
    req: operations.AppointmentProfilesDeleteRequest,
    security: operations.AppointmentProfilesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentProfilesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentProfilesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentProfilesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentProfilesDeleteResponse =
        new operations.AppointmentProfilesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search appointment profiles for a doctor's calendar
   */
  appointmentProfilesList(
    req: operations.AppointmentProfilesListRequest,
    security: operations.AppointmentProfilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentProfilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentProfilesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/appointment_profiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentProfilesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentProfilesListResponse =
        new operations.AppointmentProfilesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentProfilesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppointmentProfilesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment profile
   */
  appointmentProfilesPartialUpdate(
    req: operations.AppointmentProfilesPartialUpdateRequest,
    security: operations.AppointmentProfilesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentProfilesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentProfilesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentProfilesPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentProfilesPartialUpdateResponse =
        new operations.AppointmentProfilesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing appointment profile
   */
  appointmentProfilesRead(
    req: operations.AppointmentProfilesReadRequest,
    security: operations.AppointmentProfilesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentProfilesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentProfilesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentProfilesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentProfilesReadResponse =
        new operations.AppointmentProfilesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentProfile = utils.objectToClass(
              httpRes?.data,
              shared.AppointmentProfile
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment profile
   */
  appointmentProfilesUpdate(
    req: operations.AppointmentProfilesUpdateRequest,
    security: operations.AppointmentProfilesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentProfilesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentProfilesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentProfilesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentProfilesUpdateResponse =
        new operations.AppointmentProfilesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create appointment templates for a doctor's calendar
   */
  appointmentTemplatesCreate(
    req: operations.AppointmentTemplatesCreateRequest,
    security: operations.AppointmentTemplatesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentTemplatesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentTemplatesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/appointment_templates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentTemplatesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentTemplatesCreateResponse =
        new operations.AppointmentTemplatesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentTemplate = utils.objectToClass(
              httpRes?.data,
              shared.AppointmentTemplate
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing appointment template
   */
  appointmentTemplatesDelete(
    req: operations.AppointmentTemplatesDeleteRequest,
    security: operations.AppointmentTemplatesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentTemplatesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentTemplatesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentTemplatesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentTemplatesDeleteResponse =
        new operations.AppointmentTemplatesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search appointment templates for a doctor's calendar
   */
  appointmentTemplatesList(
    req: operations.AppointmentTemplatesListRequest,
    security: operations.AppointmentTemplatesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentTemplatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentTemplatesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/appointment_templates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentTemplatesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentTemplatesListResponse =
        new operations.AppointmentTemplatesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentTemplatesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.AppointmentTemplatesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment template
   */
  appointmentTemplatesPartialUpdate(
    req: operations.AppointmentTemplatesPartialUpdateRequest,
    security: operations.AppointmentTemplatesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentTemplatesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentTemplatesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentTemplatesPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentTemplatesPartialUpdateResponse =
        new operations.AppointmentTemplatesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing appointment template
   */
  appointmentTemplatesRead(
    req: operations.AppointmentTemplatesReadRequest,
    security: operations.AppointmentTemplatesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentTemplatesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentTemplatesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentTemplatesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentTemplatesReadResponse =
        new operations.AppointmentTemplatesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentTemplate = utils.objectToClass(
              httpRes?.data,
              shared.AppointmentTemplate
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment template
   */
  appointmentTemplatesUpdate(
    req: operations.AppointmentTemplatesUpdateRequest,
    security: operations.AppointmentTemplatesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentTemplatesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentTemplatesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointment_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentTemplatesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentTemplatesUpdateResponse =
        new operations.AppointmentTemplatesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a new appointment or break on doctor's calendar
   */
  appointmentsCreate(
    req: operations.AppointmentsCreateRequest,
    security: operations.AppointmentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/appointments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentsCreateResponse =
        new operations.AppointmentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointment = utils.objectToClass(
              httpRes?.data,
              shared.Appointment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 409, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing appointment or break
   */
  appointmentsDelete(
    req: operations.AppointmentsDeleteRequest,
    security: operations.AppointmentsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentsDeleteResponse =
        new operations.AppointmentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search appointment or breaks.
   * <b>Note:</b> Either `since`, `date` or `date_range` parameter must be specified.
   *
   */
  appointmentsList(
    req: operations.AppointmentsListRequest,
    security: operations.AppointmentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/appointments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentsListResponse =
        new operations.AppointmentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointmentsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.AppointmentsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment or break
   */
  appointmentsPartialUpdate(
    req: operations.AppointmentsPartialUpdateRequest,
    security: operations.AppointmentsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentsPartialUpdateResponse =
        new operations.AppointmentsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 409, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing appointment or break
   */
  appointmentsRead(
    req: operations.AppointmentsReadRequest,
    security: operations.AppointmentsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentsReadResponse =
        new operations.AppointmentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.appointment = utils.objectToClass(
              httpRes?.data,
              shared.Appointment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment or break
   */
  appointmentsUpdate(
    req: operations.AppointmentsUpdateRequest,
    security: operations.AppointmentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AppointmentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AppointmentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/appointments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AppointmentsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AppointmentsUpdateResponse =
        new operations.AppointmentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 409, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search care plans
   */
  carePlansList(
    req: operations.CarePlansListRequest,
    security: operations.CarePlansListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CarePlansListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CarePlansListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/care_plans";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CarePlansListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CarePlansListResponse =
        new operations.CarePlansListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.carePlansList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CarePlansList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing care plan
   */
  carePlansRead(
    req: operations.CarePlansReadRequest,
    security: operations.CarePlansReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CarePlansReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CarePlansReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/care_plans/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CarePlansReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CarePlansReadResponse =
        new operations.CarePlansReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.carePlan = utils.objectToClass(httpRes?.data, shared.CarePlan);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  careTeamMembersList(
    req: operations.CareTeamMembersListRequest,
    security: operations.CareTeamMembersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CareTeamMembersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CareTeamMembersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/care_team_members";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CareTeamMembersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CareTeamMembersListResponse =
        new operations.CareTeamMembersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.careTeamMembersList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CareTeamMembersList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  careTeamMembersRead(
    req: operations.CareTeamMembersReadRequest,
    security: operations.CareTeamMembersReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CareTeamMembersReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CareTeamMembersReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/care_team_members/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CareTeamMembersReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CareTeamMembersReadResponse =
        new operations.CareTeamMembersReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.careTeamMember = utils.objectToClass(
              httpRes?.data,
              shared.CareTeamMember
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a new billing note
   */
  claimBillingNotesCreate(
    req: operations.ClaimBillingNotesCreateRequest,
    security: operations.ClaimBillingNotesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClaimBillingNotesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClaimBillingNotesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/claim_billing_notes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClaimBillingNotesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClaimBillingNotesCreateResponse =
        new operations.ClaimBillingNotesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.claimBillingNotes = utils.objectToClass(
              httpRes?.data,
              shared.ClaimBillingNotes
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search billing notes
   */
  claimBillingNotesList(
    req: operations.ClaimBillingNotesListRequest,
    security: operations.ClaimBillingNotesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClaimBillingNotesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClaimBillingNotesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/claim_billing_notes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClaimBillingNotesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClaimBillingNotesListResponse =
        new operations.ClaimBillingNotesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.claimBillingNotesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ClaimBillingNotesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing billing note
   */
  claimBillingNotesRead(
    req: operations.ClaimBillingNotesReadRequest,
    security: operations.ClaimBillingNotesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClaimBillingNotesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClaimBillingNotesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/claim_billing_notes/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClaimBillingNotesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClaimBillingNotesReadResponse =
        new operations.ClaimBillingNotesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.claimBillingNotes = utils.objectToClass(
              httpRes?.data,
              shared.ClaimBillingNotes
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search clinical note field types
   */
  clinicalNoteFieldTypesList(
    req: operations.ClinicalNoteFieldTypesListRequest,
    security: operations.ClinicalNoteFieldTypesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldTypesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldTypesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/clinical_note_field_types";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldTypesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldTypesListResponse =
        new operations.ClinicalNoteFieldTypesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clinicalNoteFieldTypesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ClinicalNoteFieldTypesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing clinial note field type
   */
  clinicalNoteFieldTypesRead(
    req: operations.ClinicalNoteFieldTypesReadRequest,
    security: operations.ClinicalNoteFieldTypesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldTypesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldTypesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/clinical_note_field_types/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldTypesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldTypesReadResponse =
        new operations.ClinicalNoteFieldTypesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.soapNoteLineItemFieldType = utils.objectToClass(
              httpRes?.data,
              shared.SoapNoteLineItemFieldType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create clinical note field value
   */
  clinicalNoteFieldValuesCreate(
    req: operations.ClinicalNoteFieldValuesCreateRequest,
    security: operations.ClinicalNoteFieldValuesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldValuesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldValuesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/clinical_note_field_values";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldValuesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldValuesCreateResponse =
        new operations.ClinicalNoteFieldValuesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.soapNoteLineItemFieldValue = utils.objectToClass(
              httpRes?.data,
              shared.SoapNoteLineItemFieldValue
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search clinical note field values
   */
  clinicalNoteFieldValuesList(
    req: operations.ClinicalNoteFieldValuesListRequest,
    security: operations.ClinicalNoteFieldValuesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldValuesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldValuesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/clinical_note_field_values";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldValuesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldValuesListResponse =
        new operations.ClinicalNoteFieldValuesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clinicalNoteFieldValuesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ClinicalNoteFieldValuesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing clinical note field value
   */
  clinicalNoteFieldValuesPartialUpdate(
    req: operations.ClinicalNoteFieldValuesPartialUpdateRequest,
    security: operations.ClinicalNoteFieldValuesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldValuesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldValuesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/clinical_note_field_values/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldValuesPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldValuesPartialUpdateResponse =
        new operations.ClinicalNoteFieldValuesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing clinical note field value
   */
  clinicalNoteFieldValuesRead(
    req: operations.ClinicalNoteFieldValuesReadRequest,
    security: operations.ClinicalNoteFieldValuesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldValuesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldValuesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/clinical_note_field_values/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldValuesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldValuesReadResponse =
        new operations.ClinicalNoteFieldValuesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.soapNoteLineItemFieldValue = utils.objectToClass(
              httpRes?.data,
              shared.SoapNoteLineItemFieldValue
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing clinical note field value
   */
  clinicalNoteFieldValuesUpdate(
    req: operations.ClinicalNoteFieldValuesUpdateRequest,
    security: operations.ClinicalNoteFieldValuesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteFieldValuesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteFieldValuesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/clinical_note_field_values/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteFieldValuesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteFieldValuesUpdateResponse =
        new operations.ClinicalNoteFieldValuesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search clinical note templates
   */
  clinicalNoteTemplatesList(
    req: operations.ClinicalNoteTemplatesListRequest,
    security: operations.ClinicalNoteTemplatesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteTemplatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteTemplatesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/clinical_note_templates";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteTemplatesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteTemplatesListResponse =
        new operations.ClinicalNoteTemplatesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clinicalNoteTemplatesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ClinicalNoteTemplatesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing clinical note tempalte
   */
  clinicalNoteTemplatesRead(
    req: operations.ClinicalNoteTemplatesReadRequest,
    security: operations.ClinicalNoteTemplatesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNoteTemplatesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNoteTemplatesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/clinical_note_templates/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNoteTemplatesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNoteTemplatesReadResponse =
        new operations.ClinicalNoteTemplatesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.soapNoteCustomReport = utils.objectToClass(
              httpRes?.data,
              shared.SoapNoteCustomReport
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  clinicalNotesList(
    req: operations.ClinicalNotesListRequest,
    security: operations.ClinicalNotesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNotesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNotesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/clinical_notes";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNotesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNotesListResponse =
        new operations.ClinicalNotesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clinicalNotesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ClinicalNotesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  clinicalNotesRead(
    req: operations.ClinicalNotesReadRequest,
    security: operations.ClinicalNotesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ClinicalNotesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ClinicalNotesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/clinical_notes/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ClinicalNotesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ClinicalNotesReadResponse =
        new operations.ClinicalNotesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.clinicalNote = utils.objectToClass(
              httpRes?.data,
              shared.ClinicalNote
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Assign (apply) a consent form to appointment
   */
  consentFormsApplyToAppointment(
    req: operations.ConsentFormsApplyToAppointmentRequest,
    security: operations.ConsentFormsApplyToAppointmentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsApplyToAppointmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsApplyToAppointmentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/consent_forms/{id}/apply_to_appointment",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsApplyToAppointmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsApplyToAppointmentResponse =
        new operations.ConsentFormsApplyToAppointmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create a patient consent form
   */
  consentFormsCreate(
    req: operations.ConsentFormsCreateRequest,
    security: operations.ConsentFormsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/consent_forms";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsCreateResponse =
        new operations.ConsentFormsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.consentForm = utils.objectToClass(
              httpRes?.data,
              shared.ConsentForm
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient consent forms
   */
  consentFormsList(
    req: operations.ConsentFormsListRequest,
    security: operations.ConsentFormsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/consent_forms";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsListResponse =
        new operations.ConsentFormsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.consentFormsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ConsentFormsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient consent form
   */
  consentFormsPartialUpdate(
    req: operations.ConsentFormsPartialUpdateRequest,
    security: operations.ConsentFormsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/consent_forms/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsPartialUpdateResponse =
        new operations.ConsentFormsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient consent form
   */
  consentFormsRead(
    req: operations.ConsentFormsReadRequest,
    security: operations.ConsentFormsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/consent_forms/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsReadResponse =
        new operations.ConsentFormsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.consentForm = utils.objectToClass(
              httpRes?.data,
              shared.ConsentForm
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Unassign (unapply) a consent form from appointment
   */
  consentFormsUnapplyFromAppointment(
    req: operations.ConsentFormsUnapplyFromAppointmentRequest,
    security: operations.ConsentFormsUnapplyFromAppointmentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsUnapplyFromAppointmentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsUnapplyFromAppointmentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/consent_forms/{id}/unapply_from_appointment",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsUnapplyFromAppointmentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsUnapplyFromAppointmentResponse =
        new operations.ConsentFormsUnapplyFromAppointmentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient consent form
   */
  consentFormsUpdate(
    req: operations.ConsentFormsUpdateRequest,
    security: operations.ConsentFormsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ConsentFormsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ConsentFormsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/consent_forms/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ConsentFormsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ConsentFormsUpdateResponse =
        new operations.ConsentFormsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create custom appointment fields
   */
  customAppointmentFieldsCreate(
    req: operations.CustomAppointmentFieldsCreateRequest,
    security: operations.CustomAppointmentFieldsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomAppointmentFieldsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomAppointmentFieldsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/custom_appointment_fields";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomAppointmentFieldsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomAppointmentFieldsCreateResponse =
        new operations.CustomAppointmentFieldsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customAppointmentFieldType = utils.objectToClass(
              httpRes?.data,
              shared.CustomAppointmentFieldType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search custom appointment fields
   */
  customAppointmentFieldsList(
    req: operations.CustomAppointmentFieldsListRequest,
    security: operations.CustomAppointmentFieldsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomAppointmentFieldsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomAppointmentFieldsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/custom_appointment_fields";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomAppointmentFieldsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomAppointmentFieldsListResponse =
        new operations.CustomAppointmentFieldsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customAppointmentFieldsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CustomAppointmentFieldsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing custom appointment field
   */
  customAppointmentFieldsPartialUpdate(
    req: operations.CustomAppointmentFieldsPartialUpdateRequest,
    security: operations.CustomAppointmentFieldsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomAppointmentFieldsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomAppointmentFieldsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_appointment_fields/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomAppointmentFieldsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomAppointmentFieldsPartialUpdateResponse =
        new operations.CustomAppointmentFieldsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing custom appointment field
   */
  customAppointmentFieldsRead(
    req: operations.CustomAppointmentFieldsReadRequest,
    security: operations.CustomAppointmentFieldsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomAppointmentFieldsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomAppointmentFieldsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_appointment_fields/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomAppointmentFieldsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomAppointmentFieldsReadResponse =
        new operations.CustomAppointmentFieldsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customAppointmentFieldType = utils.objectToClass(
              httpRes?.data,
              shared.CustomAppointmentFieldType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing custom appointment field
   */
  customAppointmentFieldsUpdate(
    req: operations.CustomAppointmentFieldsUpdateRequest,
    security: operations.CustomAppointmentFieldsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomAppointmentFieldsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomAppointmentFieldsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_appointment_fields/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomAppointmentFieldsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomAppointmentFieldsUpdateResponse =
        new operations.CustomAppointmentFieldsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create custom demographics fields
   */
  customDemographicsCreate(
    req: operations.CustomDemographicsCreateRequest,
    security: operations.CustomDemographicsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomDemographicsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomDemographicsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/custom_demographics";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomDemographicsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomDemographicsCreateResponse =
        new operations.CustomDemographicsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customPatientFieldType = utils.objectToClass(
              httpRes?.data,
              shared.CustomPatientFieldType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search custom demographics fields
   */
  customDemographicsList(
    req: operations.CustomDemographicsListRequest,
    security: operations.CustomDemographicsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomDemographicsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomDemographicsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/custom_demographics";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomDemographicsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomDemographicsListResponse =
        new operations.CustomDemographicsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customDemographicsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CustomDemographicsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing custom demographics field
   */
  customDemographicsPartialUpdate(
    req: operations.CustomDemographicsPartialUpdateRequest,
    security: operations.CustomDemographicsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomDemographicsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomDemographicsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_demographics/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomDemographicsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomDemographicsPartialUpdateResponse =
        new operations.CustomDemographicsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing custom demographics field
   */
  customDemographicsRead(
    req: operations.CustomDemographicsReadRequest,
    security: operations.CustomDemographicsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomDemographicsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomDemographicsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_demographics/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomDemographicsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomDemographicsReadResponse =
        new operations.CustomDemographicsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customPatientFieldType = utils.objectToClass(
              httpRes?.data,
              shared.CustomPatientFieldType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing custom demographics field
   */
  customDemographicsUpdate(
    req: operations.CustomDemographicsUpdateRequest,
    security: operations.CustomDemographicsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomDemographicsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomDemographicsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_demographics/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomDemographicsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomDemographicsUpdateResponse =
        new operations.CustomDemographicsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search custom vital types
   */
  customVitalsList(
    req: operations.CustomVitalsListRequest,
    security: operations.CustomVitalsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomVitalsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomVitalsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/custom_vitals";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomVitalsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomVitalsListResponse =
        new operations.CustomVitalsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customVitalsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CustomVitalsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing custom vital type
   */
  customVitalsRead(
    req: operations.CustomVitalsReadRequest,
    security: operations.CustomVitalsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CustomVitalsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CustomVitalsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/custom_vitals/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CustomVitalsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CustomVitalsReadResponse =
        new operations.CustomVitalsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.customVitalType = utils.objectToClass(
              httpRes?.data,
              shared.CustomVitalType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create documents
   */
  documentsCreate(
    req: operations.DocumentsCreateRequest,
    security: operations.DocumentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DocumentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DocumentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/documents";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DocumentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DocumentsCreateResponse =
        new operations.DocumentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scannedClinicalDocument = utils.objectToClass(
              httpRes?.data,
              shared.ScannedClinicalDocument
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing appointment template
   */
  documentsDelete(
    req: operations.DocumentsDeleteRequest,
    security: operations.DocumentsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DocumentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DocumentsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/documents/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DocumentsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DocumentsDeleteResponse =
        new operations.DocumentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search documents
   */
  documentsList(
    req: operations.DocumentsListRequest,
    security: operations.DocumentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DocumentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DocumentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/documents";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DocumentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DocumentsListResponse =
        new operations.DocumentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.documentsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.DocumentsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment template
   */
  documentsPartialUpdate(
    req: operations.DocumentsPartialUpdateRequest,
    security: operations.DocumentsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DocumentsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DocumentsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/documents/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DocumentsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DocumentsPartialUpdateResponse =
        new operations.DocumentsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing appointment template
   */
  documentsRead(
    req: operations.DocumentsReadRequest,
    security: operations.DocumentsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DocumentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DocumentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/documents/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DocumentsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DocumentsReadResponse =
        new operations.DocumentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.scannedClinicalDocument = utils.objectToClass(
              httpRes?.data,
              shared.ScannedClinicalDocument
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing appointment template
   */
  documentsUpdate(
    req: operations.DocumentsUpdateRequest,
    security: operations.DocumentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DocumentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DocumentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/documents/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DocumentsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DocumentsUpdateResponse =
        new operations.DocumentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create EOB object
   */
  eobsCreate(
    req: operations.EobsCreateRequest,
    security: operations.EobsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EobsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EobsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/eobs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EobsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EobsCreateResponse =
        new operations.EobsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eobObject = utils.objectToClass(
              httpRes?.data,
              shared.EOBObject
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search EOB objects
   */
  eobsList(
    req: operations.EobsListRequest,
    security: operations.EobsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EobsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EobsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/eobs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EobsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EobsListResponse = new operations.EobsListResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eobsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.EobsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing EOB object
   */
  eobsRead(
    req: operations.EobsReadRequest,
    security: operations.EobsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.EobsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.EobsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/eobs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.EobsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.EobsReadResponse = new operations.EobsReadResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.eobObject = utils.objectToClass(
              httpRes?.data,
              shared.EOBObject
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  feeSchedulesList(
    req: operations.FeeSchedulesListRequest,
    security: operations.FeeSchedulesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FeeSchedulesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FeeSchedulesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/fee_schedules";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FeeSchedulesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FeeSchedulesListResponse =
        new operations.FeeSchedulesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.feeSchedulesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.FeeSchedulesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  feeSchedulesRead(
    req: operations.FeeSchedulesReadRequest,
    security: operations.FeeSchedulesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FeeSchedulesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FeeSchedulesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/fee_schedules/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FeeSchedulesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FeeSchedulesReadResponse =
        new operations.FeeSchedulesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.doctorFeeSchedule = utils.objectToClass(
              httpRes?.data,
              shared.DoctorFeeSchedule
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search implantable devices
   */
  implantableDevicesList(
    req: operations.ImplantableDevicesListRequest,
    security: operations.ImplantableDevicesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ImplantableDevicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImplantableDevicesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/implantable_devices";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ImplantableDevicesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImplantableDevicesListResponse =
        new operations.ImplantableDevicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.implantableDevicesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ImplantableDevicesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing implantable device
   */
  implantableDevicesRead(
    req: operations.ImplantableDevicesReadRequest,
    security: operations.ImplantableDevicesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ImplantableDevicesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImplantableDevicesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/implantable_devices/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ImplantableDevicesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImplantableDevicesReadResponse =
        new operations.ImplantableDevicesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.implantableDevice = utils.objectToClass(
              httpRes?.data,
              shared.ImplantableDevice
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  insurancesList(
    req: operations.InsurancesListRequest,
    security: operations.InsurancesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InsurancesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InsurancesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/insurances";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InsurancesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InsurancesListResponse =
        new operations.InsurancesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insurancesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.InsurancesList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  insurancesRead(
    req: operations.InsurancesReadRequest,
    security: operations.InsurancesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.InsurancesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InsurancesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/insurances/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.InsurancesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InsurancesReadResponse =
        new operations.InsurancesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insurance = utils.objectToClass(
              httpRes?.data,
              shared.Insurance
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create lab order documents. An example lab workflow is as following:
   *
   * - When you get orders, submit them via `/api/lab_orders`, such that doctors can see them in drchrono.
   *
   * - When results come in, submit the result document PDF via `/api/lab_documents` and submit the results data via `/api/lab_results`
   *
   * - Update `/api/lab_orders` status
   *
   */
  labDocumentsCreate(
    req: operations.LabDocumentsCreateRequest,
    security: operations.LabDocumentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabDocumentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabDocumentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_documents";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabDocumentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabDocumentsCreateResponse =
        new operations.LabDocumentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrderDocument = utils.objectToClass(
              httpRes?.data,
              shared.LabOrderDocument
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing lab order document
   */
  labDocumentsDelete(
    req: operations.LabDocumentsDeleteRequest,
    security: operations.LabDocumentsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabDocumentsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabDocumentsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_documents/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabDocumentsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabDocumentsDeleteResponse =
        new operations.LabDocumentsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search lab order documents
   */
  labDocumentsList(
    req: operations.LabDocumentsListRequest,
    security: operations.LabDocumentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabDocumentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabDocumentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_documents";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabDocumentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabDocumentsListResponse =
        new operations.LabDocumentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labDocumentsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.LabDocumentsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab order document
   */
  labDocumentsPartialUpdate(
    req: operations.LabDocumentsPartialUpdateRequest,
    security: operations.LabDocumentsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabDocumentsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabDocumentsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_documents/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabDocumentsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabDocumentsPartialUpdateResponse =
        new operations.LabDocumentsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing lab order document
   */
  labDocumentsRead(
    req: operations.LabDocumentsReadRequest,
    security: operations.LabDocumentsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabDocumentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabDocumentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_documents/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabDocumentsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabDocumentsReadResponse =
        new operations.LabDocumentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrderDocument = utils.objectToClass(
              httpRes?.data,
              shared.LabOrderDocument
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab order document
   */
  labDocumentsUpdate(
    req: operations.LabDocumentsUpdateRequest,
    security: operations.LabDocumentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabDocumentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabDocumentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_documents/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabDocumentsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabDocumentsUpdateResponse =
        new operations.LabDocumentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create lab orders. An example lab workflow is as following:
   *
   * - When you get orders, submit them via `/api/lab_orders`, such that doctors can see them in drchrono.
   *
   * - When results come in, submit the result document PDF via `/api/lab_documents` and submit the results data via `/api/lab_results`
   *
   * - Update `/api/lab_orders` status
   *
   */
  labOrdersCreate(
    req: operations.LabOrdersCreateRequest,
    security: operations.LabOrdersCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_orders";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersCreateResponse =
        new operations.LabOrdersCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrder = utils.objectToClass(httpRes?.data, shared.LabOrder);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing lab order
   */
  labOrdersDelete(
    req: operations.LabOrdersDeleteRequest,
    security: operations.LabOrdersDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_orders/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersDeleteResponse =
        new operations.LabOrdersDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search lab orders
   */
  labOrdersList(
    req: operations.LabOrdersListRequest,
    security: operations.LabOrdersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_orders";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersListResponse =
        new operations.LabOrdersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrdersList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.LabOrdersList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab order
   */
  labOrdersPartialUpdate(
    req: operations.LabOrdersPartialUpdateRequest,
    security: operations.LabOrdersPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_orders/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersPartialUpdateResponse =
        new operations.LabOrdersPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing lab order
   */
  labOrdersRead(
    req: operations.LabOrdersReadRequest,
    security: operations.LabOrdersReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_orders/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersReadResponse =
        new operations.LabOrdersReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrder = utils.objectToClass(httpRes?.data, shared.LabOrder);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  labOrdersSummaryList(
    req: operations.LabOrdersSummaryListRequest,
    security: operations.LabOrdersSummaryListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersSummaryListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersSummaryListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_orders_summary";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersSummaryListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersSummaryListResponse =
        new operations.LabOrdersSummaryListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrdersSummaryList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.LabOrdersSummaryList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  labOrdersSummaryRead(
    req: operations.LabOrdersSummaryReadRequest,
    security: operations.LabOrdersSummaryReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersSummaryReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersSummaryReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_orders_summary/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersSummaryReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersSummaryReadResponse =
        new operations.LabOrdersSummaryReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labOrder = utils.objectToClass(httpRes?.data, shared.LabOrder);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab order
   */
  labOrdersUpdate(
    req: operations.LabOrdersUpdateRequest,
    security: operations.LabOrdersUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabOrdersUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabOrdersUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_orders/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabOrdersUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabOrdersUpdateResponse =
        new operations.LabOrdersUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create lab results. An example lab workflow is as following:
   *
   * - When you get orders, submit them via `/api/lab_orders`, such that doctors can see them in drchrono.
   *
   * - When results come in, submit the result document PDF via `/api/lab_documents` and submit the results data via `/api/lab_results`
   *
   * - Update `/api/lab_orders` status
   *
   */
  labResultsCreate(
    req: operations.LabResultsCreateRequest,
    security: operations.LabResultsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabResultsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabResultsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_results";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabResultsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabResultsCreateResponse =
        new operations.LabResultsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labResult = utils.objectToClass(
              httpRes?.data,
              shared.LabResult
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing lab result
   */
  labResultsDelete(
    req: operations.LabResultsDeleteRequest,
    security: operations.LabResultsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabResultsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabResultsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabResultsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabResultsDeleteResponse =
        new operations.LabResultsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search lab results
   */
  labResultsList(
    req: operations.LabResultsListRequest,
    security: operations.LabResultsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabResultsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabResultsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_results";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabResultsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabResultsListResponse =
        new operations.LabResultsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labResultsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.LabResultsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab result
   */
  labResultsPartialUpdate(
    req: operations.LabResultsPartialUpdateRequest,
    security: operations.LabResultsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabResultsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabResultsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabResultsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabResultsPartialUpdateResponse =
        new operations.LabResultsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing lab result
   */
  labResultsRead(
    req: operations.LabResultsReadRequest,
    security: operations.LabResultsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabResultsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabResultsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabResultsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabResultsReadResponse =
        new operations.LabResultsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labResult = utils.objectToClass(
              httpRes?.data,
              shared.LabResult
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab result
   */
  labResultsUpdate(
    req: operations.LabResultsUpdateRequest,
    security: operations.LabResultsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabResultsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabResultsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabResultsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabResultsUpdateResponse =
        new operations.LabResultsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create lab tests. An example lab workflow is as following:
   *
   * - When you get orders, submit them via `/api/lab_orders`, such that doctors can see them in drchrono.
   *
   * - When results come in, submit the result document PDF via `/api/lab_documents` and submit the results data via `/api/lab_results`
   *
   * - Update `/api/lab_orders` status
   *
   */
  labTestsCreate(
    req: operations.LabTestsCreateRequest,
    security: operations.LabTestsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabTestsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabTestsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_tests";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabTestsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabTestsCreateResponse =
        new operations.LabTestsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labTest = utils.objectToClass(httpRes?.data, shared.LabTest);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing lab test
   */
  labTestsDelete(
    req: operations.LabTestsDeleteRequest,
    security: operations.LabTestsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabTestsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabTestsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_tests/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabTestsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabTestsDeleteResponse =
        new operations.LabTestsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search lab tests
   */
  labTestsList(
    req: operations.LabTestsListRequest,
    security: operations.LabTestsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabTestsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabTestsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/lab_tests";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabTestsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabTestsListResponse =
        new operations.LabTestsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labTestsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.LabTestsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab test
   */
  labTestsPartialUpdate(
    req: operations.LabTestsPartialUpdateRequest,
    security: operations.LabTestsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabTestsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabTestsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_tests/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabTestsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabTestsPartialUpdateResponse =
        new operations.LabTestsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing lab test
   */
  labTestsRead(
    req: operations.LabTestsReadRequest,
    security: operations.LabTestsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabTestsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabTestsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_tests/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabTestsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabTestsReadResponse =
        new operations.LabTestsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labTest = utils.objectToClass(httpRes?.data, shared.LabTest);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing lab test
   */
  labTestsUpdate(
    req: operations.LabTestsUpdateRequest,
    security: operations.LabTestsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LabTestsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LabTestsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/lab_tests/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LabTestsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LabTestsUpdateResponse =
        new operations.LabTestsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Append a message to the "pharmacy_note" section of the prescription, in a new paragraph
   */
  medicationsAppendToPharmacyNote(
    req: operations.MedicationsAppendToPharmacyNoteRequest,
    security: operations.MedicationsAppendToPharmacyNoteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MedicationsAppendToPharmacyNoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MedicationsAppendToPharmacyNoteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/medications/{id}/append_to_pharmacy_note",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MedicationsAppendToPharmacyNoteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MedicationsAppendToPharmacyNoteResponse =
        new operations.MedicationsAppendToPharmacyNoteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient medications
   */
  medicationsCreate(
    req: operations.MedicationsCreateRequest,
    security: operations.MedicationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MedicationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MedicationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/medications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MedicationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MedicationsCreateResponse =
        new operations.MedicationsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientDrug = utils.objectToClass(
              httpRes?.data,
              shared.PatientDrug
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient medications
   */
  medicationsList(
    req: operations.MedicationsListRequest,
    security: operations.MedicationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MedicationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MedicationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/medications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MedicationsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MedicationsListResponse =
        new operations.MedicationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.medicationsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.MedicationsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient medications
   */
  medicationsPartialUpdate(
    req: operations.MedicationsPartialUpdateRequest,
    security: operations.MedicationsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MedicationsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MedicationsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/medications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MedicationsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MedicationsPartialUpdateResponse =
        new operations.MedicationsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient medications
   */
  medicationsRead(
    req: operations.MedicationsReadRequest,
    security: operations.MedicationsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MedicationsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MedicationsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/medications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MedicationsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MedicationsReadResponse =
        new operations.MedicationsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientDrug = utils.objectToClass(
              httpRes?.data,
              shared.PatientDrug
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient medications
   */
  medicationsUpdate(
    req: operations.MedicationsUpdateRequest,
    security: operations.MedicationsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MedicationsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MedicationsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/medications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MedicationsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MedicationsUpdateResponse =
        new operations.MedicationsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient communication for CQM
   */
  patientCommunicationsCreate(
    req: operations.PatientCommunicationsCreateRequest,
    security: operations.PatientCommunicationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientCommunicationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientCommunicationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_communications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientCommunicationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientCommunicationsCreateResponse =
        new operations.PatientCommunicationsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientCommunication = utils.objectToClass(
              httpRes?.data,
              shared.PatientCommunication
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient communications for CQM
   */
  patientCommunicationsList(
    req: operations.PatientCommunicationsListRequest,
    security: operations.PatientCommunicationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientCommunicationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientCommunicationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_communications";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientCommunicationsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientCommunicationsListResponse =
        new operations.PatientCommunicationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientCommunicationsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientCommunicationsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient communication for CQM
   */
  patientCommunicationsPartialUpdate(
    req: operations.PatientCommunicationsPartialUpdateRequest,
    security: operations.PatientCommunicationsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientCommunicationsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientCommunicationsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_communications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientCommunicationsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientCommunicationsPartialUpdateResponse =
        new operations.PatientCommunicationsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient communication for CQM
   */
  patientCommunicationsRead(
    req: operations.PatientCommunicationsReadRequest,
    security: operations.PatientCommunicationsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientCommunicationsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientCommunicationsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_communications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientCommunicationsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientCommunicationsReadResponse =
        new operations.PatientCommunicationsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientCommunication = utils.objectToClass(
              httpRes?.data,
              shared.PatientCommunication
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient communication for CQM
   */
  patientCommunicationsUpdate(
    req: operations.PatientCommunicationsUpdateRequest,
    security: operations.PatientCommunicationsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientCommunicationsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientCommunicationsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_communications/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientCommunicationsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientCommunicationsUpdateResponse =
        new operations.PatientCommunicationsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient flag types
   */
  patientFlagTypesCreate(
    req: operations.PatientFlagTypesCreateRequest,
    security: operations.PatientFlagTypesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientFlagTypesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientFlagTypesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_flag_types";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientFlagTypesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientFlagTypesCreateResponse =
        new operations.PatientFlagTypesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientFlagType = utils.objectToClass(
              httpRes?.data,
              shared.PatientFlagType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient flag types
   */
  patientFlagTypesList(
    req: operations.PatientFlagTypesListRequest,
    security: operations.PatientFlagTypesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientFlagTypesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientFlagTypesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_flag_types";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientFlagTypesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientFlagTypesListResponse =
        new operations.PatientFlagTypesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientFlagTypesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientFlagTypesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient flag type
   */
  patientFlagTypesPartialUpdate(
    req: operations.PatientFlagTypesPartialUpdateRequest,
    security: operations.PatientFlagTypesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientFlagTypesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientFlagTypesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_flag_types/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientFlagTypesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientFlagTypesPartialUpdateResponse =
        new operations.PatientFlagTypesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient flag type
   */
  patientFlagTypesRead(
    req: operations.PatientFlagTypesReadRequest,
    security: operations.PatientFlagTypesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientFlagTypesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientFlagTypesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_flag_types/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientFlagTypesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientFlagTypesReadResponse =
        new operations.PatientFlagTypesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientFlagType = utils.objectToClass(
              httpRes?.data,
              shared.PatientFlagType
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient flag type
   */
  patientFlagTypesUpdate(
    req: operations.PatientFlagTypesUpdateRequest,
    security: operations.PatientFlagTypesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientFlagTypesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientFlagTypesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_flag_types/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientFlagTypesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientFlagTypesUpdateResponse =
        new operations.PatientFlagTypesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient intervention for CQM
   */
  patientInterventionsCreate(
    req: operations.PatientInterventionsCreateRequest,
    security: operations.PatientInterventionsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientInterventionsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientInterventionsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_interventions";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientInterventionsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientInterventionsCreateResponse =
        new operations.PatientInterventionsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientIntervention = utils.objectToClass(
              httpRes?.data,
              shared.PatientIntervention
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient interventions for CQM
   */
  patientInterventionsList(
    req: operations.PatientInterventionsListRequest,
    security: operations.PatientInterventionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientInterventionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientInterventionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_interventions";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientInterventionsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientInterventionsListResponse =
        new operations.PatientInterventionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientInterventionsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientInterventionsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient intervention for CQM
   */
  patientInterventionsPartialUpdate(
    req: operations.PatientInterventionsPartialUpdateRequest,
    security: operations.PatientInterventionsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientInterventionsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientInterventionsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_interventions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientInterventionsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientInterventionsPartialUpdateResponse =
        new operations.PatientInterventionsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient intervention for CQM
   */
  patientInterventionsRead(
    req: operations.PatientInterventionsReadRequest,
    security: operations.PatientInterventionsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientInterventionsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientInterventionsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_interventions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientInterventionsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientInterventionsReadResponse =
        new operations.PatientInterventionsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientIntervention = utils.objectToClass(
              httpRes?.data,
              shared.PatientIntervention
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient intervention for CQM
   */
  patientInterventionsUpdate(
    req: operations.PatientInterventionsUpdateRequest,
    security: operations.PatientInterventionsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientInterventionsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientInterventionsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_interventions/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientInterventionsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientInterventionsUpdateResponse =
        new operations.PatientInterventionsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientLabResultsCreate(
    req: operations.PatientLabResultsCreateRequest,
    security: operations.PatientLabResultsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientLabResultsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientLabResultsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_lab_results";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientLabResultsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientLabResultsCreateResponse =
        new operations.PatientLabResultsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientLabResultSet = utils.objectToClass(
              httpRes?.data,
              shared.PatientLabResultSet
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientLabResultsDelete(
    req: operations.PatientLabResultsDeleteRequest,
    security: operations.PatientLabResultsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientLabResultsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientLabResultsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientLabResultsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientLabResultsDeleteResponse =
        new operations.PatientLabResultsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientLabResultsList(
    req: operations.PatientLabResultsListRequest,
    security: operations.PatientLabResultsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientLabResultsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientLabResultsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_lab_results";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientLabResultsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientLabResultsListResponse =
        new operations.PatientLabResultsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientLabResultsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientLabResultsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientLabResultsPartialUpdate(
    req: operations.PatientLabResultsPartialUpdateRequest,
    security: operations.PatientLabResultsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientLabResultsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientLabResultsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientLabResultsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientLabResultsPartialUpdateResponse =
        new operations.PatientLabResultsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientLabResultsRead(
    req: operations.PatientLabResultsReadRequest,
    security: operations.PatientLabResultsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientLabResultsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientLabResultsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientLabResultsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientLabResultsReadResponse =
        new operations.PatientLabResultsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientLabResultSet = utils.objectToClass(
              httpRes?.data,
              shared.PatientLabResultSet
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientLabResultsUpdate(
    req: operations.PatientLabResultsUpdateRequest,
    security: operations.PatientLabResultsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientLabResultsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientLabResultsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_lab_results/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientLabResultsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientLabResultsUpdateResponse =
        new operations.PatientLabResultsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientMessagesCreate(
    req: operations.PatientMessagesCreateRequest,
    security: operations.PatientMessagesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientMessagesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientMessagesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_messages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientMessagesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientMessagesCreateResponse =
        new operations.PatientMessagesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientMessage = utils.objectToClass(
              httpRes?.data,
              shared.PatientMessage
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientMessagesList(
    req: operations.PatientMessagesListRequest,
    security: operations.PatientMessagesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientMessagesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientMessagesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patient_messages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientMessagesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientMessagesListResponse =
        new operations.PatientMessagesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientMessagesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientMessagesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientMessagesPartialUpdate(
    req: operations.PatientMessagesPartialUpdateRequest,
    security: operations.PatientMessagesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientMessagesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientMessagesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_messages/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientMessagesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientMessagesPartialUpdateResponse =
        new operations.PatientMessagesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientMessagesRead(
    req: operations.PatientMessagesReadRequest,
    security: operations.PatientMessagesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientMessagesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientMessagesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_messages/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientMessagesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientMessagesReadResponse =
        new operations.PatientMessagesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientMessage = utils.objectToClass(
              httpRes?.data,
              shared.PatientMessage
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientMessagesUpdate(
    req: operations.PatientMessagesUpdateRequest,
    security: operations.PatientMessagesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientMessagesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientMessagesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_messages/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientMessagesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientMessagesUpdateResponse =
        new operations.PatientMessagesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient physical exam for CQM
   */
  patientPhysicalExamsCreate(
    req: operations.PatientPhysicalExamsCreateRequest,
    security: operations.PatientPhysicalExamsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPhysicalExamsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPhysicalExamsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_physical_exams";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPhysicalExamsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPhysicalExamsCreateResponse =
        new operations.PatientPhysicalExamsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientPhysicalExam = utils.objectToClass(
              httpRes?.data,
              shared.PatientPhysicalExam
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient physical exams for CQM
   */
  patientPhysicalExamsList(
    req: operations.PatientPhysicalExamsListRequest,
    security: operations.PatientPhysicalExamsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPhysicalExamsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPhysicalExamsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_physical_exams";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPhysicalExamsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPhysicalExamsListResponse =
        new operations.PatientPhysicalExamsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientPhysicalExamsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientPhysicalExamsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient physical exam for CQM
   */
  patientPhysicalExamsPartialUpdate(
    req: operations.PatientPhysicalExamsPartialUpdateRequest,
    security: operations.PatientPhysicalExamsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPhysicalExamsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPhysicalExamsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_physical_exams/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPhysicalExamsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPhysicalExamsPartialUpdateResponse =
        new operations.PatientPhysicalExamsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient physical exam for CQM
   */
  patientPhysicalExamsRead(
    req: operations.PatientPhysicalExamsReadRequest,
    security: operations.PatientPhysicalExamsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPhysicalExamsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPhysicalExamsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_physical_exams/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPhysicalExamsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPhysicalExamsReadResponse =
        new operations.PatientPhysicalExamsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientPhysicalExam = utils.objectToClass(
              httpRes?.data,
              shared.PatientPhysicalExam
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient physical exam for CQM
   */
  patientPhysicalExamsUpdate(
    req: operations.PatientPhysicalExamsUpdateRequest,
    security: operations.PatientPhysicalExamsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientPhysicalExamsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientPhysicalExamsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_physical_exams/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientPhysicalExamsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientPhysicalExamsUpdateResponse =
        new operations.PatientPhysicalExamsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientRiskAssessmentsCreate(
    req: operations.PatientRiskAssessmentsCreateRequest,
    security: operations.PatientRiskAssessmentsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientRiskAssessmentsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientRiskAssessmentsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_risk_assessments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientRiskAssessmentsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientRiskAssessmentsCreateResponse =
        new operations.PatientRiskAssessmentsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientRiskAssessment = utils.objectToClass(
              httpRes?.data,
              shared.PatientRiskAssessment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientRiskAssessmentsList(
    req: operations.PatientRiskAssessmentsListRequest,
    security: operations.PatientRiskAssessmentsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientRiskAssessmentsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientRiskAssessmentsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_risk_assessments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientRiskAssessmentsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientRiskAssessmentsListResponse =
        new operations.PatientRiskAssessmentsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientRiskAssessmentsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientRiskAssessmentsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientRiskAssessmentsPartialUpdate(
    req: operations.PatientRiskAssessmentsPartialUpdateRequest,
    security: operations.PatientRiskAssessmentsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientRiskAssessmentsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientRiskAssessmentsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_risk_assessments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientRiskAssessmentsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientRiskAssessmentsPartialUpdateResponse =
        new operations.PatientRiskAssessmentsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientRiskAssessmentsRead(
    req: operations.PatientRiskAssessmentsReadRequest,
    security: operations.PatientRiskAssessmentsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientRiskAssessmentsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientRiskAssessmentsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_risk_assessments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientRiskAssessmentsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientRiskAssessmentsReadResponse =
        new operations.PatientRiskAssessmentsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientRiskAssessment = utils.objectToClass(
              httpRes?.data,
              shared.PatientRiskAssessment
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientRiskAssessmentsUpdate(
    req: operations.PatientRiskAssessmentsUpdateRequest,
    security: operations.PatientRiskAssessmentsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientRiskAssessmentsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientRiskAssessmentsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_risk_assessments/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientRiskAssessmentsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientRiskAssessmentsUpdateResponse =
        new operations.PatientRiskAssessmentsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient vaccine records
   */
  patientVaccineRecordsCreate(
    req: operations.PatientVaccineRecordsCreateRequest,
    security: operations.PatientVaccineRecordsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientVaccineRecordsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientVaccineRecordsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_vaccine_records";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientVaccineRecordsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientVaccineRecordsCreateResponse =
        new operations.PatientVaccineRecordsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientVaccineRecord = utils.objectToClass(
              httpRes?.data,
              shared.PatientVaccineRecord
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient vaccine records
   */
  patientVaccineRecordsList(
    req: operations.PatientVaccineRecordsListRequest,
    security: operations.PatientVaccineRecordsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientVaccineRecordsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientVaccineRecordsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patient_vaccine_records";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientVaccineRecordsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientVaccineRecordsListResponse =
        new operations.PatientVaccineRecordsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientVaccineRecordsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientVaccineRecordsList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient vaccine records
   */
  patientVaccineRecordsPartialUpdate(
    req: operations.PatientVaccineRecordsPartialUpdateRequest,
    security: operations.PatientVaccineRecordsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientVaccineRecordsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientVaccineRecordsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_vaccine_records/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientVaccineRecordsPartialUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientVaccineRecordsPartialUpdateResponse =
        new operations.PatientVaccineRecordsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient vaccine records
   */
  patientVaccineRecordsRead(
    req: operations.PatientVaccineRecordsReadRequest,
    security: operations.PatientVaccineRecordsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientVaccineRecordsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientVaccineRecordsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_vaccine_records/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientVaccineRecordsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientVaccineRecordsReadResponse =
        new operations.PatientVaccineRecordsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientVaccineRecord = utils.objectToClass(
              httpRes?.data,
              shared.PatientVaccineRecord
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient vaccine records
   */
  patientVaccineRecordsUpdate(
    req: operations.PatientVaccineRecordsUpdateRequest,
    security: operations.PatientVaccineRecordsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientVaccineRecordsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientVaccineRecordsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patient_vaccine_records/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientVaccineRecordsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientVaccineRecordsUpdateResponse =
        new operations.PatientVaccineRecordsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve patient CCDA
   */
  patientsCcda(
    req: operations.PatientsCcdaRequest,
    security: operations.PatientsCcdaSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsCcdaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsCcdaRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients/{id}/ccda",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsCcdaSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsCcdaResponse =
        new operations.PatientsCcdaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient
   */
  patientsCreate(
    req: operations.PatientsCreateRequest,
    security: operations.PatientsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patients";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsCreateResponse =
        new operations.PatientsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patient = utils.objectToClass(httpRes?.data, shared.Patient);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing patient
   */
  patientsDelete(
    req: operations.PatientsDeleteRequest,
    security: operations.PatientsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/patients/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsDeleteResponse =
        new operations.PatientsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patients
   */
  patientsList(
    req: operations.PatientsListRequest,
    security: operations.PatientsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patients";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsListResponse =
        new operations.PatientsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.PatientsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Send new onpatient invite to patient
   */
  patientsOnpatientAccessCreate(
    req: operations.PatientsOnpatientAccessCreateRequest,
    security: operations.PatientsOnpatientAccessCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsOnpatientAccessCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsOnpatientAccessCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients/{id}/onpatient_access",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsOnpatientAccessCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsOnpatientAccessCreateResponse =
        new operations.PatientsOnpatientAccessCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patient = utils.objectToClass(httpRes?.data, shared.Patient);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Revoke sent onpatient invites
   */
  patientsOnpatientAccessDelete(
    req: operations.PatientsOnpatientAccessDeleteRequest,
    security: operations.PatientsOnpatientAccessDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsOnpatientAccessDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsOnpatientAccessDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients/{id}/onpatient_access",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsOnpatientAccessDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsOnpatientAccessDeleteResponse =
        new operations.PatientsOnpatientAccessDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search existing onpatient access invites
   */
  patientsOnpatientAccessRead(
    req: operations.PatientsOnpatientAccessReadRequest,
    security: operations.PatientsOnpatientAccessReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsOnpatientAccessReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsOnpatientAccessReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients/{id}/onpatient_access",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsOnpatientAccessReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsOnpatientAccessReadResponse =
        new operations.PatientsOnpatientAccessReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patient = utils.objectToClass(httpRes?.data, shared.Patient);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient
   */
  patientsPartialUpdate(
    req: operations.PatientsPartialUpdateRequest,
    security: operations.PatientsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/patients/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsPartialUpdateResponse =
        new operations.PatientsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve patient QRDA1
   */
  patientsQrda1(
    req: operations.PatientsQrda1Request,
    security: operations.PatientsQrda1Security,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsQrda1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsQrda1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients/{id}/qrda1",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsQrda1Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsQrda1Response =
        new operations.PatientsQrda1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/xml`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient
   */
  patientsRead(
    req: operations.PatientsReadRequest,
    security: operations.PatientsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/patients/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsReadResponse =
        new operations.PatientsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patient = utils.objectToClass(httpRes?.data, shared.Patient);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientsSummaryCreate(
    req: operations.PatientsSummaryCreateRequest,
    security: operations.PatientsSummaryCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsSummaryCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsSummaryCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patients_summary";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsSummaryCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsSummaryCreateResponse =
        new operations.PatientsSummaryCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patient = utils.objectToClass(httpRes?.data, shared.Patient);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientsSummaryDelete(
    req: operations.PatientsSummaryDeleteRequest,
    security: operations.PatientsSummaryDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsSummaryDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsSummaryDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients_summary/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsSummaryDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsSummaryDeleteResponse =
        new operations.PatientsSummaryDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientsSummaryList(
    req: operations.PatientsSummaryListRequest,
    security: operations.PatientsSummaryListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsSummaryListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsSummaryListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patients_summary";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsSummaryListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsSummaryListResponse =
        new operations.PatientsSummaryListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientsSummaryList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PatientsSummaryList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientsSummaryPartialUpdate(
    req: operations.PatientsSummaryPartialUpdateRequest,
    security: operations.PatientsSummaryPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsSummaryPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsSummaryPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients_summary/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsSummaryPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsSummaryPartialUpdateResponse =
        new operations.PatientsSummaryPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientsSummaryRead(
    req: operations.PatientsSummaryReadRequest,
    security: operations.PatientsSummaryReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsSummaryReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsSummaryReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients_summary/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsSummaryReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsSummaryReadResponse =
        new operations.PatientsSummaryReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patient = utils.objectToClass(httpRes?.data, shared.Patient);
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  patientsSummaryUpdate(
    req: operations.PatientsSummaryUpdateRequest,
    security: operations.PatientsSummaryUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsSummaryUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsSummaryUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patients_summary/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsSummaryUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsSummaryUpdateResponse =
        new operations.PatientsSummaryUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient
   */
  patientsUpdate(
    req: operations.PatientsUpdateRequest,
    security: operations.PatientsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatientsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatientsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/patients/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatientsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatientsUpdateResponse =
        new operations.PatientsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search prescription messages
   */
  prescriptionMessagesList(
    req: operations.PrescriptionMessagesListRequest,
    security: operations.PrescriptionMessagesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrescriptionMessagesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrescriptionMessagesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/prescription_messages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrescriptionMessagesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrescriptionMessagesListResponse =
        new operations.PrescriptionMessagesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.prescriptionMessagesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PrescriptionMessagesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing prescription message
   */
  prescriptionMessagesRead(
    req: operations.PrescriptionMessagesReadRequest,
    security: operations.PrescriptionMessagesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PrescriptionMessagesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PrescriptionMessagesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/prescription_messages/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PrescriptionMessagesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PrescriptionMessagesReadResponse =
        new operations.PrescriptionMessagesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.prescriptionMessage = utils.objectToClass(
              httpRes?.data,
              shared.PrescriptionMessage
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create patient problems
   */
  problemsCreate(
    req: operations.ProblemsCreateRequest,
    security: operations.ProblemsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProblemsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProblemsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/problems";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProblemsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProblemsCreateResponse =
        new operations.ProblemsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientProblem = utils.objectToClass(
              httpRes?.data,
              shared.PatientProblem
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search patient problems
   */
  problemsList(
    req: operations.ProblemsListRequest,
    security: operations.ProblemsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProblemsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProblemsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/problems";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProblemsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProblemsListResponse =
        new operations.ProblemsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.problemsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.ProblemsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient problems
   */
  problemsPartialUpdate(
    req: operations.ProblemsPartialUpdateRequest,
    security: operations.ProblemsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProblemsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProblemsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/problems/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProblemsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProblemsPartialUpdateResponse =
        new operations.ProblemsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing patient problems
   */
  problemsRead(
    req: operations.ProblemsReadRequest,
    security: operations.ProblemsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProblemsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProblemsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/problems/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProblemsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProblemsReadResponse =
        new operations.ProblemsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.patientProblem = utils.objectToClass(
              httpRes?.data,
              shared.PatientProblem
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing patient problems
   */
  problemsUpdate(
    req: operations.ProblemsUpdateRequest,
    security: operations.ProblemsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ProblemsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ProblemsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/problems/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ProblemsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ProblemsUpdateResponse =
        new operations.ProblemsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create reminder profile
   */
  reminderProfilesCreate(
    req: operations.ReminderProfilesCreateRequest,
    security: operations.ReminderProfilesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReminderProfilesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReminderProfilesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/reminder_profiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReminderProfilesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReminderProfilesCreateResponse =
        new operations.ReminderProfilesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reminderProfile = utils.objectToClass(
              httpRes?.data,
              shared.ReminderProfile
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing reminder profile
   */
  reminderProfilesDelete(
    req: operations.ReminderProfilesDeleteRequest,
    security: operations.ReminderProfilesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReminderProfilesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReminderProfilesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/reminder_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReminderProfilesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReminderProfilesDeleteResponse =
        new operations.ReminderProfilesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search reminder profiles
   */
  reminderProfilesList(
    req: operations.ReminderProfilesListRequest,
    security: operations.ReminderProfilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReminderProfilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReminderProfilesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/reminder_profiles";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReminderProfilesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReminderProfilesListResponse =
        new operations.ReminderProfilesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reminderProfilesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.ReminderProfilesList200ApplicationJSON
              );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing reminder profile
   */
  reminderProfilesPartialUpdate(
    req: operations.ReminderProfilesPartialUpdateRequest,
    security: operations.ReminderProfilesPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReminderProfilesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReminderProfilesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/reminder_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReminderProfilesPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReminderProfilesPartialUpdateResponse =
        new operations.ReminderProfilesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing reminder profile
   */
  reminderProfilesRead(
    req: operations.ReminderProfilesReadRequest,
    security: operations.ReminderProfilesReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReminderProfilesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReminderProfilesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/reminder_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReminderProfilesReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReminderProfilesReadResponse =
        new operations.ReminderProfilesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.reminderProfile = utils.objectToClass(
              httpRes?.data,
              shared.ReminderProfile
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing reminder profile
   */
  reminderProfilesUpdate(
    req: operations.ReminderProfilesUpdateRequest,
    security: operations.ReminderProfilesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ReminderProfilesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReminderProfilesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/reminder_profiles/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ReminderProfilesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReminderProfilesUpdateResponse =
        new operations.ReminderProfilesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create sub-vendors
   *
   * - When you get orders, submit them via `/api/lab_orders`, such that doctors can see them in drchrono.
   *
   * - When results come in, submit the result document PDF via `/api/lab_documents` and submit the results data via `/api/lab_results`
   *
   * - Update `/api/lab_orders` status
   *
   */
  sublabsCreate(
    config?: AxiosRequestConfig
  ): Promise<operations.SublabsCreateResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/sublabs";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SublabsCreateResponse =
        new operations.SublabsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labVendorLocation = utils.objectToClass(
              httpRes?.data,
              shared.LabVendorLocation
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Delete an existing sub vendor
   */
  sublabsDelete(
    req: operations.SublabsDeleteRequest,
    security: operations.SublabsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SublabsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SublabsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/sublabs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SublabsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SublabsDeleteResponse =
        new operations.SublabsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve or search sub vendors
   */
  sublabsList(
    req: operations.SublabsListRequest,
    security: operations.SublabsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SublabsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SublabsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/sublabs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SublabsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SublabsListResponse =
        new operations.SublabsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sublabsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SublabsList200ApplicationJSON
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing sub vendor
   */
  sublabsPartialUpdate(
    req: operations.SublabsPartialUpdateRequest,
    security: operations.SublabsPartialUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SublabsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SublabsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/sublabs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SublabsPartialUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SublabsPartialUpdateResponse =
        new operations.SublabsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an existing sub vendor
   */
  sublabsRead(
    req: operations.SublabsReadRequest,
    security: operations.SublabsReadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SublabsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SublabsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/sublabs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SublabsReadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SublabsReadResponse =
        new operations.SublabsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labVendorLocation = utils.objectToClass(
              httpRes?.data,
              shared.LabVendorLocation
            );
          }
          break;
        case [400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update an existing sub vendor
   */
  sublabsUpdate(
    req: operations.SublabsUpdateRequest,
    security: operations.SublabsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SublabsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SublabsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/api/sublabs/{id}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SublabsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SublabsUpdateResponse =
        new operations.SublabsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 400, 401, 403, 404, 405, 500].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }
}
