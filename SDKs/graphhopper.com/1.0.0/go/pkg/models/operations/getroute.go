// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

// GetRouteAlgorithmEnum - Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
// With `alternative_route`, we give you not one but several routes that are close to optimal, but
// not too similar to each other.
// With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
// a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
// You can control both of these features with additional parameters, see below.
type GetRouteAlgorithmEnum string

const (
	GetRouteAlgorithmEnumRoundTrip        GetRouteAlgorithmEnum = "round_trip"
	GetRouteAlgorithmEnumAlternativeRoute GetRouteAlgorithmEnum = "alternative_route"
)

func (e *GetRouteAlgorithmEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "round_trip":
		fallthrough
	case "alternative_route":
		*e = GetRouteAlgorithmEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRouteAlgorithmEnum: %s", s)
	}
}

type GetRouteCurbsideEnum string

const (
	GetRouteCurbsideEnumAny   GetRouteCurbsideEnum = "any"
	GetRouteCurbsideEnumRight GetRouteCurbsideEnum = "right"
	GetRouteCurbsideEnumLeft  GetRouteCurbsideEnum = "left"
)

func (e *GetRouteCurbsideEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "any":
		fallthrough
	case "right":
		fallthrough
	case "left":
		*e = GetRouteCurbsideEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetRouteCurbsideEnum: %s", s)
	}
}

type GetRouteRequest struct {
	// Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
	// With `alternative_route`, we give you not one but several routes that are close to optimal, but
	// not too similar to each other.
	// With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
	// a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
	// You can control both of these features with additional parameters, see below.
	//
	Algorithm *GetRouteAlgorithmEnum `queryParam:"style=form,explode=true,name=algorithm"`
	// If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives.
	//
	AlternativeRouteMaxPaths *int `queryParam:"style=form,explode=true,name=alternative_route.max_paths"`
	// If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives.
	//
	AlternativeRouteMaxShareFactor *float64 `queryParam:"style=form,explode=true,name=alternative_route.max_share_factor"`
	// If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives.
	//
	AlternativeRouteMaxWeightFactor *float64 `queryParam:"style=form,explode=true,name=alternative_route.max_weight_factor"`
	// Specify which road classes and environments you would like to avoid.
	// Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
	// Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
	//
	Avoid *string `queryParam:"style=form,explode=true,name=avoid"`
	// Block road access by specifying a point close to the road segment to be blocked, with the format `lat,lon`.
	// You can also block all road segments crossing a geometric shape. Specify a circle using the format `lat,lon,radius`, or a polygon using the format `lat1,lon1,lat2,lon2,...,latN,lonN`.
	// You can specify several shapes, separating them with `;`. Requires `ch.disable=true`.
	//
	BlockArea *string `queryParam:"style=form,explode=true,name=block_area"`
	// If the points for the route should be calculated at all.
	//
	CalcPoints *bool `queryParam:"style=form,explode=true,name=calc_points"`
	// Use this parameter in combination with one or more parameters from below.
	//
	ChDisable *bool `queryParam:"style=form,explode=true,name=ch.disable"`
	// Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
	//
	Curbside []GetRouteCurbsideEnum `queryParam:"style=form,explode=true,name=curbside"`
	// If `true`, the output will be formatted.
	//
	Debug *bool `queryParam:"style=form,explode=true,name=debug"`
	// Optional parameter to retrieve path details. You can request additional details for the route: `street_name`,
	// `time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
	//
	Details []string `queryParam:"style=form,explode=true,name=details"`
	// If `true`, a third coordinate, the altitude, is included with all positions in the response.
	// This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
	// encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
	// client side that can handle three-dimensional coordinates.
	// A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
	//
	Elevation *bool `queryParam:"style=form,explode=true,name=elevation"`
	// Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
	// In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
	// This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
	//
	Heading []int `queryParam:"style=form,explode=true,name=heading"`
	// Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`.
	//
	HeadingPenalty *int `queryParam:"style=form,explode=true,name=heading_penalty"`
	// If instructions should be calculated and returned
	//
	Instructions *bool `queryParam:"style=form,explode=true,name=instructions"`
	// The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German.
	//
	Locale *string `queryParam:"style=form,explode=true,name=locale"`
	// Normally, the calculated route will visit the points in the order you specified them.
	// If you have more than two points, you can set this parameter to `"true"` and the points may be re-ordered to minimize the total travel time.
	// Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
	//
	Optimize *string `queryParam:"style=form,explode=true,name=optimize"`
	// If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`.
	//
	PassThrough *bool `queryParam:"style=form,explode=true,name=pass_through"`
	// The points for which the route should be calculated. Format: `[latitude,longitude]`. Specify at least an origin and a destination. Via points are possible.
	// The maximum number depends on your plan.
	//
	Point []string `queryParam:"style=form,explode=true,name=point"`
	// The `point_hint` is typically a road name to which the associated `point` parameter should be snapped to. Specify no `point_hint` parameter or the same number as you have `point` parameters.
	//
	PointHint []string `queryParam:"style=form,explode=true,name=point_hint"`
	// Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
	// but requires special client code to unpack. (We provide it in our JavaScript client library!)
	// Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
	// See the description of the response format for more information.
	//
	PointsEncoded *bool `queryParam:"style=form,explode=true,name=points_encoded"`
	// If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`.
	//
	RoundTripDistance *int `queryParam:"style=form,explode=true,name=round_trip.distance"`
	// If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value.
	//
	RoundTripSeed *int64 `queryParam:"style=form,explode=true,name=round_trip.seed"`
	// Optional parameter to avoid snapping to a certain road class or road environment. Currently supported values are `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&snap_prevention=motorway`.
	//
	SnapPrevention []string `queryParam:"style=form,explode=true,name=snap_prevention"`
	// Specifies if turn restrictions should be considered. Enabling this option increases the route computation time. Only supported for motor vehicles and OpenStreetMap.
	//
	TurnCosts *bool `queryParam:"style=form,explode=true,name=turn_costs"`
	// The vehicle profile for which the route should be calculated.
	//
	Vehicle *shared.VehicleProfileIDEnum `queryParam:"style=form,explode=true,name=vehicle"`
	// Determines the way the "best" route is calculated. Besides `fastest` you can use `short_fastest` which finds a reasonable balance between the distance influence (`shortest`) and the time (`fastest`). You could also use `shortest` but is deprecated and not recommended for motor vehicles. All except `fastest` require `ch.disable=true`.
	//
	Weighting *string `queryParam:"style=form,explode=true,name=weighting"`
}

type GetRouteResponse struct {
	ContentType string
	// Your request is not valid. For example, you specified too few or too many points.
	GHError *shared.GHError
	Headers map[string][]string
	// Routing Result
	RouteResponse *shared.RouteResponse
	StatusCode    int
	RawResponse   *http.Response
}
