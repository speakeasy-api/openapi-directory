"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import approximateprogress as shared_approximateprogress
from ..shared import approximatereportedprogress as shared_approximatereportedprogress
from ..shared import counterupdate as shared_counterupdate
from ..shared import dynamicsourcesplit as shared_dynamicsourcesplit
from ..shared import metricupdate as shared_metricupdate
from ..shared import position as shared_position
from ..shared import sourcefork as shared_sourcefork
from ..shared import sourceoperationresponse as shared_sourceoperationresponse
from ..shared import status as shared_status
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class WorkItemStatus:
    r"""Conveys a worker's progress through the work described by a WorkItem."""
    
    completed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('completed'), 'exclude': lambda f: f is None }})
    r"""True if the WorkItem was completed (successfully or unsuccessfully)."""  
    counter_updates: Optional[list[shared_counterupdate.CounterUpdate]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('counterUpdates'), 'exclude': lambda f: f is None }})
    r"""Worker output counters for this WorkItem."""  
    dynamic_source_split: Optional[shared_dynamicsourcesplit.DynamicSourceSplit] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dynamicSourceSplit'), 'exclude': lambda f: f is None }})
    r"""When a task splits using WorkItemStatus.dynamic_source_split, this message describes the two parts of the split relative to the description of the current task's input."""  
    errors: Optional[list[shared_status.Status]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('errors'), 'exclude': lambda f: f is None }})
    r"""Specifies errors which occurred during processing. If errors are provided, and completed = true, then the WorkItem is considered to have failed."""  
    metric_updates: Optional[list[shared_metricupdate.MetricUpdate]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricUpdates'), 'exclude': lambda f: f is None }})
    r"""DEPRECATED in favor of counter_updates."""  
    progress: Optional[shared_approximateprogress.ApproximateProgress] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('progress'), 'exclude': lambda f: f is None }})
    r"""Obsolete in favor of ApproximateReportedProgress and ApproximateSplitRequest."""  
    reported_progress: Optional[shared_approximatereportedprogress.ApproximateReportedProgress] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reportedProgress'), 'exclude': lambda f: f is None }})
    r"""A progress measurement of a WorkItem by a worker."""  
    report_index: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reportIndex'), 'exclude': lambda f: f is None }})
    r"""The report index. When a WorkItem is leased, the lease will contain an initial report index. When a WorkItem's status is reported to the system, the report should be sent with that report index, and the response will contain the index the worker should use for the next report. Reports received with unexpected index values will be rejected by the service. In order to preserve idempotency, the worker should not alter the contents of a report, even if the worker must submit the same report multiple times before getting back a response. The worker should not submit a subsequent report until the response for the previous report had been received from the service."""  
    requested_lease_duration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('requestedLeaseDuration'), 'exclude': lambda f: f is None }})
    r"""Amount of time the worker requests for its lease."""  
    source_fork: Optional[shared_sourcefork.SourceFork] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sourceFork'), 'exclude': lambda f: f is None }})
    r"""DEPRECATED in favor of DynamicSourceSplit."""  
    source_operation_response: Optional[shared_sourceoperationresponse.SourceOperationResponse] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sourceOperationResponse'), 'exclude': lambda f: f is None }})
    r"""The result of a SourceOperationRequest, specified in ReportWorkItemStatusRequest.source_operation when the work item is completed."""  
    stop_position: Optional[shared_position.Position] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('stopPosition'), 'exclude': lambda f: f is None }})
    r"""Position defines a position within a collection of data. The value can be either the end position, a key (used with ordered collections), a byte offset, or a record index."""  
    total_throttler_wait_time_seconds: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('totalThrottlerWaitTimeSeconds'), 'exclude': lambda f: f is None }})
    r"""Total time the worker spent being throttled by external systems."""  
    work_item_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('workItemId'), 'exclude': lambda f: f is None }})
    r"""Identifies the WorkItem."""  
    