"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Any, Optional

class Account:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def users_get_user_metadata(self) -> operations.UsersGetUserMetadataResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/user/metadata/optimizely'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersGetUserMetadataResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersGetUserMetadata200ApplicationJSON])
                res.users_get_user_metadata_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersGetUserMetadataDefaultApplicationJSON])
                res.users_get_user_metadata_default_application_json_object = out

        return res

    def app_api_tokens_delete(self, request: operations.AppAPITokensDeleteRequest, security: operations.AppAPITokensDeleteSecurity) -> operations.AppAPITokensDeleteResponse:
        r"""Delete the App Api Token object with the specific ID"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppAPITokensDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/api_tokens/{api_token_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppAPITokensDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensDelete400ApplicationJSON])
                res.app_api_tokens_delete_400_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensDelete401ApplicationJSON])
                res.app_api_tokens_delete_401_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensDelete404ApplicationJSON])
                res.app_api_tokens_delete_404_application_json_object = out

        return res

    def app_api_tokens_list(self, request: operations.AppAPITokensListRequest, security: operations.AppAPITokensListSecurity) -> operations.AppAPITokensListResponse:
        r"""Returns App API tokens for the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppAPITokensListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/api_tokens', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppAPITokensListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppAPITokensList200ApplicationJSON]])
                res.app_api_tokens_list_200_application_json_objects = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensList400ApplicationJSON])
                res.app_api_tokens_list_400_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensList401ApplicationJSON])
                res.app_api_tokens_list_401_application_json_object = out

        return res

    def app_api_tokens_new(self, request: operations.AppAPITokensNewRequest, security: operations.AppAPITokensNewSecurity) -> operations.AppAPITokensNewResponse:
        r"""Creates a new App API token"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppAPITokensNewRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/api_tokens', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppAPITokensNewResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensNew201ApplicationJSON])
                res.app_api_tokens_new_201_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensNew400ApplicationJSON])
                res.app_api_tokens_new_400_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppAPITokensNew401ApplicationJSON])
                res.app_api_tokens_new_401_application_json_object = out

        return res

    def app_invitations_accept(self, request: operations.AppInvitationsAcceptRequest, security: operations.AppInvitationsAcceptSecurity) -> operations.AppInvitationsAcceptResponse:
        r"""Accepts a pending invitation for the specified user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsAcceptRequest, base_url, '/v0.1/user/invitations/apps/{invitation_token}/accept', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsAcceptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsAcceptDefaultApplicationJSON])
                res.app_invitations_accept_default_application_json_object = out

        return res

    def app_invitations_create(self, request: operations.AppInvitationsCreateRequest, security: operations.AppInvitationsCreateSecurity) -> operations.AppInvitationsCreateResponse:
        r"""Invites a new or existing user to an app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/invitations', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsCreateDefaultApplicationJSON])
                res.app_invitations_create_default_application_json_object = out

        return res

    def app_invitations_create_by_email(self, request: operations.AppInvitationsCreateByEmailRequest, security: operations.AppInvitationsCreateByEmailSecurity) -> operations.AppInvitationsCreateByEmailResponse:
        r"""Invites a new or existing user to an app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsCreateByEmailRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsCreateByEmailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsCreateByEmailDefaultApplicationJSON])
                res.app_invitations_create_by_email_default_application_json_object = out

        return res

    def app_invitations_delete(self, request: operations.AppInvitationsDeleteRequest, security: operations.AppInvitationsDeleteSecurity) -> operations.AppInvitationsDeleteResponse:
        r"""Removes a user's invitation to an app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsDeleteDefaultApplicationJSON])
                res.app_invitations_delete_default_application_json_object = out

        return res

    def app_invitations_list(self, request: operations.AppInvitationsListRequest, security: operations.AppInvitationsListSecurity) -> operations.AppInvitationsListResponse:
        r"""Gets the pending invitations for the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/invitations', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsList200ApplicationJSON])
                res.app_invitations_list_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsListDefaultApplicationJSON])
                res.app_invitations_list_default_application_json_object = out

        return res

    def app_invitations_reject(self, request: operations.AppInvitationsRejectRequest, security: operations.AppInvitationsRejectSecurity) -> operations.AppInvitationsRejectResponse:
        r"""Rejects a pending invitation for the specified user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsRejectRequest, base_url, '/v0.1/user/invitations/apps/{invitation_token}/reject', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsRejectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsRejectDefaultApplicationJSON])
                res.app_invitations_reject_default_application_json_object = out

        return res

    def app_invitations_update_permissions(self, request: operations.AppInvitationsUpdatePermissionsRequest, security: operations.AppInvitationsUpdatePermissionsSecurity) -> operations.AppInvitationsUpdatePermissionsResponse:
        r"""Update pending invitation permission"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppInvitationsUpdatePermissionsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/invitations/{user_email}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppInvitationsUpdatePermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppInvitationsUpdatePermissionsDefaultApplicationJSON])
                res.app_invitations_update_permissions_default_application_json_object = out

        return res

    def apps_create(self, request: operations.AppsCreateRequestBody, security: operations.AppsCreateSecurity) -> operations.AppsCreateResponse:
        r"""Creates a new app and returns it to the caller"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/apps'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsCreate201ApplicationJSON])
                res.apps_create_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsCreateDefaultApplicationJSON])
                res.apps_create_default_application_json_object = out

        return res

    def apps_create_for_org(self, request: operations.AppsCreateForOrgRequest, security: operations.AppsCreateForOrgSecurity) -> operations.AppsCreateForOrgResponse:
        r"""Creates a new app for the organization and returns it to the caller"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsCreateForOrgRequest, base_url, '/v0.1/orgs/{org_name}/apps', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsCreateForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsCreateForOrg200ApplicationJSON])
                res.apps_create_for_org_200_application_json_object = out
        elif http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsCreateForOrg201ApplicationJSON])
                res.apps_create_for_org_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsCreateForOrgDefaultApplicationJSON])
                res.apps_create_for_org_default_application_json_object = out

        return res

    def apps_delete(self, request: operations.AppsDeleteRequest, security: operations.AppsDeleteSecurity) -> operations.AppsDeleteResponse:
        r"""Delete an app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsDeleteDefaultApplicationJSON])
                res.apps_delete_default_application_json_object = out

        return res

    def apps_delete_avatar(self, request: operations.AppsDeleteAvatarRequest, security: operations.AppsDeleteAvatarSecurity) -> operations.AppsDeleteAvatarResponse:
        r"""Deletes the uploaded app avatar"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsDeleteAvatarRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/avatar', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsDeleteAvatarResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsDeleteAvatar200ApplicationJSON])
                res.apps_delete_avatar_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsDeleteAvatarDefaultApplicationJSON])
                res.apps_delete_avatar_default_application_json_object = out

        return res

    def apps_get(self, request: operations.AppsGetRequest, security: operations.AppsGetSecurity) -> operations.AppsGetResponse:
        r"""Return a specific app with the given app name which belongs to the given owner."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsGet200ApplicationJSON])
                res.apps_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsGetDefaultApplicationJSON])
                res.apps_get_default_application_json_object = out

        return res

    def apps_get_for_org_user(self, request: operations.AppsGetForOrgUserRequest, security: operations.AppsGetForOrgUserSecurity) -> operations.AppsGetForOrgUserResponse:
        r"""Get a user apps information from an organization by name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsGetForOrgUserRequest, base_url, '/v0.1/orgs/{org_name}/users/{user_name}/apps', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsGetForOrgUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppsGetForOrgUser200ApplicationJSON]])
                res.apps_get_for_org_user_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsGetForOrgUserDefaultApplicationJSON])
                res.apps_get_for_org_user_default_application_json_object = out

        return res

    def apps_get_teams(self, request: operations.AppsGetTeamsRequest, security: operations.AppsGetTeamsSecurity) -> operations.AppsGetTeamsResponse:
        r"""Returns the details of all teams that have access to the app."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsGetTeamsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/teams', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsGetTeamsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppsGetTeams200ApplicationJSON]])
                res.apps_get_teams_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsGetTeamsDefaultApplicationJSON])
                res.apps_get_teams_default_application_json_object = out

        return res

    def apps_list(self, request: operations.AppsListRequest, security: operations.AppsListSecurity) -> operations.AppsListResponse:
        r"""Returns a list of apps"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/apps'
        
        query_params = utils.get_query_params(operations.AppsListRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppsList200ApplicationJSON]])
                res.apps_list_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsListDefaultApplicationJSON])
                res.apps_list_default_application_json_object = out

        return res

    def apps_list_for_org(self, request: operations.AppsListForOrgRequest, security: operations.AppsListForOrgSecurity) -> operations.AppsListForOrgResponse:
        r"""Returns a list of apps for the organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsListForOrgRequest, base_url, '/v0.1/orgs/{org_name}/apps', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsListForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppsListForOrg200ApplicationJSON]])
                res.apps_list_for_org_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsListForOrgDefaultApplicationJSON])
                res.apps_list_for_org_default_application_json_object = out

        return res

    def apps_list_testers(self, request: operations.AppsListTestersRequest, security: operations.AppsListTestersSecurity) -> operations.AppsListTestersResponse:
        r"""Returns the testers associated with the app specified with the given app name which belongs to the given owner."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsListTestersRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/testers', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsListTestersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AppsListTesters200ApplicationJSON]])
                res.apps_list_testers_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsListTestersDefaultApplicationJSON])
                res.apps_list_testers_default_application_json_object = out

        return res

    def apps_remove_user(self, request: operations.AppsRemoveUserRequest, security: operations.AppsRemoveUserSecurity) -> operations.AppsRemoveUserResponse:
        r"""Removes the user from the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsRemoveUserRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/users/{user_email}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsRemoveUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsRemoveUserDefaultApplicationJSON])
                res.apps_remove_user_default_application_json_object = out

        return res

    def apps_transfer_ownership_json(self, request: operations.AppsTransferOwnershipJSONRequest, security: operations.AppsTransferOwnershipJSONSecurity) -> operations.AppsTransferOwnershipJSONResponse:
        r"""Transfers ownership of an app to a different user or organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsTransferOwnershipJSONRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/transfer/{destination_owner_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsTransferOwnershipJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsTransferOwnershipJSON200ApplicationJSON])
                res.apps_transfer_ownership_json_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsTransferOwnershipJSONDefaultApplicationJSON])
                res.apps_transfer_ownership_json_default_application_json_object = out

        return res

    def apps_transfer_ownership_raw(self, request: operations.AppsTransferOwnershipRawRequest, security: operations.AppsTransferOwnershipRawSecurity) -> operations.AppsTransferOwnershipRawResponse:
        r"""Transfers ownership of an app to a different user or organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsTransferOwnershipRawRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/transfer/{destination_owner_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsTransferOwnershipRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsTransferOwnershipRaw200ApplicationJSON])
                res.apps_transfer_ownership_raw_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsTransferOwnershipRawDefaultApplicationJSON])
                res.apps_transfer_ownership_raw_default_application_json_object = out

        return res

    def apps_transfer_to_org(self, request: operations.AppsTransferToOrgRequest, security: operations.AppsTransferToOrgSecurity) -> operations.AppsTransferToOrgResponse:
        r"""Transfers ownership of an app to a new organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsTransferToOrgRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/transfer_to_org', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsTransferToOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsTransferToOrg200ApplicationJSON])
                res.apps_transfer_to_org_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsTransferToOrgDefaultApplicationJSON])
                res.apps_transfer_to_org_default_application_json_object = out

        return res

    def apps_update(self, request: operations.AppsUpdateRequest, security: operations.AppsUpdateSecurity) -> operations.AppsUpdateResponse:
        r"""Partially updates a single app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsUpdateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsUpdate200ApplicationJSON])
                res.apps_update_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsUpdateDefaultApplicationJSON])
                res.apps_update_default_application_json_object = out

        return res

    def apps_update_avatar(self, request: operations.AppsUpdateAvatarRequest, security: operations.AppsUpdateAvatarSecurity) -> operations.AppsUpdateAvatarResponse:
        r"""Sets the app avatar"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsUpdateAvatarRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/avatar', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsUpdateAvatarResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsUpdateAvatar200ApplicationJSON])
                res.apps_update_avatar_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsUpdateAvatarDefaultApplicationJSON])
                res.apps_update_avatar_default_application_json_object = out

        return res

    def apps_update_user_permissions(self, request: operations.AppsUpdateUserPermissionsRequest, security: operations.AppsUpdateUserPermissionsSecurity) -> operations.AppsUpdateUserPermissionsResponse:
        r"""Update user permission for the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AppsUpdateUserPermissionsRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/users/{user_email}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AppsUpdateUserPermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AppsUpdateUserPermissionsDefaultApplicationJSON])
                res.apps_update_user_permissions_default_application_json_object = out

        return res

    def azure_subscription_delete_for_app(self, request: operations.AzureSubscriptionDeleteForAppRequest, security: operations.AzureSubscriptionDeleteForAppSecurity) -> operations.AzureSubscriptionDeleteForAppResponse:
        r"""Delete the azure subscriptions for the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AzureSubscriptionDeleteForAppRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions/{azure_subscription_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AzureSubscriptionDeleteForAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AzureSubscriptionDeleteForAppDefaultApplicationJSON])
                res.azure_subscription_delete_for_app_default_application_json_object = out

        return res

    def azure_subscription_link_for_app(self, request: operations.AzureSubscriptionLinkForAppRequest, security: operations.AzureSubscriptionLinkForAppSecurity) -> operations.AzureSubscriptionLinkForAppResponse:
        r"""Link azure subscription to an app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AzureSubscriptionLinkForAppRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AzureSubscriptionLinkForAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AzureSubscriptionLinkForAppDefaultApplicationJSON])
                res.azure_subscription_link_for_app_default_application_json_object = out

        return res

    def azure_subscription_list_for_app(self, request: operations.AzureSubscriptionListForAppRequest, security: operations.AzureSubscriptionListForAppSecurity) -> operations.AzureSubscriptionListForAppResponse:
        r"""Returns a list of azure subscriptions for the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AzureSubscriptionListForAppRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/azure_subscriptions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AzureSubscriptionListForAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AzureSubscriptionListForApp200ApplicationJSON]])
                res.azure_subscription_list_for_app_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AzureSubscriptionListForAppDefaultApplicationJSON])
                res.azure_subscription_list_for_app_default_application_json_object = out

        return res

    def azure_subscription_list_for_org(self, request: operations.AzureSubscriptionListForOrgRequest, security: operations.AzureSubscriptionListForOrgSecurity) -> operations.AzureSubscriptionListForOrgResponse:
        r"""Returns a list of azure subscriptions for the organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AzureSubscriptionListForOrgRequest, base_url, '/v0.1/orgs/{org_name}/azure_subscriptions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AzureSubscriptionListForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AzureSubscriptionListForOrg200ApplicationJSON]])
                res.azure_subscription_list_for_org_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AzureSubscriptionListForOrgDefaultApplicationJSON])
                res.azure_subscription_list_for_org_default_application_json_object = out

        return res

    def azure_subscription_list_for_user(self) -> operations.AzureSubscriptionListForUserResponse:
        r"""Returns a list of azure subscriptions for the user"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/azure_subscriptions'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AzureSubscriptionListForUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.AzureSubscriptionListForUser200ApplicationJSON]])
                res.azure_subscription_list_for_user_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.AzureSubscriptionListForUserDefaultApplicationJSON])
                res.azure_subscription_list_for_user_default_application_json_object = out

        return res

    def distribution_group_invitations_accept_all(self, request: dict[str, Any], security: operations.DistributionGroupInvitationsAcceptAllSecurity) -> operations.DistributionGroupInvitationsAcceptAllResponse:
        r"""Accepts all pending invitations to distribution groups for the specified user"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/user/invitations/distribution_groups/accept'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupInvitationsAcceptAllResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupInvitationsAcceptAllDefaultApplicationJSON])
                res.distribution_group_invitations_accept_all_default_application_json_object = out

        return res

    def distribution_groups_add_apps(self, request: operations.DistributionGroupsAddAppsRequest, security: operations.DistributionGroupsAddAppsSecurity) -> operations.DistributionGroupsAddAppsResponse:
        r"""Add apps to distribution group in an org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsAddAppsRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsAddAppsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def distribution_groups_add_user(self, request: operations.DistributionGroupsAddUserRequest, security: operations.DistributionGroupsAddUserSecurity) -> operations.DistributionGroupsAddUserResponse:
        r"""Adds the members to the specified distribution group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsAddUserRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsAddUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsAddUser200ApplicationJSON]])
                res.distribution_groups_add_user_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsAddUserDefaultApplicationJSON])
                res.distribution_groups_add_user_default_application_json_object = out

        return res

    def distribution_groups_add_users_for_org(self, request: operations.DistributionGroupsAddUsersForOrgRequest, security: operations.DistributionGroupsAddUsersForOrgSecurity) -> operations.DistributionGroupsAddUsersForOrgResponse:
        r"""Accepts an array of user email addresses to get added to the specified group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsAddUsersForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsAddUsersForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsAddUsersForOrg200ApplicationJSON]])
                res.distribution_groups_add_users_for_org_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsAddUsersForOrgDefaultApplicationJSON])
                res.distribution_groups_add_users_for_org_default_application_json_object = out

        return res

    def distribution_groups_bulk_delete_apps(self, request: operations.DistributionGroupsBulkDeleteAppsRequest, security: operations.DistributionGroupsBulkDeleteAppsSecurity) -> operations.DistributionGroupsBulkDeleteAppsResponse:
        r"""Delete apps from distribution group in an org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsBulkDeleteAppsRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps/bulk_delete', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsBulkDeleteAppsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def distribution_groups_bulk_delete_users(self, request: operations.DistributionGroupsBulkDeleteUsersRequest, security: operations.DistributionGroupsBulkDeleteUsersSecurity) -> operations.DistributionGroupsBulkDeleteUsersResponse:
        r"""Delete testers from distribution group in an org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsBulkDeleteUsersRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members/bulk_delete', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsBulkDeleteUsersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def distribution_groups_create(self, request: operations.DistributionGroupsCreateRequest, security: operations.DistributionGroupsCreateSecurity) -> operations.DistributionGroupsCreateResponse:
        r"""Creates a new distribution group and returns it to the caller"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsCreateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsCreate201ApplicationJSON])
                res.distribution_groups_create_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsCreateDefaultApplicationJSON])
                res.distribution_groups_create_default_application_json_object = out

        return res

    def distribution_groups_create_for_org(self, request: operations.DistributionGroupsCreateForOrgRequest, security: operations.DistributionGroupsCreateForOrgSecurity) -> operations.DistributionGroupsCreateForOrgResponse:
        r"""Creates a disribution goup which can be shared across apps under an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsCreateForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsCreateForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsCreateForOrg201ApplicationJSON])
                res.distribution_groups_create_for_org_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsCreateForOrgDefaultApplicationJSON])
                res.distribution_groups_create_for_org_default_application_json_object = out

        return res

    def distribution_groups_delete(self, request: operations.DistributionGroupsDeleteRequest, security: operations.DistributionGroupsDeleteSecurity) -> operations.DistributionGroupsDeleteResponse:
        r"""Deletes a distribution group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsDeleteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsDeleteDefaultApplicationJSON])
                res.distribution_groups_delete_default_application_json_object = out

        return res

    def distribution_groups_delete_for_org(self, request: operations.DistributionGroupsDeleteForOrgRequest, security: operations.DistributionGroupsDeleteForOrgSecurity) -> operations.DistributionGroupsDeleteForOrgResponse:
        r"""Deletes a single distribution group from an org with a given distribution group name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsDeleteForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsDeleteForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsDeleteForOrgDefaultApplicationJSON])
                res.distribution_groups_delete_for_org_default_application_json_object = out

        return res

    def distribution_groups_details_for_org(self, request: operations.DistributionGroupsDetailsForOrgRequest, security: operations.DistributionGroupsDetailsForOrgSecurity) -> operations.DistributionGroupsDetailsForOrgResponse:
        r"""Returns a list of distribution groups with details for an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsDetailsForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups_details', request)
        
        query_params = utils.get_query_params(operations.DistributionGroupsDetailsForOrgRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsDetailsForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsDetailsForOrg200ApplicationJSON]])
                res.distribution_groups_details_for_org_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsDetailsForOrgDefaultApplicationJSON])
                res.distribution_groups_details_for_org_default_application_json_object = out

        return res

    def distribution_groups_get(self, request: operations.DistributionGroupsGetRequest, security: operations.DistributionGroupsGetSecurity) -> operations.DistributionGroupsGetResponse:
        r"""Returns a single distribution group for a given distribution group name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsGetRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsGet200ApplicationJSON])
                res.distribution_groups_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsGetDefaultApplicationJSON])
                res.distribution_groups_get_default_application_json_object = out

        return res

    def distribution_groups_get_apps(self, request: operations.DistributionGroupsGetAppsRequest, security: operations.DistributionGroupsGetAppsSecurity) -> operations.DistributionGroupsGetAppsResponse:
        r"""Get apps from a distribution group in an org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsGetAppsRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/apps', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsGetAppsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsGetApps200ApplicationJSON]])
                res.distribution_groups_get_apps_200_application_json_anies = out

        return res

    def distribution_groups_get_for_org(self, request: operations.DistributionGroupsGetForOrgRequest, security: operations.DistributionGroupsGetForOrgSecurity) -> operations.DistributionGroupsGetForOrgResponse:
        r"""Returns a single distribution group in org for a given distribution group name"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsGetForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsGetForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsGetForOrg200ApplicationJSON])
                res.distribution_groups_get_for_org_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsGetForOrgDefaultApplicationJSON])
                res.distribution_groups_get_for_org_default_application_json_object = out

        return res

    def distribution_groups_list(self, request: operations.DistributionGroupsListRequest, security: operations.DistributionGroupsListSecurity) -> operations.DistributionGroupsListResponse:
        r"""Returns a list of distribution groups in the app specified"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsList200ApplicationJSON]])
                res.distribution_groups_list_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsListDefaultApplicationJSON])
                res.distribution_groups_list_default_application_json_object = out

        return res

    def distribution_groups_list_all_testers_for_org(self, request: operations.DistributionGroupsListAllTestersForOrgRequest, security: operations.DistributionGroupsListAllTestersForOrgSecurity) -> operations.DistributionGroupsListAllTestersForOrgResponse:
        r"""Returns a unique list of users including the whole organization members plus testers in any shared group of that org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsListAllTestersForOrgRequest, base_url, '/v0.1/orgs/{org_name}/testers', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsListAllTestersForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsListAllTestersForOrg200ApplicationJSON]])
                res.distribution_groups_list_all_testers_for_org_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsListAllTestersForOrgDefaultApplicationJSON])
                res.distribution_groups_list_all_testers_for_org_default_application_json_object = out

        return res

    def distribution_groups_list_for_org(self, request: operations.DistributionGroupsListForOrgRequest, security: operations.DistributionGroupsListForOrgSecurity) -> operations.DistributionGroupsListForOrgResponse:
        r"""Returns a list of distribution groups in the org specified"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsListForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsListForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsListForOrg201ApplicationJSON]])
                res.distribution_groups_list_for_org_201_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsListForOrgDefaultApplicationJSON])
                res.distribution_groups_list_for_org_default_application_json_object = out

        return res

    def distribution_groups_list_users(self, request: operations.DistributionGroupsListUsersRequest, security: operations.DistributionGroupsListUsersSecurity) -> operations.DistributionGroupsListUsersResponse:
        r"""Returns a list of member details in the distribution group specified"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsListUsersRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members', request)
        
        query_params = utils.get_query_params(operations.DistributionGroupsListUsersRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsListUsersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsListUsers200ApplicationJSON]])
                res.distribution_groups_list_users_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsListUsersDefaultApplicationJSON])
                res.distribution_groups_list_users_default_application_json_object = out

        return res

    def distribution_groups_list_users_for_org(self, request: operations.DistributionGroupsListUsersForOrgRequest, security: operations.DistributionGroupsListUsersForOrgSecurity) -> operations.DistributionGroupsListUsersForOrgResponse:
        r"""Returns a list of member in the distribution group specified"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsListUsersForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/members', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsListUsersForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsListUsersForOrg200ApplicationJSON]])
                res.distribution_groups_list_users_for_org_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsListUsersForOrgDefaultApplicationJSON])
                res.distribution_groups_list_users_for_org_default_application_json_object = out

        return res

    def distribution_groups_patch_for_org(self, request: operations.DistributionGroupsPatchForOrgRequest, security: operations.DistributionGroupsPatchForOrgSecurity) -> operations.DistributionGroupsPatchForOrgResponse:
        r"""Update one given distribution group name in an org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsPatchForOrgRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsPatchForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsPatchForOrg200ApplicationJSON])
                res.distribution_groups_patch_for_org_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsPatchForOrgDefaultApplicationJSON])
                res.distribution_groups_patch_for_org_default_application_json_object = out

        return res

    def distribution_groups_remove_user(self, request: operations.DistributionGroupsRemoveUserRequest, security: operations.DistributionGroupsRemoveUserSecurity) -> operations.DistributionGroupsRemoveUserResponse:
        r"""Remove the users from the distribution group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsRemoveUserRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/members/bulk_delete', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsRemoveUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.DistributionGroupsRemoveUser200ApplicationJSON]])
                res.distribution_groups_remove_user_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsRemoveUserDefaultApplicationJSON])
                res.distribution_groups_remove_user_default_application_json_object = out

        return res

    def distribution_groups_resend_invite(self, request: operations.DistributionGroupsResendInviteRequest, security: operations.DistributionGroupsResendInviteSecurity) -> operations.DistributionGroupsResendInviteResponse:
        r"""Resend distribution group app invite notification to previously invited testers"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsResendInviteRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/resend_invite', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsResendInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsResendInviteDefaultApplicationJSON])
                res.distribution_groups_resend_invite_default_application_json_object = out

        return res

    def distribution_groups_resend_shared_invite(self, request: operations.DistributionGroupsResendSharedInviteRequest, security: operations.DistributionGroupsResendSharedInviteSecurity) -> operations.DistributionGroupsResendSharedInviteResponse:
        r"""Resend shared distribution group invite notification to previously invited testers"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsResendSharedInviteRequest, base_url, '/v0.1/orgs/{org_name}/distribution_groups/{distribution_group_name}/resend_invite', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsResendSharedInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsResendSharedInviteDefaultApplicationJSON])
                res.distribution_groups_resend_shared_invite_default_application_json_object = out

        return res

    def distribution_groups_update(self, request: operations.DistributionGroupsUpdateRequest, security: operations.DistributionGroupsUpdateSecurity) -> operations.DistributionGroupsUpdateResponse:
        r"""Updates the attributes of distribution group"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DistributionGroupsUpdateRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DistributionGroupsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsUpdate200ApplicationJSON])
                res.distribution_groups_update_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.DistributionGroupsUpdateDefaultApplicationJSON])
                res.distribution_groups_update_default_application_json_object = out

        return res

    def invitations_sent(self) -> operations.InvitationsSentResponse:
        r"""Returns all invitations sent by the caller"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/invitations/sent'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InvitationsSentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.InvitationsSent200ApplicationJSON]])
                res.invitations_sent_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.InvitationsSentDefaultApplicationJSON])
                res.invitations_sent_default_application_json_object = out

        return res

    def org_invitations_(self, request: operations.OrgInvitationsRequest, security: operations.OrgInvitationsSecurity) -> operations.OrgInvitationsResponse:
        r"""Removes a user's invitation to an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsRequest, base_url, '/v0.1/orgs/{org_name}/invitations/{email}/revoke', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsDefaultApplicationJSON])
                res.org_invitations_default_application_json_object = out

        return res

    def org_invitations_accept(self, request: operations.OrgInvitationsAcceptRequest, security: operations.OrgInvitationsAcceptSecurity) -> operations.OrgInvitationsAcceptResponse:
        r"""Accepts a pending organization invitation for the specified user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsAcceptRequest, base_url, '/v0.1/user/invitations/orgs/{invitation_token}/accept', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsAcceptResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsAcceptDefaultApplicationJSON])
                res.org_invitations_accept_default_application_json_object = out

        return res

    def org_invitations_create(self, request: operations.OrgInvitationsCreateRequest, security: operations.OrgInvitationsCreateSecurity) -> operations.OrgInvitationsCreateResponse:
        r"""Invites a new or existing user to an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsCreateRequest, base_url, '/v0.1/orgs/{org_name}/invitations', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsCreateDefaultApplicationJSON])
                res.org_invitations_create_default_application_json_object = out

        return res

    def org_invitations_delete(self, request: operations.OrgInvitationsDeleteRequest, security: operations.OrgInvitationsDeleteSecurity) -> operations.OrgInvitationsDeleteResponse:
        r"""Removes a user's invitation to an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsDeleteRequest, base_url, '/v0.1/orgs/{org_name}/invitations', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsDeleteDefaultApplicationJSON])
                res.org_invitations_delete_default_application_json_object = out

        return res

    def org_invitations_list_pending(self, request: operations.OrgInvitationsListPendingRequest, security: operations.OrgInvitationsListPendingSecurity) -> operations.OrgInvitationsListPendingResponse:
        r"""Gets the pending invitations for the organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsListPendingRequest, base_url, '/v0.1/orgs/{org_name}/invitations', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsListPendingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.OrgInvitationsListPending200ApplicationJSON]])
                res.org_invitations_list_pending_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsListPendingDefaultApplicationJSON])
                res.org_invitations_list_pending_default_application_json_object = out

        return res

    def org_invitations_reject(self, request: operations.OrgInvitationsRejectRequest, security: operations.OrgInvitationsRejectSecurity) -> operations.OrgInvitationsRejectResponse:
        r"""Rejects a pending organization invitation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsRejectRequest, base_url, '/v0.1/user/invitations/orgs/{invitation_token}/reject', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsRejectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsRejectDefaultApplicationJSON])
                res.org_invitations_reject_default_application_json_object = out

        return res

    def org_invitations_send_new_invitation(self, request: operations.OrgInvitationsSendNewInvitationRequest, security: operations.OrgInvitationsSendNewInvitationSecurity) -> operations.OrgInvitationsSendNewInvitationResponse:
        r"""Cancels an existing organization invitation for the user and sends a new one"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsSendNewInvitationRequest, base_url, '/v0.1/orgs/{org_name}/invitations/{email}/resend', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsSendNewInvitationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsSendNewInvitationDefaultApplicationJSON])
                res.org_invitations_send_new_invitation_default_application_json_object = out

        return res

    def org_invitations_update(self, request: operations.OrgInvitationsUpdateRequest, security: operations.OrgInvitationsUpdateSecurity) -> operations.OrgInvitationsUpdateResponse:
        r"""Allows the role of an invited user to be changed"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrgInvitationsUpdateRequest, base_url, '/v0.1/orgs/{org_name}/invitations/{email}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrgInvitationsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrgInvitationsUpdateDefaultApplicationJSON])
                res.org_invitations_update_default_application_json_object = out

        return res

    def organization_delete_avatar(self, request: operations.OrganizationDeleteAvatarRequest, security: operations.OrganizationDeleteAvatarSecurity) -> operations.OrganizationDeleteAvatarResponse:
        r"""Deletes the uploaded organization avatar"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrganizationDeleteAvatarRequest, base_url, '/v0.1/orgs/{org_name}/avatar', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationDeleteAvatarResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationDeleteAvatar200ApplicationJSON])
                res.organization_delete_avatar_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationDeleteAvatarDefaultApplicationJSON])
                res.organization_delete_avatar_default_application_json_object = out

        return res

    def organization_update_avatar(self, request: operations.OrganizationUpdateAvatarRequest, security: operations.OrganizationUpdateAvatarSecurity) -> operations.OrganizationUpdateAvatarResponse:
        r"""Sets the organization avatar"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrganizationUpdateAvatarRequest, base_url, '/v0.1/orgs/{org_name}/avatar', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationUpdateAvatarResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationUpdateAvatar200ApplicationJSON])
                res.organization_update_avatar_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationUpdateAvatarDefaultApplicationJSON])
                res.organization_update_avatar_default_application_json_object = out

        return res

    def organizations_create_or_update(self, request: operations.OrganizationsCreateOrUpdateRequestBody, security: operations.OrganizationsCreateOrUpdateSecurity) -> operations.OrganizationsCreateOrUpdateResponse:
        r"""Creates a new organization and returns it to the caller"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/orgs'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationsCreateOrUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsCreateOrUpdate201ApplicationJSON])
                res.organizations_create_or_update_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsCreateOrUpdateDefaultApplicationJSON])
                res.organizations_create_or_update_default_application_json_object = out

        return res

    def organizations_delete(self, request: operations.OrganizationsDeleteRequest, security: operations.OrganizationsDeleteSecurity) -> operations.OrganizationsDeleteResponse:
        r"""Deletes a single organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrganizationsDeleteRequest, base_url, '/v0.1/orgs/{org_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsDeleteDefaultApplicationJSON])
                res.organizations_delete_default_application_json_object = out

        return res

    def organizations_get(self, request: operations.OrganizationsGetRequest, security: operations.OrganizationsGetSecurity) -> operations.OrganizationsGetResponse:
        r"""Returns the details of a single organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrganizationsGetRequest, base_url, '/v0.1/orgs/{org_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationsGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsGet200ApplicationJSON])
                res.organizations_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsGetDefaultApplicationJSON])
                res.organizations_get_default_application_json_object = out

        return res

    def organizations_list(self) -> operations.OrganizationsListResponse:
        r"""Returns a list of organizations the requesting user has access to"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/orgs'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.OrganizationsList200ApplicationJSON]])
                res.organizations_list_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsListDefaultApplicationJSON])
                res.organizations_list_default_application_json_object = out

        return res

    def organizations_list_administered(self) -> operations.OrganizationsListAdministeredResponse:
        r"""Returns a list organizations in which the requesting user is an admin"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/administeredOrgs'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationsListAdministeredResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsListAdministered200ApplicationJSON])
                res.organizations_list_administered_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsListAdministeredDefaultApplicationJSON])
                res.organizations_list_administered_default_application_json_object = out

        return res

    def organizations_update(self, request: operations.OrganizationsUpdateRequest, security: operations.OrganizationsUpdateSecurity) -> operations.OrganizationsUpdateResponse:
        r"""Returns a list of organizations the requesting user has access to"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.OrganizationsUpdateRequest, base_url, '/v0.1/orgs/{org_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.OrganizationsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsUpdate200ApplicationJSON])
                res.organizations_update_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.OrganizationsUpdateDefaultApplicationJSON])
                res.organizations_update_default_application_json_object = out

        return res

    def sharedconnection_connections(self) -> operations.SharedconnectionConnectionsResponse:
        r"""Gets all service connections of the service type for GDPR export."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/user/export/serviceConnections'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SharedconnectionConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.SharedconnectionConnections200ApplicationJSON]])
                res.sharedconnection_connections_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.SharedconnectionConnectionsDefaultApplicationJSON])
                res.sharedconnection_connections_default_application_json_object = out

        return res

    def teams_add_app(self, request: operations.TeamsAddAppRequest, security: operations.TeamsAddAppSecurity) -> operations.TeamsAddAppResponse:
        r"""Adds an app to a team"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsAddAppRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/apps', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsAddAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsAddApp201ApplicationJSON])
                res.teams_add_app_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsAddAppDefaultApplicationJSON])
                res.teams_add_app_default_application_json_object = out

        return res

    def teams_add_user(self, request: operations.TeamsAddUserRequest, security: operations.TeamsAddUserSecurity) -> operations.TeamsAddUserResponse:
        r"""Adds a new user to a team that is owned by an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsAddUserRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/users', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsAddUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsAddUser201ApplicationJSON])
                res.teams_add_user_201_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsAddUserDefaultApplicationJSON])
                res.teams_add_user_default_application_json_object = out

        return res

    def teams_create_team(self, request: operations.TeamsCreateTeamRequest, security: operations.TeamsCreateTeamSecurity) -> operations.TeamsCreateTeamResponse:
        r"""Creates a team and returns it"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsCreateTeamRequest, base_url, '/v0.1/orgs/{org_name}/teams', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsCreateTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.TeamsCreateTeam201ApplicationJSON]])
                res.teams_create_team_201_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsCreateTeamDefaultApplicationJSON])
                res.teams_create_team_default_application_json_object = out

        return res

    def teams_delete(self, request: operations.TeamsDeleteRequest, security: operations.TeamsDeleteSecurity) -> operations.TeamsDeleteResponse:
        r"""Deletes a single team"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsDeleteRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsDeleteDefaultApplicationJSON])
                res.teams_delete_default_application_json_object = out

        return res

    def teams_get_team(self, request: operations.TeamsGetTeamRequest, security: operations.TeamsGetTeamSecurity) -> operations.TeamsGetTeamResponse:
        r"""Returns the details of a single team"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsGetTeamRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsGetTeamResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsGetTeam200ApplicationJSON])
                res.teams_get_team_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsGetTeamDefaultApplicationJSON])
                res.teams_get_team_default_application_json_object = out

        return res

    def teams_get_users(self, request: operations.TeamsGetUsersRequest, security: operations.TeamsGetUsersSecurity) -> operations.TeamsGetUsersResponse:
        r"""Returns the users of a team which is owned by an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsGetUsersRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/users', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsGetUsersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsGetUsers200ApplicationJSON])
                res.teams_get_users_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsGetUsersDefaultApplicationJSON])
                res.teams_get_users_default_application_json_object = out

        return res

    def teams_list_all(self, request: operations.TeamsListAllRequest, security: operations.TeamsListAllSecurity) -> operations.TeamsListAllResponse:
        r"""Returns the list of all teams in this org"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsListAllRequest, base_url, '/v0.1/orgs/{org_name}/teams', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsListAllResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.TeamsListAll200ApplicationJSON]])
                res.teams_list_all_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsListAllDefaultApplicationJSON])
                res.teams_list_all_default_application_json_object = out

        return res

    def teams_list_apps(self, request: operations.TeamsListAppsRequest, security: operations.TeamsListAppsSecurity) -> operations.TeamsListAppsResponse:
        r"""Returns the apps a team has access to"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsListAppsRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/apps', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsListAppsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.TeamsListApps200ApplicationJSON]])
                res.teams_list_apps_200_application_json_anies = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsListAppsDefaultApplicationJSON])
                res.teams_list_apps_default_application_json_object = out

        return res

    def teams_remove_app(self, request: operations.TeamsRemoveAppRequest, security: operations.TeamsRemoveAppSecurity) -> operations.TeamsRemoveAppResponse:
        r"""Removes an app from a team"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsRemoveAppRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsRemoveAppResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsRemoveAppDefaultApplicationJSON])
                res.teams_remove_app_default_application_json_object = out

        return res

    def teams_remove_user(self, request: operations.TeamsRemoveUserRequest, security: operations.TeamsRemoveUserSecurity) -> operations.TeamsRemoveUserResponse:
        r"""Removes a user from a team that is owned by an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsRemoveUserRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/users/{user_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsRemoveUserResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsRemoveUserDefaultApplicationJSON])
                res.teams_remove_user_default_application_json_object = out

        return res

    def teams_update(self, request: operations.TeamsUpdateRequest, security: operations.TeamsUpdateSecurity) -> operations.TeamsUpdateResponse:
        r"""Updates a single team"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsUpdateRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsUpdate200ApplicationJSON])
                res.teams_update_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsUpdateDefaultApplicationJSON])
                res.teams_update_default_application_json_object = out

        return res

    def teams_update_permissions(self, request: operations.TeamsUpdatePermissionsRequest, security: operations.TeamsUpdatePermissionsSecurity) -> operations.TeamsUpdatePermissionsResponse:
        r"""Updates the permissions the team has to the app"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TeamsUpdatePermissionsRequest, base_url, '/v0.1/orgs/{org_name}/teams/{team_name}/apps/{app_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TeamsUpdatePermissionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsUpdatePermissions200ApplicationJSON])
                res.teams_update_permissions_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.TeamsUpdatePermissionsDefaultApplicationJSON])
                res.teams_update_permissions_default_application_json_object = out

        return res

    def user_api_tokens_delete(self, request: operations.UserAPITokensDeleteRequest, security: operations.UserAPITokensDeleteSecurity) -> operations.UserAPITokensDeleteResponse:
        r"""Delete the user api_token object with the specific id"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UserAPITokensDeleteRequest, base_url, '/v0.1/api_tokens/{api_token_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UserAPITokensDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensDelete400ApplicationJSON])
                res.user_api_tokens_delete_400_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensDelete401ApplicationJSON])
                res.user_api_tokens_delete_401_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensDelete404ApplicationJSON])
                res.user_api_tokens_delete_404_application_json_object = out

        return res

    def user_api_tokens_list(self) -> operations.UserAPITokensListResponse:
        r"""Returns api tokens for the authenticated user"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/api_tokens'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UserAPITokensListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.UserAPITokensList200ApplicationJSON]])
                res.user_api_tokens_list_200_application_json_objects = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensList400ApplicationJSON])
                res.user_api_tokens_list_400_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensList401ApplicationJSON])
                res.user_api_tokens_list_401_application_json_object = out

        return res

    def user_api_tokens_new(self, request: operations.UserAPITokensNewRequestBody, security: operations.UserAPITokensNewSecurity) -> operations.UserAPITokensNewResponse:
        r"""Creates a new User API token"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/api_tokens'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UserAPITokensNewResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensNew201ApplicationJSON])
                res.user_api_tokens_new_201_application_json_object = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensNew400ApplicationJSON])
                res.user_api_tokens_new_400_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UserAPITokensNew401ApplicationJSON])
                res.user_api_tokens_new_401_application_json_object = out

        return res

    def users_get(self) -> operations.UsersGetResponse:
        r"""Returns the user profile data"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/user'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersGet200ApplicationJSON])
                res.users_get_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersGetDefaultApplicationJSON])
                res.users_get_default_application_json_object = out

        return res

    def users_get_for_org(self, request: operations.UsersGetForOrgRequest, security: operations.UsersGetForOrgSecurity) -> operations.UsersGetForOrgResponse:
        r"""Get a user information from an organization by name - if there is explicit permission return it, if not if not return highest implicit permission"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UsersGetForOrgRequest, base_url, '/v0.1/orgs/{org_name}/users/{user_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersGetForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersGetForOrg200ApplicationJSON])
                res.users_get_for_org_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersGetForOrgDefaultApplicationJSON])
                res.users_get_for_org_default_application_json_object = out

        return res

    def users_list(self, request: operations.UsersListRequest, security: operations.UsersListSecurity) -> operations.UsersListResponse:
        r"""Returns the users associated with the app specified with the given app name which belongs to the given owner."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UsersListRequest, base_url, '/v0.1/apps/{owner_name}/{app_name}/users', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.UsersList200ApplicationJSON]])
                res.users_list_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersListDefaultApplicationJSON])
                res.users_list_default_application_json_object = out

        return res

    def users_list_for_org(self, request: operations.UsersListForOrgRequest, security: operations.UsersListForOrgSecurity) -> operations.UsersListForOrgResponse:
        r"""Returns a list of users that belong to an organization"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UsersListForOrgRequest, base_url, '/v0.1/orgs/{org_name}/users', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersListForOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.UsersListForOrg200ApplicationJSON]])
                res.users_list_for_org_200_application_json_objects = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersListForOrgDefaultApplicationJSON])
                res.users_list_for_org_default_application_json_object = out

        return res

    def users_remove_from_org(self, request: operations.UsersRemoveFromOrgRequest, security: operations.UsersRemoveFromOrgSecurity) -> operations.UsersRemoveFromOrgResponse:
        r"""Removes a user from an organization."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UsersRemoveFromOrgRequest, base_url, '/v0.1/orgs/{org_name}/users/{user_name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersRemoveFromOrgResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersRemoveFromOrgDefaultApplicationJSON])
                res.users_remove_from_org_default_application_json_object = out

        return res

    def users_update(self, request: operations.UsersUpdateRequestBody, security: operations.UsersUpdateSecurity) -> operations.UsersUpdateResponse:
        r"""Updates the user profile and returns the updated user data"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v0.1/user'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersUpdate200ApplicationJSON])
                res.users_update_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersUpdateDefaultApplicationJSON])
                res.users_update_default_application_json_object = out

        return res

    def users_update_org_role(self, request: operations.UsersUpdateOrgRoleRequest, security: operations.UsersUpdateOrgRoleSecurity) -> operations.UsersUpdateOrgRoleResponse:
        r"""Updates the given organization user"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.UsersUpdateOrgRoleRequest, base_url, '/v0.1/orgs/{org_name}/users/{user_name}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UsersUpdateOrgRoleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersUpdateOrgRole200ApplicationJSON])
                res.users_update_org_role_200_application_json_object = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UsersUpdateOrgRoleDefaultApplicationJSON])
                res.users_update_org_role_default_application_json_object = out

        return res

    