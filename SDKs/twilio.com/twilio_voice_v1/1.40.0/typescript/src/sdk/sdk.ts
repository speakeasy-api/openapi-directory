/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://voice.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  createByocTrunk(
    req: operations.CreateByocTrunkCreateByocTrunkRequest,
    security: operations.CreateByocTrunkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateByocTrunkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateByocTrunkCreateByocTrunkRequest(req);
    }

    let baseURL: string = operations.CreateByocTrunkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/ByocTrunks";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateByocTrunkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateByocTrunkResponse =
        new operations.CreateByocTrunkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ByocTrunk = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1ByocTrunk
            );
          }
          break;
      }

      return res;
    });
  }

  createConnectionPolicy(
    req: operations.CreateConnectionPolicyCreateConnectionPolicyRequest,
    security: operations.CreateConnectionPolicySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConnectionPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConnectionPolicyCreateConnectionPolicyRequest(
        req
      );
    }

    let baseURL: string = operations.CreateConnectionPolicyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/ConnectionPolicies";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConnectionPolicySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConnectionPolicyResponse =
        new operations.CreateConnectionPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ConnectionPolicy = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1ConnectionPolicy
            );
          }
          break;
      }

      return res;
    });
  }

  createConnectionPolicyTarget(
    req: operations.CreateConnectionPolicyTargetRequest,
    security: operations.CreateConnectionPolicyTargetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConnectionPolicyTargetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConnectionPolicyTargetRequest(req);
    }

    let baseURL: string = operations.CreateConnectionPolicyTargetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateConnectionPolicyTargetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConnectionPolicyTargetResponse =
        new operations.CreateConnectionPolicyTargetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ConnectionPolicyConnectionPolicyTarget =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1ConnectionPolicyConnectionPolicyTarget
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a bulk update request to change voice dialing country permissions of one or more countries identified by the corresponding [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
   */
  createDialingPermissionsCountryBulkUpdate(
    req: operations.CreateDialingPermissionsCountryBulkUpdateCreateDialingPermissionsCountryBulkUpdateRequest,
    security: operations.CreateDialingPermissionsCountryBulkUpdateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDialingPermissionsCountryBulkUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateDialingPermissionsCountryBulkUpdateCreateDialingPermissionsCountryBulkUpdateRequest(
          req
        );
    }

    let baseURL: string =
      operations.CreateDialingPermissionsCountryBulkUpdateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/DialingPermissions/BulkCountryUpdates";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CreateDialingPermissionsCountryBulkUpdateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDialingPermissionsCountryBulkUpdateResponse =
        new operations.CreateDialingPermissionsCountryBulkUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1DialingPermissionsDialingPermissionsCountryBulkUpdate =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1DialingPermissionsDialingPermissionsCountryBulkUpdate
              );
          }
          break;
      }

      return res;
    });
  }

  createIpRecord(
    req: operations.CreateIpRecordCreateIpRecordRequest,
    security: operations.CreateIpRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateIpRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateIpRecordCreateIpRecordRequest(req);
    }

    let baseURL: string = operations.CreateIpRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/IpRecords";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateIpRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateIpRecordResponse =
        new operations.CreateIpRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1IpRecord = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1IpRecord
            );
          }
          break;
      }

      return res;
    });
  }

  createSourceIpMapping(
    req: operations.CreateSourceIpMappingCreateSourceIpMappingRequest,
    security: operations.CreateSourceIpMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSourceIpMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSourceIpMappingCreateSourceIpMappingRequest(
        req
      );
    }

    let baseURL: string = operations.CreateSourceIpMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SourceIpMappings";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSourceIpMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSourceIpMappingResponse =
        new operations.CreateSourceIpMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1SourceIpMapping = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1SourceIpMapping
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an archived call record from Bulk Export. Note: this does not also delete the record from the Voice API.
   */
  deleteArchivedCall(
    req: operations.DeleteArchivedCallRequest,
    security: operations.DeleteArchivedCallSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteArchivedCallResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteArchivedCallRequest(req);
    }

    let baseURL: string = operations.DeleteArchivedCallServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Archives/{Date}/Calls/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteArchivedCallSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteArchivedCallResponse =
        new operations.DeleteArchivedCallResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteByocTrunk(
    req: operations.DeleteByocTrunkRequest,
    security: operations.DeleteByocTrunkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteByocTrunkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteByocTrunkRequest(req);
    }

    let baseURL: string = operations.DeleteByocTrunkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/ByocTrunks/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteByocTrunkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteByocTrunkResponse =
        new operations.DeleteByocTrunkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteConnectionPolicy(
    req: operations.DeleteConnectionPolicyRequest,
    security: operations.DeleteConnectionPolicySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConnectionPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConnectionPolicyRequest(req);
    }

    let baseURL: string = operations.DeleteConnectionPolicyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConnectionPolicySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConnectionPolicyResponse =
        new operations.DeleteConnectionPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteConnectionPolicyTarget(
    req: operations.DeleteConnectionPolicyTargetRequest,
    security: operations.DeleteConnectionPolicyTargetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConnectionPolicyTargetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConnectionPolicyTargetRequest(req);
    }

    let baseURL: string = operations.DeleteConnectionPolicyTargetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteConnectionPolicyTargetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConnectionPolicyTargetResponse =
        new operations.DeleteConnectionPolicyTargetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteIpRecord(
    req: operations.DeleteIpRecordRequest,
    security: operations.DeleteIpRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteIpRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteIpRecordRequest(req);
    }

    let baseURL: string = operations.DeleteIpRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/IpRecords/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteIpRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteIpRecordResponse =
        new operations.DeleteIpRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSourceIpMapping(
    req: operations.DeleteSourceIpMappingRequest,
    security: operations.DeleteSourceIpMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSourceIpMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSourceIpMappingRequest(req);
    }

    let baseURL: string = operations.DeleteSourceIpMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SourceIpMappings/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSourceIpMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSourceIpMappingResponse =
        new operations.DeleteSourceIpMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  fetchByocTrunk(
    req: operations.FetchByocTrunkRequest,
    security: operations.FetchByocTrunkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchByocTrunkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchByocTrunkRequest(req);
    }

    let baseURL: string = operations.FetchByocTrunkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/ByocTrunks/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchByocTrunkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchByocTrunkResponse =
        new operations.FetchByocTrunkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ByocTrunk = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1ByocTrunk
            );
          }
          break;
      }

      return res;
    });
  }

  fetchConnectionPolicy(
    req: operations.FetchConnectionPolicyRequest,
    security: operations.FetchConnectionPolicySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConnectionPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConnectionPolicyRequest(req);
    }

    let baseURL: string = operations.FetchConnectionPolicyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConnectionPolicySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConnectionPolicyResponse =
        new operations.FetchConnectionPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ConnectionPolicy = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1ConnectionPolicy
            );
          }
          break;
      }

      return res;
    });
  }

  fetchConnectionPolicyTarget(
    req: operations.FetchConnectionPolicyTargetRequest,
    security: operations.FetchConnectionPolicyTargetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchConnectionPolicyTargetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchConnectionPolicyTargetRequest(req);
    }

    let baseURL: string = operations.FetchConnectionPolicyTargetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchConnectionPolicyTargetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchConnectionPolicyTargetResponse =
        new operations.FetchConnectionPolicyTargetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ConnectionPolicyConnectionPolicyTarget =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1ConnectionPolicyConnectionPolicyTarget
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve voice dialing country permissions identified by the given ISO country code
   */
  fetchDialingPermissionsCountry(
    req: operations.FetchDialingPermissionsCountryRequest,
    security: operations.FetchDialingPermissionsCountrySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDialingPermissionsCountryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDialingPermissionsCountryRequest(req);
    }

    let baseURL: string =
      operations.FetchDialingPermissionsCountryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/DialingPermissions/Countries/{IsoCode}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDialingPermissionsCountrySecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDialingPermissionsCountryResponse =
        new operations.FetchDialingPermissionsCountryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1DialingPermissionsDialingPermissionsCountryInstance =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1DialingPermissionsDialingPermissionsCountryInstance
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve voice dialing permissions inheritance for the sub-account
   */
  fetchDialingPermissionsSettings(
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDialingPermissionsSettingsResponse> {
    let baseURL: string =
      operations.FetchDialingPermissionsSettingsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Settings";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDialingPermissionsSettingsResponse =
        new operations.FetchDialingPermissionsSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1DialingPermissionsDialingPermissionsSettings =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1DialingPermissionsDialingPermissionsSettings
              );
          }
          break;
      }

      return res;
    });
  }

  fetchIpRecord(
    req: operations.FetchIpRecordRequest,
    security: operations.FetchIpRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchIpRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchIpRecordRequest(req);
    }

    let baseURL: string = operations.FetchIpRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/IpRecords/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchIpRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchIpRecordResponse =
        new operations.FetchIpRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1IpRecord = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1IpRecord
            );
          }
          break;
      }

      return res;
    });
  }

  fetchSourceIpMapping(
    req: operations.FetchSourceIpMappingRequest,
    security: operations.FetchSourceIpMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSourceIpMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSourceIpMappingRequest(req);
    }

    let baseURL: string = operations.FetchSourceIpMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SourceIpMappings/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSourceIpMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSourceIpMappingResponse =
        new operations.FetchSourceIpMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1SourceIpMapping = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1SourceIpMapping
            );
          }
          break;
      }

      return res;
    });
  }

  listByocTrunk(
    req: operations.ListByocTrunkRequest,
    security: operations.ListByocTrunkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListByocTrunkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListByocTrunkRequest(req);
    }

    let baseURL: string = operations.ListByocTrunkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/ByocTrunks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListByocTrunkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListByocTrunkResponse =
        new operations.ListByocTrunkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listByocTrunkResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListByocTrunkListByocTrunkResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listConnectionPolicy(
    req: operations.ListConnectionPolicyRequest,
    security: operations.ListConnectionPolicySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConnectionPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConnectionPolicyRequest(req);
    }

    let baseURL: string = operations.ListConnectionPolicyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/ConnectionPolicies";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConnectionPolicySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConnectionPolicyResponse =
        new operations.ListConnectionPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConnectionPolicyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConnectionPolicyListConnectionPolicyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listConnectionPolicyTarget(
    req: operations.ListConnectionPolicyTargetRequest,
    security: operations.ListConnectionPolicyTargetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListConnectionPolicyTargetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListConnectionPolicyTargetRequest(req);
    }

    let baseURL: string = operations.ListConnectionPolicyTargetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListConnectionPolicyTargetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListConnectionPolicyTargetResponse =
        new operations.ListConnectionPolicyTargetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConnectionPolicyTargetResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListConnectionPolicyTargetListConnectionPolicyTargetResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve all voice dialing country permissions for this account
   */
  listDialingPermissionsCountry(
    req: operations.ListDialingPermissionsCountryRequest,
    security: operations.ListDialingPermissionsCountrySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDialingPermissionsCountryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDialingPermissionsCountryRequest(req);
    }

    let baseURL: string = operations.ListDialingPermissionsCountryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/v1/DialingPermissions/Countries";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDialingPermissionsCountrySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDialingPermissionsCountryResponse =
        new operations.ListDialingPermissionsCountryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDialingPermissionsCountryResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDialingPermissionsCountryListDialingPermissionsCountryResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch the high-risk special services prefixes from the country resource corresponding to the [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
   */
  listDialingPermissionsHrsPrefixes(
    req: operations.ListDialingPermissionsHrsPrefixesRequest,
    security: operations.ListDialingPermissionsHrsPrefixesSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDialingPermissionsHrsPrefixesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDialingPermissionsHrsPrefixesRequest(req);
    }

    let baseURL: string =
      operations.ListDialingPermissionsHrsPrefixesServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/DialingPermissions/Countries/{IsoCode}/HighRiskSpecialPrefixes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDialingPermissionsHrsPrefixesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDialingPermissionsHrsPrefixesResponse =
        new operations.ListDialingPermissionsHrsPrefixesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDialingPermissionsHrsPrefixesResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDialingPermissionsHrsPrefixesListDialingPermissionsHrsPrefixesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listIpRecord(
    req: operations.ListIpRecordRequest,
    security: operations.ListIpRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListIpRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListIpRecordRequest(req);
    }

    let baseURL: string = operations.ListIpRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/IpRecords";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListIpRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListIpRecordResponse =
        new operations.ListIpRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listIpRecordResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListIpRecordListIpRecordResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSourceIpMapping(
    req: operations.ListSourceIpMappingRequest,
    security: operations.ListSourceIpMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSourceIpMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSourceIpMappingRequest(req);
    }

    let baseURL: string = operations.ListSourceIpMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/SourceIpMappings";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSourceIpMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSourceIpMappingResponse =
        new operations.ListSourceIpMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSourceIpMappingResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSourceIpMappingListSourceIpMappingResponse
            );
          }
          break;
      }

      return res;
    });
  }

  updateByocTrunk(
    req: operations.UpdateByocTrunkRequest,
    security: operations.UpdateByocTrunkSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateByocTrunkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateByocTrunkRequest(req);
    }

    let baseURL: string = operations.UpdateByocTrunkServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/ByocTrunks/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateByocTrunkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateByocTrunkResponse =
        new operations.UpdateByocTrunkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ByocTrunk = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1ByocTrunk
            );
          }
          break;
      }

      return res;
    });
  }

  updateConnectionPolicy(
    req: operations.UpdateConnectionPolicyRequest,
    security: operations.UpdateConnectionPolicySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConnectionPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConnectionPolicyRequest(req);
    }

    let baseURL: string = operations.UpdateConnectionPolicyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConnectionPolicySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConnectionPolicyResponse =
        new operations.UpdateConnectionPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ConnectionPolicy = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1ConnectionPolicy
            );
          }
          break;
      }

      return res;
    });
  }

  updateConnectionPolicyTarget(
    req: operations.UpdateConnectionPolicyTargetRequest,
    security: operations.UpdateConnectionPolicyTargetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConnectionPolicyTargetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConnectionPolicyTargetRequest(req);
    }

    let baseURL: string = operations.UpdateConnectionPolicyTargetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateConnectionPolicyTargetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConnectionPolicyTargetResponse =
        new operations.UpdateConnectionPolicyTargetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1ConnectionPolicyConnectionPolicyTarget =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1ConnectionPolicyConnectionPolicyTarget
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update voice dialing permissions inheritance for the sub-account
   */
  updateDialingPermissionsSettings(
    req: operations.UpdateDialingPermissionsSettingsUpdateDialingPermissionsSettingsRequest,
    security: operations.UpdateDialingPermissionsSettingsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDialingPermissionsSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateDialingPermissionsSettingsUpdateDialingPermissionsSettingsRequest(
          req
        );
    }

    let baseURL: string =
      operations.UpdateDialingPermissionsSettingsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Settings";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDialingPermissionsSettingsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDialingPermissionsSettingsResponse =
        new operations.UpdateDialingPermissionsSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1DialingPermissionsDialingPermissionsSettings =
              utils.objectToClass(
                httpRes?.data,
                shared.VoiceV1DialingPermissionsDialingPermissionsSettings
              );
          }
          break;
      }

      return res;
    });
  }

  updateIpRecord(
    req: operations.UpdateIpRecordRequest,
    security: operations.UpdateIpRecordSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateIpRecordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateIpRecordRequest(req);
    }

    let baseURL: string = operations.UpdateIpRecordServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/IpRecords/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateIpRecordSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateIpRecordResponse =
        new operations.UpdateIpRecordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1IpRecord = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1IpRecord
            );
          }
          break;
      }

      return res;
    });
  }

  updateSourceIpMapping(
    req: operations.UpdateSourceIpMappingRequest,
    security: operations.UpdateSourceIpMappingSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSourceIpMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSourceIpMappingRequest(req);
    }

    let baseURL: string = operations.UpdateSourceIpMappingServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/SourceIpMappings/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSourceIpMappingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSourceIpMappingResponse =
        new operations.UpdateSourceIpMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.voiceV1SourceIpMapping = utils.objectToClass(
              httpRes?.data,
              shared.VoiceV1SourceIpMapping
            );
          }
          break;
      }

      return res;
    });
  }
}
