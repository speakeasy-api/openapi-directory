// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type SymbolsIgnoreSecurity struct {
	APIToken string `security:"scheme,type=apiKey,subtype=header,name=X-API-Token"`
}

type SymbolsIgnoreRequest struct {
	// The name of the application
	AppName string `pathParam:"style=simple,explode=false,name=app_name"`
	// The name of the owner
	OwnerName string `pathParam:"style=simple,explode=false,name=owner_name"`
	// The ID of the symbol (uuid of the symbol)
	SymbolID string `pathParam:"style=simple,explode=false,name=symbol_id"`
}

// SymbolsIgnore500ApplicationJSON - Internal error
type SymbolsIgnore500ApplicationJSON struct {
	Message string `json:"message"`
}

// SymbolsIgnore404ApplicationJSON - Not found
type SymbolsIgnore404ApplicationJSON struct {
	Message string `json:"message"`
}

// SymbolsIgnore403ApplicationJSON - Unauthorized
type SymbolsIgnore403ApplicationJSON struct {
	Message string `json:"message"`
}

// SymbolsIgnore200ApplicationJSONOriginEnum - The origin of the symbol file
type SymbolsIgnore200ApplicationJSONOriginEnum string

const (
	SymbolsIgnore200ApplicationJSONOriginEnumSystem SymbolsIgnore200ApplicationJSONOriginEnum = "System"
	SymbolsIgnore200ApplicationJSONOriginEnumUser   SymbolsIgnore200ApplicationJSONOriginEnum = "User"
)

func (e SymbolsIgnore200ApplicationJSONOriginEnum) ToPointer() *SymbolsIgnore200ApplicationJSONOriginEnum {
	return &e
}

func (e *SymbolsIgnore200ApplicationJSONOriginEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "System":
		fallthrough
	case "User":
		*e = SymbolsIgnore200ApplicationJSONOriginEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SymbolsIgnore200ApplicationJSONOriginEnum: %v", v)
	}
}

// SymbolsIgnore200ApplicationJSONStatusEnum - Whether the symbol is ignored.
type SymbolsIgnore200ApplicationJSONStatusEnum string

const (
	SymbolsIgnore200ApplicationJSONStatusEnumAvailable SymbolsIgnore200ApplicationJSONStatusEnum = "available"
	SymbolsIgnore200ApplicationJSONStatusEnumIgnored   SymbolsIgnore200ApplicationJSONStatusEnum = "ignored"
)

func (e SymbolsIgnore200ApplicationJSONStatusEnum) ToPointer() *SymbolsIgnore200ApplicationJSONStatusEnum {
	return &e
}

func (e *SymbolsIgnore200ApplicationJSONStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "available":
		fallthrough
	case "ignored":
		*e = SymbolsIgnore200ApplicationJSONStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SymbolsIgnore200ApplicationJSONStatusEnum: %v", v)
	}
}

// SymbolsIgnore200ApplicationJSONTypeEnum - The type of the symbol for the current symbol upload
type SymbolsIgnore200ApplicationJSONTypeEnum string

const (
	SymbolsIgnore200ApplicationJSONTypeEnumApple           SymbolsIgnore200ApplicationJSONTypeEnum = "Apple"
	SymbolsIgnore200ApplicationJSONTypeEnumJavaScript      SymbolsIgnore200ApplicationJSONTypeEnum = "JavaScript"
	SymbolsIgnore200ApplicationJSONTypeEnumBreakpad        SymbolsIgnore200ApplicationJSONTypeEnum = "Breakpad"
	SymbolsIgnore200ApplicationJSONTypeEnumAndroidProguard SymbolsIgnore200ApplicationJSONTypeEnum = "AndroidProguard"
	SymbolsIgnore200ApplicationJSONTypeEnumUwp             SymbolsIgnore200ApplicationJSONTypeEnum = "UWP"
)

func (e SymbolsIgnore200ApplicationJSONTypeEnum) ToPointer() *SymbolsIgnore200ApplicationJSONTypeEnum {
	return &e
}

func (e *SymbolsIgnore200ApplicationJSONTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Apple":
		fallthrough
	case "JavaScript":
		fallthrough
	case "Breakpad":
		fallthrough
	case "AndroidProguard":
		fallthrough
	case "UWP":
		*e = SymbolsIgnore200ApplicationJSONTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SymbolsIgnore200ApplicationJSONTypeEnum: %v", v)
	}
}

// SymbolsIgnore200ApplicationJSON - Success
type SymbolsIgnore200ApplicationJSON struct {
	// The other symbols in the same file
	AlternateSymbolIds []string `json:"alternate_symbol_ids"`
	// The application that this symbol belongs to
	AppID string `json:"app_id"`
	// The build number. Optional for Apple. Required for Android.
	Build *string `json:"build,omitempty"`
	// The origin of the symbol file
	Origin SymbolsIgnore200ApplicationJSONOriginEnum `json:"origin"`
	// The platform that this symbol is associated with
	Platform string `json:"platform"`
	// Whether the symbol is ignored.
	Status SymbolsIgnore200ApplicationJSONStatusEnum `json:"status"`
	// The unique id for this symbol (uuid)
	SymbolID string `json:"symbol_id"`
	// The id of the symbol upload this symbol belongs to.
	SymbolUploadID string `json:"symbol_upload_id"`
	// The type of the symbol for the current symbol upload
	Type SymbolsIgnore200ApplicationJSONTypeEnum `json:"type"`
	// The path name of the symbol file in blob storage
	URL string `json:"url"`
	// The version number. Optional for Apple. Required for Android.
	Version *string `json:"version,omitempty"`
}

type SymbolsIgnoreResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Success
	SymbolsIgnore200ApplicationJSONObject *SymbolsIgnore200ApplicationJSON
	// Unauthorized
	SymbolsIgnore403ApplicationJSONObject *SymbolsIgnore403ApplicationJSON
	// Not found
	SymbolsIgnore404ApplicationJSONObject *SymbolsIgnore404ApplicationJSON
	// Internal error
	SymbolsIgnore500ApplicationJSONObject *SymbolsIgnore500ApplicationJSON
}
