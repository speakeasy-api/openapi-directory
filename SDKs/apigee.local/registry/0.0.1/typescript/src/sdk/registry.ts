/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Registry {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * CreateApi creates a specified API.
   */
  registryCreateApi(
    req: operations.RegistryCreateApiRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryCreateApiResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryCreateApiRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryCreateApiResponse =
        new operations.RegistryCreateApiResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.api = utils.objectToClass(httpRes?.data, shared.Api);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * CreateApiDeployment creates a specified deployment.
   */
  registryCreateApiDeployment(
    req: operations.RegistryCreateApiDeploymentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryCreateApiDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryCreateApiDeploymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiDeploymentInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryCreateApiDeploymentResponse =
        new operations.RegistryCreateApiDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ApiDeployment
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * CreateApiSpec creates a specified spec.
   */
  registryCreateApiSpec(
    req: operations.RegistryCreateApiSpecRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryCreateApiSpecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryCreateApiSpecRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiSpecInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryCreateApiSpecResponse =
        new operations.RegistryCreateApiSpecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiSpec = utils.objectToClass(
              httpRes?.data,
              shared.ApiSpecOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * CreateApiVersion creates a specified version.
   */
  registryCreateApiVersion(
    req: operations.RegistryCreateApiVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryCreateApiVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryCreateApiVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiVersionInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryCreateApiVersionResponse =
        new operations.RegistryCreateApiVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiVersion = utils.objectToClass(
              httpRes?.data,
              shared.ApiVersion
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * CreateArtifact creates a specified artifact.
   */
  registryCreateArtifact(
    req: operations.RegistryCreateArtifactRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryCreateArtifactResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryCreateArtifactRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/artifacts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "artifactInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryCreateArtifactResponse =
        new operations.RegistryCreateArtifactResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.artifact = utils.objectToClass(
              httpRes?.data,
              shared.ArtifactOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteApi removes a specified API and all of the resources that it
   *  owns.
   */
  registryDeleteApi(
    req: operations.RegistryDeleteApiRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteApiResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteApiRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteApiResponse =
        new operations.RegistryDeleteApiResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteApiDeployment removes a specified deployment, all revisions, and all
   *  child resources (e.g. artifacts).
   */
  registryDeleteApiDeployment(
    req: operations.RegistryDeleteApiDeploymentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteApiDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteApiDeploymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteApiDeploymentResponse =
        new operations.RegistryDeleteApiDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteApiDeploymentRevision deletes a revision of a deployment.
   */
  registryDeleteApiDeploymentRevision(
    req: operations.RegistryDeleteApiDeploymentRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteApiDeploymentRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteApiDeploymentRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:deleteRevision",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteApiDeploymentRevisionResponse =
        new operations.RegistryDeleteApiDeploymentRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ApiDeployment
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteApiSpec removes a specified spec, all revisions, and all child
   *  resources (e.g. artifacts).
   */
  registryDeleteApiSpec(
    req: operations.RegistryDeleteApiSpecRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteApiSpecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteApiSpecRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteApiSpecResponse =
        new operations.RegistryDeleteApiSpecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteApiSpecRevision deletes a revision of a spec.
   */
  registryDeleteApiSpecRevision(
    req: operations.RegistryDeleteApiSpecRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteApiSpecRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteApiSpecRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:deleteRevision",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteApiSpecRevisionResponse =
        new operations.RegistryDeleteApiSpecRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiSpec = utils.objectToClass(
              httpRes?.data,
              shared.ApiSpecOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteApiVersion removes a specified version and all of the resources that
   *  it owns.
   */
  registryDeleteApiVersion(
    req: operations.RegistryDeleteApiVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteApiVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteApiVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteApiVersionResponse =
        new operations.RegistryDeleteApiVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteArtifact removes a specified artifact.
   */
  registryDeleteArtifact(
    req: operations.RegistryDeleteArtifactRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryDeleteArtifactResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryDeleteArtifactRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/artifacts/{artifact}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryDeleteArtifactResponse =
        new operations.RegistryDeleteArtifactResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetApi returns a specified API.
   */
  registryGetApi(
    req: operations.RegistryGetApiRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetApiResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetApiRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetApiResponse =
        new operations.RegistryGetApiResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.api = utils.objectToClass(httpRes?.data, shared.Api);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetApiDeployment returns a specified deployment.
   */
  registryGetApiDeployment(
    req: operations.RegistryGetApiDeploymentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetApiDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetApiDeploymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetApiDeploymentResponse =
        new operations.RegistryGetApiDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ApiDeployment
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetApiSpec returns a specified spec.
   */
  registryGetApiSpec(
    req: operations.RegistryGetApiSpecRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetApiSpecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetApiSpecRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetApiSpecResponse =
        new operations.RegistryGetApiSpecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiSpec = utils.objectToClass(
              httpRes?.data,
              shared.ApiSpecOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetApiSpecContents returns the contents of a specified spec.
   *  If specs are stored with GZip compression, the default behavior
   *  is to return the spec uncompressed (the mime_type response field
   *  indicates the exact format returned).
   */
  registryGetApiSpecContents(
    req: operations.RegistryGetApiSpecContentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetApiSpecContentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetApiSpecContentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:getContents",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetApiSpecContentsResponse =
        new operations.RegistryGetApiSpecContentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetApiVersion returns a specified version.
   */
  registryGetApiVersion(
    req: operations.RegistryGetApiVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetApiVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetApiVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetApiVersionResponse =
        new operations.RegistryGetApiVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiVersion = utils.objectToClass(
              httpRes?.data,
              shared.ApiVersion
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetArtifact returns a specified artifact.
   */
  registryGetArtifact(
    req: operations.RegistryGetArtifactRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetArtifactResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetArtifactRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/artifacts/{artifact}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetArtifactResponse =
        new operations.RegistryGetArtifactResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.artifact = utils.objectToClass(
              httpRes?.data,
              shared.ArtifactOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetArtifactContents returns the contents of a specified artifact.
   *  If artifacts are stored with GZip compression, the default behavior
   *  is to return the artifact uncompressed (the mime_type response field
   *  indicates the exact format returned).
   */
  registryGetArtifactContents(
    req: operations.RegistryGetArtifactContentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryGetArtifactContentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryGetArtifactContentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/artifacts/{artifact}:getContents",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryGetArtifactContentsResponse =
        new operations.RegistryGetArtifactContentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListApiDeploymentRevisions lists all revisions of a deployment.
   *  Revisions are returned in descending order of revision creation time.
   */
  registryListApiDeploymentRevisions(
    req: operations.RegistryListApiDeploymentRevisionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListApiDeploymentRevisionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListApiDeploymentRevisionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:listRevisions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListApiDeploymentRevisionsResponse =
        new operations.RegistryListApiDeploymentRevisionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApiDeploymentRevisionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListApiDeploymentRevisionsResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListApiDeployments returns matching deployments.
   */
  registryListApiDeployments(
    req: operations.RegistryListApiDeploymentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListApiDeploymentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListApiDeploymentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListApiDeploymentsResponse =
        new operations.RegistryListApiDeploymentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApiDeploymentsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListApiDeploymentsResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListApiSpecRevisions lists all revisions of a spec.
   *  Revisions are returned in descending order of revision creation time.
   */
  registryListApiSpecRevisions(
    req: operations.RegistryListApiSpecRevisionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListApiSpecRevisionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListApiSpecRevisionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:listRevisions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListApiSpecRevisionsResponse =
        new operations.RegistryListApiSpecRevisionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApiSpecRevisionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListApiSpecRevisionsResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListApiSpecs returns matching specs.
   */
  registryListApiSpecs(
    req: operations.RegistryListApiSpecsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListApiSpecsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListApiSpecsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListApiSpecsResponse =
        new operations.RegistryListApiSpecsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApiSpecsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListApiSpecsResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListApiVersions returns matching versions.
   */
  registryListApiVersions(
    req: operations.RegistryListApiVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListApiVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListApiVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListApiVersionsResponse =
        new operations.RegistryListApiVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApiVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListApiVersionsResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListApis returns matching APIs.
   */
  registryListApis(
    req: operations.RegistryListApisRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListApisResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListApisRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListApisResponse =
        new operations.RegistryListApisResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listApisResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListApisResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListArtifacts returns matching artifacts.
   */
  registryListArtifacts(
    req: operations.RegistryListArtifactsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryListArtifactsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryListArtifactsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/artifacts",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryListArtifactsResponse =
        new operations.RegistryListArtifactsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listArtifactsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListArtifactsResponse
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * ReplaceArtifact can be used to replace a specified artifact.
   */
  registryReplaceArtifact(
    req: operations.RegistryReplaceArtifactRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryReplaceArtifactResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryReplaceArtifactRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/artifacts/{artifact}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "artifactInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryReplaceArtifactResponse =
        new operations.RegistryReplaceArtifactResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.artifact = utils.objectToClass(
              httpRes?.data,
              shared.ArtifactOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * RollbackApiDeployment sets the current revision to a specified prior
   *  revision. Note that this creates a new revision with a new revision ID.
   */
  registryRollbackApiDeployment(
    req: operations.RegistryRollbackApiDeploymentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryRollbackApiDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryRollbackApiDeploymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:rollback",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rollbackApiDeploymentRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryRollbackApiDeploymentResponse =
        new operations.RegistryRollbackApiDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ApiDeployment
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * RollbackApiSpec sets the current revision to a specified prior revision.
   *  Note that this creates a new revision with a new revision ID.
   */
  registryRollbackApiSpec(
    req: operations.RegistryRollbackApiSpecRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryRollbackApiSpecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryRollbackApiSpecRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:rollback",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rollbackApiSpecRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryRollbackApiSpecResponse =
        new operations.RegistryRollbackApiSpecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiSpec = utils.objectToClass(
              httpRes?.data,
              shared.ApiSpecOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * TagApiDeploymentRevision adds a tag to a specified revision of a
   *  deployment.
   */
  registryTagApiDeploymentRevision(
    req: operations.RegistryTagApiDeploymentRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryTagApiDeploymentRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryTagApiDeploymentRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}:tagRevision",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tagApiDeploymentRevisionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryTagApiDeploymentRevisionResponse =
        new operations.RegistryTagApiDeploymentRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ApiDeployment
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * TagApiSpecRevision adds a tag to a specified revision of a spec.
   */
  registryTagApiSpecRevision(
    req: operations.RegistryTagApiSpecRevisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryTagApiSpecRevisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryTagApiSpecRevisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}:tagRevision",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tagApiSpecRevisionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryTagApiSpecRevisionResponse =
        new operations.RegistryTagApiSpecRevisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiSpec = utils.objectToClass(
              httpRes?.data,
              shared.ApiSpecOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateApi can be used to modify a specified API.
   */
  registryUpdateApi(
    req: operations.RegistryUpdateApiRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryUpdateApiResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryUpdateApiRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryUpdateApiResponse =
        new operations.RegistryUpdateApiResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.api = utils.objectToClass(httpRes?.data, shared.Api);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateApiDeployment can be used to modify a specified deployment.
   */
  registryUpdateApiDeployment(
    req: operations.RegistryUpdateApiDeploymentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryUpdateApiDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryUpdateApiDeploymentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/deployments/{deployment}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiDeploymentInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryUpdateApiDeploymentResponse =
        new operations.RegistryUpdateApiDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiDeployment = utils.objectToClass(
              httpRes?.data,
              shared.ApiDeployment
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateApiSpec can be used to modify a specified spec.
   */
  registryUpdateApiSpec(
    req: operations.RegistryUpdateApiSpecRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryUpdateApiSpecResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryUpdateApiSpecRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiSpecInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryUpdateApiSpecResponse =
        new operations.RegistryUpdateApiSpecResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiSpec = utils.objectToClass(
              httpRes?.data,
              shared.ApiSpecOutput
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateApiVersion can be used to modify a specified version.
   */
  registryUpdateApiVersion(
    req: operations.RegistryUpdateApiVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegistryUpdateApiVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegistryUpdateApiVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/projects/{project}/locations/{location}/apis/{api}/versions/{version}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "apiVersionInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegistryUpdateApiVersionResponse =
        new operations.RegistryUpdateApiVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.apiVersion = utils.objectToClass(
              httpRes?.data,
              shared.ApiVersion
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }
}
