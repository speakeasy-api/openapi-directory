"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Any, Optional

class MessageEncodingEnum(str, Enum):
    r"""The type of the content.  See the `encoding` field for more information."""
    TEXT = 'TEXT'
    UNICODE = 'UNICODE'
    BINARY = 'BINARY'

class MessageStatusSubtypeEnum(str, Enum):
    r"""Has a value only if the `type` is FAILED.
    
    EXPIRED  Delivery failed because message expired before delivery was possible.
    
    HANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).
    
    BLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).
    
    NOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).
    """
    EXPIRED = 'EXPIRED'
    HANDSET_ERROR = 'HANDSET_ERROR'
    BLOCKED = 'BLOCKED'
    NOT_SENT = 'NOT_SENT'

class MessageStatusTypeEnum(str, Enum):
    r"""ACCEPTED  Message accepted for delivery. Only returned for initial message submissions.
    
    SCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.
    
    SENT  Message has been relayed away from our systems.
    
    DELIVERED  Successfully delivered to phone.
    
    UNKNOWN  Message is in an unknown state.
    
    FAILED  Delivery failed.
    """
    ACCEPTED = 'ACCEPTED'
    SCHEDULED = 'SCHEDULED'
    SENT = 'SENT'
    DELIVERED = 'DELIVERED'
    UNKNOWN = 'UNKNOWN'
    FAILED = 'FAILED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class MessageStatus:
    r"""The status of the message"""
    
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""A concatenated value A.B where A is the `status.type` and B is the `status.subtype`.
    It there is no value for `subtype` then B takes string value `\"null\"` (e.g. `\"SENT.null\"`).
    """  
    type: MessageStatusTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""ACCEPTED  Message accepted for delivery. Only returned for initial message submissions.
    
    SCHEDULED  Message accepted for delivery at a later date. Only returned for initial message  submissions.
    
    SENT  Message has been relayed away from our systems.
    
    DELIVERED  Successfully delivered to phone.
    
    UNKNOWN  Message is in an unknown state.
    
    FAILED  Delivery failed.
    """  
    subtype: Optional[MessageStatusSubtypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subtype'), 'exclude': lambda f: f is None }})
    r"""Has a value only if the `type` is FAILED.
    
    EXPIRED  Delivery failed because message expired before delivery was possible.
    
    HANDSET_ERROR  Delivery failed because of a problem related to the phone (e.g. message storage area full).
    
    BLOCKED  Your account has been blocked from sending to this phone (e.g. recipient replied STOP to block communication).
    
    NOT_SENT  Message delivery was not attempted (e.g. because we were not able to find a route for the supplied phone number).
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class MessageSubmission:
    r"""Identifies the submission."""
    
    date_: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('date'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})
    r"""The date and time the submission was processed. If the `type` is RECEIVED, this field reflects the date and time the received message was processed."""  
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""A unique identity shared by all messages that were created from the same submission. This field should be ignored if the `type` is not SENT."""  
    
class MessageTypeEnum(str, Enum):
    r"""The message direction"""
    SENT = 'SENT'
    RECEIVED = 'RECEIVED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Message:
    r"""The message detail"""
    
    body: Any = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('body') }})
    r"""The content of the message"""  
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""A unique identifier that is assigned when the message is created."""  
    status: MessageStatus = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""The status of the message"""  
    to: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to') }})
    r"""The phone number of the recipient"""  
    type: MessageTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""The message direction"""  
    credit_cost: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('creditCost'), 'exclude': lambda f: f is None }})
    r"""The cost of the message (in credits).   Note that this field does not have a value in the submission response."""  
    encoding: Optional[MessageEncodingEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encoding'), 'exclude': lambda f: f is None }})
    r"""The type of the content.  See the `encoding` field for more information."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The address part of the sender id"""  
    message_class: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('messageClass'), 'exclude': lambda f: f is None }})
    r"""See the `messageClass` field for more information."""  
    number_of_parts: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numberOfParts'), 'exclude': lambda f: f is None }})
    r"""The number of parts.  If this is a concatenated message, the number of parts will be more than 1.  Note that this field does not have a value in the submission response."""  
    protocol_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocolId'), 'exclude': lambda f: f is None }})
    r"""See the `protocolId` field for more information."""  
    related_sent_message_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('relatedSentMessageId'), 'exclude': lambda f: f is None }})
    r"""This field has a value only if the type is RECEIVED.
    With SMS messages, it is not possible to link a reply directly with a specific sent message.  However, if you specified `REPLIABLE` in the `from` property, BulkSMS will link any reply to the most recent message sent to a given phone number.
    
    The `relatedSentMessageId` property keeps the information about this link.
    
    You can use this property to derive an implicit conversation from a set of messages.
      - If a received reply message has a `relatedSentMessageId`, you can use it to retrieve the last message that was sent before the reply was received.
      - If you have the `id` of the sent message and you want all the received messages that relate to it, you can use the List Related Messages Operation.
    """  
    submission: Optional[MessageSubmission] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('submission'), 'exclude': lambda f: f is None }})
    r"""Identifies the submission."""  
    user_supplied_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userSuppliedId'), 'exclude': lambda f: f is None }})
    r"""This is the value you supplied in the `userSuppliedId` field.
    Has a value only if the `type` is SENT.
    """  
    