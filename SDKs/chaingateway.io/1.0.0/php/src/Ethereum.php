<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Ethereum 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * broadcastTransaction
     * 
     * Broadcast raw transactions
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BroadcasttransactionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BroadcasttransactionResponse
     */
	public function broadcasttransaction(
        \OpenAPI\OpenAPI\Models\Operations\BroadcasttransactionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BroadcasttransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/eth/transactions/broadcast');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BroadcasttransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->broadcasttransaction200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Broadcasttransaction200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * deleteAddress
     * 
     * deleteAddress
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteaddressRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteaddressResponse
     */
	public function deleteaddress(
        \OpenAPI\OpenAPI\Models\Operations\DeleteaddressRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/addresses/{address}', \OpenAPI\OpenAPI\Models\Operations\DeleteaddressRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deleteaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Deleteaddress200ApplicationJSON', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 422) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deleteaddress422ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Deleteaddress422ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * exportAddress
     * 
     * exportAddress
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExportaddressRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExportaddressResponse
     */
	public function exportaddress(
        \OpenAPI\OpenAPI\Models\Operations\ExportaddressRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExportaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/addresses/export/{address}', \OpenAPI\OpenAPI\Models\Operations\ExportaddressRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExportaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exportaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Exportaddress200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getAllERC20Balance
     * 
     * Get the balance of an ERC20 address
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\Getallerc20balanceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\Getallerc20balanceResponse
     */
	public function getallerc20balance(
        \OpenAPI\OpenAPI\Models\Operations\Getallerc20balanceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\Getallerc20balanceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/balances/{address}/erc20/{erc20_token}', \OpenAPI\OpenAPI\Models\Operations\Getallerc20balanceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\Getallerc20balanceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getallerc20balance200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getallerc20balance200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getBlock
     * 
     * Get information of a specific block
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetblockRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetblockResponse
     */
	public function getblock(
        \OpenAPI\OpenAPI\Models\Operations\GetblockRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetblockResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/blocks/{block}', \OpenAPI\OpenAPI\Models\Operations\GetblockRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetblockResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getblock200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getblock200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getERC20
     * 
     * Get information about an ERC20 token
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\Geterc20Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\Geterc20Response
     */
	public function geterc20(
        \OpenAPI\OpenAPI\Models\Operations\Geterc20Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\Geterc20Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/erc20/{erc20_token}', \OpenAPI\OpenAPI\Models\Operations\Geterc20Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\Geterc20Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->geterc20200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Geterc20200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getEthereumBalance
     * 
     * Get the balance of an address
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetethereumbalanceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetethereumbalanceResponse
     */
	public function getethereumbalance(
        \OpenAPI\OpenAPI\Models\Operations\GetethereumbalanceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetethereumbalanceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/balances/{address}', \OpenAPI\OpenAPI\Models\Operations\GetethereumbalanceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetethereumbalanceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getethereumbalance200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getethereumbalance200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getGasPrice
     * 
     * Get gas price
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetgaspriceResponse
     */
	public function getgasprice(
    ): \OpenAPI\OpenAPI\Models\Operations\GetgaspriceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/gasprice');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetgaspriceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getgasprice200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getgasprice200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getLastBlockNumber
     * 
     * Get the latest block number
     * 
     * @param string $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetlastblocknumberResponse
     */
	public function getlastblocknumber(
        string $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetlastblocknumberResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/blocks/number');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "raw");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetlastblocknumberResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getlastblocknumber200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getlastblocknumber200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getNFTOwner
     * 
     * Get the Owner of an NFT
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetnftownerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetnftownerResponse
     */
	public function getnftowner(
        \OpenAPI\OpenAPI\Models\Operations\GetnftownerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetnftownerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/nfts/{contract}/owner/{token_id}', \OpenAPI\OpenAPI\Models\Operations\GetnftownerRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetnftownerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getnftowner200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getnftowner200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getNFTUri
     * 
     * Get the URI of an NFT
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetnfturiRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetnfturiResponse
     */
	public function getnfturi(
        \OpenAPI\OpenAPI\Models\Operations\GetnfturiRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetnfturiResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/nfts/{contract}/uri/{token_id}', \OpenAPI\OpenAPI\Models\Operations\GetnfturiRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetnfturiResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getnfturi200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Getnfturi200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getTransaction
     * 
     * Get info about a transaction
     * 
     * You can choose if you want to get the Transaction encoded or decoded by add /decoded to your request. See examlpes for details
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GettransactionRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GettransactionResponse
     */
	public function gettransaction(
        \OpenAPI\OpenAPI\Models\Operations\GettransactionRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GettransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/transactions/{transaction}/decoded', \OpenAPI\OpenAPI\Models\Operations\GettransactionRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GettransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->gettransaction200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Gettransaction200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * getTransactionReceipt
     * 
     * Get info about a transaction receipt
     * 
     * You can choose if you want to get the Transaction encoded or decoded by add /decoded to your request. See examlpes for details
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GettransactionreceiptRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GettransactionreceiptResponse
     */
	public function gettransactionreceipt(
        \OpenAPI\OpenAPI\Models\Operations\GettransactionreceiptRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GettransactionreceiptResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/transactions/{transaction}/receipt/decoded', \OpenAPI\OpenAPI\Models\Operations\GettransactionreceiptRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GettransactionreceiptResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->gettransactionreceipt200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Gettransactionreceipt200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * importAddress
     * 
     * importAddress
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ImportaddressRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ImportaddressResponse
     */
	public function importaddress(
        \OpenAPI\OpenAPI\Models\Operations\ImportaddressRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ImportaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/addresses/import');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ImportaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->importaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Importaddress200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * listAddresses
     * 
     * listAddresses
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\ListaddressesResponse
     */
	public function listaddresses(
    ): \OpenAPI\OpenAPI\Models\Operations\ListaddressesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/addresses');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListaddressesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listaddresses200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Listaddresses200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * listFailedIPNs
     * 
     * Returns all subscriptions/IPNs created with an account.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListfailedipnsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListfailedipnsResponse
     */
	public function listfailedipns(
        \OpenAPI\OpenAPI\Models\Operations\ListfailedipnsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListfailedipnsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/webkhooks/{webhook}/notifications/failed', \OpenAPI\OpenAPI\Models\Operations\ListfailedipnsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListfailedipnsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listfailedipns200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Listfailedipns200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * listIPNsByWebhookId
     * 
     * Returns all subscriptions/IPNs created with an account.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\ListipnsbywebhookidResponse
     */
	public function listipnsbywebhookid(
    ): \OpenAPI\OpenAPI\Models\Operations\ListipnsbywebhookidResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/webkhooks/notifications/failed');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListipnsbywebhookidResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listipnsbywebhookid200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Listipnsbywebhookid200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * listSubscribedAddresses
     * 
     * Returns all subscriptions/IPNs created with an account.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\ListsubscribedaddressesResponse
     */
	public function listsubscribedaddresses(
    ): \OpenAPI\OpenAPI\Models\Operations\ListsubscribedaddressesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/webhooks');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListsubscribedaddressesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listsubscribedaddresses200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Listsubscribedaddresses200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * ListTransactionsByAddress
     * 
     * Our API provides an endpoint for retrieving all transactions associated with a particular blockchain address. To use this endpoint, you will need to provide the wallet address as a parameter in the request.
     * 
     * Each page of results returned by this endpoint contains up to 100 entries, and you can use a paginator to navigate through the pages of results.
     * 
     * To use the paginator, you can include parameter in your request: "page" . The "page" parameter specifies which page of results to retrieve,
     * 
     * For example, to retrieve the first 100 transactions associated with a particular blockchain address, you would make a request to the following URL:
     * 
     * ```
     * /addresses//transactions/1
     * 
     * ```
     * 
     * If there are more than 100 transactions associated with the blockchain address, you can retrieve additional pages of results by incrementing the "page" parameter in your request. For example, to retrieve the next 100 transactions, you would make a request to the following URL:
     * 
     * ```
     * /addresses//transactions/2
     * ```
     * 
     * By using the paginator, you can retrieve all transactions associated with a particular blockchain address, regardless of the total number of transactions in the blockchain.
     * 
     * each request tells you the max pages within the Request in the **max_pages** field
     * 
     * `"max_pages": 515`
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ListtransactionsbyaddressRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ListtransactionsbyaddressResponse
     */
	public function listtransactionsbyaddress(
        \OpenAPI\OpenAPI\Models\Operations\ListtransactionsbyaddressRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ListtransactionsbyaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/addresses/{address}/transactions/{page}', \OpenAPI\OpenAPI\Models\Operations\ListtransactionsbyaddressRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ListtransactionsbyaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listtransactionsbyaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Listtransactionsbyaddress200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * newAddress
     * 
     * newAddress
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\NewaddressRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\NewaddressResponse
     */
	public function newaddress(
        \OpenAPI\OpenAPI\Models\Operations\NewaddressRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\NewaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/addresses');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\NewaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->newaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Newaddress200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * resendFailedIPN
     * 
     * Returns all subscriptions/IPNs created with an account.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ResendfailedipnRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ResendfailedipnResponse
     */
	public function resendfailedipn(
        \OpenAPI\OpenAPI\Models\Operations\ResendfailedipnRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ResendfailedipnResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/webhooks/notifications/failed/{notification}', \OpenAPI\OpenAPI\Models\Operations\ResendfailedipnRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ResendfailedipnResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->resendfailedipn200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Resendfailedipn200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * sendERC20
     * 
     * sendERC20
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\Senderc20RequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\Senderc20Response
     */
	public function senderc20(
        \OpenAPI\OpenAPI\Models\Operations\Senderc20RequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\Senderc20Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/transactions/erc20');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\Senderc20Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * sendERC721
     * 
     * sendERC721
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\Senderc721RequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\Senderc721Response
     */
	public function senderc721(
        \OpenAPI\OpenAPI\Models\Operations\Senderc721RequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\Senderc721Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/transactions/erc721');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\Senderc721Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * sendTransaction
     * 
     * sendTransaction
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SendtransactionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SendtransactionResponse
     */
	public function sendtransaction(
        \OpenAPI\OpenAPI\Models\Operations\SendtransactionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SendtransactionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/transactions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SendtransactionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * subscribeAddress
     * 
     * Creates a new subscription/IPN for the given address (and contractaddress). You will receive a notification to the given url every time a deposit is received. Unsubscribe the address before sending tokens/ETH from it or you won't get reliable notifications anymore.
     * 
     * You can choose one or more from following filter criterias
     * 
     * | **Parameter** | **Description** |
     * | --- | --- |
     * | from | ethereum address |
     * | to | ethereum address |
     * | contractaddress | contract address |
     * | tokenid | token id |
     * 
     * You also need to dpecify the parameter "type". you can choose between \['ETH', 'ERC20', 'ERC721', null\]
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SubscribeaddressRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SubscribeaddressResponse
     */
	public function subscribeaddress(
        \OpenAPI\OpenAPI\Models\Operations\SubscribeaddressRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SubscribeaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/webhooks');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SubscribeaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->subscribeaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Subscribeaddress200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * unsubscribeAddress
     * 
     * Deletes an existing subscription/IPN for the given address (and contractaddress).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UnsubscribeaddressRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UnsubscribeaddressResponse
     */
	public function unsubscribeaddress(
        \OpenAPI\OpenAPI\Models\Operations\UnsubscribeaddressRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UnsubscribeaddressResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/ethereum/webhooks/{webhook}', \OpenAPI\OpenAPI\Models\Operations\UnsubscribeaddressRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UnsubscribeaddressResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->unsubscribeaddress200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\Unsubscribeaddress200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}