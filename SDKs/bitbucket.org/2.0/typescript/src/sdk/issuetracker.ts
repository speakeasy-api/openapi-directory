/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * The issue resources provide functionality for getting information on
 *
 * @remarks
 * issues in an issue tracker, creating new issues, updating them and deleting
 * them.
 *
 * You can access public issues without authentication, but you can't gain access
 * to private repositories' issues. By authenticating, you will get the ability
 * to create issues, as well as access to updating data or deleting issues you
 * have access to.
 *
 */
export class IssueTracker {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete an issue
   *
   * @remarks
   * Deletes the specified issue. This requires write access to the
   * repository.
   */
  deleteRepositoriesWorkspaceRepoSlugIssuesIssueId(
    req: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest,
    security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an attachment for an issue
   *
   * @remarks
   * Deletes an attachment.
   */
  deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPath(
    req: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest,
    security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case [204, 401].includes(httpRes?.status):
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a comment on an issue
   *
   * @remarks
   * Deletes the specified comment.
   */
  deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentId(
    req: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest,
    security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove vote for an issue
   *
   * @remarks
   * Retract your vote.
   */
  deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVote(
    req: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest,
    security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stop watching an issue
   *
   * @remarks
   * Stop watching this issue.
   */
  deleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatch(
    req: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest,
    security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse =
        new operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List components
   *
   * @remarks
   * Returns the components that have been defined in the issue tracker.
   *
   * This resource is only available on repositories that have the issue
   * tracker enabled.
   */
  getRepositoriesWorkspaceRepoSlugComponents(
    req: operations.GetRepositoriesWorkspaceRepoSlugComponentsRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugComponentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugComponentsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/components",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugComponentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedComponents = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedComponents
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a component for issues
   *
   * @remarks
   * Returns the specified issue tracker component object.
   */
  getRepositoriesWorkspaceRepoSlugComponentsComponentId(
    req: operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/components/{component_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.component = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List issues
   *
   * @remarks
   * Returns the issues in the issue tracker.
   */
  getRepositoriesWorkspaceRepoSlugIssues(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugIssuesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetRepositoriesWorkspaceRepoSlugIssuesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedIssues = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedIssues
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check issue export status
   *
   * @remarks
   * This endpoint is used to poll for the progress of an issue export
   * job and return the zip file after the job is complete.
   * As long as the job is running, this will return a 200 response
   * with in the response body a description of the current status.
   *
   * After the job has been scheduled, but before it starts executing, this
   * endpoint's response is:
   *
   * {
   *  "type": "issue_job_status",
   *  "status": "ACCEPTED",
   *  "phase": "Initializing",
   *  "total": 0,
   *  "count": 0,
   *  "pct": 0
   * }
   *
   *
   * Then once it starts running, it becomes:
   *
   * {
   *  "type": "issue_job_status",
   *  "status": "STARTED",
   *  "phase": "Attachments",
   *  "total": 15,
   *  "count": 11,
   *  "pct": 73
   * }
   *
   * Once the job has successfully completed, it returns a stream of the zip file.
   */
  getRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZip(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIdZipResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueJobStatus = utils.objectToClass(
              httpRes?.data,
              shared.IssueJobStatus
            );
          }
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check issue import status
   *
   * @remarks
   * When using GET, this endpoint reports the status of the current import task. Request example:
   *
   * ```
   * $ curl -u <username> -X GET https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
   * ```
   *
   * After the job has been scheduled, but before it starts executing, this endpoint's response is:
   *
   * ```
   * < HTTP/1.1 202 Accepted
   * {
   *     "type": "issue_job_status",
   *     "status": "PENDING",
   *     "phase": "Attachments",
   *     "total": 15,
   *     "count": 0,
   *     "percent": 0
   * }
   * ```
   *
   * Once it starts running, it is a 202 response with status STARTED and progress filled.
   *
   * After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.
   */
  getRepositoriesWorkspaceRepoSlugIssuesImport(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesImportRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesImportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugIssuesImportRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/import",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesImportSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 202].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueJobStatus = utils.objectToClass(
              httpRes?.data,
              shared.IssueJobStatus
            );
          }
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get an issue
   *
   * @remarks
   * Returns the specified issue.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueId(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List attachments for an issue
   *
   * @remarks
   * Returns all attachments for this issue.
   *
   * This returns the files' meta data. This does not return the files'
   * actual contents.
   *
   * The files are always ordered by their upload date.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachments(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedIssueAttachments = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedIssueAttachments
            );
          }
          break;
        case httpRes?.status == 401:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get attachment for an issue
   *
   * @remarks
   * Returns the contents of the specified file attachment.
   *
   * Note that this endpoint does not return a JSON response, but instead
   * returns a redirect pointing to the actual file that in turn will return
   * the raw contents.
   *
   * The redirect URL contains a one-time token that has a limited lifetime.
   * As a result, the link should not be persisted, stored, or shared.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPath(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsPathResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 302:
          break;
        case httpRes?.status == 401:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List changes on an issue
   *
   * @remarks
   * Returns the list of all changes that have been made to the specified
   * issue. Changes are returned in chronological order with the oldest
   * change first.
   *
   * Each time an issue is edited in the UI or through the API, an immutable
   * change record is created under the `/issues/123/changes` endpoint. It
   * also has a comment associated with the change.
   *
   * Note that this operation is changing significantly, due to privacy changes.
   * See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)
   * for details.
   *
   * ```
   * $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .
   *
   * {
   *   "pagelen": 20,
   *   "values": [
   *     {
   *       "changes": {
   *         "priority": {
   *           "new": "trivial",
   *           "old": "major"
   *         },
   *         "assignee": {
   *           "new": "",
   *           "old": "evzijst"
   *         },
   *         "assignee_account_id": {
   *           "new": "",
   *           "old": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
   *         },
   *         "kind": {
   *           "new": "enhancement",
   *           "old": "bug"
   *         }
   *       },
   *       "links": {
   *         "self": {
   *           "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2"
   *         },
   *         "html": {
   *           "href": "https://bitbucket.org/evzijst/dogslow/issues/1#comment-2"
   *         }
   *       },
   *       "issue": {
   *         "links": {
   *           "self": {
   *             "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1"
   *           }
   *         },
   *         "type": "issue",
   *         "id": 1,
   *         "repository": {
   *           "links": {
   *             "self": {
   *               "href": "https://api.bitbucket.org/2.0/repositories/evzijst/dogslow"
   *             },
   *             "html": {
   *               "href": "https://bitbucket.org/evzijst/dogslow"
   *             },
   *             "avatar": {
   *               "href": "https://bitbucket.org/evzijst/dogslow/avatar/32/"
   *             }
   *           },
   *           "type": "repository",
   *           "name": "dogslow",
   *           "full_name": "evzijst/dogslow",
   *           "uuid": "{988b17c6-1a47-4e70-84ee-854d5f012bf6}"
   *         },
   *         "title": "Updated title"
   *       },
   *       "created_on": "2018-03-03T00:35:28.353630+00:00",
   *       "user": {
   *         "username": "evzijst",
   *         "nickname": "evzijst",
   *         "display_name": "evzijst",
   *         "type": "user",
   *         "uuid": "{aaa7972b-38af-4fb1-802d-6e3854c95778}",
   *         "links": {
   *           "self": {
   *             "href": "https://api.bitbucket.org/2.0/users/evzijst"
   *           },
   *           "html": {
   *             "href": "https://bitbucket.org/evzijst/"
   *           },
   *           "avatar": {
   *             "href": "https://bitbucket.org/account/evzijst/avatar/32/"
   *           }
   *         }
   *       },
   *       "message": {
   *         "raw": "Removed assignee, changed kind and priority.",
   *         "markup": "markdown",
   *         "html": "<p>Removed assignee, changed kind and priority.</p>",
   *         "type": "rendered"
   *       },
   *       "type": "issue_change",
   *       "id": 2
   *     }
   *   ],
   *   "page": 1
   * }
   * ```
   *
   * Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that
   * can be used to search for specific changes. For instance, to see
   * when an issue transitioned to "resolved":
   *
   * ```
   * $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \
   *    -G --data-urlencode='q=changes.state.new = "resolved"'
   * ```
   *
   * This resource is only available on repositories that have the issue
   * tracker enabled.
   *
   * N.B.
   *
   * The `changes.assignee` and `changes.assignee_account_id` fields are not
   * a `user` object. Instead, they contain the raw `username` and
   * `account_id` of the user. This is to protect the integrity of the audit
   * log even after a user account gets deleted.
   *
   * The `changes.assignee` field is deprecated will disappear in the
   * future. Use `changes.assignee_account_id` instead.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdChanges(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedLogEntries = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedLogEntries
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get issue change object
   *
   * @remarks
   * Returns the specified issue change object.
   *
   * This resource is only available on repositories that have the issue
   * tracker enabled.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeId(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesChangeIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueChange = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List comments on an issue
   *
   * @remarks
   * Returns a paginated list of all comments that were made on the
   * specified issue.
   *
   * The default sorting is oldest to newest and can be overridden with
   * the `sort` query parameter.
   *
   * This endpoint also supports filtering and sorting of the results. See
   * [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdComments(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedIssueComments = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedIssueComments
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a comment on an issue
   *
   * @remarks
   * Returns the specified issue comment object.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentId(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComment = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check if current user voted for an issue
   *
   * @remarks
   * Check whether the authenticated user has voted for this issue.
   * A 204 status code indicates that the user has voted, while a 404
   * implies they haven't.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdVote(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check if current user is watching a issue
   *
   * @remarks
   * Indicated whether or not the authenticated user is watching this
   * issue.
   */
  getRepositoriesWorkspaceRepoSlugIssuesIssueIdWatch(
    req: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List milestones
   *
   * @remarks
   * Returns the milestones that have been defined in the issue tracker.
   *
   * This resource is only available on repositories that have the issue
   * tracker enabled.
   */
  getRepositoriesWorkspaceRepoSlugMilestones(
    req: operations.GetRepositoriesWorkspaceRepoSlugMilestonesRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugMilestonesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugMilestonesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/milestones",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugMilestonesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedMilestones = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedMilestones
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a milestone
   *
   * @remarks
   * Returns the specified issue tracker milestone object.
   */
  getRepositoriesWorkspaceRepoSlugMilestonesMilestoneId(
    req: operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.milestone = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List defined versions for issues
   *
   * @remarks
   * Returns the versions that have been defined in the issue tracker.
   *
   * This resource is only available on repositories that have the issue
   * tracker enabled.
   */
  getRepositoriesWorkspaceRepoSlugVersions(
    req: operations.GetRepositoriesWorkspaceRepoSlugVersionsRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugVersionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugVersionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedVersions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedVersions
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a defined version for issues
   *
   * @remarks
   * Returns the specified issue tracker version object.
   */
  getRepositoriesWorkspaceRepoSlugVersionsVersionId(
    req: operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/versions/{version_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.version = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an issue
   *
   * @remarks
   * Creates a new issue.
   *
   * This call requires authentication. Private repositories or private
   * issue trackers require the caller to authenticate with an account that
   * has appropriate authorization.
   *
   * The authenticated user is used for the issue's `reporter` field.
   */
  postRepositoriesWorkspaceRepoSlugIssues(
    req: operations.PostRepositoriesWorkspaceRepoSlugIssuesRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugIssuesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRepositoriesWorkspaceRepoSlugIssuesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostRepositoriesWorkspaceRepoSlugIssuesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Export issues
   *
   * @remarks
   * A POST request to this endpoint initiates a new background celery task that archives the repo's issues.
   *
   * For example, you can run:
   *
   * curl -u <username> -X POST http://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/
   * issues/export
   *
   * When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the
   * 'Location' response header. This url is the endpoint for where the user can obtain their zip files."
   */
  postRepositoriesWorkspaceRepoSlugIssuesExport(
    req: operations.PostRepositoriesWorkspaceRepoSlugIssuesExportRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugIssuesExportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRepositoriesWorkspaceRepoSlugIssuesExportRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/export",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesExportSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Import issues
   *
   * @remarks
   * A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All
   * existing issues will be deleted and replaced by the contents of the imported zip file.
   *
   * Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name
   * "archive," which needs to be a file field:
   *
   * ```
   * $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
   * ```
   *
   * When the import job is accepted, here is example output:
   *
   * ```
   * < HTTP/1.1 202 Accepted
   *
   * {
   *     "type": "issue_job_status",
   *     "status": "ACCEPTED",
   *     "phase": "Attachments",
   *     "total": 15,
   *     "count": 0,
   *     "percent": 0
   * }
   * ```
   */
  postRepositoriesWorkspaceRepoSlugIssuesImport(
    req: operations.PostRepositoriesWorkspaceRepoSlugIssuesImportRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugIssuesImportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRepositoriesWorkspaceRepoSlugIssuesImportRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/import",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesImportSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueJobStatus = utils.objectToClass(
              httpRes?.data,
              shared.IssueJobStatus
            );
          }
          break;
        case [401, 403, 404, 409].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Upload an attachment to an issue
   *
   * @remarks
   * Upload new issue attachments.
   *
   * To upload files, perform a `multipart/form-data` POST containing one
   * or more file fields.
   *
   * When a file is uploaded with the same name as an existing attachment,
   * then the existing file will be replaced.
   */
  postRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachments(
    req: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdAttachmentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          break;
        case [400, 401].includes(httpRes?.status):
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modify the state of an issue
   *
   * @remarks
   * Makes a change to the specified issue.
   *
   * For example, to change an issue's state and assignee, create a new
   * change object that modifies these fields:
   *
   * ```
   * curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \
   *   -s -u evzijst -X POST -H "Content-Type: application/json" \
   *   -d '{
   *     "changes": {
   *       "assignee_account_id": {
   *         "new": "557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443"
   *       },
   *       "state": {
   *         "new": 'resolved"
   *       }
   *     }
   *     "message": {
   *       "raw": "This is now resolved."
   *     }
   *   }'
   * ```
   *
   * The above example also includes a custom comment to go alongside the
   * change. This comment will also be visible on the issue page in the UI.
   *
   * The fields of the `changes` object are strings, not objects. This
   * allows for immutable change log records, even after user accounts,
   * milestones, or other objects recorded in a change entry, get renamed or
   * deleted.
   *
   * The `assignee_account_id` field stores the account id. When POSTing a
   * new change and changing the assignee, the client should therefore use
   * the user's account_id in the `changes.assignee_account_id.new` field.
   *
   * This call requires authentication. Private repositories or private
   * issue trackers require the caller to authenticate with an account that
   * has appropriate authorization.
   */
  postRepositoriesWorkspaceRepoSlugIssuesIssueIdChanges(
    req: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdChangesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueChange = utils.objectToClass(httpRes?.data);
          }
          break;
        case [401, 403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a comment on an issue
   *
   * @remarks
   * Creates a new issue comment.
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \
   *   -X POST -u evzijst \
   *   -H 'Content-Type: application/json' \
   *   -d '{"content": {"raw": "Lorem ipsum."}}'
   * ```
   */
  postRepositoriesWorkspaceRepoSlugIssuesIssueIdComments(
    req: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an issue
   *
   * @remarks
   * Modifies the issue.
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \
   *   -u evzijst -s -X PUT -H 'Content-Type: application/json' \
   *   -d '{
   *   "title": "Updated title",
   *   "assignee": {
   *     "account_id": "5d5355e8c6b9320d9ea5b28d"
   *   },
   *   "priority": "minor",
   *   "version": {
   *     "name": "1.0"
   *   },
   *   "component": null
   * }'
   * ```
   *
   * This example changes the `title`, `assignee`, `priority` and the
   * `version`. It also removes the value of the `component` from the issue
   * by setting the field to `null`. Any field not present keeps its existing
   * value.
   *
   * Each time an issue is edited in the UI or through the API, an immutable
   * change record is created under the `/issues/123/changes` endpoint. It
   * also has a comment associated with the change.
   */
  putRepositoriesWorkspaceRepoSlugIssuesIssueId(
    req: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest,
    security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a comment on an issue
   *
   * @remarks
   * Updates the content of the specified issue comment. Note that only
   * the `content.raw` field can be modified.
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \
   *   -X PUT -u evzijst \
   *   -H 'Content-Type: application/json' \
   *   -d '{"content": {"raw": "Lorem ipsum."}'
   * ```
   */
  putRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentId(
    req: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest,
    security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdCommentsCommentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComment = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Vote for an issue
   *
   * @remarks
   * Vote for this issue.
   *
   * To cast your vote, do an empty PUT. The 204 status code indicates that
   * the operation was successful.
   */
  putRepositoriesWorkspaceRepoSlugIssuesIssueIdVote(
    req: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest,
    security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdVoteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Watch an issue
   *
   * @remarks
   * Start watching this issue.
   *
   * To start watching this issue, do an empty PUT. The 204 status code
   * indicates that the operation was successful.
   */
  putRepositoriesWorkspaceRepoSlugIssuesIssueIdWatch(
    req: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest,
    security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse =
        new operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIdWatchResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case [204, 401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }
}
