"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class General:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def post_account_holder_balance(self, request: shared.AccountHolderBalanceRequest, security: operations.PostAccountHolderBalanceSecurity) -> operations.PostAccountHolderBalanceResponse:
        r"""Get the balances of an account holder
        Returns the account balances of an account holder. An account's balances are organized according by currencies. This mean that an account may have multiple balances: one for each currency.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/accountHolderBalance'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAccountHolderBalanceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountHolderBalanceResponse])
                res.account_holder_balance_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_account_holder_transaction_list(self, request: shared.AccountHolderTransactionListRequest, security: operations.PostAccountHolderTransactionListSecurity) -> operations.PostAccountHolderTransactionListResponse:
        r"""Get a list of transactions
        Returns a list of transactions for an account holder's accounts. You can specify the accounts and transaction statuses to be included on the list. The call returns a maximum of 50 transactions for each account. To retrieve all transactions, you must make another call with the 'page' value incremented. Transactions are listed in chronological order, with the most recent transaction first.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/accountHolderTransactionList'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAccountHolderTransactionListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountHolderTransactionListResponse])
                res.account_holder_transaction_list_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_debit_account_holder(self, request: shared.DebitAccountHolderRequest, security: operations.PostDebitAccountHolderSecurity) -> operations.PostDebitAccountHolderResponse:
        r"""Send a direct debit request
        Sends a direct debit request to an account holder's bank account. If the direct debit is successful, the funds are settled in the accounts specified in the split instructions. Adyen sends the result of the direct debit in a [`DIRECT_DEBIT_INITIATED`](https://docs.adyen.com/api-explorer/#/NotificationService/latest/post/DIRECT_DEBIT_INITIATED) notification webhook.
        
         To learn more about direct debits, see [Top up accounts](https://docs.adyen.com/marketplaces-and-platforms/classic/top-up-accounts).
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/debitAccountHolder'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostDebitAccountHolderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DebitAccountHolderResponse])
                res.debit_account_holder_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_payout_account_holder(self, request: shared.PayoutAccountHolderRequest, security: operations.PostPayoutAccountHolderSecurity) -> operations.PostPayoutAccountHolderResponse:
        r"""Pay out from an account to the account holder
        Pays out a specified amount from an account to the bank account of account holder.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/payoutAccountHolder'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostPayoutAccountHolderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PayoutAccountHolderResponse])
                res.payout_account_holder_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_refund_funds_transfer(self, request: shared.RefundFundsTransferRequest, security: operations.PostRefundFundsTransferSecurity) -> operations.PostRefundFundsTransferResponse:
        r"""Refund a funds transfer
        Refunds funds transferred from one account to another. Both accounts must be in the same platform, but can have different account holders.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/refundFundsTransfer'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRefundFundsTransferResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RefundFundsTransferResponse])
                res.refund_funds_transfer_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_refund_not_paid_out_transfers(self, request: shared.RefundNotPaidOutTransfersRequest, security: operations.PostRefundNotPaidOutTransfersSecurity) -> operations.PostRefundNotPaidOutTransfersResponse:
        r"""Refund all transactions of an account since the most recent payout
        Refunds all the transactions of an account that have taken place since the most recent payout. This request is on a account basis (as opposed to a payment basis), so only the portion of the payment that was made to the specified account is refunded. The commissions, fees, and payments to other accounts remain in the accounts to which they were sent as designated by the original payment's split details.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/refundNotPaidOutTransfers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRefundNotPaidOutTransfersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RefundNotPaidOutTransfersResponse])
                res.refund_not_paid_out_transfers_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_setup_beneficiary(self, request: shared.SetupBeneficiaryRequest, security: operations.PostSetupBeneficiarySecurity) -> operations.PostSetupBeneficiaryResponse:
        r"""Designate a beneficiary account and transfer the benefactor's current balance
        Defines a benefactor and a beneficiary relationship between two accounts. At the time of benefactor/beneficiary setup, the funds in the benefactor account are transferred to the beneficiary account, and any further payments to the benefactor account are automatically sent to the beneficiary account. A series of benefactor/beneficiaries may not exceed four beneficiaries and may not have a cycle in it.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/setupBeneficiary'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostSetupBeneficiaryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SetupBeneficiaryResponse])
                res.setup_beneficiary_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def post_transfer_funds(self, request: shared.TransferFundsRequest, security: operations.PostTransferFundsSecurity) -> operations.PostTransferFundsResponse:
        r"""Transfer funds between platform accounts
        Transfers funds from one account to another account. Both accounts must be in the same platform, but can have different account holders. The transfer must include a transfer code, which should be determined by the platform, in compliance with local regulations.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/transferFunds'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostTransferFundsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransferFundsResponse])
                res.transfer_funds_response = out
        elif http_res.status_code in [400, 401, 403, 422, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    