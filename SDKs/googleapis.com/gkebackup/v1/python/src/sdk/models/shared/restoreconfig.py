"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import clusterresourcerestorescope as shared_clusterresourcerestorescope
from ..shared import namespacednames as shared_namespacednames
from ..shared import namespaces as shared_namespaces
from ..shared import substitutionrule as shared_substitutionrule
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class RestoreConfigClusterResourceConflictPolicyEnum(str, Enum):
    r"""Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty."""
    CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED = 'CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED'
    USE_EXISTING_VERSION = 'USE_EXISTING_VERSION'
    USE_BACKUP_VERSION = 'USE_BACKUP_VERSION'

class RestoreConfigNamespacedResourceRestoreModeEnum(str, Enum):
    r"""Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED."""
    NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED = 'NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED'
    DELETE_AND_RESTORE = 'DELETE_AND_RESTORE'
    FAIL_ON_CONFLICT = 'FAIL_ON_CONFLICT'

class RestoreConfigVolumeDataRestorePolicyEnum(str, Enum):
    r"""Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION)."""
    VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED = 'VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED'
    RESTORE_VOLUME_DATA_FROM_BACKUP = 'RESTORE_VOLUME_DATA_FROM_BACKUP'
    REUSE_VOLUME_HANDLE_FROM_BACKUP = 'REUSE_VOLUME_HANDLE_FROM_BACKUP'
    NO_VOLUME_DATA_RESTORATION = 'NO_VOLUME_DATA_RESTORATION'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RestoreConfig:
    r"""Configuration of a restore. Next id: 12"""
    
    all_namespaces: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allNamespaces'), 'exclude': lambda f: f is None }})
    r"""Restore all namespaced resources in the Backup if set to \\"True\\". Specifying this field to \\"False\\" is an error."""  
    cluster_resource_conflict_policy: Optional[RestoreConfigClusterResourceConflictPolicyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clusterResourceConflictPolicy'), 'exclude': lambda f: f is None }})
    r"""Defines the behavior for handling the situation where cluster-scoped resources being restored already exist in the target cluster. This MUST be set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if cluster_resource_restore_scope is not empty."""  
    cluster_resource_restore_scope: Optional[shared_clusterresourcerestorescope.ClusterResourceRestoreScope] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clusterResourceRestoreScope'), 'exclude': lambda f: f is None }})
    r"""Defines the scope of cluster-scoped resources to restore. Some group kinds are not reasonable choices for a restore, and will cause an error if selected here. Any scope selection that would restore \\"all valid\\" resources automatically excludes these group kinds. - gkebackup.gke.io/BackupJob - gkebackup.gke.io/RestoreJob - metrics.k8s.io/NodeMetrics - migration.k8s.io/StorageState - migration.k8s.io/StorageVersionMigration - Node - snapshot.storage.k8s.io/VolumeSnapshotContent - storage.k8s.io/CSINode Some group kinds are driven by restore configuration elsewhere, and will cause an error if selected here. - Namespace - PersistentVolume"""  
    namespaced_resource_restore_mode: Optional[RestoreConfigNamespacedResourceRestoreModeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('namespacedResourceRestoreMode'), 'exclude': lambda f: f is None }})
    r"""Defines the behavior for handling the situation where sets of namespaced resources being restored already exist in the target cluster. This MUST be set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED."""  
    selected_applications: Optional[shared_namespacednames.NamespacedNames] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selectedApplications'), 'exclude': lambda f: f is None }})
    r"""A list of namespaced Kubernetes resources."""  
    selected_namespaces: Optional[shared_namespaces.Namespaces] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selectedNamespaces'), 'exclude': lambda f: f is None }})
    r"""A list of Kubernetes Namespaces"""  
    substitution_rules: Optional[list[shared_substitutionrule.SubstitutionRule]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('substitutionRules'), 'exclude': lambda f: f is None }})
    r"""A list of transformation rules to be applied against Kubernetes resources as they are selected for restoration from a Backup. Rules are executed in order defined - this order matters, as changes made by a rule may impact the filtering logic of subsequent rules. An empty list means no substitution will occur."""  
    volume_data_restore_policy: Optional[RestoreConfigVolumeDataRestorePolicyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('volumeDataRestorePolicy'), 'exclude': lambda f: f is None }})
    r"""Specifies the mechanism to be used to restore volume data. Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as NO_VOLUME_DATA_RESTORATION)."""  
    