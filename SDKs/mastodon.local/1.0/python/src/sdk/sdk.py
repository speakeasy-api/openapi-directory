"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from .accounts import Accounts
from .apps import Apps
from .oauth import Oauth
from .todosecurity import TODOSecurity
from sdk.models import operations, shared
from typing import Any, Optional

SERVERS = [
    "http://mastodon.local",
    "https://mastodon.social",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    todo_security: TODOSecurity
    accounts: Accounts
    apps: Apps
    oauth: Oauth

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        self._init_sdks()
    
    def _init_sdks(self):
        self.todo_security = TODOSecurity(
            self._client,
            self._security_client,
            self._server_url,
            self._language,
            self._sdk_version,
            self._gen_version
        )
        
        self.accounts = Accounts(
            self._client,
            self._security_client,
            self._server_url,
            self._language,
            self._sdk_version,
            self._gen_version
        )
        
        self.apps = Apps(
            self._client,
            self._security_client,
            self._server_url,
            self._language,
            self._sdk_version,
            self._gen_version
        )
        
        self.oauth = Oauth(
            self._client,
            self._security_client,
            self._server_url,
            self._language,
            self._sdk_version,
            self._gen_version
        )
        
    def delete_api_v1_announcements_id_reactions_name_(self, request: operations.DeleteAPIV1AnnouncementsIDReactionsNameRequest, security: operations.DeleteAPIV1AnnouncementsIDReactionsNameSecurity) -> operations.DeleteAPIV1AnnouncementsIDReactionsNameResponse:
        r"""Undo a react emoji to an announcement."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1AnnouncementsIDReactionsNameRequest, base_url, '/api/v1/announcements/{id}/reactions/{name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1AnnouncementsIDReactionsNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_announcements_id_reactions_name_200_application_json_object = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_conversations_id_(self, request: operations.DeleteAPIV1ConversationsIDRequest, security: operations.DeleteAPIV1ConversationsIDSecurity) -> operations.DeleteAPIV1ConversationsIDResponse:
        r"""Remove converstation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1ConversationsIDRequest, base_url, '/api/v1/conversations/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1ConversationsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_conversations_id_200_application_json_object = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_domain_blocks(self, request: operations.DeleteAPIV1DomainBlocksRequest, security: operations.DeleteAPIV1DomainBlocksSecurity) -> operations.DeleteAPIV1DomainBlocksResponse:
        r"""Remove a domain block, if it exists in the user's array of blocked domains."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/domain_blocks'
        
        query_params = utils.get_query_params(operations.DeleteAPIV1DomainBlocksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1DomainBlocksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_domain_blocks_200_application_json_object = out
        elif http_res.status_code in [401, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_featured_tags_id_(self, request: operations.DeleteAPIV1FeaturedTagsIDRequest, security: operations.DeleteAPIV1FeaturedTagsIDSecurity) -> operations.DeleteAPIV1FeaturedTagsIDResponse:
        r"""Unfeature a tag"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1FeaturedTagsIDRequest, base_url, '/api/v1/featured_tags/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1FeaturedTagsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_featured_tags_id_200_application_json_object = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_filters_id_(self, request: operations.DeleteAPIV1FiltersIDRequest, security: operations.DeleteAPIV1FiltersIDSecurity) -> operations.DeleteAPIV1FiltersIDResponse:
        r"""Delete a filter."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1FiltersIDRequest, base_url, '/api/v1/filters/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1FiltersIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_lists(self) -> operations.DeleteAPIV1ListsResponse:
        r"""Delete a list"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/lists'
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1ListsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_lists_200_application_json_object = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_lists_id_accounts(self, request: operations.DeleteAPIV1ListsIDAccountsRequest, security: operations.DeleteAPIV1ListsIDAccountsSecurity) -> operations.DeleteAPIV1ListsIDAccountsResponse:
        r"""Remove accounts from the given list."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1ListsIDAccountsRequest, base_url, '/api/v1/lists/{id}/accounts', request)
        
        query_params = utils.get_query_params(operations.DeleteAPIV1ListsIDAccountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1ListsIDAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_lists_id_accounts_200_application_json_object = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_push_subscription(self) -> operations.DeleteAPIV1PushSubscriptionResponse:
        r"""Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/push/subscription'
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1PushSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_push_subscription_200_application_json_object = out

        return res

    def delete_api_v1_scheduled_statuses_id_(self, request: operations.DeleteAPIV1ScheduledStatusesIDRequest, security: operations.DeleteAPIV1ScheduledStatusesIDSecurity) -> operations.DeleteAPIV1ScheduledStatusesIDResponse:
        r"""Cancel a scheduled status"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1ScheduledStatusesIDRequest, base_url, '/api/v1/scheduled_statuses/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1ScheduledStatusesIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_scheduled_statuses_id_200_application_json_object = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_statuses_id_(self, request: operations.DeleteAPIV1StatusesIDRequest, security: operations.DeleteAPIV1StatusesIDSecurity) -> operations.DeleteAPIV1StatusesIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1StatusesIDRequest, base_url, '/api/v1/statuses/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1StatusesIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_api_v1_suggestions_id_(self, request: operations.DeleteAPIV1SuggestionsIDRequest, security: operations.DeleteAPIV1SuggestionsIDSecurity) -> operations.DeleteAPIV1SuggestionsIDResponse:
        r"""Delete user suggestion"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAPIV1SuggestionsIDRequest, base_url, '/api/v1/suggestions/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAPIV1SuggestionsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.delete_api_v1_suggestions_id_200_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_oembed(self, request: operations.GetAPIOembedRequest) -> operations.GetAPIOembedResponse:
        r"""OEmbed as JSON"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/oembed'
        
        query_params = utils.get_query_params(operations.GetAPIOembedRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIOembedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Card])
                res.card = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_proofs(self, request: operations.GetAPIProofsRequest) -> operations.GetAPIProofsResponse:
        r"""View identity proof"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/proofs'
        
        query_params = utils.get_query_params(operations.GetAPIProofsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIProofsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IdentityProof])
                res.identity_proof = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_admin_accounts(self, request: operations.GetAPIV1AdminAccountsRequest, security: operations.GetAPIV1AdminAccountsSecurity) -> operations.GetAPIV1AdminAccountsResponse:
        r"""View accounts matching certain criteria for filtering, up to 100 at a time. Pagination may be done with the HTTP Link header in the response."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/admin/accounts'
        
        query_params = utils.get_query_params(operations.GetAPIV1AdminAccountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1AdminAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AdminAccount]])
                res.admin_accounts = out

        return res

    def get_api_v1_admin_accounts_id_(self, request: operations.GetAPIV1AdminAccountsIDRequest, security: operations.GetAPIV1AdminAccountsIDSecurity) -> operations.GetAPIV1AdminAccountsIDResponse:
        r"""View admin-level information about the given account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1AdminAccountsIDRequest, base_url, '/api/v1/admin/accounts/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1AdminAccountsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AdminAccount])
                res.admin_account = out

        return res

    def get_api_v1_admin_reports(self, request: operations.GetAPIV1AdminReportsRequest, security: operations.GetAPIV1AdminReportsSecurity) -> operations.GetAPIV1AdminReportsResponse:
        r"""View all reports. Pagination may be done with HTTP Link header in the response."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/admin/reports'
        
        query_params = utils.get_query_params(operations.GetAPIV1AdminReportsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1AdminReportsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.AdminReport]])
                res.admin_reports = out

        return res

    def get_api_v1_admin_reports_id_(self, request: operations.GetAPIV1AdminReportsIDRequest, security: operations.GetAPIV1AdminReportsIDSecurity) -> operations.GetAPIV1AdminReportsIDResponse:
        r"""View information about the report with the given ID."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1AdminReportsIDRequest, base_url, '/api/v1/admin/reports/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1AdminReportsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AdminReport])
                res.admin_report = out

        return res

    def get_api_v1_announcements(self, request: operations.GetAPIV1AnnouncementsRequest, security: operations.GetAPIV1AnnouncementsSecurity) -> operations.GetAPIV1AnnouncementsResponse:
        r"""See all currently active announcements set by admins."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/announcements'
        
        query_params = utils.get_query_params(operations.GetAPIV1AnnouncementsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1AnnouncementsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Announcement]])
                res.announcements = out

        return res

    def get_api_v1_blocks(self, request: operations.GetAPIV1BlocksRequest, security: operations.GetAPIV1BlocksSecurity) -> operations.GetAPIV1BlocksResponse:
        r"""Get blocked users."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/blocks'
        
        query_params = utils.get_query_params(operations.GetAPIV1BlocksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1BlocksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Account]])
                res.accounts = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_bookmarks(self, request: operations.GetAPIV1BookmarksRequest, security: operations.GetAPIV1BookmarksSecurity) -> operations.GetAPIV1BookmarksResponse:
        r"""Statuses the user has bookmarked."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/bookmarks'
        
        query_params = utils.get_query_params(operations.GetAPIV1BookmarksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1BookmarksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Status]])
                res.statuses = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_conversations(self, request: operations.GetAPIV1ConversationsRequest, security: operations.GetAPIV1ConversationsSecurity) -> operations.GetAPIV1ConversationsResponse:
        r"""Show conversation."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/conversations'
        
        query_params = utils.get_query_params(operations.GetAPIV1ConversationsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1ConversationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Conversation]])
                res.conversations = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_custom_emojis(self) -> operations.GetAPIV1CustomEmojisResponse:
        r"""Returns custom emojis that are available on the server."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/custom_emojis'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1CustomEmojisResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Emoji]])
                res.emojis = out

        return res

    def get_api_v1_directory(self, request: operations.GetAPIV1DirectoryRequest) -> operations.GetAPIV1DirectoryResponse:
        r"""List accounts visible in the directory."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/directory'
        
        query_params = utils.get_query_params(operations.GetAPIV1DirectoryRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1DirectoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Account]])
                res.accounts = out

        return res

    def get_api_v1_domain_blocks(self, request: operations.GetAPIV1DomainBlocksRequest, security: operations.GetAPIV1DomainBlocksSecurity) -> operations.GetAPIV1DomainBlocksResponse:
        r"""View domains the user has blocked."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/domain_blocks'
        
        query_params = utils.get_query_params(operations.GetAPIV1DomainBlocksRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1DomainBlocksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.get_api_v1_domain_blocks_200_application_json_strings = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_endorsements(self, request: operations.GetAPIV1EndorsementsRequest, security: operations.GetAPIV1EndorsementsSecurity) -> operations.GetAPIV1EndorsementsResponse:
        r"""Accounts that the user is currently featuring on their profile."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/endorsements'
        
        query_params = utils.get_query_params(operations.GetAPIV1EndorsementsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1EndorsementsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Account]])
                res.accounts = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_favourites(self, request: operations.GetAPIV1FavouritesRequest, security: operations.GetAPIV1FavouritesSecurity) -> operations.GetAPIV1FavouritesResponse:
        r"""Statuses the user has favourited."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/favourites'
        
        query_params = utils.get_query_params(operations.GetAPIV1FavouritesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1FavouritesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Status]])
                res.statuses = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_featured_tags(self) -> operations.GetAPIV1FeaturedTagsResponse:
        r"""View your featured tags."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/featured_tags'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1FeaturedTagsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.FeaturedTag]])
                res.featured_tags = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_featured_tags_suggestions(self) -> operations.GetAPIV1FeaturedTagsSuggestionsResponse:
        r"""Shows your 10 most-used tags, with usage history for the past week."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/featured_tags/suggestions'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1FeaturedTagsSuggestionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.FeaturedTag]])
                res.featured_tags = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_filters(self) -> operations.GetAPIV1FiltersResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/filters'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1FiltersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Filter]])
                res.filters = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_filters_id_(self, request: operations.GetAPIV1FiltersIDRequest, security: operations.GetAPIV1FiltersIDSecurity) -> operations.GetAPIV1FiltersIDResponse:
        r"""Get one filter."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1FiltersIDRequest, base_url, '/api/v1/filters/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1FiltersIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Filter])
                res.filter = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_follow_requests(self, request: operations.GetAPIV1FollowRequestsRequest, security: operations.GetAPIV1FollowRequestsSecurity) -> operations.GetAPIV1FollowRequestsResponse:
        r"""Pending Follows"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/follow_requests'
        
        query_params = utils.get_query_params(operations.GetAPIV1FollowRequestsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1FollowRequestsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Account]])
                res.accounts = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_instance(self) -> operations.GetAPIV1InstanceResponse:
        r"""Information about the server."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/instance'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1InstanceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Instance])
                res.instance = out

        return res

    def get_api_v1_instance_activity(self) -> operations.GetAPIV1InstanceActivityResponse:
        r"""Instance activity over the last 3 months, binned weekly."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/instance/activity'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1InstanceActivityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Activity]])
                res.activities = out

        return res

    def get_api_v1_instance_peers(self) -> operations.GetAPIV1InstancePeersResponse:
        r"""Information about the server."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/instance/peers'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1InstancePeersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.get_api_v1_instance_peers_200_application_json_strings = out

        return res

    def get_api_v1_lists(self) -> operations.GetAPIV1ListsResponse:
        r"""Fetch all lists that the user owns."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/lists'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1ListsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.List]])
                res.lists = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_lists_id_(self, request: operations.GetAPIV1ListsIDRequest, security: operations.GetAPIV1ListsIDSecurity) -> operations.GetAPIV1ListsIDResponse:
        r"""Remove converstation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1ListsIDRequest, base_url, '/api/v1/lists/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1ListsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.List])
                res.list_ = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_lists_id_accounts(self, request: operations.GetAPIV1ListsIDAccountsRequest, security: operations.GetAPIV1ListsIDAccountsSecurity) -> operations.GetAPIV1ListsIDAccountsResponse:
        r"""View accounts in List"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1ListsIDAccountsRequest, base_url, '/api/v1/lists/{id}/accounts', request)
        
        query_params = utils.get_query_params(operations.GetAPIV1ListsIDAccountsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1ListsIDAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Account]])
                res.accounts = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_media_id_(self, request: operations.GetAPIV1MediaIDRequest, security: operations.GetAPIV1MediaIDSecurity) -> operations.GetAPIV1MediaIDResponse:
        r"""Get an attachement."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1MediaIDRequest, base_url, '/api/v1/media/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1MediaIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 206]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Attachment])
                res.attachment = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_mutes(self, request: operations.GetAPIV1MutesRequest, security: operations.GetAPIV1MutesSecurity) -> operations.GetAPIV1MutesResponse:
        r"""Accounts the user has muted."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/mutes'
        
        query_params = utils.get_query_params(operations.GetAPIV1MutesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1MutesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Account]])
                res.accounts = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_notifications(self, request: operations.GetAPIV1NotificationsRequest, security: operations.GetAPIV1NotificationsSecurity) -> operations.GetAPIV1NotificationsResponse:
        r"""Notifications concerning the user. This API returns Link headers containing links to the next/previous page. However, the links can also be constructed dynamically using query params and id values."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/notifications'
        
        query_params = utils.get_query_params(operations.GetAPIV1NotificationsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1NotificationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Notification]])
                res.notifications = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_notifications_id_(self, request: operations.GetAPIV1NotificationsIDRequest, security: operations.GetAPIV1NotificationsIDSecurity) -> operations.GetAPIV1NotificationsIDResponse:
        r"""View information about a notification with a given ID."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1NotificationsIDRequest, base_url, '/api/v1/notifications/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1NotificationsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Notification])
                res.notification = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_polls_id_(self, request: operations.GetAPIV1PollsIDRequest) -> operations.GetAPIV1PollsIDResponse:
        r"""View a poll."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1PollsIDRequest, base_url, '/api/v1/polls/{id}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1PollsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Poll])
                res.poll = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_preferences(self) -> operations.GetAPIV1PreferencesResponse:
        r"""Shows your 10 most-used tags, with usage history for the past week."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/preferences'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1PreferencesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Preferences])
                res.preferences = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_push_subscription(self) -> operations.GetAPIV1PushSubscriptionResponse:
        r"""View the PushSubscription currently associated with this access token."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/push/subscription'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1PushSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PushSubscription])
                res.push_subscription = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_scheduled_statuses(self, request: operations.GetAPIV1ScheduledStatusesRequest, security: operations.GetAPIV1ScheduledStatusesSecurity) -> operations.GetAPIV1ScheduledStatusesResponse:
        r"""View scheduled statuses"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/scheduled_statuses'
        
        query_params = utils.get_query_params(operations.GetAPIV1ScheduledStatusesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1ScheduledStatusesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ScheduledStatus]])
                res.scheduled_statuses = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_scheduled_statuses_id_(self, request: operations.GetAPIV1ScheduledStatusesIDRequest, security: operations.GetAPIV1ScheduledStatusesIDSecurity) -> operations.GetAPIV1ScheduledStatusesIDResponse:
        r"""View a single scheduled status"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1ScheduledStatusesIDRequest, base_url, '/api/v1/scheduled_statuses/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1ScheduledStatusesIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ScheduledStatus])
                res.scheduled_status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_statuses_id_(self, request: operations.GetAPIV1StatusesIDRequest, security: operations.GetAPIV1StatusesIDSecurity) -> operations.GetAPIV1StatusesIDResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1StatusesIDRequest, base_url, '/api/v1/statuses/{id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1StatusesIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_statuses_id_context(self, request: operations.GetAPIV1StatusesIDContextRequest, security: operations.GetAPIV1StatusesIDContextSecurity) -> operations.GetAPIV1StatusesIDContextResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1StatusesIDContextRequest, base_url, '/api/v1/statuses/{id}/context', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1StatusesIDContextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Context])
                res.context = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_statuses_id_favourited_by(self, request: operations.GetAPIV1StatusesIDFavouritedByRequest) -> operations.GetAPIV1StatusesIDFavouritedByResponse:
        r"""View who favourited a given status."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1StatusesIDFavouritedByRequest, base_url, '/api/v1/statuses/{id}/favourited_by', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1StatusesIDFavouritedByResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_statuses_id_reblogged_by(self, request: operations.GetAPIV1StatusesIDRebloggedByRequest) -> operations.GetAPIV1StatusesIDRebloggedByResponse:
        r"""View who boosted a given status."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1StatusesIDRebloggedByRequest, base_url, '/api/v1/statuses/{id}/reblogged_by', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1StatusesIDRebloggedByResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_suggestions(self, request: operations.GetAPIV1SuggestionsRequest, security: operations.GetAPIV1SuggestionsSecurity) -> operations.GetAPIV1SuggestionsResponse:
        r"""Accounts the user has had past positive interactions with, but is not yet following."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/suggestions'
        
        query_params = utils.get_query_params(operations.GetAPIV1SuggestionsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1SuggestionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_timelines_home(self, request: operations.GetAPIV1TimelinesHomeRequest, security: operations.GetAPIV1TimelinesHomeSecurity) -> operations.GetAPIV1TimelinesHomeResponse:
        r"""View statuses from followed users."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/timelines/home'
        
        query_params = utils.get_query_params(operations.GetAPIV1TimelinesHomeRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1TimelinesHomeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Status]])
                res.statuses = out
        elif http_res.status_code == 206:
            pass
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_timelines_list_list_id_(self, request: operations.GetAPIV1TimelinesListListIDRequest, security: operations.GetAPIV1TimelinesListListIDSecurity) -> operations.GetAPIV1TimelinesListListIDResponse:
        r"""View statuses in the given list timeline."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1TimelinesListListIDRequest, base_url, '/api/v1/timelines/list/{list_id}', request)
        
        query_params = utils.get_query_params(operations.GetAPIV1TimelinesListListIDRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1TimelinesListListIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Status]])
                res.statuses = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_api_v1_timelines_public(self, request: operations.GetAPIV1TimelinesPublicRequest) -> operations.GetAPIV1TimelinesPublicResponse:
        r"""Public timeline"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/timelines/public'
        
        query_params = utils.get_query_params(operations.GetAPIV1TimelinesPublicRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1TimelinesPublicResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Status]])
                res.statuses = out

        return res

    def get_api_v1_timelines_tag_hashtag_(self, request: operations.GetAPIV1TimelinesTagHashtagRequest) -> operations.GetAPIV1TimelinesTagHashtagResponse:
        r"""View public statuses containing the given hashtag."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAPIV1TimelinesTagHashtagRequest, base_url, '/api/v1/timelines/tag/{hashtag}', request)
        
        query_params = utils.get_query_params(operations.GetAPIV1TimelinesTagHashtagRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1TimelinesTagHashtagResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Status]])
                res.statuses = out

        return res

    def get_api_v1_trends(self, request: operations.GetAPIV1TrendsRequest) -> operations.GetAPIV1TrendsResponse:
        r"""Tags that are being used more frequently within the past week."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/trends'
        
        query_params = utils.get_query_params(operations.GetAPIV1TrendsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV1TrendsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Tag]])
                res.tags = out

        return res

    def get_api_v2_search(self, request: operations.GetAPIV2SearchRequest, security: operations.GetAPIV2SearchSecurity) -> operations.GetAPIV2SearchResponse:
        r"""Search results"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v2/search'
        
        query_params = utils.get_query_params(operations.GetAPIV2SearchRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAPIV2SearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetAPIV2Search200ApplicationJSON])
                res.get_api_v2_search_200_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_admin_accounts_id_action(self, request: operations.PostAPIV1AdminAccountsIDActionRequest, security: operations.PostAPIV1AdminAccountsIDActionSecurity) -> operations.PostAPIV1AdminAccountsIDActionResponse:
        r"""Perform an action against an account and log this action in the moderation history."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminAccountsIDActionRequest, base_url, '/api/v1/admin/accounts/{id}/action', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminAccountsIDActionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_api_v1_admin_accounts_id_approve(self, request: operations.PostAPIV1AdminAccountsIDApproveRequest, security: operations.PostAPIV1AdminAccountsIDApproveSecurity) -> operations.PostAPIV1AdminAccountsIDApproveResponse:
        r"""Approve the given local account if it is currently pending approval."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminAccountsIDApproveRequest, base_url, '/api/v1/admin/accounts/{id}/approve', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminAccountsIDApproveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_api_v1_admin_accounts_id_enable(self, request: operations.PostAPIV1AdminAccountsIDEnableRequest, security: operations.PostAPIV1AdminAccountsIDEnableSecurity) -> operations.PostAPIV1AdminAccountsIDEnableResponse:
        r"""Re-enable a local account whose login is currently disabled."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminAccountsIDEnableRequest, base_url, '/api/v1/admin/accounts/{id}/enable', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminAccountsIDEnableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_api_v1_admin_accounts_id_reject(self, request: operations.PostAPIV1AdminAccountsIDRejectRequest, security: operations.PostAPIV1AdminAccountsIDRejectSecurity) -> operations.PostAPIV1AdminAccountsIDRejectResponse:
        r"""Reject the given local account if it is currently pending approval."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminAccountsIDRejectRequest, base_url, '/api/v1/admin/accounts/{id}/reject', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminAccountsIDRejectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_api_v1_admin_accounts_id_unsilence(self, request: operations.PostAPIV1AdminAccountsIDUnsilenceRequest, security: operations.PostAPIV1AdminAccountsIDUnsilenceSecurity) -> operations.PostAPIV1AdminAccountsIDUnsilenceResponse:
        r"""Unsilence a currently silenced account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminAccountsIDUnsilenceRequest, base_url, '/api/v1/admin/accounts/{id}/unsilence', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminAccountsIDUnsilenceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_api_v1_admin_accounts_id_unsuspend(self, request: operations.PostAPIV1AdminAccountsIDUnsuspendRequest, security: operations.PostAPIV1AdminAccountsIDUnsuspendSecurity) -> operations.PostAPIV1AdminAccountsIDUnsuspendResponse:
        r"""Unsuspend a currently suspended account."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminAccountsIDUnsuspendRequest, base_url, '/api/v1/admin/accounts/{id}/unsuspend', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminAccountsIDUnsuspendResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def post_api_v1_admin_reports_id_assign_to_self(self, request: operations.PostAPIV1AdminReportsIDAssignToSelfRequest, security: operations.PostAPIV1AdminReportsIDAssignToSelfSecurity) -> operations.PostAPIV1AdminReportsIDAssignToSelfResponse:
        r"""Claim the handling of this report to yourself."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminReportsIDAssignToSelfRequest, base_url, '/api/v1/admin/reports/{id}/assign_to_self', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminReportsIDAssignToSelfResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AdminReport])
                res.admin_report = out

        return res

    def post_api_v1_admin_reports_id_reopen(self, request: operations.PostAPIV1AdminReportsIDReopenRequest, security: operations.PostAPIV1AdminReportsIDReopenSecurity) -> operations.PostAPIV1AdminReportsIDReopenResponse:
        r"""Mark a report as resolved with no further action taken."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminReportsIDReopenRequest, base_url, '/api/v1/admin/reports/{id}/reopen', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminReportsIDReopenResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AdminReport])
                res.admin_report = out

        return res

    def post_api_v1_admin_reports_id_resolve(self, request: operations.PostAPIV1AdminReportsIDResolveRequest, security: operations.PostAPIV1AdminReportsIDResolveSecurity) -> operations.PostAPIV1AdminReportsIDResolveResponse:
        r"""Mark a report as resolved with no further action taken."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminReportsIDResolveRequest, base_url, '/api/v1/admin/reports/{id}/resolve', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminReportsIDResolveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AdminReport])
                res.admin_report = out

        return res

    def post_api_v1_admin_reports_id_unassign(self, request: operations.PostAPIV1AdminReportsIDUnassignRequest, security: operations.PostAPIV1AdminReportsIDUnassignSecurity) -> operations.PostAPIV1AdminReportsIDUnassignResponse:
        r"""Unassign a report so that someone else can claim it."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AdminReportsIDUnassignRequest, base_url, '/api/v1/admin/reports/{id}/unassign', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AdminReportsIDUnassignResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AdminReport])
                res.admin_report = out

        return res

    def post_api_v1_announcements_id_dismiss(self, request: operations.PostAPIV1AnnouncementsIDDismissRequest, security: operations.PostAPIV1AnnouncementsIDDismissSecurity) -> operations.PostAPIV1AnnouncementsIDDismissResponse:
        r"""Allows a user to mark the announcement as read."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1AnnouncementsIDDismissRequest, base_url, '/api/v1/announcements/{id}/dismiss', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1AnnouncementsIDDismissResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_api_v1_announcements_id_dismiss_200_application_json_object = out

        return res

    def post_api_v1_conversations_id_read(self, request: operations.PostAPIV1ConversationsIDReadRequest, security: operations.PostAPIV1ConversationsIDReadSecurity) -> operations.PostAPIV1ConversationsIDReadResponse:
        r"""Remove converstation"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1ConversationsIDReadRequest, base_url, '/api/v1/conversations/{id}/read', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1ConversationsIDReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Conversation])
                res.conversation = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_domain_blocks(self, request: bytes, security: operations.PostAPIV1DomainBlocksSecurity) -> operations.PostAPIV1DomainBlocksResponse:
        r"""\\"Block a domain to:
        - hide all public posts from it
        - hide all notifications from it
        - remove all followers from it
        - prevent following new users from it (but does not remove existing follows)\\" 
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/domain_blocks'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1DomainBlocksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_api_v1_domain_blocks_200_application_json_object = out
        elif http_res.status_code in [401, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_featured_tags(self, request: operations.PostAPIV1FeaturedTagsRequestBody, security: operations.PostAPIV1FeaturedTagsSecurity) -> operations.PostAPIV1FeaturedTagsResponse:
        r"""Create a feature a tag."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/featured_tags'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1FeaturedTagsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FeaturedTag])
                res.featured_tag = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_filters(self, request: bytes, security: operations.PostAPIV1FiltersSecurity) -> operations.PostAPIV1FiltersResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/filters'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1FiltersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Filter])
                res.filter = out
        elif http_res.status_code in [401, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_follow_requests_id_authorize(self, request: operations.PostAPIV1FollowRequestsIDAuthorizeRequest, security: operations.PostAPIV1FollowRequestsIDAuthorizeSecurity) -> operations.PostAPIV1FollowRequestsIDAuthorizeResponse:
        r"""Accept Follow"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1FollowRequestsIDAuthorizeRequest, base_url, '/api/v1/follow_requests/{id}/authorize', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1FollowRequestsIDAuthorizeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Relationship])
                res.relationship = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_follow_requests_id_reject(self, request: operations.PostAPIV1FollowRequestsIDRejectRequest, security: operations.PostAPIV1FollowRequestsIDRejectSecurity) -> operations.PostAPIV1FollowRequestsIDRejectResponse:
        r"""Accept Follow"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1FollowRequestsIDRejectRequest, base_url, '/api/v1/follow_requests/{id}/reject', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1FollowRequestsIDRejectResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Relationship])
                res.relationship = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_lists(self, request: operations.PostAPIV1ListsRequestBody, security: operations.PostAPIV1ListsSecurity) -> operations.PostAPIV1ListsResponse:
        r"""Create a new list."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/lists'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1ListsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.List])
                res.list_ = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_lists_id_accounts(self, request: operations.PostAPIV1ListsIDAccountsRequest, security: operations.PostAPIV1ListsIDAccountsSecurity) -> operations.PostAPIV1ListsIDAccountsResponse:
        r"""Add accounts to the given list. Note that the user must be following these accounts."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1ListsIDAccountsRequest, base_url, '/api/v1/lists/{id}/accounts', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1ListsIDAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_api_v1_lists_id_accounts_200_application_json_object = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_markers(self, request: dict[str, Any], security: operations.PostAPIV1MarkersSecurity) -> operations.PostAPIV1MarkersResponse:
        r"""Get saved timeline position"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/markers'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1MarkersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_api_v1_markers_200_application_json_object = out
        elif http_res.status_code in [401, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_media(self, request: bytes, security: operations.PostAPIV1MediaSecurity) -> operations.PostAPIV1MediaResponse:
        r"""Creates an attachment to be used with a new status."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/media'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1MediaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Attachment])
                res.attachment = out
        elif http_res.status_code in [401, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_media_id_(self, request: operations.PostAPIV1MediaIDRequest, security: operations.PostAPIV1MediaIDSecurity) -> operations.PostAPIV1MediaIDResponse:
        r"""Update an Attachment, before it is attached to a status and posted."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1MediaIDRequest, base_url, '/api/v1/media/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1MediaIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Attachment])
                res.attachment = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_notifications_clear(self) -> operations.PostAPIV1NotificationsClearResponse:
        r"""Clear all notifications from the server."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/notifications/clear'
        
        
        client = self._client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1NotificationsClearResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_api_v1_notifications_clear_200_application_json_object = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_notifications_id_dismiss(self, request: operations.PostAPIV1NotificationsIDDismissRequest, security: operations.PostAPIV1NotificationsIDDismissSecurity) -> operations.PostAPIV1NotificationsIDDismissResponse:
        r"""Clear a single notification from the server."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1NotificationsIDDismissRequest, base_url, '/api/v1/notifications/{id}/dismiss', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1NotificationsIDDismissResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Notification])
                res.notification = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_polls_id_(self, request: operations.PostAPIV1PollsIDRequest, security: operations.PostAPIV1PollsIDSecurity) -> operations.PostAPIV1PollsIDResponse:
        r"""Vote on a poll."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1PollsIDRequest, base_url, '/api/v1/polls/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1PollsIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Poll])
                res.poll = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_push_subscription(self, request: operations.PostAPIV1PushSubscriptionRequestBody, security: operations.PostAPIV1PushSubscriptionSecurity) -> operations.PostAPIV1PushSubscriptionResponse:
        r"""Add a Web Push API subscription to receive notifications. Each access token can have one push subscription. If you create a new subscription, the old subscription is deleted."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/push/subscription'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1PushSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PushSubscription])
                res.push_subscription = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_reports(self, request: operations.PostAPIV1ReportsRequestBody, security: operations.PostAPIV1ReportsSecurity) -> operations.PostAPIV1ReportsResponse:
        r"""File a report."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/reports'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1ReportsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Report])
                res.report = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses(self, request: operations.PostAPIV1StatusesRequest, security: operations.PostAPIV1StatusesSecurity) -> operations.PostAPIV1StatusesResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/statuses'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Any])
                res.post_api_v1_statuses_200_application_json_one_of = out
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_bookmark(self, request: operations.PostAPIV1StatusesIDBookmarkRequest, security: operations.PostAPIV1StatusesIDBookmarkSecurity) -> operations.PostAPIV1StatusesIDBookmarkResponse:
        r"""Privately bookmark a status."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDBookmarkRequest, base_url, '/api/v1/statuses/{id}/bookmark', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDBookmarkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_favourite(self, request: operations.PostAPIV1StatusesIDFavouriteRequest, security: operations.PostAPIV1StatusesIDFavouriteSecurity) -> operations.PostAPIV1StatusesIDFavouriteResponse:
        r"""Add a status to your favourites list."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDFavouriteRequest, base_url, '/api/v1/statuses/{id}/favourite', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDFavouriteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_mute(self, request: operations.PostAPIV1StatusesIDMuteRequest, security: operations.PostAPIV1StatusesIDMuteSecurity) -> operations.PostAPIV1StatusesIDMuteResponse:
        r"""Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDMuteRequest, base_url, '/api/v1/statuses/{id}/mute', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDMuteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_pin(self, request: operations.PostAPIV1StatusesIDPinRequest, security: operations.PostAPIV1StatusesIDPinSecurity) -> operations.PostAPIV1StatusesIDPinResponse:
        r"""Feature one of your own public statuses at the top of your profile."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDPinRequest, base_url, '/api/v1/statuses/{id}/pin', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDPinResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_reblog(self, request: operations.PostAPIV1StatusesIDReblogRequest, security: operations.PostAPIV1StatusesIDReblogSecurity) -> operations.PostAPIV1StatusesIDReblogResponse:
        r"""Reshare a status."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDReblogRequest, base_url, '/api/v1/statuses/{id}/reblog', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDReblogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_unbookmark(self, request: operations.PostAPIV1StatusesIDUnbookmarkRequest, security: operations.PostAPIV1StatusesIDUnbookmarkSecurity) -> operations.PostAPIV1StatusesIDUnbookmarkResponse:
        r"""Remove a status from your private bookmarks."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDUnbookmarkRequest, base_url, '/api/v1/statuses/{id}/unbookmark', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDUnbookmarkResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_unfavourite(self, request: operations.PostAPIV1StatusesIDUnfavouriteRequest, security: operations.PostAPIV1StatusesIDUnfavouriteSecurity) -> operations.PostAPIV1StatusesIDUnfavouriteResponse:
        r"""Remove a status from your favourites list."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDUnfavouriteRequest, base_url, '/api/v1/statuses/{id}/unfavourite', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDUnfavouriteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_unmute(self, request: operations.PostAPIV1StatusesIDUnmuteRequest, security: operations.PostAPIV1StatusesIDUnmuteSecurity) -> operations.PostAPIV1StatusesIDUnmuteResponse:
        r"""Status's conversation unmuted, or was already unmuted"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDUnmuteRequest, base_url, '/api/v1/statuses/{id}/unmute', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDUnmuteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_unpin(self, request: operations.PostAPIV1StatusesIDUnpinRequest, security: operations.PostAPIV1StatusesIDUnpinSecurity) -> operations.PostAPIV1StatusesIDUnpinResponse:
        r"""Unfeature a status from the top of your profile."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDUnpinRequest, base_url, '/api/v1/statuses/{id}/unpin', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDUnpinResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def post_api_v1_statuses_id_unreblog(self, request: operations.PostAPIV1StatusesIDUnreblogRequest, security: operations.PostAPIV1StatusesIDUnreblogSecurity) -> operations.PostAPIV1StatusesIDUnreblogResponse:
        r"""Undo a reshare of a status."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAPIV1StatusesIDUnreblogRequest, base_url, '/api/v1/statuses/{id}/unreblog', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAPIV1StatusesIDUnreblogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Status])
                res.status = out
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def put_api_v1_announcements_id_reactions_name_(self, request: operations.PutAPIV1AnnouncementsIDReactionsNameRequest, security: operations.PutAPIV1AnnouncementsIDReactionsNameSecurity) -> operations.PutAPIV1AnnouncementsIDReactionsNameResponse:
        r"""Allows a user to mark the announcement as read."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutAPIV1AnnouncementsIDReactionsNameRequest, base_url, '/api/v1/announcements/{id}/reactions/{name}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAPIV1AnnouncementsIDReactionsNameResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.put_api_v1_announcements_id_reactions_name_200_application_json_object = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def put_api_v1_filters_id_(self, request: operations.PutAPIV1FiltersIDRequest, security: operations.PutAPIV1FiltersIDSecurity) -> operations.PutAPIV1FiltersIDResponse:
        r"""Update a filter."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutAPIV1FiltersIDRequest, base_url, '/api/v1/filters/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAPIV1FiltersIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Filter])
                res.filter = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def put_api_v1_lists(self, request: operations.PutAPIV1ListsRequestBody, security: operations.PutAPIV1ListsSecurity) -> operations.PutAPIV1ListsResponse:
        r"""Change the title of a list, or which replies to show."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/lists'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAPIV1ListsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.List])
                res.list_ = out
        elif http_res.status_code in [401, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def put_api_v1_push_subscription(self, request: operations.PutAPIV1PushSubscriptionRequestBody, security: operations.PutAPIV1PushSubscriptionSecurity) -> operations.PutAPIV1PushSubscriptionResponse:
        r"""Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api/v1/push/subscription'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAPIV1PushSubscriptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PushSubscription])
                res.push_subscription = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def put_api_v1_scheduled_statuses_id_(self, request: operations.PutAPIV1ScheduledStatusesIDRequest, security: operations.PutAPIV1ScheduledStatusesIDSecurity) -> operations.PutAPIV1ScheduledStatusesIDResponse:
        r"""View a single scheduled status"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutAPIV1ScheduledStatusesIDRequest, base_url, '/api/v1/scheduled_statuses/{id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAPIV1ScheduledStatusesIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ScheduledStatus])
                res.scheduled_status = out
        elif http_res.status_code in [401, 404, 422]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    