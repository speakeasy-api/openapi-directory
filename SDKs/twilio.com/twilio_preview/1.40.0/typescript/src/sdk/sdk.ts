/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://preview.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Enroll a new Certificate credential to the Fleet, optionally giving it a friendly name and assigning to a Device.
   */
  createDeployedDevicesCertificate(
    req: operations.CreateDeployedDevicesCertificateRequest,
    security: operations.CreateDeployedDevicesCertificateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeployedDevicesCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeployedDevicesCertificateRequest(req);
    }

    let baseURL: string =
      operations.CreateDeployedDevicesCertificateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Certificates",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeployedDevicesCertificateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeployedDevicesCertificateResponse =
        new operations.CreateDeployedDevicesCertificateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetCertificate = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetCertificate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Deployment in the Fleet, optionally giving it a friendly name and linking to a specific Twilio Sync service instance.
   */
  createDeployedDevicesDeployment(
    req: operations.CreateDeployedDevicesDeploymentRequest,
    security: operations.CreateDeployedDevicesDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeployedDevicesDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeployedDevicesDeploymentRequest(req);
    }

    let baseURL: string =
      operations.CreateDeployedDevicesDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Deployments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeployedDevicesDeploymentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeployedDevicesDeploymentResponse =
        new operations.CreateDeployedDevicesDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetDeployment = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetDeployment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Device in the Fleet, optionally giving it a unique name, friendly name, and assigning to a Deployment and/or human identity.
   */
  createDeployedDevicesDevice(
    req: operations.CreateDeployedDevicesDeviceRequest,
    security: operations.CreateDeployedDevicesDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeployedDevicesDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeployedDevicesDeviceRequest(req);
    }

    let baseURL: string = operations.CreateDeployedDevicesDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Devices",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeployedDevicesDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeployedDevicesDeviceResponse =
        new operations.CreateDeployedDevicesDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetDevice = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetDevice
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Fleet for scoping of deployed devices within your account.
   */
  createDeployedDevicesFleet(
    req: operations.CreateDeployedDevicesFleetCreateDeployedDevicesFleetRequest,
    security: operations.CreateDeployedDevicesFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeployedDevicesFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateDeployedDevicesFleetCreateDeployedDevicesFleetRequest(
          req
        );
    }

    let baseURL: string = operations.CreateDeployedDevicesFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/DeployedDevices/Fleets";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeployedDevicesFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeployedDevicesFleetResponse =
        new operations.CreateDeployedDevicesFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleet = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleet
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new Key credential in the Fleet, optionally giving it a friendly name and assigning to a Device.
   */
  createDeployedDevicesKey(
    req: operations.CreateDeployedDevicesKeyRequest,
    security: operations.CreateDeployedDevicesKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeployedDevicesKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeployedDevicesKeyRequest(req);
    }

    let baseURL: string = operations.CreateDeployedDevicesKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Keys",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateDeployedDevicesKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeployedDevicesKeyResponse =
        new operations.CreateDeployedDevicesKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetKey = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an AuthorizationDocument for authorizing the hosting of phone number capabilities on Twilio's platform.
   */
  createHostedNumbersAuthorizationDocument(
    req: operations.CreateHostedNumbersAuthorizationDocumentCreateHostedNumbersAuthorizationDocumentRequest,
    security: operations.CreateHostedNumbersAuthorizationDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateHostedNumbersAuthorizationDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateHostedNumbersAuthorizationDocumentCreateHostedNumbersAuthorizationDocumentRequest(
          req
        );
    }

    let baseURL: string =
      operations.CreateHostedNumbersAuthorizationDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/HostedNumbers/AuthorizationDocuments";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CreateHostedNumbersAuthorizationDocumentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateHostedNumbersAuthorizationDocumentResponse =
        new operations.CreateHostedNumbersAuthorizationDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewHostedNumbersAuthorizationDocument = utils.objectToClass(
              httpRes?.data,
              shared.PreviewHostedNumbersAuthorizationDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Host a phone number's capability on Twilio's platform.
   */
  createHostedNumbersHostedNumberOrder(
    req: operations.CreateHostedNumbersHostedNumberOrderCreateHostedNumbersHostedNumberOrderRequest,
    security: operations.CreateHostedNumbersHostedNumberOrderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateHostedNumbersHostedNumberOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateHostedNumbersHostedNumberOrderCreateHostedNumbersHostedNumberOrderRequest(
          req
        );
    }

    let baseURL: string =
      operations.CreateHostedNumbersHostedNumberOrderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/HostedNumbers/HostedNumberOrders";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateHostedNumbersHostedNumberOrderSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateHostedNumbersHostedNumberOrderResponse =
        new operations.CreateHostedNumbersHostedNumberOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewHostedNumbersHostedNumberOrder = utils.objectToClass(
              httpRes?.data,
              shared.PreviewHostedNumbersHostedNumberOrder
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Install an Add-on for the Account specified.
   */
  createMarketplaceInstalledAddOn(
    req: operations.CreateMarketplaceInstalledAddOnCreateMarketplaceInstalledAddOnRequest,
    security: operations.CreateMarketplaceInstalledAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateMarketplaceInstalledAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateMarketplaceInstalledAddOnCreateMarketplaceInstalledAddOnRequest(
          req
        );
    }

    let baseURL: string =
      operations.CreateMarketplaceInstalledAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/marketplace/InstalledAddOns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateMarketplaceInstalledAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateMarketplaceInstalledAddOnResponse =
        new operations.CreateMarketplaceInstalledAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceInstalledAddOn = utils.objectToClass(
              httpRes?.data,
              shared.PreviewMarketplaceInstalledAddOn
            );
          }
          break;
      }

      return res;
    });
  }

  createSyncDocument(
    req: operations.CreateSyncDocumentRequest,
    security: operations.CreateSyncDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSyncDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSyncDocumentRequest(req);
    }

    let baseURL: string = operations.CreateSyncDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSyncDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSyncDocumentResponse =
        new operations.CreateSyncDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceDocument = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceDocument
            );
          }
          break;
      }

      return res;
    });
  }

  createSyncService(
    req: operations.CreateSyncServiceCreateSyncServiceRequest,
    security: operations.CreateSyncServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSyncServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSyncServiceCreateSyncServiceRequest(req);
    }

    let baseURL: string = operations.CreateSyncServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/Sync/Services";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSyncServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSyncServiceResponse =
        new operations.CreateSyncServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncService = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncService
            );
          }
          break;
      }

      return res;
    });
  }

  createSyncSyncList(
    req: operations.CreateSyncSyncListRequest,
    security: operations.CreateSyncSyncListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSyncSyncListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSyncSyncListRequest(req);
    }

    let baseURL: string = operations.CreateSyncSyncListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSyncSyncListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSyncSyncListResponse =
        new operations.CreateSyncSyncListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncList = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncList
            );
          }
          break;
      }

      return res;
    });
  }

  createSyncSyncListItem(
    req: operations.CreateSyncSyncListItemRequest,
    security: operations.CreateSyncSyncListItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSyncSyncListItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSyncSyncListItemRequest(req);
    }

    let baseURL: string = operations.CreateSyncSyncListItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSyncSyncListItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSyncSyncListItemResponse =
        new operations.CreateSyncSyncListItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncListSyncListItem = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncListSyncListItem
            );
          }
          break;
      }

      return res;
    });
  }

  createSyncSyncMap(
    req: operations.CreateSyncSyncMapRequest,
    security: operations.CreateSyncSyncMapSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSyncSyncMapResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSyncSyncMapRequest(req);
    }

    let baseURL: string = operations.CreateSyncSyncMapServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSyncSyncMapSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSyncSyncMapResponse =
        new operations.CreateSyncSyncMapResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMap = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncMap
            );
          }
          break;
      }

      return res;
    });
  }

  createSyncSyncMapItem(
    req: operations.CreateSyncSyncMapItemRequest,
    security: operations.CreateSyncSyncMapItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSyncSyncMapItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSyncSyncMapItemRequest(req);
    }

    let baseURL: string = operations.CreateSyncSyncMapItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateSyncSyncMapItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSyncSyncMapItemResponse =
        new operations.CreateSyncSyncMapItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMapSyncMapItem = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncMapSyncMapItem
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandAssistant(
    req: operations.CreateUnderstandAssistantCreateUnderstandAssistantRequest,
    security: operations.CreateUnderstandAssistantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandAssistantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateUnderstandAssistantCreateUnderstandAssistantRequest(
          req
        );
    }

    let baseURL: string = operations.CreateUnderstandAssistantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/understand/Assistants";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandAssistantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandAssistantResponse =
        new operations.CreateUnderstandAssistantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistant = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistant
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandField(
    req: operations.CreateUnderstandFieldRequest,
    security: operations.CreateUnderstandFieldSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandFieldResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandFieldRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandFieldServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandFieldSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandFieldResponse =
        new operations.CreateUnderstandFieldResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskField = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskField
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandFieldType(
    req: operations.CreateUnderstandFieldTypeRequest,
    security: operations.CreateUnderstandFieldTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandFieldTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandFieldTypeRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandFieldTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandFieldTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandFieldTypeResponse =
        new operations.CreateUnderstandFieldTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantFieldType = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantFieldType
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandFieldValue(
    req: operations.CreateUnderstandFieldValueRequest,
    security: operations.CreateUnderstandFieldValueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandFieldValueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandFieldValueRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandFieldValueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandFieldValueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandFieldValueResponse =
        new operations.CreateUnderstandFieldValueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantFieldTypeFieldValue =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantFieldTypeFieldValue
              );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandModelBuild(
    req: operations.CreateUnderstandModelBuildRequest,
    security: operations.CreateUnderstandModelBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandModelBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandModelBuildRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandModelBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/ModelBuilds",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandModelBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandModelBuildResponse =
        new operations.CreateUnderstandModelBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantModelBuild = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantModelBuild
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandQuery(
    req: operations.CreateUnderstandQueryRequest,
    security: operations.CreateUnderstandQuerySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandQueryRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandQueryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Queries",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandQuerySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandQueryResponse =
        new operations.CreateUnderstandQueryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantQuery = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantQuery
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandSample(
    req: operations.CreateUnderstandSampleRequest,
    security: operations.CreateUnderstandSampleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandSampleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandSampleRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandSampleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandSampleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandSampleResponse =
        new operations.CreateUnderstandSampleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskSample = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskSample
            );
          }
          break;
      }

      return res;
    });
  }

  createUnderstandTask(
    req: operations.CreateUnderstandTaskRequest,
    security: operations.CreateUnderstandTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUnderstandTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUnderstandTaskRequest(req);
    }

    let baseURL: string = operations.CreateUnderstandTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateUnderstandTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUnderstandTaskResponse =
        new operations.CreateUnderstandTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTask = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTask
            );
          }
          break;
      }

      return res;
    });
  }

  createWirelessCommand(
    req: operations.CreateWirelessCommandCreateWirelessCommandRequest,
    security: operations.CreateWirelessCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWirelessCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWirelessCommandCreateWirelessCommandRequest(
        req
      );
    }

    let baseURL: string = operations.CreateWirelessCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/wireless/Commands";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWirelessCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWirelessCommandResponse =
        new operations.CreateWirelessCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessCommand = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessCommand
            );
          }
          break;
      }

      return res;
    });
  }

  createWirelessRatePlan(
    req: operations.CreateWirelessRatePlanCreateWirelessRatePlanRequest,
    security: operations.CreateWirelessRatePlanSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWirelessRatePlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWirelessRatePlanCreateWirelessRatePlanRequest(
        req
      );
    }

    let baseURL: string = operations.CreateWirelessRatePlanServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/wireless/RatePlans";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateWirelessRatePlanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWirelessRatePlanResponse =
        new operations.CreateWirelessRatePlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessRatePlan = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessRatePlan
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unregister a specific Certificate credential from the Fleet, effectively disallowing any inbound client connections that are presenting it.
   */
  deleteDeployedDevicesCertificate(
    req: operations.DeleteDeployedDevicesCertificateRequest,
    security: operations.DeleteDeployedDevicesCertificateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeployedDevicesCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeployedDevicesCertificateRequest(req);
    }

    let baseURL: string =
      operations.DeleteDeployedDevicesCertificateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeployedDevicesCertificateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeployedDevicesCertificateResponse =
        new operations.DeleteDeployedDevicesCertificateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Deployment from the Fleet, leaving associated devices effectively undeployed.
   */
  deleteDeployedDevicesDeployment(
    req: operations.DeleteDeployedDevicesDeploymentRequest,
    security: operations.DeleteDeployedDevicesDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeployedDevicesDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeployedDevicesDeploymentRequest(req);
    }

    let baseURL: string =
      operations.DeleteDeployedDevicesDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeployedDevicesDeploymentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeployedDevicesDeploymentResponse =
        new operations.DeleteDeployedDevicesDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Device from the Fleet, also removing it from associated Deployments.
   */
  deleteDeployedDevicesDevice(
    req: operations.DeleteDeployedDevicesDeviceRequest,
    security: operations.DeleteDeployedDevicesDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeployedDevicesDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeployedDevicesDeviceRequest(req);
    }

    let baseURL: string = operations.DeleteDeployedDevicesDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeployedDevicesDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeployedDevicesDeviceResponse =
        new operations.DeleteDeployedDevicesDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Fleet from your account, also destroys all nested resources: Devices, Deployments, Certificates, Keys.
   */
  deleteDeployedDevicesFleet(
    req: operations.DeleteDeployedDevicesFleetRequest,
    security: operations.DeleteDeployedDevicesFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeployedDevicesFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeployedDevicesFleetRequest(req);
    }

    let baseURL: string = operations.DeleteDeployedDevicesFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeployedDevicesFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeployedDevicesFleetResponse =
        new operations.DeleteDeployedDevicesFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Key credential from the Fleet, effectively disallowing any inbound client connections that are presenting it.
   */
  deleteDeployedDevicesKey(
    req: operations.DeleteDeployedDevicesKeyRequest,
    security: operations.DeleteDeployedDevicesKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDeployedDevicesKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDeployedDevicesKeyRequest(req);
    }

    let baseURL: string = operations.DeleteDeployedDevicesKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteDeployedDevicesKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDeployedDevicesKeyResponse =
        new operations.DeleteDeployedDevicesKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Cancel the HostedNumberOrder (only available when the status is in `received`).
   */
  deleteHostedNumbersHostedNumberOrder(
    req: operations.DeleteHostedNumbersHostedNumberOrderRequest,
    security: operations.DeleteHostedNumbersHostedNumberOrderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteHostedNumbersHostedNumberOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteHostedNumbersHostedNumberOrderRequest(req);
    }

    let baseURL: string =
      operations.DeleteHostedNumbersHostedNumberOrderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/HostedNumbers/HostedNumberOrders/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteHostedNumbersHostedNumberOrderSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteHostedNumbersHostedNumberOrderResponse =
        new operations.DeleteHostedNumbersHostedNumberOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Remove an Add-on installation from your account
   */
  deleteMarketplaceInstalledAddOn(
    req: operations.DeleteMarketplaceInstalledAddOnRequest,
    security: operations.DeleteMarketplaceInstalledAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteMarketplaceInstalledAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteMarketplaceInstalledAddOnRequest(req);
    }

    let baseURL: string =
      operations.DeleteMarketplaceInstalledAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/InstalledAddOns/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteMarketplaceInstalledAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteMarketplaceInstalledAddOnResponse =
        new operations.DeleteMarketplaceInstalledAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSyncDocument(
    req: operations.DeleteSyncDocumentRequest,
    security: operations.DeleteSyncDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncDocumentRequest(req);
    }

    let baseURL: string = operations.DeleteSyncDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncDocumentResponse =
        new operations.DeleteSyncDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Sync Document Permission.
   */
  deleteSyncDocumentPermission(
    req: operations.DeleteSyncDocumentPermissionRequest,
    security: operations.DeleteSyncDocumentPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncDocumentPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncDocumentPermissionRequest(req);
    }

    let baseURL: string = operations.DeleteSyncDocumentPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncDocumentPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncDocumentPermissionResponse =
        new operations.DeleteSyncDocumentPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSyncService(
    req: operations.DeleteSyncServiceRequest,
    security: operations.DeleteSyncServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncServiceRequest(req);
    }

    let baseURL: string = operations.DeleteSyncServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/Sync/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncServiceResponse =
        new operations.DeleteSyncServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSyncSyncList(
    req: operations.DeleteSyncSyncListRequest,
    security: operations.DeleteSyncSyncListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncSyncListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncSyncListRequest(req);
    }

    let baseURL: string = operations.DeleteSyncSyncListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncSyncListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncSyncListResponse =
        new operations.DeleteSyncSyncListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSyncSyncListItem(
    req: operations.DeleteSyncSyncListItemRequest,
    security: operations.DeleteSyncSyncListItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncSyncListItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncSyncListItemRequest(req);
    }

    let baseURL: string = operations.DeleteSyncSyncListItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncSyncListItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncSyncListItemResponse =
        new operations.DeleteSyncSyncListItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Sync List Permission.
   */
  deleteSyncSyncListPermission(
    req: operations.DeleteSyncSyncListPermissionRequest,
    security: operations.DeleteSyncSyncListPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncSyncListPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncSyncListPermissionRequest(req);
    }

    let baseURL: string = operations.DeleteSyncSyncListPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncSyncListPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncSyncListPermissionResponse =
        new operations.DeleteSyncSyncListPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSyncSyncMap(
    req: operations.DeleteSyncSyncMapRequest,
    security: operations.DeleteSyncSyncMapSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncSyncMapResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncSyncMapRequest(req);
    }

    let baseURL: string = operations.DeleteSyncSyncMapServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncSyncMapSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncSyncMapResponse =
        new operations.DeleteSyncSyncMapResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteSyncSyncMapItem(
    req: operations.DeleteSyncSyncMapItemRequest,
    security: operations.DeleteSyncSyncMapItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncSyncMapItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncSyncMapItemRequest(req);
    }

    let baseURL: string = operations.DeleteSyncSyncMapItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncSyncMapItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncSyncMapItemResponse =
        new operations.DeleteSyncSyncMapItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Sync Map Permission.
   */
  deleteSyncSyncMapPermission(
    req: operations.DeleteSyncSyncMapPermissionRequest,
    security: operations.DeleteSyncSyncMapPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSyncSyncMapPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSyncSyncMapPermissionRequest(req);
    }

    let baseURL: string = operations.DeleteSyncSyncMapPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSyncSyncMapPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSyncSyncMapPermissionResponse =
        new operations.DeleteSyncSyncMapPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandAssistant(
    req: operations.DeleteUnderstandAssistantRequest,
    security: operations.DeleteUnderstandAssistantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandAssistantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandAssistantRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandAssistantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandAssistantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandAssistantResponse =
        new operations.DeleteUnderstandAssistantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandField(
    req: operations.DeleteUnderstandFieldRequest,
    security: operations.DeleteUnderstandFieldSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandFieldResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandFieldRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandFieldServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandFieldSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandFieldResponse =
        new operations.DeleteUnderstandFieldResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandFieldType(
    req: operations.DeleteUnderstandFieldTypeRequest,
    security: operations.DeleteUnderstandFieldTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandFieldTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandFieldTypeRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandFieldTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandFieldTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandFieldTypeResponse =
        new operations.DeleteUnderstandFieldTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandFieldValue(
    req: operations.DeleteUnderstandFieldValueRequest,
    security: operations.DeleteUnderstandFieldValueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandFieldValueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandFieldValueRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandFieldValueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandFieldValueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandFieldValueResponse =
        new operations.DeleteUnderstandFieldValueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandModelBuild(
    req: operations.DeleteUnderstandModelBuildRequest,
    security: operations.DeleteUnderstandModelBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandModelBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandModelBuildRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandModelBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandModelBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandModelBuildResponse =
        new operations.DeleteUnderstandModelBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandQuery(
    req: operations.DeleteUnderstandQueryRequest,
    security: operations.DeleteUnderstandQuerySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandQueryRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandQueryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Queries/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandQuerySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandQueryResponse =
        new operations.DeleteUnderstandQueryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandSample(
    req: operations.DeleteUnderstandSampleRequest,
    security: operations.DeleteUnderstandSampleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandSampleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandSampleRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandSampleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandSampleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandSampleResponse =
        new operations.DeleteUnderstandSampleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteUnderstandTask(
    req: operations.DeleteUnderstandTaskRequest,
    security: operations.DeleteUnderstandTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUnderstandTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUnderstandTaskRequest(req);
    }

    let baseURL: string = operations.DeleteUnderstandTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteUnderstandTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUnderstandTaskResponse =
        new operations.DeleteUnderstandTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  deleteWirelessRatePlan(
    req: operations.DeleteWirelessRatePlanRequest,
    security: operations.DeleteWirelessRatePlanSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWirelessRatePlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWirelessRatePlanRequest(req);
    }

    let baseURL: string = operations.DeleteWirelessRatePlanServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/wireless/RatePlans/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWirelessRatePlanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWirelessRatePlanResponse =
        new operations.DeleteWirelessRatePlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Fetch information about a specific Certificate credential in the Fleet.
   */
  fetchDeployedDevicesCertificate(
    req: operations.FetchDeployedDevicesCertificateRequest,
    security: operations.FetchDeployedDevicesCertificateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeployedDevicesCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeployedDevicesCertificateRequest(req);
    }

    let baseURL: string =
      operations.FetchDeployedDevicesCertificateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeployedDevicesCertificateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeployedDevicesCertificateResponse =
        new operations.FetchDeployedDevicesCertificateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetCertificate = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetCertificate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch information about a specific Deployment in the Fleet.
   */
  fetchDeployedDevicesDeployment(
    req: operations.FetchDeployedDevicesDeploymentRequest,
    security: operations.FetchDeployedDevicesDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeployedDevicesDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeployedDevicesDeploymentRequest(req);
    }

    let baseURL: string =
      operations.FetchDeployedDevicesDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeployedDevicesDeploymentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeployedDevicesDeploymentResponse =
        new operations.FetchDeployedDevicesDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetDeployment = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetDeployment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch information about a specific Device in the Fleet.
   */
  fetchDeployedDevicesDevice(
    req: operations.FetchDeployedDevicesDeviceRequest,
    security: operations.FetchDeployedDevicesDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeployedDevicesDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeployedDevicesDeviceRequest(req);
    }

    let baseURL: string = operations.FetchDeployedDevicesDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeployedDevicesDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeployedDevicesDeviceResponse =
        new operations.FetchDeployedDevicesDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetDevice = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetDevice
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch information about a specific Fleet in your account.
   */
  fetchDeployedDevicesFleet(
    req: operations.FetchDeployedDevicesFleetRequest,
    security: operations.FetchDeployedDevicesFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeployedDevicesFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeployedDevicesFleetRequest(req);
    }

    let baseURL: string = operations.FetchDeployedDevicesFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeployedDevicesFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeployedDevicesFleetResponse =
        new operations.FetchDeployedDevicesFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleet = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleet
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch information about a specific Key credential in the Fleet.
   */
  fetchDeployedDevicesKey(
    req: operations.FetchDeployedDevicesKeyRequest,
    security: operations.FetchDeployedDevicesKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchDeployedDevicesKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchDeployedDevicesKeyRequest(req);
    }

    let baseURL: string = operations.FetchDeployedDevicesKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchDeployedDevicesKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchDeployedDevicesKeyResponse =
        new operations.FetchDeployedDevicesKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetKey = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific AuthorizationDocument.
   */
  fetchHostedNumbersAuthorizationDocument(
    req: operations.FetchHostedNumbersAuthorizationDocumentRequest,
    security: operations.FetchHostedNumbersAuthorizationDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchHostedNumbersAuthorizationDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchHostedNumbersAuthorizationDocumentRequest(req);
    }

    let baseURL: string =
      operations.FetchHostedNumbersAuthorizationDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/HostedNumbers/AuthorizationDocuments/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchHostedNumbersAuthorizationDocumentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchHostedNumbersAuthorizationDocumentResponse =
        new operations.FetchHostedNumbersAuthorizationDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewHostedNumbersAuthorizationDocument = utils.objectToClass(
              httpRes?.data,
              shared.PreviewHostedNumbersAuthorizationDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific HostedNumberOrder.
   */
  fetchHostedNumbersHostedNumberOrder(
    req: operations.FetchHostedNumbersHostedNumberOrderRequest,
    security: operations.FetchHostedNumbersHostedNumberOrderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchHostedNumbersHostedNumberOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchHostedNumbersHostedNumberOrderRequest(req);
    }

    let baseURL: string =
      operations.FetchHostedNumbersHostedNumberOrderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/HostedNumbers/HostedNumberOrders/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchHostedNumbersHostedNumberOrderSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchHostedNumbersHostedNumberOrderResponse =
        new operations.FetchHostedNumbersHostedNumberOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewHostedNumbersHostedNumberOrder = utils.objectToClass(
              httpRes?.data,
              shared.PreviewHostedNumbersHostedNumberOrder
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an Add-on currently available to be installed.
   */
  fetchMarketplaceAvailableAddOn(
    req: operations.FetchMarketplaceAvailableAddOnRequest,
    security: operations.FetchMarketplaceAvailableAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMarketplaceAvailableAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMarketplaceAvailableAddOnRequest(req);
    }

    let baseURL: string =
      operations.FetchMarketplaceAvailableAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/AvailableAddOns/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMarketplaceAvailableAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMarketplaceAvailableAddOnResponse =
        new operations.FetchMarketplaceAvailableAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceAvailableAddOn = utils.objectToClass(
              httpRes?.data,
              shared.PreviewMarketplaceAvailableAddOn
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an Extension for the Available Add-on.
   */
  fetchMarketplaceAvailableAddOnExtension(
    req: operations.FetchMarketplaceAvailableAddOnExtensionRequest,
    security: operations.FetchMarketplaceAvailableAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMarketplaceAvailableAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMarketplaceAvailableAddOnExtensionRequest(req);
    }

    let baseURL: string =
      operations.FetchMarketplaceAvailableAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/AvailableAddOns/{AvailableAddOnSid}/Extensions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMarketplaceAvailableAddOnExtensionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMarketplaceAvailableAddOnExtensionResponse =
        new operations.FetchMarketplaceAvailableAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceAvailableAddOnAvailableAddOnExtension =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewMarketplaceAvailableAddOnAvailableAddOnExtension
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an Add-on currently installed on this Account.
   */
  fetchMarketplaceInstalledAddOn(
    req: operations.FetchMarketplaceInstalledAddOnRequest,
    security: operations.FetchMarketplaceInstalledAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMarketplaceInstalledAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMarketplaceInstalledAddOnRequest(req);
    }

    let baseURL: string =
      operations.FetchMarketplaceInstalledAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/InstalledAddOns/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMarketplaceInstalledAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMarketplaceInstalledAddOnResponse =
        new operations.FetchMarketplaceInstalledAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceInstalledAddOn = utils.objectToClass(
              httpRes?.data,
              shared.PreviewMarketplaceInstalledAddOn
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch an instance of an Extension for the Installed Add-on.
   */
  fetchMarketplaceInstalledAddOnExtension(
    req: operations.FetchMarketplaceInstalledAddOnExtensionRequest,
    security: operations.FetchMarketplaceInstalledAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchMarketplaceInstalledAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchMarketplaceInstalledAddOnExtensionRequest(req);
    }

    let baseURL: string =
      operations.FetchMarketplaceInstalledAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchMarketplaceInstalledAddOnExtensionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchMarketplaceInstalledAddOnExtensionResponse =
        new operations.FetchMarketplaceInstalledAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceInstalledAddOnInstalledAddOnExtension =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension
              );
          }
          break;
      }

      return res;
    });
  }

  fetchSyncDocument(
    req: operations.FetchSyncDocumentRequest,
    security: operations.FetchSyncDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncDocumentRequest(req);
    }

    let baseURL: string = operations.FetchSyncDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncDocumentResponse =
        new operations.FetchSyncDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceDocument = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Sync Document Permission.
   */
  fetchSyncDocumentPermission(
    req: operations.FetchSyncDocumentPermissionRequest,
    security: operations.FetchSyncDocumentPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncDocumentPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncDocumentPermissionRequest(req);
    }

    let baseURL: string = operations.FetchSyncDocumentPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncDocumentPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncDocumentPermissionResponse =
        new operations.FetchSyncDocumentPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceDocumentDocumentPermission =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewSyncServiceDocumentDocumentPermission
              );
          }
          break;
      }

      return res;
    });
  }

  fetchSyncService(
    req: operations.FetchSyncServiceRequest,
    security: operations.FetchSyncServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncServiceRequest(req);
    }

    let baseURL: string = operations.FetchSyncServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/Sync/Services/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncServiceResponse =
        new operations.FetchSyncServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncService = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncService
            );
          }
          break;
      }

      return res;
    });
  }

  fetchSyncSyncList(
    req: operations.FetchSyncSyncListRequest,
    security: operations.FetchSyncSyncListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncSyncListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncSyncListRequest(req);
    }

    let baseURL: string = operations.FetchSyncSyncListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncSyncListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncSyncListResponse =
        new operations.FetchSyncSyncListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncList = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncList
            );
          }
          break;
      }

      return res;
    });
  }

  fetchSyncSyncListItem(
    req: operations.FetchSyncSyncListItemRequest,
    security: operations.FetchSyncSyncListItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncSyncListItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncSyncListItemRequest(req);
    }

    let baseURL: string = operations.FetchSyncSyncListItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncSyncListItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncSyncListItemResponse =
        new operations.FetchSyncSyncListItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncListSyncListItem = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncListSyncListItem
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Sync List Permission.
   */
  fetchSyncSyncListPermission(
    req: operations.FetchSyncSyncListPermissionRequest,
    security: operations.FetchSyncSyncListPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncSyncListPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncSyncListPermissionRequest(req);
    }

    let baseURL: string = operations.FetchSyncSyncListPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncSyncListPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncSyncListPermissionResponse =
        new operations.FetchSyncSyncListPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncListSyncListPermission =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewSyncServiceSyncListSyncListPermission
              );
          }
          break;
      }

      return res;
    });
  }

  fetchSyncSyncMap(
    req: operations.FetchSyncSyncMapRequest,
    security: operations.FetchSyncSyncMapSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncSyncMapResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncSyncMapRequest(req);
    }

    let baseURL: string = operations.FetchSyncSyncMapServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncSyncMapSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncSyncMapResponse =
        new operations.FetchSyncSyncMapResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMap = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncMap
            );
          }
          break;
      }

      return res;
    });
  }

  fetchSyncSyncMapItem(
    req: operations.FetchSyncSyncMapItemRequest,
    security: operations.FetchSyncSyncMapItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncSyncMapItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncSyncMapItemRequest(req);
    }

    let baseURL: string = operations.FetchSyncSyncMapItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncSyncMapItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncSyncMapItemResponse =
        new operations.FetchSyncSyncMapItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMapSyncMapItem = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncMapSyncMapItem
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Fetch a specific Sync Map Permission.
   */
  fetchSyncSyncMapPermission(
    req: operations.FetchSyncSyncMapPermissionRequest,
    security: operations.FetchSyncSyncMapPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchSyncSyncMapPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchSyncSyncMapPermissionRequest(req);
    }

    let baseURL: string = operations.FetchSyncSyncMapPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchSyncSyncMapPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchSyncSyncMapPermissionResponse =
        new operations.FetchSyncSyncMapPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMapSyncMapPermission =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewSyncServiceSyncMapSyncMapPermission
              );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandAssistant(
    req: operations.FetchUnderstandAssistantRequest,
    security: operations.FetchUnderstandAssistantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandAssistantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandAssistantRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandAssistantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandAssistantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandAssistantResponse =
        new operations.FetchUnderstandAssistantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistant = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistant
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandAssistantFallbackActions(
    req: operations.FetchUnderstandAssistantFallbackActionsRequest,
    security: operations.FetchUnderstandAssistantFallbackActionsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandAssistantFallbackActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandAssistantFallbackActionsRequest(req);
    }

    let baseURL: string =
      operations.FetchUnderstandAssistantFallbackActionsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FallbackActions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandAssistantFallbackActionsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandAssistantFallbackActionsResponse =
        new operations.FetchUnderstandAssistantFallbackActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantAssistantFallbackActions =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantAssistantFallbackActions
              );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandAssistantInitiationActions(
    req: operations.FetchUnderstandAssistantInitiationActionsRequest,
    security: operations.FetchUnderstandAssistantInitiationActionsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandAssistantInitiationActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandAssistantInitiationActionsRequest(
        req
      );
    }

    let baseURL: string =
      operations.FetchUnderstandAssistantInitiationActionsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/InitiationActions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.FetchUnderstandAssistantInitiationActionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandAssistantInitiationActionsResponse =
        new operations.FetchUnderstandAssistantInitiationActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantAssistantInitiationActions =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantAssistantInitiationActions
              );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandDialogue(
    req: operations.FetchUnderstandDialogueRequest,
    security: operations.FetchUnderstandDialogueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandDialogueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandDialogueRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandDialogueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Dialogues/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandDialogueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandDialogueResponse =
        new operations.FetchUnderstandDialogueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantDialogue = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantDialogue
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandField(
    req: operations.FetchUnderstandFieldRequest,
    security: operations.FetchUnderstandFieldSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandFieldResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandFieldRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandFieldServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandFieldSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandFieldResponse =
        new operations.FetchUnderstandFieldResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskField = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskField
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandFieldType(
    req: operations.FetchUnderstandFieldTypeRequest,
    security: operations.FetchUnderstandFieldTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandFieldTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandFieldTypeRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandFieldTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandFieldTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandFieldTypeResponse =
        new operations.FetchUnderstandFieldTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantFieldType = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantFieldType
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandFieldValue(
    req: operations.FetchUnderstandFieldValueRequest,
    security: operations.FetchUnderstandFieldValueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandFieldValueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandFieldValueRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandFieldValueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandFieldValueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandFieldValueResponse =
        new operations.FetchUnderstandFieldValueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantFieldTypeFieldValue =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantFieldTypeFieldValue
              );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandModelBuild(
    req: operations.FetchUnderstandModelBuildRequest,
    security: operations.FetchUnderstandModelBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandModelBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandModelBuildRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandModelBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandModelBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandModelBuildResponse =
        new operations.FetchUnderstandModelBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantModelBuild = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantModelBuild
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandQuery(
    req: operations.FetchUnderstandQueryRequest,
    security: operations.FetchUnderstandQuerySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandQueryRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandQueryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Queries/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandQuerySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandQueryResponse =
        new operations.FetchUnderstandQueryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantQuery = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantQuery
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandSample(
    req: operations.FetchUnderstandSampleRequest,
    security: operations.FetchUnderstandSampleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandSampleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandSampleRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandSampleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandSampleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandSampleResponse =
        new operations.FetchUnderstandSampleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskSample = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskSample
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns Style sheet JSON object for this Assistant
   */
  fetchUnderstandStyleSheet(
    req: operations.FetchUnderstandStyleSheetRequest,
    security: operations.FetchUnderstandStyleSheetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandStyleSheetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandStyleSheetRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandStyleSheetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/StyleSheet",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandStyleSheetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandStyleSheetResponse =
        new operations.FetchUnderstandStyleSheetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantStyleSheet = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantStyleSheet
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandTask(
    req: operations.FetchUnderstandTaskRequest,
    security: operations.FetchUnderstandTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandTaskRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandTaskResponse =
        new operations.FetchUnderstandTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTask = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTask
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns JSON actions for this Task.
   */
  fetchUnderstandTaskActions(
    req: operations.FetchUnderstandTaskActionsRequest,
    security: operations.FetchUnderstandTaskActionsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandTaskActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandTaskActionsRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandTaskActionsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandTaskActionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandTaskActionsResponse =
        new operations.FetchUnderstandTaskActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskTaskActions = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskTaskActions
            );
          }
          break;
      }

      return res;
    });
  }

  fetchUnderstandTaskStatistics(
    req: operations.FetchUnderstandTaskStatisticsRequest,
    security: operations.FetchUnderstandTaskStatisticsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchUnderstandTaskStatisticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchUnderstandTaskStatisticsRequest(req);
    }

    let baseURL: string = operations.FetchUnderstandTaskStatisticsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Statistics",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchUnderstandTaskStatisticsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchUnderstandTaskStatisticsResponse =
        new operations.FetchUnderstandTaskStatisticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskTaskStatistics =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantTaskTaskStatistics
              );
          }
          break;
      }

      return res;
    });
  }

  fetchWirelessCommand(
    req: operations.FetchWirelessCommandRequest,
    security: operations.FetchWirelessCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWirelessCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWirelessCommandRequest(req);
    }

    let baseURL: string = operations.FetchWirelessCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/wireless/Commands/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWirelessCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWirelessCommandResponse =
        new operations.FetchWirelessCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessCommand = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessCommand
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWirelessRatePlan(
    req: operations.FetchWirelessRatePlanRequest,
    security: operations.FetchWirelessRatePlanSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWirelessRatePlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWirelessRatePlanRequest(req);
    }

    let baseURL: string = operations.FetchWirelessRatePlanServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/wireless/RatePlans/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWirelessRatePlanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWirelessRatePlanResponse =
        new operations.FetchWirelessRatePlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessRatePlan = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessRatePlan
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWirelessSim(
    req: operations.FetchWirelessSimRequest,
    security: operations.FetchWirelessSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWirelessSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWirelessSimRequest(req);
    }

    let baseURL: string = operations.FetchWirelessSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/wireless/Sims/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWirelessSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWirelessSimResponse =
        new operations.FetchWirelessSimResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessSim = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessSim
            );
          }
          break;
      }

      return res;
    });
  }

  fetchWirelessUsage(
    req: operations.FetchWirelessUsageRequest,
    security: operations.FetchWirelessUsageSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchWirelessUsageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchWirelessUsageRequest(req);
    }

    let baseURL: string = operations.FetchWirelessUsageServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/wireless/Sims/{SimSid}/Usage",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchWirelessUsageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchWirelessUsageResponse =
        new operations.FetchWirelessUsageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessSimUsage = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessSimUsage
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Certificate credentials belonging to the Fleet.
   */
  listDeployedDevicesCertificate(
    req: operations.ListDeployedDevicesCertificateRequest,
    security: operations.ListDeployedDevicesCertificateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeployedDevicesCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeployedDevicesCertificateRequest(req);
    }

    let baseURL: string =
      operations.ListDeployedDevicesCertificateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Certificates",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeployedDevicesCertificateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeployedDevicesCertificateResponse =
        new operations.ListDeployedDevicesCertificateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeployedDevicesCertificateResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeployedDevicesCertificateListDeployedDevicesCertificateResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Deployments belonging to the Fleet.
   */
  listDeployedDevicesDeployment(
    req: operations.ListDeployedDevicesDeploymentRequest,
    security: operations.ListDeployedDevicesDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeployedDevicesDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeployedDevicesDeploymentRequest(req);
    }

    let baseURL: string = operations.ListDeployedDevicesDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Deployments",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeployedDevicesDeploymentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeployedDevicesDeploymentResponse =
        new operations.ListDeployedDevicesDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeployedDevicesDeploymentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeployedDevicesDeploymentListDeployedDevicesDeploymentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Devices belonging to the Fleet.
   */
  listDeployedDevicesDevice(
    req: operations.ListDeployedDevicesDeviceRequest,
    security: operations.ListDeployedDevicesDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeployedDevicesDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeployedDevicesDeviceRequest(req);
    }

    let baseURL: string = operations.ListDeployedDevicesDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Devices",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeployedDevicesDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeployedDevicesDeviceResponse =
        new operations.ListDeployedDevicesDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeployedDevicesDeviceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeployedDevicesDeviceListDeployedDevicesDeviceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Fleets belonging to your account.
   */
  listDeployedDevicesFleet(
    req: operations.ListDeployedDevicesFleetRequest,
    security: operations.ListDeployedDevicesFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeployedDevicesFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeployedDevicesFleetRequest(req);
    }

    let baseURL: string = operations.ListDeployedDevicesFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/DeployedDevices/Fleets";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeployedDevicesFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeployedDevicesFleetResponse =
        new operations.ListDeployedDevicesFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeployedDevicesFleetResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeployedDevicesFleetListDeployedDevicesFleetResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Keys credentials belonging to the Fleet.
   */
  listDeployedDevicesKey(
    req: operations.ListDeployedDevicesKeyRequest,
    security: operations.ListDeployedDevicesKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDeployedDevicesKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDeployedDevicesKeyRequest(req);
    }

    let baseURL: string = operations.ListDeployedDevicesKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Keys",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListDeployedDevicesKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDeployedDevicesKeyResponse =
        new operations.ListDeployedDevicesKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeployedDevicesKeyResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListDeployedDevicesKeyListDeployedDevicesKeyResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of AuthorizationDocuments belonging to the account initiating the request.
   */
  listHostedNumbersAuthorizationDocument(
    req: operations.ListHostedNumbersAuthorizationDocumentRequest,
    security: operations.ListHostedNumbersAuthorizationDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListHostedNumbersAuthorizationDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListHostedNumbersAuthorizationDocumentRequest(req);
    }

    let baseURL: string =
      operations.ListHostedNumbersAuthorizationDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/HostedNumbers/AuthorizationDocuments";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListHostedNumbersAuthorizationDocumentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListHostedNumbersAuthorizationDocumentResponse =
        new operations.ListHostedNumbersAuthorizationDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listHostedNumbersAuthorizationDocumentResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListHostedNumbersAuthorizationDocumentListHostedNumbersAuthorizationDocumentResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of dependent HostedNumberOrders belonging to the AuthorizationDocument.
   */
  listHostedNumbersDependentHostedNumberOrder(
    req: operations.ListHostedNumbersDependentHostedNumberOrderRequest,
    security: operations.ListHostedNumbersDependentHostedNumberOrderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListHostedNumbersDependentHostedNumberOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListHostedNumbersDependentHostedNumberOrderRequest(
        req
      );
    }

    let baseURL: string =
      operations.ListHostedNumbersDependentHostedNumberOrderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/HostedNumbers/AuthorizationDocuments/{SigningDocumentSid}/DependentHostedNumberOrders",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ListHostedNumbersDependentHostedNumberOrderSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListHostedNumbersDependentHostedNumberOrderResponse =
        new operations.ListHostedNumbersDependentHostedNumberOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listHostedNumbersDependentHostedNumberOrderResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListHostedNumbersDependentHostedNumberOrderListHostedNumbersDependentHostedNumberOrderResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of HostedNumberOrders belonging to the account initiating the request.
   */
  listHostedNumbersHostedNumberOrder(
    req: operations.ListHostedNumbersHostedNumberOrderRequest,
    security: operations.ListHostedNumbersHostedNumberOrderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListHostedNumbersHostedNumberOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListHostedNumbersHostedNumberOrderRequest(req);
    }

    let baseURL: string =
      operations.ListHostedNumbersHostedNumberOrderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/HostedNumbers/HostedNumberOrders";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListHostedNumbersHostedNumberOrderSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListHostedNumbersHostedNumberOrderResponse =
        new operations.ListHostedNumbersHostedNumberOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listHostedNumbersHostedNumberOrderResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListHostedNumbersHostedNumberOrderListHostedNumbersHostedNumberOrderResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Add-ons currently available to be installed.
   */
  listMarketplaceAvailableAddOn(
    req: operations.ListMarketplaceAvailableAddOnRequest,
    security: operations.ListMarketplaceAvailableAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMarketplaceAvailableAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMarketplaceAvailableAddOnRequest(req);
    }

    let baseURL: string = operations.ListMarketplaceAvailableAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/marketplace/AvailableAddOns";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMarketplaceAvailableAddOnSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMarketplaceAvailableAddOnResponse =
        new operations.ListMarketplaceAvailableAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMarketplaceAvailableAddOnResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMarketplaceAvailableAddOnListMarketplaceAvailableAddOnResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Extensions for the Available Add-on.
   */
  listMarketplaceAvailableAddOnExtension(
    req: operations.ListMarketplaceAvailableAddOnExtensionRequest,
    security: operations.ListMarketplaceAvailableAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMarketplaceAvailableAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMarketplaceAvailableAddOnExtensionRequest(req);
    }

    let baseURL: string =
      operations.ListMarketplaceAvailableAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/AvailableAddOns/{AvailableAddOnSid}/Extensions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMarketplaceAvailableAddOnExtensionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMarketplaceAvailableAddOnExtensionResponse =
        new operations.ListMarketplaceAvailableAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMarketplaceAvailableAddOnExtensionResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListMarketplaceAvailableAddOnExtensionListMarketplaceAvailableAddOnExtensionResponse
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Add-ons currently installed on this Account.
   */
  listMarketplaceInstalledAddOn(
    req: operations.ListMarketplaceInstalledAddOnRequest,
    security: operations.ListMarketplaceInstalledAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMarketplaceInstalledAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMarketplaceInstalledAddOnRequest(req);
    }

    let baseURL: string = operations.ListMarketplaceInstalledAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string =
      baseURL.replace(/\/$/, "") + "/marketplace/InstalledAddOns";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMarketplaceInstalledAddOnSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMarketplaceInstalledAddOnResponse =
        new operations.ListMarketplaceInstalledAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMarketplaceInstalledAddOnResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListMarketplaceInstalledAddOnListMarketplaceInstalledAddOnResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of Extensions for the Installed Add-on.
   */
  listMarketplaceInstalledAddOnExtension(
    req: operations.ListMarketplaceInstalledAddOnExtensionRequest,
    security: operations.ListMarketplaceInstalledAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMarketplaceInstalledAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMarketplaceInstalledAddOnExtensionRequest(req);
    }

    let baseURL: string =
      operations.ListMarketplaceInstalledAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListMarketplaceInstalledAddOnExtensionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMarketplaceInstalledAddOnExtensionResponse =
        new operations.ListMarketplaceInstalledAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMarketplaceInstalledAddOnExtensionResponse =
              utils.objectToClass(
                httpRes?.data,
                operations.ListMarketplaceInstalledAddOnExtensionListMarketplaceInstalledAddOnExtensionResponse
              );
          }
          break;
      }

      return res;
    });
  }

  listSyncDocument(
    req: operations.ListSyncDocumentRequest,
    security: operations.ListSyncDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncDocumentRequest(req);
    }

    let baseURL: string = operations.ListSyncDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncDocumentResponse =
        new operations.ListSyncDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncDocumentResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncDocumentListSyncDocumentResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Permissions applying to a Sync Document.
   */
  listSyncDocumentPermission(
    req: operations.ListSyncDocumentPermissionRequest,
    security: operations.ListSyncDocumentPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncDocumentPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncDocumentPermissionRequest(req);
    }

    let baseURL: string = operations.ListSyncDocumentPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncDocumentPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncDocumentPermissionResponse =
        new operations.ListSyncDocumentPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncDocumentPermissionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncDocumentPermissionListSyncDocumentPermissionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSyncService(
    req: operations.ListSyncServiceRequest,
    security: operations.ListSyncServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncServiceRequest(req);
    }

    let baseURL: string = operations.ListSyncServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/Sync/Services";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncServiceResponse =
        new operations.ListSyncServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncServiceResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncServiceListSyncServiceResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSyncSyncList(
    req: operations.ListSyncSyncListRequest,
    security: operations.ListSyncSyncListSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncSyncListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncSyncListRequest(req);
    }

    let baseURL: string = operations.ListSyncSyncListServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncSyncListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncSyncListResponse =
        new operations.ListSyncSyncListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncSyncListResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncSyncListListSyncSyncListResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSyncSyncListItem(
    req: operations.ListSyncSyncListItemRequest,
    security: operations.ListSyncSyncListItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncSyncListItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncSyncListItemRequest(req);
    }

    let baseURL: string = operations.ListSyncSyncListItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncSyncListItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncSyncListItemResponse =
        new operations.ListSyncSyncListItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncSyncListItemResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncSyncListItemListSyncSyncListItemResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Permissions applying to a Sync List.
   */
  listSyncSyncListPermission(
    req: operations.ListSyncSyncListPermissionRequest,
    security: operations.ListSyncSyncListPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncSyncListPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncSyncListPermissionRequest(req);
    }

    let baseURL: string = operations.ListSyncSyncListPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncSyncListPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncSyncListPermissionResponse =
        new operations.ListSyncSyncListPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncSyncListPermissionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncSyncListPermissionListSyncSyncListPermissionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSyncSyncMap(
    req: operations.ListSyncSyncMapRequest,
    security: operations.ListSyncSyncMapSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncSyncMapResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncSyncMapRequest(req);
    }

    let baseURL: string = operations.ListSyncSyncMapServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncSyncMapSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncSyncMapResponse =
        new operations.ListSyncSyncMapResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncSyncMapResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncSyncMapListSyncSyncMapResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listSyncSyncMapItem(
    req: operations.ListSyncSyncMapItemRequest,
    security: operations.ListSyncSyncMapItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncSyncMapItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncSyncMapItemRequest(req);
    }

    let baseURL: string = operations.ListSyncSyncMapItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncSyncMapItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncSyncMapItemResponse =
        new operations.ListSyncSyncMapItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncSyncMapItemResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncSyncMapItemListSyncSyncMapItemResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Permissions applying to a Sync Map.
   */
  listSyncSyncMapPermission(
    req: operations.ListSyncSyncMapPermissionRequest,
    security: operations.ListSyncSyncMapPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSyncSyncMapPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSyncSyncMapPermissionRequest(req);
    }

    let baseURL: string = operations.ListSyncSyncMapPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSyncSyncMapPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSyncSyncMapPermissionResponse =
        new operations.ListSyncSyncMapPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSyncSyncMapPermissionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListSyncSyncMapPermissionListSyncSyncMapPermissionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandAssistant(
    req: operations.ListUnderstandAssistantRequest,
    security: operations.ListUnderstandAssistantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandAssistantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandAssistantRequest(req);
    }

    let baseURL: string = operations.ListUnderstandAssistantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/understand/Assistants";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandAssistantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandAssistantResponse =
        new operations.ListUnderstandAssistantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandAssistantResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandAssistantListUnderstandAssistantResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandField(
    req: operations.ListUnderstandFieldRequest,
    security: operations.ListUnderstandFieldSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandFieldResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandFieldRequest(req);
    }

    let baseURL: string = operations.ListUnderstandFieldServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandFieldSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandFieldResponse =
        new operations.ListUnderstandFieldResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandFieldResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandFieldListUnderstandFieldResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandFieldType(
    req: operations.ListUnderstandFieldTypeRequest,
    security: operations.ListUnderstandFieldTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandFieldTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandFieldTypeRequest(req);
    }

    let baseURL: string = operations.ListUnderstandFieldTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandFieldTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandFieldTypeResponse =
        new operations.ListUnderstandFieldTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandFieldTypeResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandFieldTypeListUnderstandFieldTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandFieldValue(
    req: operations.ListUnderstandFieldValueRequest,
    security: operations.ListUnderstandFieldValueSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandFieldValueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandFieldValueRequest(req);
    }

    let baseURL: string = operations.ListUnderstandFieldValueServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandFieldValueSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandFieldValueResponse =
        new operations.ListUnderstandFieldValueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandFieldValueResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandFieldValueListUnderstandFieldValueResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandModelBuild(
    req: operations.ListUnderstandModelBuildRequest,
    security: operations.ListUnderstandModelBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandModelBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandModelBuildRequest(req);
    }

    let baseURL: string = operations.ListUnderstandModelBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/ModelBuilds",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandModelBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandModelBuildResponse =
        new operations.ListUnderstandModelBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandModelBuildResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandModelBuildListUnderstandModelBuildResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandQuery(
    req: operations.ListUnderstandQueryRequest,
    security: operations.ListUnderstandQuerySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandQueryRequest(req);
    }

    let baseURL: string = operations.ListUnderstandQueryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Queries",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandQuerySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandQueryResponse =
        new operations.ListUnderstandQueryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandQueryResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandQueryListUnderstandQueryResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandSample(
    req: operations.ListUnderstandSampleRequest,
    security: operations.ListUnderstandSampleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandSampleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandSampleRequest(req);
    }

    let baseURL: string = operations.ListUnderstandSampleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandSampleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandSampleResponse =
        new operations.ListUnderstandSampleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandSampleResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandSampleListUnderstandSampleResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listUnderstandTask(
    req: operations.ListUnderstandTaskRequest,
    security: operations.ListUnderstandTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListUnderstandTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListUnderstandTaskRequest(req);
    }

    let baseURL: string = operations.ListUnderstandTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListUnderstandTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListUnderstandTaskResponse =
        new operations.ListUnderstandTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUnderstandTaskResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListUnderstandTaskListUnderstandTaskResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWirelessCommand(
    req: operations.ListWirelessCommandRequest,
    security: operations.ListWirelessCommandSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWirelessCommandResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWirelessCommandRequest(req);
    }

    let baseURL: string = operations.ListWirelessCommandServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/wireless/Commands";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWirelessCommandSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWirelessCommandResponse =
        new operations.ListWirelessCommandResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWirelessCommandResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWirelessCommandListWirelessCommandResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWirelessRatePlan(
    req: operations.ListWirelessRatePlanRequest,
    security: operations.ListWirelessRatePlanSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWirelessRatePlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWirelessRatePlanRequest(req);
    }

    let baseURL: string = operations.ListWirelessRatePlanServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/wireless/RatePlans";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWirelessRatePlanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWirelessRatePlanResponse =
        new operations.ListWirelessRatePlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWirelessRatePlanResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWirelessRatePlanListWirelessRatePlanResponse
            );
          }
          break;
      }

      return res;
    });
  }

  listWirelessSim(
    req: operations.ListWirelessSimRequest,
    security: operations.ListWirelessSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWirelessSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWirelessSimRequest(req);
    }

    let baseURL: string = operations.ListWirelessSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/wireless/Sims";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWirelessSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWirelessSimResponse =
        new operations.ListWirelessSimResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWirelessSimResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListWirelessSimListWirelessSimResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the given properties of a specific Certificate credential in the Fleet, giving it a friendly name or assigning to a Device.
   */
  updateDeployedDevicesCertificate(
    req: operations.UpdateDeployedDevicesCertificateRequest,
    security: operations.UpdateDeployedDevicesCertificateSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeployedDevicesCertificateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeployedDevicesCertificateRequest(req);
    }

    let baseURL: string =
      operations.UpdateDeployedDevicesCertificateServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Certificates/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeployedDevicesCertificateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeployedDevicesCertificateResponse =
        new operations.UpdateDeployedDevicesCertificateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetCertificate = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetCertificate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the given properties of a specific Deployment credential in the Fleet, giving it a friendly name or linking to a specific Twilio Sync service instance.
   */
  updateDeployedDevicesDeployment(
    req: operations.UpdateDeployedDevicesDeploymentRequest,
    security: operations.UpdateDeployedDevicesDeploymentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeployedDevicesDeploymentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeployedDevicesDeploymentRequest(req);
    }

    let baseURL: string =
      operations.UpdateDeployedDevicesDeploymentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Deployments/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeployedDevicesDeploymentSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeployedDevicesDeploymentResponse =
        new operations.UpdateDeployedDevicesDeploymentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetDeployment = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetDeployment
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the given properties of a specific Device in the Fleet, giving it a friendly name, assigning to a Deployment, or a human identity.
   */
  updateDeployedDevicesDevice(
    req: operations.UpdateDeployedDevicesDeviceRequest,
    security: operations.UpdateDeployedDevicesDeviceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeployedDevicesDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeployedDevicesDeviceRequest(req);
    }

    let baseURL: string = operations.UpdateDeployedDevicesDeviceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Devices/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeployedDevicesDeviceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeployedDevicesDeviceResponse =
        new operations.UpdateDeployedDevicesDeviceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetDevice = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetDevice
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the friendly name property of a specific Fleet in your account.
   */
  updateDeployedDevicesFleet(
    req: operations.UpdateDeployedDevicesFleetRequest,
    security: operations.UpdateDeployedDevicesFleetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeployedDevicesFleetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeployedDevicesFleetRequest(req);
    }

    let baseURL: string = operations.UpdateDeployedDevicesFleetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeployedDevicesFleetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeployedDevicesFleetResponse =
        new operations.UpdateDeployedDevicesFleetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleet = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleet
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the given properties of a specific Key credential in the Fleet, giving it a friendly name or assigning to a Device.
   */
  updateDeployedDevicesKey(
    req: operations.UpdateDeployedDevicesKeyRequest,
    security: operations.UpdateDeployedDevicesKeySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeployedDevicesKeyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeployedDevicesKeyRequest(req);
    }

    let baseURL: string = operations.UpdateDeployedDevicesKeyServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/DeployedDevices/Fleets/{FleetSid}/Keys/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateDeployedDevicesKeySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeployedDevicesKeyResponse =
        new operations.UpdateDeployedDevicesKeyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewDeployedDevicesFleetKey = utils.objectToClass(
              httpRes?.data,
              shared.PreviewDeployedDevicesFleetKey
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a specific AuthorizationDocument.
   */
  updateHostedNumbersAuthorizationDocument(
    req: operations.UpdateHostedNumbersAuthorizationDocumentRequest,
    security: operations.UpdateHostedNumbersAuthorizationDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateHostedNumbersAuthorizationDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateHostedNumbersAuthorizationDocumentRequest(req);
    }

    let baseURL: string =
      operations.UpdateHostedNumbersAuthorizationDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/HostedNumbers/AuthorizationDocuments/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.UpdateHostedNumbersAuthorizationDocumentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateHostedNumbersAuthorizationDocumentResponse =
        new operations.UpdateHostedNumbersAuthorizationDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewHostedNumbersAuthorizationDocument = utils.objectToClass(
              httpRes?.data,
              shared.PreviewHostedNumbersAuthorizationDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a specific HostedNumberOrder.
   */
  updateHostedNumbersHostedNumberOrder(
    req: operations.UpdateHostedNumbersHostedNumberOrderRequest,
    security: operations.UpdateHostedNumbersHostedNumberOrderSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateHostedNumbersHostedNumberOrderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateHostedNumbersHostedNumberOrderRequest(req);
    }

    let baseURL: string =
      operations.UpdateHostedNumbersHostedNumberOrderServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/HostedNumbers/HostedNumberOrders/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateHostedNumbersHostedNumberOrderSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateHostedNumbersHostedNumberOrderResponse =
        new operations.UpdateHostedNumbersHostedNumberOrderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewHostedNumbersHostedNumberOrder = utils.objectToClass(
              httpRes?.data,
              shared.PreviewHostedNumbersHostedNumberOrder
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Add-on installation for the Account specified.
   */
  updateMarketplaceInstalledAddOn(
    req: operations.UpdateMarketplaceInstalledAddOnRequest,
    security: operations.UpdateMarketplaceInstalledAddOnSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateMarketplaceInstalledAddOnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateMarketplaceInstalledAddOnRequest(req);
    }

    let baseURL: string =
      operations.UpdateMarketplaceInstalledAddOnServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/InstalledAddOns/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateMarketplaceInstalledAddOnSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateMarketplaceInstalledAddOnResponse =
        new operations.UpdateMarketplaceInstalledAddOnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceInstalledAddOn = utils.objectToClass(
              httpRes?.data,
              shared.PreviewMarketplaceInstalledAddOn
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an Extension for an Add-on installation.
   */
  updateMarketplaceInstalledAddOnExtension(
    req: operations.UpdateMarketplaceInstalledAddOnExtensionRequest,
    security: operations.UpdateMarketplaceInstalledAddOnExtensionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateMarketplaceInstalledAddOnExtensionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateMarketplaceInstalledAddOnExtensionRequest(req);
    }

    let baseURL: string =
      operations.UpdateMarketplaceInstalledAddOnExtensionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/marketplace/InstalledAddOns/{InstalledAddOnSid}/Extensions/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.UpdateMarketplaceInstalledAddOnExtensionSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateMarketplaceInstalledAddOnExtensionResponse =
        new operations.UpdateMarketplaceInstalledAddOnExtensionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewMarketplaceInstalledAddOnInstalledAddOnExtension =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewMarketplaceInstalledAddOnInstalledAddOnExtension
              );
          }
          break;
      }

      return res;
    });
  }

  updateSyncDocument(
    req: operations.UpdateSyncDocumentRequest,
    security: operations.UpdateSyncDocumentSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncDocumentRequest(req);
    }

    let baseURL: string = operations.UpdateSyncDocumentServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncDocumentSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncDocumentResponse =
        new operations.UpdateSyncDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceDocument = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceDocument
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an identity's access to a specific Sync Document.
   */
  updateSyncDocumentPermission(
    req: operations.UpdateSyncDocumentPermissionRequest,
    security: operations.UpdateSyncDocumentPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncDocumentPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncDocumentPermissionRequest(req);
    }

    let baseURL: string = operations.UpdateSyncDocumentPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncDocumentPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncDocumentPermissionResponse =
        new operations.UpdateSyncDocumentPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceDocumentDocumentPermission =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewSyncServiceDocumentDocumentPermission
              );
          }
          break;
      }

      return res;
    });
  }

  updateSyncService(
    req: operations.UpdateSyncServiceRequest,
    security: operations.UpdateSyncServiceSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncServiceRequest(req);
    }

    let baseURL: string = operations.UpdateSyncServiceServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/Sync/Services/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncServiceSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncServiceResponse =
        new operations.UpdateSyncServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncService = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncService
            );
          }
          break;
      }

      return res;
    });
  }

  updateSyncSyncListItem(
    req: operations.UpdateSyncSyncListItemRequest,
    security: operations.UpdateSyncSyncListItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncSyncListItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncSyncListItemRequest(req);
    }

    let baseURL: string = operations.UpdateSyncSyncListItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncSyncListItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncSyncListItemResponse =
        new operations.UpdateSyncSyncListItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncListSyncListItem = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncListSyncListItem
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an identity's access to a specific Sync List.
   */
  updateSyncSyncListPermission(
    req: operations.UpdateSyncSyncListPermissionRequest,
    security: operations.UpdateSyncSyncListPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncSyncListPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncSyncListPermissionRequest(req);
    }

    let baseURL: string = operations.UpdateSyncSyncListPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncSyncListPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncSyncListPermissionResponse =
        new operations.UpdateSyncSyncListPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncListSyncListPermission =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewSyncServiceSyncListSyncListPermission
              );
          }
          break;
      }

      return res;
    });
  }

  updateSyncSyncMapItem(
    req: operations.UpdateSyncSyncMapItemRequest,
    security: operations.UpdateSyncSyncMapItemSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncSyncMapItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncSyncMapItemRequest(req);
    }

    let baseURL: string = operations.UpdateSyncSyncMapItemServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncSyncMapItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncSyncMapItemResponse =
        new operations.UpdateSyncSyncMapItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMapSyncMapItem = utils.objectToClass(
              httpRes?.data,
              shared.PreviewSyncServiceSyncMapSyncMapItem
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an identity's access to a specific Sync Map.
   */
  updateSyncSyncMapPermission(
    req: operations.UpdateSyncSyncMapPermissionRequest,
    security: operations.UpdateSyncSyncMapPermissionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSyncSyncMapPermissionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSyncSyncMapPermissionRequest(req);
    }

    let baseURL: string = operations.UpdateSyncSyncMapPermissionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/Sync/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateSyncSyncMapPermissionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSyncSyncMapPermissionResponse =
        new operations.UpdateSyncSyncMapPermissionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewSyncServiceSyncMapSyncMapPermission =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewSyncServiceSyncMapSyncMapPermission
              );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandAssistant(
    req: operations.UpdateUnderstandAssistantRequest,
    security: operations.UpdateUnderstandAssistantSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandAssistantResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandAssistantRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandAssistantServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandAssistantSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandAssistantResponse =
        new operations.UpdateUnderstandAssistantResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistant = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistant
            );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandAssistantFallbackActions(
    req: operations.UpdateUnderstandAssistantFallbackActionsRequest,
    security: operations.UpdateUnderstandAssistantFallbackActionsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandAssistantFallbackActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandAssistantFallbackActionsRequest(req);
    }

    let baseURL: string =
      operations.UpdateUnderstandAssistantFallbackActionsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FallbackActions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.UpdateUnderstandAssistantFallbackActionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandAssistantFallbackActionsResponse =
        new operations.UpdateUnderstandAssistantFallbackActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantAssistantFallbackActions =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantAssistantFallbackActions
              );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandAssistantInitiationActions(
    req: operations.UpdateUnderstandAssistantInitiationActionsRequest,
    security: operations.UpdateUnderstandAssistantInitiationActionsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandAssistantInitiationActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandAssistantInitiationActionsRequest(
        req
      );
    }

    let baseURL: string =
      operations.UpdateUnderstandAssistantInitiationActionsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/InitiationActions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.UpdateUnderstandAssistantInitiationActionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandAssistantInitiationActionsResponse =
        new operations.UpdateUnderstandAssistantInitiationActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantAssistantInitiationActions =
              utils.objectToClass(
                httpRes?.data,
                shared.PreviewUnderstandAssistantAssistantInitiationActions
              );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandFieldType(
    req: operations.UpdateUnderstandFieldTypeRequest,
    security: operations.UpdateUnderstandFieldTypeSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandFieldTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandFieldTypeRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandFieldTypeServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/FieldTypes/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandFieldTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandFieldTypeResponse =
        new operations.UpdateUnderstandFieldTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantFieldType = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantFieldType
            );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandModelBuild(
    req: operations.UpdateUnderstandModelBuildRequest,
    security: operations.UpdateUnderstandModelBuildSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandModelBuildResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandModelBuildRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandModelBuildServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/ModelBuilds/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandModelBuildSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandModelBuildResponse =
        new operations.UpdateUnderstandModelBuildResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantModelBuild = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantModelBuild
            );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandQuery(
    req: operations.UpdateUnderstandQueryRequest,
    security: operations.UpdateUnderstandQuerySecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandQueryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandQueryRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandQueryServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Queries/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandQuerySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandQueryResponse =
        new operations.UpdateUnderstandQueryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantQuery = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantQuery
            );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandSample(
    req: operations.UpdateUnderstandSampleRequest,
    security: operations.UpdateUnderstandSampleSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandSampleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandSampleRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandSampleServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandSampleSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandSampleResponse =
        new operations.UpdateUnderstandSampleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskSample = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskSample
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the style sheet for an assistant identified by {AssistantSid} or {AssistantUniqueName}.
   */
  updateUnderstandStyleSheet(
    req: operations.UpdateUnderstandStyleSheetRequest,
    security: operations.UpdateUnderstandStyleSheetSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandStyleSheetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandStyleSheetRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandStyleSheetServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/StyleSheet",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandStyleSheetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandStyleSheetResponse =
        new operations.UpdateUnderstandStyleSheetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantStyleSheet = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantStyleSheet
            );
          }
          break;
      }

      return res;
    });
  }

  updateUnderstandTask(
    req: operations.UpdateUnderstandTaskRequest,
    security: operations.UpdateUnderstandTaskSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandTaskResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandTaskRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandTaskServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandTaskSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandTaskResponse =
        new operations.UpdateUnderstandTaskResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTask = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTask
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the actions of an Task identified by {TaskSid} or {TaskUniqueName}.
   */
  updateUnderstandTaskActions(
    req: operations.UpdateUnderstandTaskActionsRequest,
    security: operations.UpdateUnderstandTaskActionsSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUnderstandTaskActionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUnderstandTaskActionsRequest(req);
    }

    let baseURL: string = operations.UpdateUnderstandTaskActionsServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/understand/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateUnderstandTaskActionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUnderstandTaskActionsResponse =
        new operations.UpdateUnderstandTaskActionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewUnderstandAssistantTaskTaskActions = utils.objectToClass(
              httpRes?.data,
              shared.PreviewUnderstandAssistantTaskTaskActions
            );
          }
          break;
      }

      return res;
    });
  }

  updateWirelessRatePlan(
    req: operations.UpdateWirelessRatePlanRequest,
    security: operations.UpdateWirelessRatePlanSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWirelessRatePlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWirelessRatePlanRequest(req);
    }

    let baseURL: string = operations.UpdateWirelessRatePlanServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/wireless/RatePlans/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWirelessRatePlanSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWirelessRatePlanResponse =
        new operations.UpdateWirelessRatePlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessRatePlan = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessRatePlan
            );
          }
          break;
      }

      return res;
    });
  }

  updateWirelessSim(
    req: operations.UpdateWirelessSimRequest,
    security: operations.UpdateWirelessSimSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWirelessSimResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWirelessSimRequest(req);
    }

    let baseURL: string = operations.UpdateWirelessSimServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/wireless/Sims/{Sid}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWirelessSimSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWirelessSimResponse =
        new operations.UpdateWirelessSimResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.previewWirelessSim = utils.objectToClass(
              httpRes?.data,
              shared.PreviewWirelessSim
            );
          }
          break;
      }

      return res;
    });
  }
}
