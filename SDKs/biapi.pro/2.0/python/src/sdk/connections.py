"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Connections:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_connections_id_connection_sources_id_source_(self, request: operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest) -> operations.DeleteConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Disable a connection source
        This will make it so the specified source will not be synchronized anymore.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def delete_users_id_user_connections(self, request: operations.DeleteUsersIDUserConnectionsRequest) -> operations.DeleteUsersIDUserConnectionsResponse:
        r"""Delete all connections"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def delete_users_id_user_connections_id_connection_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionResponse:
        r"""Delete a connection.
        This endpoint deletes a connection and all related accounts and transactions.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def delete_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Disable a connection source
        This will make it so the specified source will not be synchronized anymore.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def get_banks(self, request: operations.GetBanksRequest) -> operations.GetBanksResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/banks'
        
        query_params = utils.get_query_params(operations.GetBanksRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanks200ApplicationJSON])
                res.get_banks_200_application_json_object = out

        return res

    def get_banks_id_bank_(self, request: operations.GetBanksIDBankRequest) -> operations.GetBanksIDBankResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDBankRequest, base_url, '/banks/{id_bank}', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDBankRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDBankResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_banks_id_connector_connections(self, request: operations.GetBanksIDConnectorConnectionsRequest) -> operations.GetBanksIDConnectorConnectionsResponse:
        r"""Get a subset of id_connection for a given bank. Different selection methode are possible
        By default, it selects a set of 3 connections with the 'diversity' method<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorConnectionsRequest, base_url, '/banks/{id_connector}/connections', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorConnections200ApplicationJSON])
                res.get_banks_id_connector_connections_200_application_json_object = out

        return res

    def get_banks_id_connector_sources(self, request: operations.GetBanksIDConnectorSourcesRequest) -> operations.GetBanksIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesRequest, base_url, '/banks/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorSources200ApplicationJSON])
                res.get_banks_id_connector_sources_200_application_json_object = out

        return res

    def get_banks_id_connector_sources_id_connector_source_fields(self, request: operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsRequest) -> operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsResponse:
        r"""Get fields specific to a domain and a source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsRequest, base_url, '/banks/{id_connector}/sources/{id_connector_source}/fields', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorSourcesIDConnectorSourceFields200ApplicationJSON])
                res.get_banks_id_connector_sources_id_connector_source_fields_200_application_json_object = out

        return res

    def get_banks_id_connector_sources_id_source_(self, request: operations.GetBanksIDConnectorSourcesIDSourceRequest) -> operations.GetBanksIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesIDSourceRequest, base_url, '/banks/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_connections(self, request: operations.GetConnectionsRequest) -> operations.GetConnectionsResponse:
        r"""Get connections without a user"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connections'
        
        query_params = utils.get_query_params(operations.GetConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnections200ApplicationJSON])
                res.get_connections_200_application_json_object = out

        return res

    def get_connections_id_connection_logs(self, request: operations.GetConnectionsIDConnectionLogsRequest) -> operations.GetConnectionsIDConnectionLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectionsIDConnectionLogsRequest, base_url, '/connections/{id_connection}/logs', request)
        
        query_params = utils.get_query_params(operations.GetConnectionsIDConnectionLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsIDConnectionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectionsIDConnectionLogs200ApplicationJSON])
                res.get_connections_id_connection_logs_200_application_json_object = out

        return res

    def get_connections_id_connection_sources(self, request: operations.GetConnectionsIDConnectionSourcesRequest) -> operations.GetConnectionsIDConnectionSourcesResponse:
        r"""Get connection sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectionsIDConnectionSourcesRequest, base_url, '/connections/{id_connection}/sources', request)
        
        query_params = utils.get_query_params(operations.GetConnectionsIDConnectionSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsIDConnectionSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectionsIDConnectionSources200ApplicationJSON])
                res.get_connections_id_connection_sources_200_application_json_object = out

        return res

    def get_connectors(self, request: operations.GetConnectorsRequest) -> operations.GetConnectorsResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        query_params = utils.get_query_params(operations.GetConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectors200ApplicationJSON])
                res.get_connectors_200_application_json_object = out

        return res

    def get_connectors_id_connector_(self, request: operations.GetConnectorsIDConnectorRequest) -> operations.GetConnectorsIDConnectorResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorRequest, base_url, '/connectors/{id_connector}', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_connectors_id_connector_sources(self, request: operations.GetConnectorsIDConnectorSourcesRequest) -> operations.GetConnectorsIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesRequest, base_url, '/connectors/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorSources200ApplicationJSON])
                res.get_connectors_id_connector_sources_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources_id_connector_source_fields(self, request: operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsRequest) -> operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsResponse:
        r"""Get fields specific to a domain and a source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsRequest, base_url, '/connectors/{id_connector}/sources/{id_connector_source}/fields', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFields200ApplicationJSON])
                res.get_connectors_id_connector_sources_id_connector_source_fields_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources_id_source_(self, request: operations.GetConnectorsIDConnectorSourcesIDSourceRequest) -> operations.GetConnectorsIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesIDSourceRequest, base_url, '/connectors/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_logs(self, request: operations.GetLogsRequest) -> operations.GetLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/logs'
        
        query_params = utils.get_query_params(operations.GetLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetLogs200ApplicationJSON])
                res.get_logs_200_application_json_object = out

        return res

    def get_providers(self, request: operations.GetProvidersRequest) -> operations.GetProvidersResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/providers'
        
        query_params = utils.get_query_params(operations.GetProvidersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProviders200ApplicationJSON])
                res.get_providers_200_application_json_object = out

        return res

    def get_providers_id_connector_connections(self, request: operations.GetProvidersIDConnectorConnectionsRequest) -> operations.GetProvidersIDConnectorConnectionsResponse:
        r"""Get a random subset of provider's id_connection
        By default, it selects a set of 3 connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorConnectionsRequest, base_url, '/providers/{id_connector}/connections', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorConnections200ApplicationJSON])
                res.get_providers_id_connector_connections_200_application_json_object = out

        return res

    def get_providers_id_connector_sources(self, request: operations.GetProvidersIDConnectorSourcesRequest) -> operations.GetProvidersIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesRequest, base_url, '/providers/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorSources200ApplicationJSON])
                res.get_providers_id_connector_sources_200_application_json_object = out

        return res

    def get_providers_id_connector_sources_id_connector_source_fields(self, request: operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsRequest) -> operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsResponse:
        r"""Get fields specific to a domain and a source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsRequest, base_url, '/providers/{id_connector}/sources/{id_connector_source}/fields', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorSourcesIDConnectorSourceFields200ApplicationJSON])
                res.get_providers_id_connector_sources_id_connector_source_fields_200_application_json_object = out

        return res

    def get_providers_id_connector_sources_id_source_(self, request: operations.GetProvidersIDConnectorSourcesIDSourceRequest) -> operations.GetProvidersIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesIDSourceRequest, base_url, '/providers/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_providers_id_provider_(self, request: operations.GetProvidersIDProviderRequest) -> operations.GetProvidersIDProviderResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDProviderRequest, base_url, '/providers/{id_provider}', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDProviderRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDProviderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_users_id_user_connections(self, request: operations.GetUsersIDUserConnectionsRequest) -> operations.GetUsersIDUserConnectionsResponse:
        r"""Get connections"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnections200ApplicationJSON])
                res.get_users_id_user_connections_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_informations(self, request: operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionInformationsResponse:
        r"""Get connection additionnal informations
        <br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest, base_url, '/users/{id_user}/connections/{id_connection}/informations', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionInformationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionInformations200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_informations_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_logs(self, request: operations.GetUsersIDUserConnectionsIDConnectionLogsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionLogsRequest, base_url, '/users/{id_user}/connections/{id_connection}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionLogs200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_logs_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_sources(self, request: operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest) -> operations.GetUsersIDUserConnectionsIDConnectionSourcesResponse:
        r"""Get connection sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionSources200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_sources_200_application_json_object = out

        return res

    def get_users_id_user_logs(self, request: operations.GetUsersIDUserLogsRequest) -> operations.GetUsersIDUserLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserLogsRequest, base_url, '/users/{id_user}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserLogs200ApplicationJSON])
                res.get_users_id_user_logs_200_application_json_object = out

        return res

    def post_connections_id_connection_sources_id_source_(self, request: operations.PostConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PostConnectionsIDConnectionSourcesIDSourceResponse:
        r"""\\" 
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def post_connectors(self, request: operations.PostConnectorsRequest) -> operations.PostConnectorsResponse:
        r"""Request a new connector
        Send a request to add a new connector<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def post_users_id_user_connections(self, request: operations.PostUsersIDUserConnectionsRequest) -> operations.PostUsersIDUserConnectionsResponse:
        r"""Add a new connection.
        Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def post_users_id_user_connections_id_connection_(self, request: operations.PostUsersIDUserConnectionsIDConnectionRequest) -> operations.PostUsersIDUserConnectionsIDConnectionResponse:
        r"""Update a connection.
        Give new parameters to change on the configuration of this connection (for example \"password\").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code \"wrongpass\" or \"websiteUnavailable\".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>It's possible to execute the update/synchronization in the background with a query parameter. If done in background this endpoint will respond with data that is not yet updated. To obtain updated data, polling is required as the the data will be filled in the background.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def post_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""\\" 
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def put_connections_id_connection_sources_id_source_(self, request: operations.PutConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PutConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Update connection source
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def put_connectors_id_connector_sources(self, request: operations.PutConnectorsIDConnectorSourcesRequest) -> operations.PutConnectorsIDConnectorSourcesResponse:
        r"""Edit several connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorSourcesRequest, base_url, '/connectors/{id_connector}/sources', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def put_connectors_id_connector_sources_id_source_(self, request: operations.PutConnectorsIDConnectorSourcesIDSourceRequest) -> operations.PutConnectorsIDConnectorSourcesIDSourceResponse:
        r"""Edit the provided connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorSourcesIDSourceRequest, base_url, '/connectors/{id_connector}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def put_users_id_user_connections_id_connection_(self, request: operations.PutUsersIDUserConnectionsIDConnectionRequest) -> operations.PutUsersIDUserConnectionsIDConnectionResponse:
        r"""Force synchronisation of a connection.
        We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def put_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Update connection source
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    