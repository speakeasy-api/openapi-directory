/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Files {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a copy of a file and applies any requested updates with patch semantics. Folders cannot be copied.
   */
  driveFilesCopy(
    req: operations.DriveFilesCopyRequest,
    security: operations.DriveFilesCopySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesCopyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesCopyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{fileId}/copy", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "fileInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesCopySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesCopyResponse =
        new operations.DriveFilesCopyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a file.
   */
  driveFilesCreate(
    req: operations.DriveFilesCreateRequest,
    security: operations.DriveFilesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesCreateResponse =
        new operations.DriveFilesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Permanently deletes a file owned by the user without moving it to the trash. If the file belongs to a shared drive the user must be an organizer on the parent. If the target is a folder, all descendants owned by the user are also deleted.
   */
  driveFilesDelete(
    req: operations.DriveFilesDeleteRequest,
    security: operations.DriveFilesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{fileId}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesDeleteResponse =
        new operations.DriveFilesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Permanently deletes all of the user's trashed files.
   */
  driveFilesEmptyTrash(
    req: operations.DriveFilesEmptyTrashRequest,
    security: operations.DriveFilesEmptyTrashSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesEmptyTrashResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesEmptyTrashRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files/trash";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesEmptyTrashSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesEmptyTrashResponse =
        new operations.DriveFilesEmptyTrashResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Exports a Google Workspace document to the requested MIME type and returns exported byte content. Note that the exported content is limited to 10MB.
   */
  driveFilesExport(
    req: operations.DriveFilesExportRequest,
    security: operations.DriveFilesExportSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesExportResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesExportRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/files/{fileId}/export",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesExportSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesExportResponse =
        new operations.DriveFilesExportResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Generates a set of file IDs which can be provided in create or copy requests.
   */
  driveFilesGenerateIds(
    req: operations.DriveFilesGenerateIdsRequest,
    security: operations.DriveFilesGenerateIdsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesGenerateIdsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesGenerateIdsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files/generateIds";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesGenerateIdsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesGenerateIdsResponse =
        new operations.DriveFilesGenerateIdsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.generatedIds = utils.objectToClass(
              httpRes?.data,
              shared.GeneratedIds
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a file's metadata or content by ID.
   */
  driveFilesGet(
    req: operations.DriveFilesGetRequest,
    security: operations.DriveFilesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{fileId}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesGetResponse =
        new operations.DriveFilesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists or searches files.
   */
  driveFilesList(
    req: operations.DriveFilesListRequest,
    security: operations.DriveFilesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesListResponse =
        new operations.DriveFilesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fileList = utils.objectToClass(httpRes?.data, shared.FileList);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the labels on a file.
   */
  driveFilesListLabels(
    req: operations.DriveFilesListLabelsRequest,
    security: operations.DriveFilesListLabelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesListLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesListLabelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/files/{fileId}/listLabels",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesListLabelsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesListLabelsResponse =
        new operations.DriveFilesListLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labelList = utils.objectToClass(
              httpRes?.data,
              shared.LabelList
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies the set of labels on a file.
   */
  driveFilesModifyLabels(
    req: operations.DriveFilesModifyLabelsRequest,
    security: operations.DriveFilesModifyLabelsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesModifyLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesModifyLabelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/files/{fileId}/modifyLabels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "modifyLabelsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesModifyLabelsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesModifyLabelsResponse =
        new operations.DriveFilesModifyLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.modifyLabelsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ModifyLabelsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a file's metadata and/or content. When calling this method, only populate fields in the request that you want to modify. When updating fields, some fields might change automatically, such as modifiedDate. This method supports patch semantics.
   */
  driveFilesUpdate(
    req: operations.DriveFilesUpdateRequest,
    security: operations.DriveFilesUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{fileId}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesUpdateResponse =
        new operations.DriveFilesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Subscribes to changes to a file. While you can establish a channel for changes to a file on a shared drive, a change to a shared drive file won't create a notification.
   */
  driveFilesWatch(
    req: operations.DriveFilesWatchRequest,
    security: operations.DriveFilesWatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DriveFilesWatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DriveFilesWatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/files/{fileId}/watch",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "channel",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DriveFilesWatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DriveFilesWatchResponse =
        new operations.DriveFilesWatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.channel = utils.objectToClass(httpRes?.data, shared.Channel);
          }
          break;
      }

      return res;
    });
  }
}
