"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://flex-api.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_channel(self, request: operations.CreateChannelCreateChannelRequest, security: operations.CreateChannelSecurity, server_url: Optional[str] = None) -> operations.CreateChannelResponse:
        base_url = operations.CREATE_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Channels'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1Channel])
                res.flex_v1_channel = out

        return res

    def create_flex_flow(self, request: operations.CreateFlexFlowCreateFlexFlowRequest, security: operations.CreateFlexFlowSecurity, server_url: Optional[str] = None) -> operations.CreateFlexFlowResponse:
        base_url = operations.CREATE_FLEX_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/FlexFlows'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateFlexFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1FlexFlow])
                res.flex_v1_flex_flow = out

        return res

    def create_insights_assessments(self, request: operations.CreateInsightsAssessmentsRequest, security: operations.CreateInsightsAssessmentsSecurity, server_url: Optional[str] = None) -> operations.CreateInsightsAssessmentsResponse:
        r"""Add assessments against conversation to dynamo db. Used in assessments screen by user. Users can select the questionnaire and pick up answers for each and every question."""
        base_url = operations.CREATE_INSIGHTS_ASSESSMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Assessments'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInsightsAssessmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsAssessments])
                res.flex_v1_insights_assessments = out

        return res

    def create_insights_assessments_comment(self, request: operations.CreateInsightsAssessmentsCommentRequest, security: operations.CreateInsightsAssessmentsCommentSecurity, server_url: Optional[str] = None) -> operations.CreateInsightsAssessmentsCommentResponse:
        r"""To create a comment assessment for a conversation"""
        base_url = operations.CREATE_INSIGHTS_ASSESSMENTS_COMMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Assessments/Comments'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInsightsAssessmentsCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsAssessmentsComment])
                res.flex_v1_insights_assessments_comment = out

        return res

    def create_insights_questionnaires(self, request: operations.CreateInsightsQuestionnairesRequest, security: operations.CreateInsightsQuestionnairesSecurity, server_url: Optional[str] = None) -> operations.CreateInsightsQuestionnairesResponse:
        r"""To create a Questionnaire"""
        base_url = operations.CREATE_INSIGHTS_QUESTIONNAIRES_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Questionnaires'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInsightsQuestionnairesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnaires])
                res.flex_v1_insights_questionnaires = out

        return res

    def create_insights_questionnaires_category(self, request: operations.CreateInsightsQuestionnairesCategoryRequest, security: operations.CreateInsightsQuestionnairesCategorySecurity, server_url: Optional[str] = None) -> operations.CreateInsightsQuestionnairesCategoryResponse:
        r"""To create a category for Questions"""
        base_url = operations.CREATE_INSIGHTS_QUESTIONNAIRES_CATEGORY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Categories'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInsightsQuestionnairesCategoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnairesCategory])
                res.flex_v1_insights_questionnaires_category = out

        return res

    def create_insights_questionnaires_question(self, request: operations.CreateInsightsQuestionnairesQuestionRequest, security: operations.CreateInsightsQuestionnairesQuestionSecurity, server_url: Optional[str] = None) -> operations.CreateInsightsQuestionnairesQuestionResponse:
        r"""To create a question for a Category"""
        base_url = operations.CREATE_INSIGHTS_QUESTIONNAIRES_QUESTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Questions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInsightsQuestionnairesQuestionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnairesQuestion])
                res.flex_v1_insights_questionnaires_question = out

        return res

    def create_insights_session(self, request: operations.CreateInsightsSessionRequest, security: operations.CreateInsightsSessionSecurity, server_url: Optional[str] = None) -> operations.CreateInsightsSessionResponse:
        r"""To obtain session details for fetching reports and dashboards"""
        base_url = operations.CREATE_INSIGHTS_SESSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/Session'
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInsightsSessionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsSession])
                res.flex_v1_insights_session = out

        return res

    def create_interaction(self, request: operations.CreateInteractionCreateInteractionRequest, security: operations.CreateInteractionSecurity, server_url: Optional[str] = None) -> operations.CreateInteractionResponse:
        r"""Create a new Interaction."""
        base_url = operations.CREATE_INTERACTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Interactions'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInteractionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1Interaction])
                res.flex_v1_interaction = out

        return res

    def create_interaction_channel_invite(self, request: operations.CreateInteractionChannelInviteRequest, security: operations.CreateInteractionChannelInviteSecurity, server_url: Optional[str] = None) -> operations.CreateInteractionChannelInviteResponse:
        r"""Invite an Agent or a TaskQueue to a Channel."""
        base_url = operations.CREATE_INTERACTION_CHANNEL_INVITE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateInteractionChannelInviteRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Invites', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInteractionChannelInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InteractionInteractionChannelInteractionChannelInvite])
                res.flex_v1_interaction_interaction_channel_interaction_channel_invite = out

        return res

    def create_interaction_channel_participant(self, request: operations.CreateInteractionChannelParticipantRequest, security: operations.CreateInteractionChannelParticipantSecurity, server_url: Optional[str] = None) -> operations.CreateInteractionChannelParticipantResponse:
        r"""Add a Participant to a Channel."""
        base_url = operations.CREATE_INTERACTION_CHANNEL_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateInteractionChannelParticipantRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInteractionChannelParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InteractionInteractionChannelInteractionChannelParticipant])
                res.flex_v1_interaction_interaction_channel_interaction_channel_participant = out

        return res

    def create_web_channel(self, request: operations.CreateWebChannelCreateWebChannelRequest, security: operations.CreateWebChannelSecurity, server_url: Optional[str] = None) -> operations.CreateWebChannelResponse:
        base_url = operations.CREATE_WEB_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/WebChannels'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateWebChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1WebChannel])
                res.flex_v1_web_channel = out

        return res

    def delete_channel(self, request: operations.DeleteChannelRequest, security: operations.DeleteChannelSecurity, server_url: Optional[str] = None) -> operations.DeleteChannelResponse:
        base_url = operations.DELETE_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteChannelRequest, base_url, '/v1/Channels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_flex_flow(self, request: operations.DeleteFlexFlowRequest, security: operations.DeleteFlexFlowSecurity, server_url: Optional[str] = None) -> operations.DeleteFlexFlowResponse:
        base_url = operations.DELETE_FLEX_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteFlexFlowRequest, base_url, '/v1/FlexFlows/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteFlexFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_insights_questionnaires(self, request: operations.DeleteInsightsQuestionnairesRequest, security: operations.DeleteInsightsQuestionnairesSecurity, server_url: Optional[str] = None) -> operations.DeleteInsightsQuestionnairesResponse:
        r"""To delete the questionnaire"""
        base_url = operations.DELETE_INSIGHTS_QUESTIONNAIRES_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteInsightsQuestionnairesRequest, base_url, '/v1/Insights/QM/Questionnaires/{Id}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteInsightsQuestionnairesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_insights_questionnaires_category(self, request: operations.DeleteInsightsQuestionnairesCategoryRequest, security: operations.DeleteInsightsQuestionnairesCategorySecurity, server_url: Optional[str] = None) -> operations.DeleteInsightsQuestionnairesCategoryResponse:
        base_url = operations.DELETE_INSIGHTS_QUESTIONNAIRES_CATEGORY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteInsightsQuestionnairesCategoryRequest, base_url, '/v1/Insights/QM/Categories/{CategoryId}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteInsightsQuestionnairesCategoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_insights_questionnaires_question(self, request: operations.DeleteInsightsQuestionnairesQuestionRequest, security: operations.DeleteInsightsQuestionnairesQuestionSecurity, server_url: Optional[str] = None) -> operations.DeleteInsightsQuestionnairesQuestionResponse:
        base_url = operations.DELETE_INSIGHTS_QUESTIONNAIRES_QUESTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteInsightsQuestionnairesQuestionRequest, base_url, '/v1/Insights/QM/Questions/{QuestionId}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteInsightsQuestionnairesQuestionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_web_channel(self, request: operations.DeleteWebChannelRequest, security: operations.DeleteWebChannelSecurity, server_url: Optional[str] = None) -> operations.DeleteWebChannelResponse:
        base_url = operations.DELETE_WEB_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteWebChannelRequest, base_url, '/v1/WebChannels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteWebChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_channel(self, request: operations.FetchChannelRequest, security: operations.FetchChannelSecurity, server_url: Optional[str] = None) -> operations.FetchChannelResponse:
        base_url = operations.FETCH_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchChannelRequest, base_url, '/v1/Channels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1Channel])
                res.flex_v1_channel = out

        return res

    def fetch_configuration(self, request: operations.FetchConfigurationRequest, security: operations.FetchConfigurationSecurity, server_url: Optional[str] = None) -> operations.FetchConfigurationResponse:
        base_url = operations.FETCH_CONFIGURATION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Configuration'
        
        query_params = utils.get_query_params(operations.FetchConfigurationRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchConfigurationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1Configuration])
                res.flex_v1_configuration = out

        return res

    def fetch_flex_flow(self, request: operations.FetchFlexFlowRequest, security: operations.FetchFlexFlowSecurity, server_url: Optional[str] = None) -> operations.FetchFlexFlowResponse:
        base_url = operations.FETCH_FLEX_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFlexFlowRequest, base_url, '/v1/FlexFlows/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFlexFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1FlexFlow])
                res.flex_v1_flex_flow = out

        return res

    def fetch_insights_questionnaires(self, request: operations.FetchInsightsQuestionnairesRequest, security: operations.FetchInsightsQuestionnairesSecurity, server_url: Optional[str] = None) -> operations.FetchInsightsQuestionnairesResponse:
        r"""To get the Questionnaire Detail"""
        base_url = operations.FETCH_INSIGHTS_QUESTIONNAIRES_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchInsightsQuestionnairesRequest, base_url, '/v1/Insights/QM/Questionnaires/{Id}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInsightsQuestionnairesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnaires])
                res.flex_v1_insights_questionnaires = out

        return res

    def fetch_insights_segments(self, request: operations.FetchInsightsSegmentsRequest, security: operations.FetchInsightsSegmentsSecurity, server_url: Optional[str] = None) -> operations.FetchInsightsSegmentsResponse:
        r"""To get the Segments of an Account"""
        base_url = operations.FETCH_INSIGHTS_SEGMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchInsightsSegmentsRequest, base_url, '/v1/Insights/Segments/{SegmentId}', request)
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInsightsSegmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsSegments])
                res.flex_v1_insights_segments = out

        return res

    def fetch_insights_settings_answersets(self, request: operations.FetchInsightsSettingsAnswersetsRequest, security: operations.FetchInsightsSettingsAnswersetsSecurity, server_url: Optional[str] = None) -> operations.FetchInsightsSettingsAnswersetsResponse:
        r"""To get the Answer Set Settings for an Account"""
        base_url = operations.FETCH_INSIGHTS_SETTINGS_ANSWERSETS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Settings/AnswerSets'
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInsightsSettingsAnswersetsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsSettingsAnswersets])
                res.flex_v1_insights_settings_answersets = out

        return res

    def fetch_insights_settings_comment(self, request: operations.FetchInsightsSettingsCommentRequest, security: operations.FetchInsightsSettingsCommentSecurity, server_url: Optional[str] = None) -> operations.FetchInsightsSettingsCommentResponse:
        r"""To get the Comment Settings for an Account"""
        base_url = operations.FETCH_INSIGHTS_SETTINGS_COMMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Settings/CommentTags'
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInsightsSettingsCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsSettingsComment])
                res.flex_v1_insights_settings_comment = out

        return res

    def fetch_insights_user_roles(self, request: operations.FetchInsightsUserRolesRequest, security: operations.FetchInsightsUserRolesSecurity, server_url: Optional[str] = None) -> operations.FetchInsightsUserRolesResponse:
        r"""This is used by Flex UI and Quality Management to fetch the Flex Insights roles for the user"""
        base_url = operations.FETCH_INSIGHTS_USER_ROLES_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/UserRoles'
        
        headers = utils.get_headers(request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInsightsUserRolesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsUserRoles])
                res.flex_v1_insights_user_roles = out

        return res

    def fetch_interaction(self, request: operations.FetchInteractionRequest, security: operations.FetchInteractionSecurity, server_url: Optional[str] = None) -> operations.FetchInteractionResponse:
        base_url = operations.FETCH_INTERACTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchInteractionRequest, base_url, '/v1/Interactions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInteractionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1Interaction])
                res.flex_v1_interaction = out

        return res

    def fetch_interaction_channel(self, request: operations.FetchInteractionChannelRequest, security: operations.FetchInteractionChannelSecurity, server_url: Optional[str] = None) -> operations.FetchInteractionChannelResponse:
        r"""Fetch a Channel for an Interaction."""
        base_url = operations.FETCH_INTERACTION_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchInteractionChannelRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchInteractionChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InteractionInteractionChannel])
                res.flex_v1_interaction_interaction_channel = out

        return res

    def fetch_web_channel(self, request: operations.FetchWebChannelRequest, security: operations.FetchWebChannelSecurity, server_url: Optional[str] = None) -> operations.FetchWebChannelResponse:
        base_url = operations.FETCH_WEB_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchWebChannelRequest, base_url, '/v1/WebChannels/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchWebChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1WebChannel])
                res.flex_v1_web_channel = out

        return res

    def list_channel(self, request: operations.ListChannelRequest, security: operations.ListChannelSecurity, server_url: Optional[str] = None) -> operations.ListChannelResponse:
        base_url = operations.LIST_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Channels'
        
        query_params = utils.get_query_params(operations.ListChannelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListChannelListChannelResponse])
                res.list_channel_response = out

        return res

    def list_flex_flow(self, request: operations.ListFlexFlowRequest, security: operations.ListFlexFlowSecurity, server_url: Optional[str] = None) -> operations.ListFlexFlowResponse:
        base_url = operations.LIST_FLEX_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/FlexFlows'
        
        query_params = utils.get_query_params(operations.ListFlexFlowRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFlexFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListFlexFlowListFlexFlowResponse])
                res.list_flex_flow_response = out

        return res

    def list_insights_assessments(self, request: operations.ListInsightsAssessmentsRequest, security: operations.ListInsightsAssessmentsSecurity, server_url: Optional[str] = None) -> operations.ListInsightsAssessmentsResponse:
        r"""Get assessments done for a conversation by logged in user"""
        base_url = operations.LIST_INSIGHTS_ASSESSMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Assessments'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsAssessmentsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsAssessmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsAssessmentsListInsightsAssessmentsResponse])
                res.list_insights_assessments_response = out

        return res

    def list_insights_assessments_comment(self, request: operations.ListInsightsAssessmentsCommentRequest, security: operations.ListInsightsAssessmentsCommentSecurity, server_url: Optional[str] = None) -> operations.ListInsightsAssessmentsCommentResponse:
        r"""To create a comment assessment for a conversation"""
        base_url = operations.LIST_INSIGHTS_ASSESSMENTS_COMMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Assessments/Comments'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsAssessmentsCommentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsAssessmentsCommentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsAssessmentsCommentListInsightsAssessmentsCommentResponse])
                res.list_insights_assessments_comment_response = out

        return res

    def list_insights_conversations(self, request: operations.ListInsightsConversationsRequest, security: operations.ListInsightsConversationsSecurity, server_url: Optional[str] = None) -> operations.ListInsightsConversationsResponse:
        r"""To get conversation with segment id"""
        base_url = operations.LIST_INSIGHTS_CONVERSATIONS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/Conversations'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsConversationsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsConversationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsConversationsListInsightsConversationsResponse])
                res.list_insights_conversations_response = out

        return res

    def list_insights_questionnaires(self, request: operations.ListInsightsQuestionnairesRequest, security: operations.ListInsightsQuestionnairesSecurity, server_url: Optional[str] = None) -> operations.ListInsightsQuestionnairesResponse:
        r"""To get all questionnaires with questions"""
        base_url = operations.LIST_INSIGHTS_QUESTIONNAIRES_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Questionnaires'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsQuestionnairesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsQuestionnairesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsQuestionnairesListInsightsQuestionnairesResponse])
                res.list_insights_questionnaires_response = out

        return res

    def list_insights_questionnaires_category(self, request: operations.ListInsightsQuestionnairesCategoryRequest, security: operations.ListInsightsQuestionnairesCategorySecurity, server_url: Optional[str] = None) -> operations.ListInsightsQuestionnairesCategoryResponse:
        r"""To get all the categories"""
        base_url = operations.LIST_INSIGHTS_QUESTIONNAIRES_CATEGORY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Categories'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsQuestionnairesCategoryRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsQuestionnairesCategoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsQuestionnairesCategoryListInsightsQuestionnairesCategoryResponse])
                res.list_insights_questionnaires_category_response = out

        return res

    def list_insights_questionnaires_question(self, request: operations.ListInsightsQuestionnairesQuestionRequest, security: operations.ListInsightsQuestionnairesQuestionSecurity, server_url: Optional[str] = None) -> operations.ListInsightsQuestionnairesQuestionResponse:
        r"""To get all the question for the given categories"""
        base_url = operations.LIST_INSIGHTS_QUESTIONNAIRES_QUESTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/QM/Questions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsQuestionnairesQuestionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsQuestionnairesQuestionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsQuestionnairesQuestionListInsightsQuestionnairesQuestionResponse])
                res.list_insights_questionnaires_question_response = out

        return res

    def list_insights_segments(self, request: operations.ListInsightsSegmentsRequest, security: operations.ListInsightsSegmentsSecurity, server_url: Optional[str] = None) -> operations.ListInsightsSegmentsResponse:
        r"""To get segments for given reservation Ids"""
        base_url = operations.LIST_INSIGHTS_SEGMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Insights/Segments'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ListInsightsSegmentsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInsightsSegmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInsightsSegmentsListInsightsSegmentsResponse])
                res.list_insights_segments_response = out

        return res

    def list_interaction_channel(self, request: operations.ListInteractionChannelRequest, security: operations.ListInteractionChannelSecurity, server_url: Optional[str] = None) -> operations.ListInteractionChannelResponse:
        r"""List all Channels for an Interaction."""
        base_url = operations.LIST_INTERACTION_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListInteractionChannelRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels', request)
        
        query_params = utils.get_query_params(operations.ListInteractionChannelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInteractionChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInteractionChannelListInteractionChannelResponse])
                res.list_interaction_channel_response = out

        return res

    def list_interaction_channel_invite(self, request: operations.ListInteractionChannelInviteRequest, security: operations.ListInteractionChannelInviteSecurity, server_url: Optional[str] = None) -> operations.ListInteractionChannelInviteResponse:
        r"""List all Invites for a Channel."""
        base_url = operations.LIST_INTERACTION_CHANNEL_INVITE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListInteractionChannelInviteRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Invites', request)
        
        query_params = utils.get_query_params(operations.ListInteractionChannelInviteRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInteractionChannelInviteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInteractionChannelInviteListInteractionChannelInviteResponse])
                res.list_interaction_channel_invite_response = out

        return res

    def list_interaction_channel_participant(self, request: operations.ListInteractionChannelParticipantRequest, security: operations.ListInteractionChannelParticipantSecurity, server_url: Optional[str] = None) -> operations.ListInteractionChannelParticipantResponse:
        r"""List all Participants for a Channel."""
        base_url = operations.LIST_INTERACTION_CHANNEL_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListInteractionChannelParticipantRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants', request)
        
        query_params = utils.get_query_params(operations.ListInteractionChannelParticipantRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInteractionChannelParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListInteractionChannelParticipantListInteractionChannelParticipantResponse])
                res.list_interaction_channel_participant_response = out

        return res

    def list_web_channel(self, request: operations.ListWebChannelRequest, security: operations.ListWebChannelSecurity, server_url: Optional[str] = None) -> operations.ListWebChannelResponse:
        base_url = operations.LIST_WEB_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/WebChannels'
        
        query_params = utils.get_query_params(operations.ListWebChannelRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListWebChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListWebChannelListWebChannelResponse])
                res.list_web_channel_response = out

        return res

    def update_flex_flow(self, request: operations.UpdateFlexFlowRequest, security: operations.UpdateFlexFlowSecurity, server_url: Optional[str] = None) -> operations.UpdateFlexFlowResponse:
        base_url = operations.UPDATE_FLEX_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateFlexFlowRequest, base_url, '/v1/FlexFlows/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateFlexFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1FlexFlow])
                res.flex_v1_flex_flow = out

        return res

    def update_insights_assessments(self, request: operations.UpdateInsightsAssessmentsRequest, security: operations.UpdateInsightsAssessmentsSecurity, server_url: Optional[str] = None) -> operations.UpdateInsightsAssessmentsResponse:
        r"""Update a specific Assessment assessed earlier"""
        base_url = operations.UPDATE_INSIGHTS_ASSESSMENTS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateInsightsAssessmentsRequest, base_url, '/v1/Insights/QM/Assessments/{AssessmentId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInsightsAssessmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsAssessments])
                res.flex_v1_insights_assessments = out

        return res

    def update_insights_questionnaires(self, request: operations.UpdateInsightsQuestionnairesRequest, security: operations.UpdateInsightsQuestionnairesSecurity, server_url: Optional[str] = None) -> operations.UpdateInsightsQuestionnairesResponse:
        r"""To update the questionnaire"""
        base_url = operations.UPDATE_INSIGHTS_QUESTIONNAIRES_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateInsightsQuestionnairesRequest, base_url, '/v1/Insights/QM/Questionnaires/{Id}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInsightsQuestionnairesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnaires])
                res.flex_v1_insights_questionnaires = out

        return res

    def update_insights_questionnaires_category(self, request: operations.UpdateInsightsQuestionnairesCategoryRequest, security: operations.UpdateInsightsQuestionnairesCategorySecurity, server_url: Optional[str] = None) -> operations.UpdateInsightsQuestionnairesCategoryResponse:
        r"""To update the category for Questions"""
        base_url = operations.UPDATE_INSIGHTS_QUESTIONNAIRES_CATEGORY_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateInsightsQuestionnairesCategoryRequest, base_url, '/v1/Insights/QM/Categories/{CategoryId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInsightsQuestionnairesCategoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnairesCategory])
                res.flex_v1_insights_questionnaires_category = out

        return res

    def update_insights_questionnaires_question(self, request: operations.UpdateInsightsQuestionnairesQuestionRequest, security: operations.UpdateInsightsQuestionnairesQuestionSecurity, server_url: Optional[str] = None) -> operations.UpdateInsightsQuestionnairesQuestionResponse:
        r"""To update the question"""
        base_url = operations.UPDATE_INSIGHTS_QUESTIONNAIRES_QUESTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateInsightsQuestionnairesQuestionRequest, base_url, '/v1/Insights/QM/Questions/{QuestionId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInsightsQuestionnairesQuestionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InsightsQuestionnairesQuestion])
                res.flex_v1_insights_questionnaires_question = out

        return res

    def update_interaction_channel(self, request: operations.UpdateInteractionChannelRequest, security: operations.UpdateInteractionChannelSecurity, server_url: Optional[str] = None) -> operations.UpdateInteractionChannelResponse:
        r"""Update an existing Interaction Channel."""
        base_url = operations.UPDATE_INTERACTION_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateInteractionChannelRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInteractionChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InteractionInteractionChannel])
                res.flex_v1_interaction_interaction_channel = out

        return res

    def update_interaction_channel_participant(self, request: operations.UpdateInteractionChannelParticipantRequest, security: operations.UpdateInteractionChannelParticipantSecurity, server_url: Optional[str] = None) -> operations.UpdateInteractionChannelParticipantResponse:
        r"""Update an existing Channel Participant."""
        base_url = operations.UPDATE_INTERACTION_CHANNEL_PARTICIPANT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateInteractionChannelParticipantRequest, base_url, '/v1/Interactions/{InteractionSid}/Channels/{ChannelSid}/Participants/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInteractionChannelParticipantResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1InteractionInteractionChannelInteractionChannelParticipant])
                res.flex_v1_interaction_interaction_channel_interaction_channel_participant = out

        return res

    def update_web_channel(self, request: operations.UpdateWebChannelRequest, security: operations.UpdateWebChannelSecurity, server_url: Optional[str] = None) -> operations.UpdateWebChannelResponse:
        base_url = operations.UPDATE_WEB_CHANNEL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateWebChannelRequest, base_url, '/v1/WebChannels/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateWebChannelResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FlexV1WebChannel])
                res.flex_v1_web_channel = out

        return res

    