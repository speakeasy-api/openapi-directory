/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Appliance {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Generate a new vMX authentication token
   *
   * @remarks
   * Generate a new vMX authentication token
   */
  createDeviceApplianceVmxAuthenticationToken(
    req: operations.CreateDeviceApplianceVmxAuthenticationTokenRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDeviceApplianceVmxAuthenticationTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDeviceApplianceVmxAuthenticationTokenRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/vmx/authenticationToken",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDeviceApplianceVmxAuthenticationTokenResponse =
        new operations.CreateDeviceApplianceVmxAuthenticationTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createDeviceApplianceVmxAuthenticationToken201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CreateDeviceApplianceVmxAuthenticationToken201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a static delegated prefix from a network
   *
   * @remarks
   * Add a static delegated prefix from a network
   */
  createNetworkAppliancePrefixesDelegatedStatic(
    req: operations.CreateNetworkAppliancePrefixesDelegatedStaticRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkAppliancePrefixesDelegatedStaticResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNetworkAppliancePrefixesDelegatedStaticRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/prefixes/delegated/statics",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkAppliancePrefixesDelegatedStaticResponse =
        new operations.CreateNetworkAppliancePrefixesDelegatedStaticResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createNetworkAppliancePrefixesDelegatedStatic201ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a static route for an MX or teleworker network
   *
   * @remarks
   * Add a static route for an MX or teleworker network
   */
  createNetworkApplianceStaticRoute(
    req: operations.CreateNetworkApplianceStaticRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkApplianceStaticRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNetworkApplianceStaticRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/staticRoutes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkApplianceStaticRouteResponse =
        new operations.CreateNetworkApplianceStaticRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createNetworkApplianceStaticRoute201ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a custom performance class for an MX network
   *
   * @remarks
   * Add a custom performance class for an MX network
   */
  createNetworkApplianceTrafficShapingCustomPerformanceClass(
    req: operations.CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkApplianceTrafficShapingCustomPerformanceClassResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CreateNetworkApplianceTrafficShapingCustomPerformanceClassRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkApplianceTrafficShapingCustomPerformanceClassResponse =
        new operations.CreateNetworkApplianceTrafficShapingCustomPerformanceClassResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createNetworkApplianceTrafficShapingCustomPerformanceClass201ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a VLAN
   *
   * @remarks
   * Add a VLAN
   */
  createNetworkApplianceVlan(
    req: operations.CreateNetworkApplianceVlanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateNetworkApplianceVlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateNetworkApplianceVlanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateNetworkApplianceVlanResponse =
        new operations.CreateNetworkApplianceVlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createNetworkApplianceVlan201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.CreateNetworkApplianceVlan201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a static delegated prefix from a network
   *
   * @remarks
   * Delete a static delegated prefix from a network
   */
  deleteNetworkAppliancePrefixesDelegatedStatic(
    req: operations.DeleteNetworkAppliancePrefixesDelegatedStaticRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkAppliancePrefixesDelegatedStaticResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNetworkAppliancePrefixesDelegatedStaticRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkAppliancePrefixesDelegatedStaticResponse =
        new operations.DeleteNetworkAppliancePrefixesDelegatedStaticResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a static route from an MX or teleworker network
   *
   * @remarks
   * Delete a static route from an MX or teleworker network
   */
  deleteNetworkApplianceStaticRoute(
    req: operations.DeleteNetworkApplianceStaticRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkApplianceStaticRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNetworkApplianceStaticRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/staticRoutes/{staticRouteId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkApplianceStaticRouteResponse =
        new operations.DeleteNetworkApplianceStaticRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a custom performance class from an MX network
   *
   * @remarks
   * Delete a custom performance class from an MX network
   */
  deleteNetworkApplianceTrafficShapingCustomPerformanceClass(
    req: operations.DeleteNetworkApplianceTrafficShapingCustomPerformanceClassRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkApplianceTrafficShapingCustomPerformanceClassResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteNetworkApplianceTrafficShapingCustomPerformanceClassRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkApplianceTrafficShapingCustomPerformanceClassResponse =
        new operations.DeleteNetworkApplianceTrafficShapingCustomPerformanceClassResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a VLAN from a network
   *
   * @remarks
   * Delete a VLAN from a network
   */
  deleteNetworkApplianceVlan(
    req: operations.DeleteNetworkApplianceVlanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteNetworkApplianceVlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteNetworkApplianceVlanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans/{vlanId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteNetworkApplianceVlanResponse =
        new operations.DeleteNetworkApplianceVlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Return the DHCP subnet information for an appliance
   *
   * @remarks
   * Return the DHCP subnet information for an appliance
   */
  getDeviceApplianceDhcpSubnets(
    req: operations.GetDeviceApplianceDhcpSubnetsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeviceApplianceDhcpSubnetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDeviceApplianceDhcpSubnetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/dhcp/subnets",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeviceApplianceDhcpSubnetsResponse =
        new operations.GetDeviceApplianceDhcpSubnetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDeviceApplianceDhcpSubnets200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the performance score for a single MX
   *
   * @remarks
   * Return the performance score for a single MX. Only primary MX devices supported. If no data is available, a 204 error code is returned.
   */
  getDeviceAppliancePerformance(
    req: operations.GetDeviceAppliancePerformanceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeviceAppliancePerformanceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDeviceAppliancePerformanceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/performance",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeviceAppliancePerformanceResponse =
        new operations.GetDeviceAppliancePerformanceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDeviceAppliancePerformance200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return current delegated IPv6 prefixes on an appliance.
   *
   * @remarks
   * Return current delegated IPv6 prefixes on an appliance.
   */
  getDeviceAppliancePrefixesDelegated(
    req: operations.GetDeviceAppliancePrefixesDelegatedRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeviceAppliancePrefixesDelegatedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDeviceAppliancePrefixesDelegatedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/prefixes/delegated",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeviceAppliancePrefixesDelegatedResponse =
        new operations.GetDeviceAppliancePrefixesDelegatedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDeviceAppliancePrefixesDelegated200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
   *
   * @remarks
   * Return prefixes assigned to all IPv6 enabled VLANs on an appliance.
   */
  getDeviceAppliancePrefixesDelegatedVlanAssignments(
    req: operations.GetDeviceAppliancePrefixesDelegatedVlanAssignmentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeviceAppliancePrefixesDelegatedVlanAssignmentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetDeviceAppliancePrefixesDelegatedVlanAssignmentsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/prefixes/delegated/vlanAssignments",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeviceAppliancePrefixesDelegatedVlanAssignmentsResponse =
        new operations.GetDeviceAppliancePrefixesDelegatedVlanAssignmentsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDeviceAppliancePrefixesDelegatedVlanAssignments200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the uplink settings for an MX appliance
   *
   * @remarks
   * Return the uplink settings for an MX appliance
   */
  getDeviceApplianceUplinksSettings(
    req: operations.GetDeviceApplianceUplinksSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDeviceApplianceUplinksSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDeviceApplianceUplinksSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/uplinks/settings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDeviceApplianceUplinksSettingsResponse =
        new operations.GetDeviceApplianceUplinksSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDeviceApplianceUplinksSettings200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetDeviceApplianceUplinksSettings200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the security events for a client
   *
   * @remarks
   * List the security events for a client. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
   */
  getNetworkApplianceClientSecurityEvents(
    req: operations.GetNetworkApplianceClientSecurityEventsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceClientSecurityEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceClientSecurityEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/clients/{clientId}/security/events",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceClientSecurityEventsResponse =
        new operations.GetNetworkApplianceClientSecurityEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceClientSecurityEvents200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the connectivity testing destinations for an MX network
   *
   * @remarks
   * Return the connectivity testing destinations for an MX network
   */
  getNetworkApplianceConnectivityMonitoringDestinations(
    req: operations.GetNetworkApplianceConnectivityMonitoringDestinationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceConnectivityMonitoringDestinationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceConnectivityMonitoringDestinationsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/connectivityMonitoringDestinations",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceConnectivityMonitoringDestinationsResponse =
        new operations.GetNetworkApplianceConnectivityMonitoringDestinationsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceConnectivityMonitoringDestinations200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the content filtering settings for an MX network
   *
   * @remarks
   * Return the content filtering settings for an MX network
   */
  getNetworkApplianceContentFiltering(
    req: operations.GetNetworkApplianceContentFilteringRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceContentFilteringResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceContentFilteringRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/contentFiltering",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceContentFilteringResponse =
        new operations.GetNetworkApplianceContentFilteringResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceContentFiltering200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all available content filtering categories for an MX network
   *
   * @remarks
   * List all available content filtering categories for an MX network
   */
  getNetworkApplianceContentFilteringCategories(
    req: operations.GetNetworkApplianceContentFilteringCategoriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceContentFilteringCategoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceContentFilteringCategoriesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/contentFiltering/categories",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceContentFilteringCategoriesResponse =
        new operations.GetNetworkApplianceContentFilteringCategoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceContentFilteringCategories200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the cellular firewall rules for an MX network
   *
   * @remarks
   * Return the cellular firewall rules for an MX network
   */
  getNetworkApplianceFirewallCellularFirewallRules(
    req: operations.GetNetworkApplianceFirewallCellularFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallCellularFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceFirewallCellularFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/cellularFirewallRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallCellularFirewallRulesResponse =
        new operations.GetNetworkApplianceFirewallCellularFirewallRulesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallCellularFirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
   *
   * @remarks
   * Return the accessibility settings of the given service ('ICMP', 'web', or 'SNMP')
   */
  getNetworkApplianceFirewallFirewalledService(
    req: operations.GetNetworkApplianceFirewallFirewalledServiceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallFirewalledServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallFirewalledServiceRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/firewalledServices/{service}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallFirewalledServiceResponse =
        new operations.GetNetworkApplianceFirewallFirewalledServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallFirewalledService200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the appliance services and their accessibility rules
   *
   * @remarks
   * List the appliance services and their accessibility rules
   */
  getNetworkApplianceFirewallFirewalledServices(
    req: operations.GetNetworkApplianceFirewallFirewalledServicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallFirewalledServicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallFirewalledServicesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/firewalledServices",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallFirewalledServicesResponse =
        new operations.GetNetworkApplianceFirewallFirewalledServicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallFirewalledServices200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the inbound cellular firewall rules for an MX network
   *
   * @remarks
   * Return the inbound cellular firewall rules for an MX network
   */
  getNetworkApplianceFirewallInboundCellularFirewallRules(
    req: operations.GetNetworkApplianceFirewallInboundCellularFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallInboundCellularFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceFirewallInboundCellularFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/inboundCellularFirewallRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallInboundCellularFirewallRulesResponse =
        new operations.GetNetworkApplianceFirewallInboundCellularFirewallRulesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallInboundCellularFirewallRules200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the inbound firewall rules for an MX network
   *
   * @remarks
   * Return the inbound firewall rules for an MX network
   */
  getNetworkApplianceFirewallInboundFirewallRules(
    req: operations.GetNetworkApplianceFirewallInboundFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallInboundFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceFirewallInboundFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/inboundFirewallRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallInboundFirewallRulesResponse =
        new operations.GetNetworkApplianceFirewallInboundFirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallInboundFirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the L3 firewall rules for an MX network
   *
   * @remarks
   * Return the L3 firewall rules for an MX network
   */
  getNetworkApplianceFirewallL3FirewallRules(
    req: operations.GetNetworkApplianceFirewallL3FirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallL3FirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallL3FirewallRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/l3FirewallRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallL3FirewallRulesResponse =
        new operations.GetNetworkApplianceFirewallL3FirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallL3FirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the MX L7 firewall rules for an MX network
   *
   * @remarks
   * List the MX L7 firewall rules for an MX network
   */
  getNetworkApplianceFirewallL7FirewallRules(
    req: operations.GetNetworkApplianceFirewallL7FirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallL7FirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallL7FirewallRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/l7FirewallRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallL7FirewallRulesResponse =
        new operations.GetNetworkApplianceFirewallL7FirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallL7FirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the L7 firewall application categories and their associated applications for an MX network
   *
   * @remarks
   * Return the L7 firewall application categories and their associated applications for an MX network
   */
  getNetworkApplianceFirewallL7FirewallRulesApplicationCategories(
    req: operations.GetNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/l7FirewallRules/applicationCategories",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesResponse =
        new operations.GetNetworkApplianceFirewallL7FirewallRulesApplicationCategoriesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallL7FirewallRulesApplicationCategories200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the 1:Many NAT mapping rules for an MX network
   *
   * @remarks
   * Return the 1:Many NAT mapping rules for an MX network
   */
  getNetworkApplianceFirewallOneToManyNatRules(
    req: operations.GetNetworkApplianceFirewallOneToManyNatRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallOneToManyNatRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallOneToManyNatRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/oneToManyNatRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallOneToManyNatRulesResponse =
        new operations.GetNetworkApplianceFirewallOneToManyNatRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallOneToManyNatRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the 1:1 NAT mapping rules for an MX network
   *
   * @remarks
   * Return the 1:1 NAT mapping rules for an MX network
   */
  getNetworkApplianceFirewallOneToOneNatRules(
    req: operations.GetNetworkApplianceFirewallOneToOneNatRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallOneToOneNatRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallOneToOneNatRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/oneToOneNatRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallOneToOneNatRulesResponse =
        new operations.GetNetworkApplianceFirewallOneToOneNatRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallOneToOneNatRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the port forwarding rules for an MX network
   *
   * @remarks
   * Return the port forwarding rules for an MX network
   */
  getNetworkApplianceFirewallPortForwardingRules(
    req: operations.GetNetworkApplianceFirewallPortForwardingRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallPortForwardingRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceFirewallPortForwardingRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/portForwardingRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallPortForwardingRulesResponse =
        new operations.GetNetworkApplianceFirewallPortForwardingRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallPortForwardingRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the firewall settings for this network
   *
   * @remarks
   * Return the firewall settings for this network
   */
  getNetworkApplianceFirewallSettings(
    req: operations.GetNetworkApplianceFirewallSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceFirewallSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceFirewallSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/settings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceFirewallSettingsResponse =
        new operations.GetNetworkApplianceFirewallSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceFirewallSettings200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return per-port VLAN settings for a single MX port.
   *
   * @remarks
   * Return per-port VLAN settings for a single MX port.
   */
  getNetworkAppliancePort(
    req: operations.GetNetworkAppliancePortRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkAppliancePortResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkAppliancePortRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/ports/{portId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkAppliancePortResponse =
        new operations.GetNetworkAppliancePortResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkAppliancePort200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkAppliancePort200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List per-port VLAN settings for all ports of a MX.
   *
   * @remarks
   * List per-port VLAN settings for all ports of a MX.
   */
  getNetworkAppliancePorts(
    req: operations.GetNetworkAppliancePortsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkAppliancePortsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkAppliancePortsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/ports",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkAppliancePortsResponse =
        new operations.GetNetworkAppliancePortsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkAppliancePorts200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkAppliancePorts200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkAppliancePorts200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a static delegated prefix from a network
   *
   * @remarks
   * Return a static delegated prefix from a network
   */
  getNetworkAppliancePrefixesDelegatedStatic(
    req: operations.GetNetworkAppliancePrefixesDelegatedStaticRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkAppliancePrefixesDelegatedStaticResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkAppliancePrefixesDelegatedStaticRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkAppliancePrefixesDelegatedStaticResponse =
        new operations.GetNetworkAppliancePrefixesDelegatedStaticResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkAppliancePrefixesDelegatedStatic200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkAppliancePrefixesDelegatedStatic200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List static delegated prefixes for a network
   *
   * @remarks
   * List static delegated prefixes for a network
   */
  getNetworkAppliancePrefixesDelegatedStatics(
    req: operations.GetNetworkAppliancePrefixesDelegatedStaticsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkAppliancePrefixesDelegatedStaticsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkAppliancePrefixesDelegatedStaticsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/prefixes/delegated/statics",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkAppliancePrefixesDelegatedStaticsResponse =
        new operations.GetNetworkAppliancePrefixesDelegatedStaticsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkAppliancePrefixesDelegatedStatics200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkAppliancePrefixesDelegatedStatics200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkAppliancePrefixesDelegatedStatics200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the security events for a network
   *
   * @remarks
   * List the security events for a network
   */
  getNetworkApplianceSecurityEvents(
    req: operations.GetNetworkApplianceSecurityEventsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSecurityEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSecurityEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/security/events",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSecurityEventsResponse =
        new operations.GetNetworkApplianceSecurityEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSecurityEvents200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all supported intrusion settings for an MX network
   *
   * @remarks
   * Returns all supported intrusion settings for an MX network
   */
  getNetworkApplianceSecurityIntrusion(
    req: operations.GetNetworkApplianceSecurityIntrusionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSecurityIntrusionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSecurityIntrusionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/security/intrusion",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSecurityIntrusionResponse =
        new operations.GetNetworkApplianceSecurityIntrusionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSecurityIntrusion200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all supported malware settings for an MX network
   *
   * @remarks
   * Returns all supported malware settings for an MX network
   */
  getNetworkApplianceSecurityMalware(
    req: operations.GetNetworkApplianceSecurityMalwareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSecurityMalwareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSecurityMalwareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/security/malware",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSecurityMalwareResponse =
        new operations.GetNetworkApplianceSecurityMalwareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSecurityMalware200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the appliance settings for a network
   *
   * @remarks
   * Return the appliance settings for a network
   */
  getNetworkApplianceSettings(
    req: operations.GetNetworkApplianceSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/settings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSettingsResponse =
        new operations.GetNetworkApplianceSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSettings200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceSettings200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return single LAN configuration
   *
   * @remarks
   * Return single LAN configuration
   */
  getNetworkApplianceSingleLan(
    req: operations.GetNetworkApplianceSingleLanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSingleLanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSingleLanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/singleLan",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSingleLanResponse =
        new operations.GetNetworkApplianceSingleLanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSingleLan200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceSingleLan200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a single MX SSID
   *
   * @remarks
   * Return a single MX SSID
   */
  getNetworkApplianceSsid(
    req: operations.GetNetworkApplianceSsidRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSsidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSsidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/ssids/{number}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSsidResponse =
        new operations.GetNetworkApplianceSsidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSsid200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceSsid200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the MX SSIDs in a network
   *
   * @remarks
   * List the MX SSIDs in a network
   */
  getNetworkApplianceSsids(
    req: operations.GetNetworkApplianceSsidsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceSsidsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceSsidsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/ssids",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceSsidsResponse =
        new operations.GetNetworkApplianceSsidsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceSsids200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkApplianceSsids200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceSsids200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a static route for an MX or teleworker network
   *
   * @remarks
   * Return a static route for an MX or teleworker network
   */
  getNetworkApplianceStaticRoute(
    req: operations.GetNetworkApplianceStaticRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceStaticRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceStaticRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/staticRoutes/{staticRouteId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceStaticRouteResponse =
        new operations.GetNetworkApplianceStaticRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceStaticRoute200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the static routes for an MX or teleworker network
   *
   * @remarks
   * List the static routes for an MX or teleworker network
   */
  getNetworkApplianceStaticRoutes(
    req: operations.GetNetworkApplianceStaticRoutesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceStaticRoutesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceStaticRoutesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/staticRoutes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceStaticRoutesResponse =
        new operations.GetNetworkApplianceStaticRoutesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceStaticRoutes200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Display the traffic shaping settings for an MX network
   *
   * @remarks
   * Display the traffic shaping settings for an MX network
   */
  getNetworkApplianceTrafficShaping(
    req: operations.GetNetworkApplianceTrafficShapingRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceTrafficShapingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceTrafficShapingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceTrafficShapingResponse =
        new operations.GetNetworkApplianceTrafficShapingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceTrafficShaping200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a custom performance class for an MX network
   *
   * @remarks
   * Return a custom performance class for an MX network
   */
  getNetworkApplianceTrafficShapingCustomPerformanceClass(
    req: operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassResponse =
        new operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceTrafficShapingCustomPerformanceClass200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all custom performance classes for an MX network
   *
   * @remarks
   * List all custom performance classes for an MX network
   */
  getNetworkApplianceTrafficShapingCustomPerformanceClasses(
    req: operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassesResponse =
        new operations.GetNetworkApplianceTrafficShapingCustomPerformanceClassesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceTrafficShapingCustomPerformanceClasses200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Display the traffic shaping settings rules for an MX network
   *
   * @remarks
   * Display the traffic shaping settings rules for an MX network
   */
  getNetworkApplianceTrafficShapingRules(
    req: operations.GetNetworkApplianceTrafficShapingRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceTrafficShapingRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceTrafficShapingRulesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/rules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceTrafficShapingRulesResponse =
        new operations.GetNetworkApplianceTrafficShapingRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceTrafficShapingRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the uplink bandwidth settings for your MX network.
   *
   * @remarks
   * Returns the uplink bandwidth settings for your MX network.
   */
  getNetworkApplianceTrafficShapingUplinkBandwidth(
    req: operations.GetNetworkApplianceTrafficShapingUplinkBandwidthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceTrafficShapingUplinkBandwidthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceTrafficShapingUplinkBandwidthRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceTrafficShapingUplinkBandwidthResponse =
        new operations.GetNetworkApplianceTrafficShapingUplinkBandwidthResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceTrafficShapingUplinkBandwidth200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceTrafficShapingUplinkBandwidth200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show uplink selection settings for an MX network
   *
   * @remarks
   * Show uplink selection settings for an MX network
   */
  getNetworkApplianceTrafficShapingUplinkSelection(
    req: operations.GetNetworkApplianceTrafficShapingUplinkSelectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceTrafficShapingUplinkSelectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetNetworkApplianceTrafficShapingUplinkSelectionRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/uplinkSelection",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceTrafficShapingUplinkSelectionResponse =
        new operations.GetNetworkApplianceTrafficShapingUplinkSelectionResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the sent and received bytes for each uplink of a network.
   *
   * @remarks
   * Get the sent and received bytes for each uplink of a network.
   */
  getNetworkApplianceUplinksUsageHistory(
    req: operations.GetNetworkApplianceUplinksUsageHistoryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceUplinksUsageHistoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceUplinksUsageHistoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/uplinks/usageHistory",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceUplinksUsageHistoryResponse =
        new operations.GetNetworkApplianceUplinksUsageHistoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceUplinksUsageHistory200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a VLAN
   *
   * @remarks
   * Return a VLAN
   */
  getNetworkApplianceVlan(
    req: operations.GetNetworkApplianceVlanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceVlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceVlanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans/{vlanId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceVlanResponse =
        new operations.GetNetworkApplianceVlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceVlan200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceVlan200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the VLANs for an MX network
   *
   * @remarks
   * List the VLANs for an MX network
   */
  getNetworkApplianceVlans(
    req: operations.GetNetworkApplianceVlansRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceVlansResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceVlansRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceVlansResponse =
        new operations.GetNetworkApplianceVlansResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceVlans200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getNetworkApplianceVlans200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceVlans200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the enabled status of VLANs for the network
   *
   * @remarks
   * Returns the enabled status of VLANs for the network
   */
  getNetworkApplianceVlansSettings(
    req: operations.GetNetworkApplianceVlansSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceVlansSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceVlansSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans/settings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceVlansSettingsResponse =
        new operations.GetNetworkApplianceVlansSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceVlansSettings200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return a Hub BGP Configuration
   *
   * @remarks
   * Return a Hub BGP Configuration
   */
  getNetworkApplianceVpnBgp(
    req: operations.GetNetworkApplianceVpnBgpRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceVpnBgpResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceVpnBgpRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vpn/bgp",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceVpnBgpResponse =
        new operations.GetNetworkApplianceVpnBgpResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceVpnBgp200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the site-to-site VPN settings of a network
   *
   * @remarks
   * Return the site-to-site VPN settings of a network. Only valid for MX networks.
   */
  getNetworkApplianceVpnSiteToSiteVpn(
    req: operations.GetNetworkApplianceVpnSiteToSiteVpnRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceVpnSiteToSiteVpnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceVpnSiteToSiteVpnRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vpn/siteToSiteVpn",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceVpnSiteToSiteVpnResponse =
        new operations.GetNetworkApplianceVpnSiteToSiteVpnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceVpnSiteToSiteVpn200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetNetworkApplianceVpnSiteToSiteVpn200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return MX warm spare settings
   *
   * @remarks
   * Return MX warm spare settings
   */
  getNetworkApplianceWarmSpare(
    req: operations.GetNetworkApplianceWarmSpareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNetworkApplianceWarmSpareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNetworkApplianceWarmSpareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/warmSpare",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNetworkApplianceWarmSpareResponse =
        new operations.GetNetworkApplianceWarmSpareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getNetworkApplianceWarmSpare200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the security events for an organization
   *
   * @remarks
   * List the security events for an organization
   */
  getOrganizationApplianceSecurityEvents(
    req: operations.GetOrganizationApplianceSecurityEventsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceSecurityEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceSecurityEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/security/events",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceSecurityEventsResponse =
        new operations.GetOrganizationApplianceSecurityEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceSecurityEvents200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all supported intrusion settings for an organization
   *
   * @remarks
   * Returns all supported intrusion settings for an organization
   */
  getOrganizationApplianceSecurityIntrusion(
    req: operations.GetOrganizationApplianceSecurityIntrusionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceSecurityIntrusionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceSecurityIntrusionRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/security/intrusion",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceSecurityIntrusionResponse =
        new operations.GetOrganizationApplianceSecurityIntrusionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceSecurityIntrusion200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List the uplink status of every Meraki MX and Z series appliances in the organization
   *
   * @remarks
   * List the uplink status of every Meraki MX and Z series appliances in the organization
   */
  getOrganizationApplianceUplinkStatuses(
    req: operations.GetOrganizationApplianceUplinkStatusesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceUplinkStatusesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceUplinkStatusesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/uplink/statuses",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceUplinkStatusesResponse =
        new operations.GetOrganizationApplianceUplinkStatusesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceUplinkStatuses200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show VPN history stat for networks in an organization
   *
   * @remarks
   * Show VPN history stat for networks in an organization
   */
  getOrganizationApplianceVpnStats(
    req: operations.GetOrganizationApplianceVpnStatsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceVpnStatsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceVpnStatsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/vpn/stats",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceVpnStatsResponse =
        new operations.GetOrganizationApplianceVpnStatsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceVpnStats200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show VPN status for networks in an organization
   *
   * @remarks
   * Show VPN status for networks in an organization
   */
  getOrganizationApplianceVpnStatuses(
    req: operations.GetOrganizationApplianceVpnStatusesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceVpnStatusesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceVpnStatusesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/vpn/statuses",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceVpnStatusesResponse =
        new operations.GetOrganizationApplianceVpnStatusesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceVpnStatuses200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the third party VPN peers for an organization
   *
   * @remarks
   * Return the third party VPN peers for an organization
   */
  getOrganizationApplianceVPNThirdPartyVPNPeers(
    req: operations.GetOrganizationApplianceVPNThirdPartyVPNPeersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceVPNThirdPartyVPNPeersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceVPNThirdPartyVPNPeersRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceVPNThirdPartyVPNPeersResponse =
        new operations.GetOrganizationApplianceVPNThirdPartyVPNPeersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceVPNThirdPartyVPNPeers200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetOrganizationApplianceVPNThirdPartyVPNPeers200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return the firewall rules for an organization's site-to-site VPN
   *
   * @remarks
   * Return the firewall rules for an organization's site-to-site VPN
   */
  getOrganizationApplianceVpnVpnFirewallRules(
    req: operations.GetOrganizationApplianceVpnVpnFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetOrganizationApplianceVpnVpnFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetOrganizationApplianceVpnVpnFirewallRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/vpn/vpnFirewallRules",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetOrganizationApplianceVpnVpnFirewallRulesResponse =
        new operations.GetOrganizationApplianceVpnVpnFirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getOrganizationApplianceVpnVpnFirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Swap MX primary and warm spare appliances
   *
   * @remarks
   * Swap MX primary and warm spare appliances
   */
  swapNetworkApplianceWarmSpare(
    req: operations.SwapNetworkApplianceWarmSpareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SwapNetworkApplianceWarmSpareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SwapNetworkApplianceWarmSpareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/warmSpare/swap",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SwapNetworkApplianceWarmSpareResponse =
        new operations.SwapNetworkApplianceWarmSpareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.swapNetworkApplianceWarmSpare200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the uplink settings for an MX appliance
   *
   * @remarks
   * Update the uplink settings for an MX appliance
   */
  updateDeviceApplianceUplinksSettings(
    req: operations.UpdateDeviceApplianceUplinksSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDeviceApplianceUplinksSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDeviceApplianceUplinksSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/devices/{serial}/appliance/uplinks/settings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDeviceApplianceUplinksSettingsResponse =
        new operations.UpdateDeviceApplianceUplinksSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateDeviceApplianceUplinksSettings200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateDeviceApplianceUplinksSettings200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the connectivity testing destinations for an MX network
   *
   * @remarks
   * Update the connectivity testing destinations for an MX network
   */
  updateNetworkApplianceConnectivityMonitoringDestinations(
    req: operations.UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceConnectivityMonitoringDestinationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceConnectivityMonitoringDestinationsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/connectivityMonitoringDestinations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceConnectivityMonitoringDestinationsResponse =
        new operations.UpdateNetworkApplianceConnectivityMonitoringDestinationsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceConnectivityMonitoringDestinations200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the content filtering settings for an MX network
   *
   * @remarks
   * Update the content filtering settings for an MX network
   */
  updateNetworkApplianceContentFiltering(
    req: operations.UpdateNetworkApplianceContentFilteringRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceContentFilteringResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceContentFilteringRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/contentFiltering",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceContentFilteringResponse =
        new operations.UpdateNetworkApplianceContentFilteringResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceContentFiltering200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the cellular firewall rules of an MX network
   *
   * @remarks
   * Update the cellular firewall rules of an MX network
   */
  updateNetworkApplianceFirewallCellularFirewallRules(
    req: operations.UpdateNetworkApplianceFirewallCellularFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallCellularFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallCellularFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/cellularFirewallRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallCellularFirewallRulesResponse =
        new operations.UpdateNetworkApplianceFirewallCellularFirewallRulesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallCellularFirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')
   *
   * @remarks
   * Updates the accessibility settings for the given service ('ICMP', 'web', or 'SNMP')
   */
  updateNetworkApplianceFirewallFirewalledService(
    req: operations.UpdateNetworkApplianceFirewallFirewalledServiceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallFirewalledServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallFirewalledServiceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/firewalledServices/{service}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallFirewalledServiceResponse =
        new operations.UpdateNetworkApplianceFirewallFirewalledServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallFirewalledService200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the inbound cellular firewall rules of an MX network
   *
   * @remarks
   * Update the inbound cellular firewall rules of an MX network
   */
  updateNetworkApplianceFirewallInboundCellularFirewallRules(
    req: operations.UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallInboundCellularFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallInboundCellularFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/inboundCellularFirewallRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallInboundCellularFirewallRulesResponse =
        new operations.UpdateNetworkApplianceFirewallInboundCellularFirewallRulesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallInboundCellularFirewallRules200ApplicationJSONObjects =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the inbound firewall rules of an MX network
   *
   * @remarks
   * Update the inbound firewall rules of an MX network
   */
  updateNetworkApplianceFirewallInboundFirewallRules(
    req: operations.UpdateNetworkApplianceFirewallInboundFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallInboundFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallInboundFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/inboundFirewallRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallInboundFirewallRulesResponse =
        new operations.UpdateNetworkApplianceFirewallInboundFirewallRulesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallInboundFirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the L3 firewall rules of an MX network
   *
   * @remarks
   * Update the L3 firewall rules of an MX network
   */
  updateNetworkApplianceFirewallL3FirewallRules(
    req: operations.UpdateNetworkApplianceFirewallL3FirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallL3FirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceFirewallL3FirewallRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/l3FirewallRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallL3FirewallRulesResponse =
        new operations.UpdateNetworkApplianceFirewallL3FirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallL3FirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the MX L7 firewall rules for an MX network
   *
   * @remarks
   * Update the MX L7 firewall rules for an MX network
   */
  updateNetworkApplianceFirewallL7FirewallRules(
    req: operations.UpdateNetworkApplianceFirewallL7FirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallL7FirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceFirewallL7FirewallRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/l7FirewallRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallL7FirewallRulesResponse =
        new operations.UpdateNetworkApplianceFirewallL7FirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallL7FirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set the 1:Many NAT mapping rules for an MX network
   *
   * @remarks
   * Set the 1:Many NAT mapping rules for an MX network
   */
  updateNetworkApplianceFirewallOneToManyNatRules(
    req: operations.UpdateNetworkApplianceFirewallOneToManyNatRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallOneToManyNatRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallOneToManyNatRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/oneToManyNatRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallOneToManyNatRulesResponse =
        new operations.UpdateNetworkApplianceFirewallOneToManyNatRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallOneToManyNatRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set the 1:1 NAT mapping rules for an MX network
   *
   * @remarks
   * Set the 1:1 NAT mapping rules for an MX network
   */
  updateNetworkApplianceFirewallOneToOneNatRules(
    req: operations.UpdateNetworkApplianceFirewallOneToOneNatRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallOneToOneNatRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallOneToOneNatRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/oneToOneNatRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallOneToOneNatRulesResponse =
        new operations.UpdateNetworkApplianceFirewallOneToOneNatRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallOneToOneNatRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the port forwarding rules for an MX network
   *
   * @remarks
   * Update the port forwarding rules for an MX network
   */
  updateNetworkApplianceFirewallPortForwardingRules(
    req: operations.UpdateNetworkApplianceFirewallPortForwardingRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallPortForwardingRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceFirewallPortForwardingRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/portForwardingRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallPortForwardingRulesResponse =
        new operations.UpdateNetworkApplianceFirewallPortForwardingRulesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallPortForwardingRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the firewall settings for this network
   *
   * @remarks
   * Update the firewall settings for this network
   */
  updateNetworkApplianceFirewallSettings(
    req: operations.UpdateNetworkApplianceFirewallSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceFirewallSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceFirewallSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/firewall/settings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceFirewallSettingsResponse =
        new operations.UpdateNetworkApplianceFirewallSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceFirewallSettings200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the per-port VLAN settings for a single MX port.
   *
   * @remarks
   * Update the per-port VLAN settings for a single MX port.
   */
  updateNetworkAppliancePort(
    req: operations.UpdateNetworkAppliancePortRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkAppliancePortResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkAppliancePortRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/ports/{portId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkAppliancePortResponse =
        new operations.UpdateNetworkAppliancePortResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkAppliancePort200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkAppliancePort200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a static delegated prefix from a network
   *
   * @remarks
   * Update a static delegated prefix from a network
   */
  updateNetworkAppliancePrefixesDelegatedStatic(
    req: operations.UpdateNetworkAppliancePrefixesDelegatedStaticRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkAppliancePrefixesDelegatedStaticResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkAppliancePrefixesDelegatedStaticRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/prefixes/delegated/statics/{staticDelegatedPrefixId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkAppliancePrefixesDelegatedStaticResponse =
        new operations.UpdateNetworkAppliancePrefixesDelegatedStaticResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkAppliancePrefixesDelegatedStatic200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set the supported intrusion settings for an MX network
   *
   * @remarks
   * Set the supported intrusion settings for an MX network
   */
  updateNetworkApplianceSecurityIntrusion(
    req: operations.UpdateNetworkApplianceSecurityIntrusionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceSecurityIntrusionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceSecurityIntrusionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/security/intrusion",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceSecurityIntrusionResponse =
        new operations.UpdateNetworkApplianceSecurityIntrusionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceSecurityIntrusion200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set the supported malware settings for an MX network
   *
   * @remarks
   * Set the supported malware settings for an MX network
   */
  updateNetworkApplianceSecurityMalware(
    req: operations.UpdateNetworkApplianceSecurityMalwareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceSecurityMalwareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceSecurityMalwareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/security/malware",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceSecurityMalwareResponse =
        new operations.UpdateNetworkApplianceSecurityMalwareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceSecurityMalware200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the appliance settings for a network
   *
   * @remarks
   * Update the appliance settings for a network
   */
  updateNetworkApplianceSettings(
    req: operations.UpdateNetworkApplianceSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/settings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceSettingsResponse =
        new operations.UpdateNetworkApplianceSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceSettings200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkApplianceSettings200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update single LAN configuration
   *
   * @remarks
   * Update single LAN configuration
   */
  updateNetworkApplianceSingleLan(
    req: operations.UpdateNetworkApplianceSingleLanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceSingleLanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceSingleLanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/singleLan",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceSingleLanResponse =
        new operations.UpdateNetworkApplianceSingleLanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceSingleLan200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkApplianceSingleLan200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the attributes of an MX SSID
   *
   * @remarks
   * Update the attributes of an MX SSID
   */
  updateNetworkApplianceSsid(
    req: operations.UpdateNetworkApplianceSsidRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceSsidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceSsidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/ssids/{number}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceSsidResponse =
        new operations.UpdateNetworkApplianceSsidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceSsid200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkApplianceSsid200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a static route for an MX or teleworker network
   *
   * @remarks
   * Update a static route for an MX or teleworker network
   */
  updateNetworkApplianceStaticRoute(
    req: operations.UpdateNetworkApplianceStaticRouteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceStaticRouteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceStaticRouteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/staticRoutes/{staticRouteId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceStaticRouteResponse =
        new operations.UpdateNetworkApplianceStaticRouteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceStaticRoute200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the traffic shaping settings for an MX network
   *
   * @remarks
   * Update the traffic shaping settings for an MX network
   */
  updateNetworkApplianceTrafficShaping(
    req: operations.UpdateNetworkApplianceTrafficShapingRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceTrafficShapingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceTrafficShapingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceTrafficShapingResponse =
        new operations.UpdateNetworkApplianceTrafficShapingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceTrafficShaping200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a custom performance class for an MX network
   *
   * @remarks
   * Update a custom performance class for an MX network
   */
  updateNetworkApplianceTrafficShapingCustomPerformanceClass(
    req: operations.UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceTrafficShapingCustomPerformanceClassResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceTrafficShapingCustomPerformanceClassRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/customPerformanceClasses/{customPerformanceClassId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceTrafficShapingCustomPerformanceClassResponse =
        new operations.UpdateNetworkApplianceTrafficShapingCustomPerformanceClassResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceTrafficShapingCustomPerformanceClass200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the traffic shaping settings rules for an MX network
   *
   * @remarks
   * Update the traffic shaping settings rules for an MX network
   */
  updateNetworkApplianceTrafficShapingRules(
    req: operations.UpdateNetworkApplianceTrafficShapingRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceTrafficShapingRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceTrafficShapingRulesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/rules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceTrafficShapingRulesResponse =
        new operations.UpdateNetworkApplianceTrafficShapingRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceTrafficShapingRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the uplink bandwidth settings for your MX network.
   *
   * @remarks
   * Updates the uplink bandwidth settings for your MX network.
   */
  updateNetworkApplianceTrafficShapingUplinkBandwidth(
    req: operations.UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceTrafficShapingUplinkBandwidthResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceTrafficShapingUplinkBandwidthRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/uplinkBandwidth",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceTrafficShapingUplinkBandwidthResponse =
        new operations.UpdateNetworkApplianceTrafficShapingUplinkBandwidthResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceTrafficShapingUplinkBandwidth200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update uplink selection settings for an MX network
   *
   * @remarks
   * Update uplink selection settings for an MX network
   */
  updateNetworkApplianceTrafficShapingUplinkSelection(
    req: operations.UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceTrafficShapingUplinkSelectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateNetworkApplianceTrafficShapingUplinkSelectionRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/trafficShaping/uplinkSelection",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceTrafficShapingUplinkSelectionResponse =
        new operations.UpdateNetworkApplianceTrafficShapingUplinkSelectionResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkApplianceTrafficShapingUplinkSelection200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a VLAN
   *
   * @remarks
   * Update a VLAN
   */
  updateNetworkApplianceVlan(
    req: operations.UpdateNetworkApplianceVlanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceVlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceVlanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans/{vlanId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceVlanResponse =
        new operations.UpdateNetworkApplianceVlanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceVlan200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkApplianceVlan200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enable/Disable VLANs for the given network
   *
   * @remarks
   * Enable/Disable VLANs for the given network
   */
  updateNetworkApplianceVlansSettings(
    req: operations.UpdateNetworkApplianceVlansSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceVlansSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceVlansSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vlans/settings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceVlansSettingsResponse =
        new operations.UpdateNetworkApplianceVlansSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceVlansSettings200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a Hub BGP Configuration
   *
   * @remarks
   * Update a Hub BGP Configuration
   */
  updateNetworkApplianceVpnBgp(
    req: operations.UpdateNetworkApplianceVpnBgpRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceVpnBgpResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceVpnBgpRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vpn/bgp",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceVpnBgpResponse =
        new operations.UpdateNetworkApplianceVpnBgpResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceVpnBgp200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the site-to-site VPN settings of a network
   *
   * @remarks
   * Update the site-to-site VPN settings of a network. Only valid for MX networks in NAT mode.
   */
  updateNetworkApplianceVpnSiteToSiteVpn(
    req: operations.UpdateNetworkApplianceVpnSiteToSiteVpnRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceVpnSiteToSiteVpnResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceVpnSiteToSiteVpnRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/vpn/siteToSiteVpn",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceVpnSiteToSiteVpnResponse =
        new operations.UpdateNetworkApplianceVpnSiteToSiteVpnResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceVpnSiteToSiteVpn200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateNetworkApplianceVpnSiteToSiteVpn200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update MX warm spare settings
   *
   * @remarks
   * Update MX warm spare settings
   */
  updateNetworkApplianceWarmSpare(
    req: operations.UpdateNetworkApplianceWarmSpareRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNetworkApplianceWarmSpareResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNetworkApplianceWarmSpareRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/networks/{networkId}/appliance/warmSpare",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNetworkApplianceWarmSpareResponse =
        new operations.UpdateNetworkApplianceWarmSpareResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateNetworkApplianceWarmSpare200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets supported intrusion settings for an organization
   *
   * @remarks
   * Sets supported intrusion settings for an organization
   */
  updateOrganizationApplianceSecurityIntrusion(
    req: operations.UpdateOrganizationApplianceSecurityIntrusionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOrganizationApplianceSecurityIntrusionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateOrganizationApplianceSecurityIntrusionRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/security/intrusion",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOrganizationApplianceSecurityIntrusionResponse =
        new operations.UpdateOrganizationApplianceSecurityIntrusionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateOrganizationApplianceSecurityIntrusion200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the third party VPN peers for an organization
   *
   * @remarks
   * Update the third party VPN peers for an organization
   */
  updateOrganizationApplianceVPNThirdPartyVPNPeers(
    req: operations.UpdateOrganizationApplianceVPNThirdPartyVPNPeersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOrganizationApplianceVPNThirdPartyVPNPeersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateOrganizationApplianceVPNThirdPartyVPNPeersRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/vpn/thirdPartyVPNPeers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOrganizationApplianceVPNThirdPartyVPNPeersResponse =
        new operations.UpdateOrganizationApplianceVPNThirdPartyVPNPeersResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateOrganizationApplianceVPNThirdPartyVPNPeers200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.UpdateOrganizationApplianceVPNThirdPartyVPNPeers200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the firewall rules of an organization's site-to-site VPN
   *
   * @remarks
   * Update the firewall rules of an organization's site-to-site VPN
   */
  updateOrganizationApplianceVpnVpnFirewallRules(
    req: operations.UpdateOrganizationApplianceVpnVpnFirewallRulesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateOrganizationApplianceVpnVpnFirewallRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.UpdateOrganizationApplianceVpnVpnFirewallRulesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/organizations/{organizationId}/appliance/vpn/vpnFirewallRules",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateOrganizationApplianceVpnVpnFirewallRulesResponse =
        new operations.UpdateOrganizationApplianceVpnVpnFirewallRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateOrganizationApplianceVpnVpnFirewallRules200ApplicationJSONObject =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }
}
