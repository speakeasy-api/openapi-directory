"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterNat = exports.RouterNatTypeEnum = exports.RouterNatSourceSubnetworkIpRangesToNatEnum = exports.RouterNatNatIpAllocateOptionEnum = exports.RouterNatEndpointTypesEnum = exports.RouterNatAutoNetworkTierEnum = void 0;
var utils_1 = require("../../../internal/utils");
var routernatlogconfig_1 = require("./routernatlogconfig");
var routernatrule_1 = require("./routernatrule");
var routernatsubnetworktonat_1 = require("./routernatsubnetworktonat");
var class_transformer_1 = require("class-transformer");
/**
 * The network tier to use when automatically reserving IP addresses. Must be one of: PREMIUM, STANDARD. If not specified, PREMIUM tier will be used.
 */
var RouterNatAutoNetworkTierEnum;
(function (RouterNatAutoNetworkTierEnum) {
    RouterNatAutoNetworkTierEnum["FixedStandard"] = "FIXED_STANDARD";
    RouterNatAutoNetworkTierEnum["Premium"] = "PREMIUM";
    RouterNatAutoNetworkTierEnum["Select"] = "SELECT";
    RouterNatAutoNetworkTierEnum["Standard"] = "STANDARD";
    RouterNatAutoNetworkTierEnum["StandardOverridesFixedStandard"] = "STANDARD_OVERRIDES_FIXED_STANDARD";
})(RouterNatAutoNetworkTierEnum = exports.RouterNatAutoNetworkTierEnum || (exports.RouterNatAutoNetworkTierEnum = {}));
var RouterNatEndpointTypesEnum;
(function (RouterNatEndpointTypesEnum) {
    RouterNatEndpointTypesEnum["EndpointTypeManagedProxyLb"] = "ENDPOINT_TYPE_MANAGED_PROXY_LB";
    RouterNatEndpointTypesEnum["EndpointTypeSwg"] = "ENDPOINT_TYPE_SWG";
    RouterNatEndpointTypesEnum["EndpointTypeVm"] = "ENDPOINT_TYPE_VM";
})(RouterNatEndpointTypesEnum = exports.RouterNatEndpointTypesEnum || (exports.RouterNatEndpointTypesEnum = {}));
/**
 * Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty.
 */
var RouterNatNatIpAllocateOptionEnum;
(function (RouterNatNatIpAllocateOptionEnum) {
    RouterNatNatIpAllocateOptionEnum["AutoOnly"] = "AUTO_ONLY";
    RouterNatNatIpAllocateOptionEnum["ManualOnly"] = "MANUAL_ONLY";
})(RouterNatNatIpAllocateOptionEnum = exports.RouterNatNatIpAllocateOptionEnum || (exports.RouterNatNatIpAllocateOptionEnum = {}));
/**
 * Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
 */
var RouterNatSourceSubnetworkIpRangesToNatEnum;
(function (RouterNatSourceSubnetworkIpRangesToNatEnum) {
    RouterNatSourceSubnetworkIpRangesToNatEnum["AllSubnetworksAllIpRanges"] = "ALL_SUBNETWORKS_ALL_IP_RANGES";
    RouterNatSourceSubnetworkIpRangesToNatEnum["AllSubnetworksAllPrimaryIpRanges"] = "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES";
    RouterNatSourceSubnetworkIpRangesToNatEnum["ListOfSubnetworks"] = "LIST_OF_SUBNETWORKS";
})(RouterNatSourceSubnetworkIpRangesToNatEnum = exports.RouterNatSourceSubnetworkIpRangesToNatEnum || (exports.RouterNatSourceSubnetworkIpRangesToNatEnum = {}));
/**
 * Indicates whether this NAT is used for public or private IP translation. If unspecified, it defaults to PUBLIC.
 */
var RouterNatTypeEnum;
(function (RouterNatTypeEnum) {
    RouterNatTypeEnum["Private"] = "PRIVATE";
    RouterNatTypeEnum["Public"] = "PUBLIC";
})(RouterNatTypeEnum = exports.RouterNatTypeEnum || (exports.RouterNatTypeEnum = {}));
/**
 * Represents a Nat resource. It enables the VMs within the specified subnetworks to access Internet without external IP addresses. It specifies a list of subnetworks (and the ranges within) that want to use NAT. Customers can also provide the external IPs that would be used for NAT. GCP would auto-allocate ephemeral IPs if no external IPs are provided.
 */
var RouterNat = /** @class */ (function (_super) {
    __extends(RouterNat, _super);
    function RouterNat() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "autoNetworkTier" }),
        __metadata("design:type", String)
    ], RouterNat.prototype, "autoNetworkTier", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "drainNatIps" }),
        __metadata("design:type", Array)
    ], RouterNat.prototype, "drainNatIps", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "enableDynamicPortAllocation" }),
        __metadata("design:type", Boolean)
    ], RouterNat.prototype, "enableDynamicPortAllocation", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "enableEndpointIndependentMapping" }),
        __metadata("design:type", Boolean)
    ], RouterNat.prototype, "enableEndpointIndependentMapping", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "endpointTypes" }),
        __metadata("design:type", Array)
    ], RouterNat.prototype, "endpointTypes", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "icmpIdleTimeoutSec" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "icmpIdleTimeoutSec", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "logConfig" }),
        (0, class_transformer_1.Type)(function () { return routernatlogconfig_1.RouterNatLogConfig; }),
        __metadata("design:type", routernatlogconfig_1.RouterNatLogConfig)
    ], RouterNat.prototype, "logConfig", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "maxPortsPerVm" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "maxPortsPerVm", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "minPortsPerVm" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "minPortsPerVm", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "name" }),
        __metadata("design:type", String)
    ], RouterNat.prototype, "name", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "natIpAllocateOption" }),
        __metadata("design:type", String)
    ], RouterNat.prototype, "natIpAllocateOption", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "natIps" }),
        __metadata("design:type", Array)
    ], RouterNat.prototype, "natIps", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: routernatrule_1.RouterNatRule }),
        (0, class_transformer_1.Expose)({ name: "rules" }),
        (0, class_transformer_1.Type)(function () { return routernatrule_1.RouterNatRule; }),
        __metadata("design:type", Array)
    ], RouterNat.prototype, "rules", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "sourceSubnetworkIpRangesToNat" }),
        __metadata("design:type", String)
    ], RouterNat.prototype, "sourceSubnetworkIpRangesToNat", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)({ elemType: routernatsubnetworktonat_1.RouterNatSubnetworkToNat }),
        (0, class_transformer_1.Expose)({ name: "subnetworks" }),
        (0, class_transformer_1.Type)(function () { return routernatsubnetworktonat_1.RouterNatSubnetworkToNat; }),
        __metadata("design:type", Array)
    ], RouterNat.prototype, "subnetworks", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "tcpEstablishedIdleTimeoutSec" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "tcpEstablishedIdleTimeoutSec", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "tcpTimeWaitTimeoutSec" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "tcpTimeWaitTimeoutSec", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "tcpTransitoryIdleTimeoutSec" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "tcpTransitoryIdleTimeoutSec", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "type" }),
        __metadata("design:type", String)
    ], RouterNat.prototype, "type", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "udpIdleTimeoutSec" }),
        __metadata("design:type", Number)
    ], RouterNat.prototype, "udpIdleTimeoutSec", void 0);
    return RouterNat;
}(utils_1.SpeakeasyBase));
exports.RouterNat = RouterNat;
