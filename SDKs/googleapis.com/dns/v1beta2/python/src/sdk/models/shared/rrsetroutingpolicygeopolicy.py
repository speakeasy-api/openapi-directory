"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import rrsetroutingpolicygeopolicygeopolicyitem as shared_rrsetroutingpolicygeopolicygeopolicyitem
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RRSetRoutingPolicyGeoPolicy:
    r"""Configures a RRSetRoutingPolicy that routes based on the geo location of the querying user."""
    
    enable_fencing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enableFencing'), 'exclude': lambda f: f is None }})
    r"""Without fencing, if health check fails for all configured items in the current geo bucket, we'll failover to the next nearest geo bucket. With fencing, if health check is enabled, as long as some targets in the current geo bucket are healthy, we'll return only the healthy targets. However, if they're all unhealthy, we won't failover to the next nearest bucket, we'll simply return all the items in the current bucket even though they're unhealthy."""  
    items: Optional[list[shared_rrsetroutingpolicygeopolicygeopolicyitem.RRSetRoutingPolicyGeoPolicyGeoPolicyItem]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items'), 'exclude': lambda f: f is None }})
    r"""The primary geo routing configuration. If there are multiple items with the same location, an error is returned instead."""  
    kind: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kind'), 'exclude': lambda f: f is None }})  
    