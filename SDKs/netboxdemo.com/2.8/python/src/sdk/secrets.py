"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Secrets:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def secrets_generate_rsa_key_pair_list(self) -> operations.SecretsGenerateRsaKeyPairListResponse:
        r"""This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.
        {
                \"public_key\": \"<public key>\",
                \"private_key\": \"<private key>\"
            }
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/secrets/generate-rsa-key-pair/'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsGenerateRsaKeyPairListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def secrets_get_session_key_create(self) -> operations.SecretsGetSessionKeyCreateResponse:
        r"""Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user's private RSA
        key is POSTed with the name `private_key`. An example:
        
            curl -v -X POST -H \\"Authorization: Token <token>\\" -H \\"Accept: application/json; indent=4\\" \
            --data-urlencode \\"private_key@<filename>\\" https://netbox/api/secrets/get-session-key/
        
        This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:
        
            {
                \\"session_key\\": \\"+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf=\\"
            }
        
        This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session
        key will be returned instead of a new one.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/secrets/get-session-key/'
        
        
        client = self._security_client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsGetSessionKeyCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def secrets_secret_roles_create(self, request: shared.SecretRoleInput) -> operations.SecretsSecretRolesCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/secrets/secret-roles/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretRolesCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SecretRole])
                res.secret_role = out

        return res

    def secrets_secret_roles_delete(self, request: operations.SecretsSecretRolesDeleteRequest) -> operations.SecretsSecretRolesDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretRolesDeleteRequest, base_url, '/secrets/secret-roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretRolesDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def secrets_secret_roles_list(self, request: operations.SecretsSecretRolesListRequest) -> operations.SecretsSecretRolesListResponse:
        r"""Call to super to allow for caching"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/secrets/secret-roles/'
        
        query_params = utils.get_query_params(operations.SecretsSecretRolesListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretRolesListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.SecretsSecretRolesList200ApplicationJSON])
                res.secrets_secret_roles_list_200_application_json_object = out

        return res

    def secrets_secret_roles_partial_update(self, request: operations.SecretsSecretRolesPartialUpdateRequest) -> operations.SecretsSecretRolesPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretRolesPartialUpdateRequest, base_url, '/secrets/secret-roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "secret_role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretRolesPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SecretRole])
                res.secret_role = out

        return res

    def secrets_secret_roles_read(self, request: operations.SecretsSecretRolesReadRequest) -> operations.SecretsSecretRolesReadResponse:
        r"""Call to super to allow for caching"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretRolesReadRequest, base_url, '/secrets/secret-roles/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretRolesReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SecretRole])
                res.secret_role = out

        return res

    def secrets_secret_roles_update(self, request: operations.SecretsSecretRolesUpdateRequest) -> operations.SecretsSecretRolesUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretRolesUpdateRequest, base_url, '/secrets/secret-roles/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "secret_role_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretRolesUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SecretRole])
                res.secret_role = out

        return res

    def secrets_secrets_create(self, request: shared.WritableSecretInput) -> operations.SecretsSecretsCreateResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/secrets/secrets/'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretsCreateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Secret])
                res.secret = out

        return res

    def secrets_secrets_delete(self, request: operations.SecretsSecretsDeleteRequest) -> operations.SecretsSecretsDeleteResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretsDeleteRequest, base_url, '/secrets/secrets/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretsDeleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def secrets_secrets_list(self, request: operations.SecretsSecretsListRequest) -> operations.SecretsSecretsListResponse:
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/secrets/secrets/'
        
        query_params = utils.get_query_params(operations.SecretsSecretsListRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretsListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.SecretsSecretsList200ApplicationJSON])
                res.secrets_secrets_list_200_application_json_object = out

        return res

    def secrets_secrets_partial_update(self, request: operations.SecretsSecretsPartialUpdateRequest) -> operations.SecretsSecretsPartialUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretsPartialUpdateRequest, base_url, '/secrets/secrets/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_secret_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PATCH', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretsPartialUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Secret])
                res.secret = out

        return res

    def secrets_secrets_read(self, request: operations.SecretsSecretsReadRequest) -> operations.SecretsSecretsReadResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretsReadRequest, base_url, '/secrets/secrets/{id}/', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretsReadResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Secret])
                res.secret = out

        return res

    def secrets_secrets_update(self, request: operations.SecretsSecretsUpdateRequest) -> operations.SecretsSecretsUpdateResponse:
        base_url = self._server_url
        
        url = utils.generate_url(operations.SecretsSecretsUpdateRequest, base_url, '/secrets/secrets/{id}/', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "writable_secret_input", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._security_client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SecretsSecretsUpdateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Secret])
                res.secret = out

        return res

    