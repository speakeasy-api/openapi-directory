/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Many of the Vonage APIs are accessed using an API key and secret. It is recommended that you change or "rotate" your secrets from time to time for security purposes. This section provides the API interface for achieving this.
 *
 * @remarks
 * Note: to work on secrets for your secondary accounts, you may authenticate with your primary credentials and supply the secondary API keys as URL parameters to these API endpoints.
 */
export class SecretManagement {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create API Secret
   */
  createAPISecret(
    req: operations.CreateAPISecretRequest,
    security: operations.CreateAPISecretSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAPISecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAPISecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{api_key}/secrets",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createSecretRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateAPISecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAPISecretResponse =
        new operations.CreateAPISecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.secretInfo = utils.objectToClass(
              httpRes?.data,
              shared.SecretInfo
            );
          }
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createAPISecret400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CreateAPISecret400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createAPISecret401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.CreateAPISecret401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorAPIKeyNotFound = utils.objectToClass(
              httpRes?.data,
              shared.ErrorAPIKeyNotFound
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve one API Secret
   */
  retrieveAPISecret(
    req: operations.RetrieveAPISecretRequest,
    security: operations.RetrieveAPISecretSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAPISecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAPISecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{api_key}/secrets/{secret_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RetrieveAPISecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAPISecretResponse =
        new operations.RetrieveAPISecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.secretInfo = utils.objectToClass(
              httpRes?.data,
              shared.SecretInfo
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.retrieveAPISecret401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.RetrieveAPISecret401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.retrieveAPISecret404ApplicationJSONOneOf = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve API Secrets
   */
  retrieveAPISecrets(
    req: operations.RetrieveAPISecretsRequest,
    security: operations.RetrieveAPISecretsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveAPISecretsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveAPISecretsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{api_key}/secrets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RetrieveAPISecretsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RetrieveAPISecretsResponse =
        new operations.RetrieveAPISecretsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.retrieveAPISecrets200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RetrieveAPISecrets200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.retrieveAPISecrets401ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RetrieveAPISecrets401ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorAPIKeyNotFound = utils.objectToClass(
              httpRes?.data,
              shared.ErrorAPIKeyNotFound
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Revoke an API Secret
   */
  revokeAPISecret(
    req: operations.RevokeAPISecretRequest,
    security: operations.RevokeAPISecretSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RevokeAPISecretResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RevokeAPISecretRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/accounts/{api_key}/secrets/{secret_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RevokeAPISecretSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RevokeAPISecretResponse =
        new operations.RevokeAPISecretResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.revokeAPISecret401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.RevokeAPISecret401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.revokeAPISecret403ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.RevokeAPISecret403ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.revokeAPISecret404ApplicationJSONOneOf = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
