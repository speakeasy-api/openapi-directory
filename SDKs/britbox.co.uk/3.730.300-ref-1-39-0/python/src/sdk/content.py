"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Content:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def get_anon_next_playback_item(self, request: operations.GetAnonNextPlaybackItemRequest) -> operations.GetAnonNextPlaybackItemResponse:
        r"""Identical to GET /account/profile/items/{itemId}/next route but for users
        that are not logged in i.e. this endpoint does not require authorisation
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAnonNextPlaybackItemRequest, base_url, '/items/{itemId}/next', request)
        
        query_params = utils.get_query_params(operations.GetAnonNextPlaybackItemRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAnonNextPlaybackItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NextPlaybackItem])
                res.next_playback_item = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item(self, request: operations.GetItemRequest) -> operations.GetItemResponse:
        r"""Returns the details of an item with the specified id."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemRequest, base_url, '/items/{id}', request)
        
        query_params = utils.get_query_params(operations.GetItemRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemDetail])
                res.item_detail = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_children_list(self, request: operations.GetItemChildrenListRequest) -> operations.GetItemChildrenListResponse:
        r"""Returns the List of child summary items under an item.
        
        If the item is a Season then the children will be episodes and ordered by episode number.
        
        If the item is a Show then the children will be Seasons and ordered by season number.
        
        Returns 404 if no children found.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemChildrenListRequest, base_url, '/items/{id}/children', request)
        
        query_params = utils.get_query_params(operations.GetItemChildrenListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemChildrenListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_downloadables(self, request: operations.GetItemDownloadablesRequest) -> operations.GetItemDownloadablesResponse:
        r"""Returns the details of an item with the specified id."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/itv/items/downloadable'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "item_downloadable_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GetItemDownloadablesRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemDownloadablesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemDownloadableList])
                res.item_downloadable_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_item_related_list(self, request: operations.GetItemRelatedListRequest) -> operations.GetItemRelatedListResponse:
        r"""Returns the list of items related to the parent item.
        
        Note for now, due to the size of the list being unknown, only a single page will be returned.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetItemRelatedListRequest, base_url, '/items/{id}/related', request)
        
        query_params = utils.get_query_params(operations.GetItemRelatedListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemRelatedListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_items_media_clip_files(self, request: operations.GetItemsMediaClipFilesRequest) -> operations.GetItemsMediaClipFilesResponse:
        r"""Get the media clip files associated with items."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/itv/items/clips'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "item_downloadable_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.GetItemsMediaClipFilesRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetItemsMediaClipFilesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemClipFilesList])
                res.item_clip_files_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_list(self, request: operations.GetListRequest) -> operations.GetListResponse:
        r"""Returns a list of items under the specified item list"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetListRequest, base_url, '/lists/{id}', request)
        
        query_params = utils.get_query_params(operations.GetListRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetListResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ItemList])
                res.item_list = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_lists(self, request: operations.GetListsRequest) -> operations.GetListsResponse:
        r"""Returns an array of item lists with their first page of content resolved."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/lists'
        
        query_params = utils.get_query_params(operations.GetListsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetListsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ItemList]])
                res.item_lists = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_public_item_media_files(self, request: operations.GetPublicItemMediaFilesRequest) -> operations.GetPublicItemMediaFilesResponse:
        r"""Get the free / public video files associated with an item given maximum resolution,
        device type and one or more delivery types.
        
        Returns an array of video file objects which each include a url to a video.
        
        The first entry in the array contains what is predicted to be the best match.
        The remainder of the entries, if any, may contain resolutions below what was
        requests. For example if you request HD-720 the response may also contain
        SD entries.
        
        If you specify multiple delivery types, then the response array will insert
        types in the order you specify them in the query. For example `stream,progressive`
        would return an array with 0 or more stream files followed by 0 or more progressive files.
        
        If no files are found a 404 is returned.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPublicItemMediaFilesRequest, base_url, '/items/{id}/videos', request)
        
        query_params = utils.get_query_params(operations.GetPublicItemMediaFilesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPublicItemMediaFilesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.MediaFile]])
                res.media_files = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_schedules(self, request: operations.GetSchedulesRequest) -> operations.GetSchedulesResponse:
        r"""Returns schedules for a defined set of channels over a requested period.
        
        Schedules are requested in hour blocks and returned grouped by the channel
        they belong to.
        
        For example, to load 12 hours of schedules for channels `4343` and `5234`,
        on 21/2/2017 starting from 08:00.
        
        ```
        channels=4343,5234
        date=2017-02-21
        hour=8
        duration=12
        ```
        
        Please remember that `date` and `hour` combined represent a normal datetime, 
        so they should be converted to UTC on the client - this will help to avoid 
        issues with EPG schedules near midnight.
        
        If a channel id is passed which doesn't exist then this endpoint will
        return an empty schedule list for it. If instead we returned 404,
        this would invalidate all other channel schedules in the same request
        which would be unfriendly for clients presenting these channel schedules.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/schedules'
        
        query_params = utils.get_query_params(operations.GetSchedulesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetSchedulesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ItemScheduleList]])
                res.item_schedule_lists = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def get_plans_id_(self, request: operations.GetPlansIDRequest) -> operations.GetPlansIDResponse:
        r"""Returns the details of a Plan with the specified id."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPlansIDRequest, base_url, '/plans/{id}', request)
        
        query_params = utils.get_query_params(operations.GetPlansIDRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPlansIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Plan])
                res.plan = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    def search(self, request: operations.SearchRequest) -> operations.SearchResponse:
        r"""Search the catalog of items and people."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/search'
        
        query_params = utils.get_query_params(operations.SearchRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SearchResults])
                res.search_results = out
        else:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServiceError])
                res.service_error = out

        return res

    