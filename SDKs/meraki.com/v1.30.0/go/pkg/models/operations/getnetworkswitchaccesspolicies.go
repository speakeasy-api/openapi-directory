// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type GetNetworkSwitchAccessPoliciesPathParams struct {
	NetworkID string `pathParam:"style=simple,explode=false,name=networkId"`
}

type GetNetworkSwitchAccessPoliciesRequest struct {
	PathParams GetNetworkSwitchAccessPoliciesPathParams
}

// GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum - Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
type GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum string

const (
	GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnumEightHundredAndTwo1x    GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum = "802.1x"
	GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnumHybridAuthentication    GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum = "Hybrid authentication"
	GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnumMacAuthenticationBypass GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum = "MAC authentication bypass"
)

func (e *GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "802.1x":
		fallthrough
	case "Hybrid authentication":
		fallthrough
	case "MAC authentication bypass":
		*e = GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum: %s", s)
	}
}

// GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum - Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
type GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum string

const (
	GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnumBoth    GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum = "both"
	GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnumInbound GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum = "inbound"
)

func (e *GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "both":
		fallthrough
	case "inbound":
		*e = GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum: %s", s)
	}
}

// GetNetworkSwitchAccessPolicies200ApplicationJSONDot1x - 802.1x Settings
type GetNetworkSwitchAccessPolicies200ApplicationJSONDot1x struct {
	// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
	ControlDirection *GetNetworkSwitchAccessPolicies200ApplicationJSONDot1xControlDirectionEnum `json:"controlDirection,omitempty"`
}

// GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum - Choose the Host Mode for the access policy.
type GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum string

const (
	GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnumMultiAuth   GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum = "Multi-Auth"
	GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnumMultiDomain GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum = "Multi-Domain"
	GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnumMultiHost   GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum = "Multi-Host"
	GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnumSingleHost  GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum = "Single-Host"
)

func (e *GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Multi-Auth":
		fallthrough
	case "Multi-Domain":
		fallthrough
	case "Multi-Host":
		fallthrough
	case "Single-Host":
		*e = GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum: %s", s)
	}
}

// GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusCriticalAuth - Critical auth settings for when authentication is rejected by the RADIUS server
type GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusCriticalAuth struct {
	// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	DataVlanID *int64 `json:"dataVlanId,omitempty"`
	// Enable to suspend port bounce when RADIUS servers are unreachable
	SuspendPortBounce *bool `json:"suspendPortBounce,omitempty"`
	// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	VoiceVlanID *int64 `json:"voiceVlanId,omitempty"`
}

// GetNetworkSwitchAccessPolicies200ApplicationJSONRadius - Object for RADIUS Settings
type GetNetworkSwitchAccessPolicies200ApplicationJSONRadius struct {
	// Critical auth settings for when authentication is rejected by the RADIUS server
	CriticalAuth *GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusCriticalAuth `json:"criticalAuth,omitempty"`
	// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	FailedAuthVlanID *int64 `json:"failedAuthVlanId,omitempty"`
	// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
	ReAuthenticationInterval *int64 `json:"reAuthenticationInterval,omitempty"`
}

type GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusAccountingServers struct {
	// Public IP address of the RADIUS accounting server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS Accounting server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

type GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusServers struct {
	// Public IP address of the RADIUS server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

type GetNetworkSwitchAccessPolicies200ApplicationJSON struct {
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *GetNetworkSwitchAccessPolicies200ApplicationJSONAccessPolicyTypeEnum `json:"accessPolicyType,omitempty"`
	// 802.1x Settings
	Dot1x *GetNetworkSwitchAccessPolicies200ApplicationJSONDot1x `json:"dot1x,omitempty"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanID *int64 `json:"guestVlanId,omitempty"`
	// Choose the Host Mode for the access policy.
	HostMode *GetNetworkSwitchAccessPolicies200ApplicationJSONHostModeEnum `json:"hostMode,omitempty"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `json:"increaseAccessSpeed,omitempty"`
	// Name of the access policy
	Name *string `json:"name,omitempty"`
	// Object for RADIUS Settings
	Radius *GetNetworkSwitchAccessPolicies200ApplicationJSONRadius `json:"radius,omitempty"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `json:"radiusAccountingEnabled,omitempty"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `json:"radiusCoaSupportEnabled,omitempty"`
	// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
	RadiusGroupAttribute *string `json:"radiusGroupAttribute,omitempty"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []GetNetworkSwitchAccessPolicies200ApplicationJSONRadiusServers `json:"radiusServers,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `json:"radiusTestingEnabled,omitempty"`
	// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenEnabled *bool `json:"urlRedirectWalledGardenEnabled,omitempty"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenRanges []string `json:"urlRedirectWalledGardenRanges,omitempty"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `json:"voiceVlanClients,omitempty"`
}

type GetNetworkSwitchAccessPoliciesResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	GetNetworkSwitchAccessPolicies200ApplicationJSONObjects []GetNetworkSwitchAccessPolicies200ApplicationJSON
}
