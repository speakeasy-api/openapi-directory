// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
)

type SpotGet3AntennaReportLocations struct {
	// Antenna number
	AntennaNumber  *int64    `json:"antenna_number,omitempty"`
	ReportLocation *Location `json:"report_location,omitempty"`
	// Unique identifier for resource.
	ReportLocationID *string `json:"report_location_id,omitempty"`
	// Url to the individual resource.
	ReportLocationURL *string `json:"report_location_url,omitempty"`
}

type SpotGet3 struct {
	// You may configure this field to an object which couples individual antenna ports to locations.
	AntennaReportLocations []SpotGet3AntennaReportLocations `json:"antenna_report_locations,omitempty"`
	// JSON object with possible settings. Refer to individual service documentation for a good overview.
	Config map[string]interface{} `json:"config,omitempty"`
	// Object containing the new configuration. This will be applied automatically when the values are valid.
	ConfigRequest map[string]interface{} `json:"config_request,omitempty"`
	// Last known geolocation estimate of this object. Not guaranteed to be included in response.
	GeoCoords *GeoCoords `json:"geo_coords,omitempty"`
	// Unique identifier for resource.
	ID *string `json:"id,omitempty"`
	// Whether or not this resource is actively connected to the Brain.
	IsOnline *bool `json:"is_online,omitempty"`
	// Url to the individual resource.
	ReportLocationURL *string `json:"report_location_url,omitempty"`
	// The total number of HTTP requests that this resource has done.
	RequestCounter *int64 `json:"request_counter,omitempty"`
	// Senses are values that in most cases are generated inside the spot (number of presences, spot booted etc.). We also have a few senses that can be controlled by the brain. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information.
	Senses map[string]interface{} `json:"senses,omitempty"`
	// Object containing the new senses configuration. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information.
	SensesRequest map[string]interface{} `json:"senses_request,omitempty"`
	// This is the fixed and unique spot number. It's assigned during the production process and used to identify an individual device during its lifetime.
	SerialNumber *int64 `json:"serial_number,omitempty"`
	// An object with specific information about the spot, directly send by the spot itself when the connection is created.
	Status interface{} `json:"status,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created.
	TimeCreated *string `json:"time_created,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated.
	TimeUpdated *string `json:"time_updated,omitempty"`
	// Url to the individual resource.
	URL *string `json:"url,omitempty"`
}

type SpotGet2AntennaReportLocations struct {
	// Antenna number
	AntennaNumber  *int64    `json:"antenna_number,omitempty"`
	ReportLocation *Location `json:"report_location,omitempty"`
	// Unique identifier for resource.
	ReportLocationID *string `json:"report_location_id,omitempty"`
	// Url to the individual resource.
	ReportLocationURL *string `json:"report_location_url,omitempty"`
}

type SpotGet2 struct {
	// You may configure this field to an object which couples individual antenna ports to locations.
	AntennaReportLocations []SpotGet2AntennaReportLocations `json:"antenna_report_locations,omitempty"`
	// JSON object with possible settings. Refer to individual service documentation for a good overview.
	Config map[string]interface{} `json:"config,omitempty"`
	// Object containing the new configuration. This will be applied automatically when the values are valid.
	ConfigRequest map[string]interface{} `json:"config_request,omitempty"`
	// Last known geolocation estimate of this object. Not guaranteed to be included in response.
	GeoCoords *GeoCoords `json:"geo_coords,omitempty"`
	// Unique identifier for resource.
	ID *string `json:"id,omitempty"`
	// Whether or not this resource is actively connected to the Brain.
	IsOnline *bool `json:"is_online,omitempty"`
	// Unique identifier for resource.
	ReportLocationID *string `json:"report_location_id,omitempty"`
	// The total number of HTTP requests that this resource has done.
	RequestCounter *int64 `json:"request_counter,omitempty"`
	// Senses are values that in most cases are generated inside the spot (number of presences, spot booted etc.). We also have a few senses that can be controlled by the brain. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information.
	Senses map[string]interface{} `json:"senses,omitempty"`
	// Object containing the new senses configuration. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information.
	SensesRequest map[string]interface{} `json:"senses_request,omitempty"`
	// This is the fixed and unique spot number. It's assigned during the production process and used to identify an individual device during its lifetime.
	SerialNumber *int64 `json:"serial_number,omitempty"`
	// An object with specific information about the spot, directly send by the spot itself when the connection is created.
	Status interface{} `json:"status,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created.
	TimeCreated *string `json:"time_created,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated.
	TimeUpdated *string `json:"time_updated,omitempty"`
	// Url to the individual resource.
	URL *string `json:"url,omitempty"`
}

type SpotGet1AntennaReportLocations struct {
	// Antenna number
	AntennaNumber  *int64    `json:"antenna_number,omitempty"`
	ReportLocation *Location `json:"report_location,omitempty"`
	// Unique identifier for resource.
	ReportLocationID *string `json:"report_location_id,omitempty"`
	// Url to the individual resource.
	ReportLocationURL *string `json:"report_location_url,omitempty"`
}

type SpotGet1 struct {
	// You may configure this field to an object which couples individual antenna ports to locations.
	AntennaReportLocations []SpotGet1AntennaReportLocations `json:"antenna_report_locations,omitempty"`
	// JSON object with possible settings. Refer to individual service documentation for a good overview.
	Config map[string]interface{} `json:"config,omitempty"`
	// Object containing the new configuration. This will be applied automatically when the values are valid.
	ConfigRequest map[string]interface{} `json:"config_request,omitempty"`
	// Last known geolocation estimate of this object. Not guaranteed to be included in response.
	GeoCoords *GeoCoords `json:"geo_coords,omitempty"`
	// Unique identifier for resource.
	ID *string `json:"id,omitempty"`
	// Whether or not this resource is actively connected to the Brain.
	IsOnline       *bool     `json:"is_online,omitempty"`
	ReportLocation *Location `json:"report_location,omitempty"`
	// The total number of HTTP requests that this resource has done.
	RequestCounter *int64 `json:"request_counter,omitempty"`
	// Senses are values that in most cases are generated inside the spot (number of presences, spot booted etc.). We also have a few senses that can be controlled by the brain. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information.
	Senses map[string]interface{} `json:"senses,omitempty"`
	// Object containing the new senses configuration. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information.
	SensesRequest map[string]interface{} `json:"senses_request,omitempty"`
	// This is the fixed and unique spot number. It's assigned during the production process and used to identify an individual device during its lifetime.
	SerialNumber *int64 `json:"serial_number,omitempty"`
	// An object with specific information about the spot, directly send by the spot itself when the connection is created.
	Status interface{} `json:"status,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created.
	TimeCreated *string `json:"time_created,omitempty"`
	// [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated.
	TimeUpdated *string `json:"time_updated,omitempty"`
	// Url to the individual resource.
	URL *string `json:"url,omitempty"`
}

type SpotGetType string

const (
	SpotGetTypeSpotGet1 SpotGetType = "SpotGet_1"
	SpotGetTypeSpotGet2 SpotGetType = "SpotGet_2"
	SpotGetTypeSpotGet3 SpotGetType = "SpotGet_3"
)

type SpotGet struct {
	SpotGet1 *SpotGet1
	SpotGet2 *SpotGet2
	SpotGet3 *SpotGet3

	Type SpotGetType
}

func CreateSpotGetSpotGet1(spotGet1 SpotGet1) SpotGet {
	typ := SpotGetTypeSpotGet1

	return SpotGet{
		SpotGet1: &spotGet1,
		Type:     typ,
	}
}

func CreateSpotGetSpotGet2(spotGet2 SpotGet2) SpotGet {
	typ := SpotGetTypeSpotGet2

	return SpotGet{
		SpotGet2: &spotGet2,
		Type:     typ,
	}
}

func CreateSpotGetSpotGet3(spotGet3 SpotGet3) SpotGet {
	typ := SpotGetTypeSpotGet3

	return SpotGet{
		SpotGet3: &spotGet3,
		Type:     typ,
	}
}

func (u *SpotGet) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	spotGet1 := new(SpotGet1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&spotGet1); err == nil {
		u.SpotGet1 = spotGet1
		u.Type = SpotGetTypeSpotGet1
		return nil
	}

	spotGet2 := new(SpotGet2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&spotGet2); err == nil {
		u.SpotGet2 = spotGet2
		u.Type = SpotGetTypeSpotGet2
		return nil
	}

	spotGet3 := new(SpotGet3)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&spotGet3); err == nil {
		u.SpotGet3 = spotGet3
		u.Type = SpotGetTypeSpotGet3
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SpotGet) MarshalJSON() ([]byte, error) {
	if u.SpotGet1 != nil {
		return json.Marshal(u.SpotGet1)
	}

	if u.SpotGet2 != nil {
		return json.Marshal(u.SpotGet2)
	}

	if u.SpotGet3 != nil {
		return json.Marshal(u.SpotGet3)
	}

	return nil, nil
}
