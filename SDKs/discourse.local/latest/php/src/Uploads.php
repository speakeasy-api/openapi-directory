<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Uploads 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Abort multipart upload
     * 
     * This endpoint aborts the multipart upload initiated with /create-multipart.
     * This should be used when cancelling the upload. It does not matter if parts
     * were already uploaded into the external storage provider.
     * 
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     * 
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     * 
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AbortMultipartRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AbortMultipartResponse
     */
	public function abortMultipart(
        \OpenAPI\OpenAPI\Models\Operations\AbortMultipartRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AbortMultipartResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads/abort-multipart.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AbortMultipartResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->abortMultipart200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\AbortMultipart200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generates batches of presigned URLs for multipart parts
     * 
     * Multipart uploads are uploaded in chunks or parts to individual presigned
     * URLs, similar to the one generated by /generate-presigned-put. The part
     * numbers provided must be between 1 and 10000. The total number of parts
     * will depend on the chunk size in bytes that you intend to use to upload
     * each chunk. For example a 12MB file may have 2 5MB chunks and a final
     * 2MB chunk, for part numbers 1, 2, and 3.
     * 
     * This endpoint will return a presigned URL for each part number provided,
     * which you can then use to send PUT requests for the binary chunk corresponding
     * to that part. When the part is uploaded, the provider should return an
     * ETag for the part, and this should be stored along with the part number,
     * because this is needed to complete the multipart upload.
     * 
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     * 
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     * 
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BatchPresignMultipartPartsRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BatchPresignMultipartPartsResponse
     */
	public function batchPresignMultipartParts(
        \OpenAPI\OpenAPI\Models\Operations\BatchPresignMultipartPartsRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BatchPresignMultipartPartsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads/batch-presign-multipart-parts.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BatchPresignMultipartPartsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->batchPresignMultipartParts200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\BatchPresignMultipartParts200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Completes a direct external upload
     * 
     * Completes an external upload initialized with /get-presigned-put. The
     * file will be moved from its temporary location in external storage to
     * a final destination in the S3 bucket. An Upload record will also be
     * created in the database in most cases.
     * 
     * If a sha1-checksum was provided in the initial request it will also
     * be compared with the uploaded file in storage to make sure the same
     * file was uploaded. The file size will be compared for the same reason.
     * 
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     * 
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     * 
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteExternalUploadRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteExternalUploadResponse
     */
	public function completeExternalUpload(
        \OpenAPI\OpenAPI\Models\Operations\CompleteExternalUploadRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteExternalUploadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads/complete-external-upload.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteExternalUploadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->completeExternalUpload200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CompleteExternalUpload200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Complete multipart upload
     * 
     * Completes the multipart upload in the external store, and copies the
     * file from its temporary location to its final location in the store.
     * All of the parts must have been uploaded to the external storage provider.
     * An Upload record will be completed in most cases once the file is copied
     * to its final location.
     * 
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     * 
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     * 
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteMultipartRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteMultipartResponse
     */
	public function completeMultipart(
        \OpenAPI\OpenAPI\Models\Operations\CompleteMultipartRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteMultipartResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads/complete-multipart.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteMultipartResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->completeMultipart200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CompleteMultipart200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a multipart external upload
     * 
     * Creates a multipart upload in the external storage provider, storing
     * a temporary reference to the external upload similar to /get-presigned-put.
     * 
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     * 
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     * 
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateMultipartUploadRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateMultipartUploadResponse
     */
	public function createMultipartUpload(
        \OpenAPI\OpenAPI\Models\Operations\CreateMultipartUploadRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateMultipartUploadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads/create-multipart.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateMultipartUploadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createMultipartUpload200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateMultipartUpload200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates an upload
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateUploadRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateUploadResponse
     */
	public function createUpload(
        \OpenAPI\OpenAPI\Models\Operations\CreateUploadRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateUploadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateUploadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createUpload200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateUpload200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Initiates a direct external upload
     * 
     * Direct external uploads bypass the usual method of creating uploads
     * via the POST /uploads route, and upload directly to an external provider,
     * which by default is S3. This route begins the process, and will return
     * a unique identifier for the external upload as well as a presigned URL
     * which is where the file binary blob should be uploaded to.
     * 
     * Once the upload is complete to the external service, you must call the
     * POST /complete-external-upload route using the unique identifier returned
     * by this route, which will create any required Upload record in the Discourse
     * database and also move file from its temporary location to the final
     * destination in the external storage service.
     * 
     * You must have the correct permissions and CORS settings configured in your
     * external provider. We support AWS S3 as the default. See:
     * 
     * https://meta.discourse.org/t/-/210469#s3-multipart-direct-uploads-4.
     * 
     * An external file store must be set up and `enable_direct_s3_uploads` must
     * be set to true for this endpoint to function.
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedPutRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedPutResponse
     */
	public function generatePresignedPut(
        \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedPutRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedPutResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/uploads/generate-presigned-put.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedPutResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->generatePresignedPut200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GeneratePresignedPut200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}