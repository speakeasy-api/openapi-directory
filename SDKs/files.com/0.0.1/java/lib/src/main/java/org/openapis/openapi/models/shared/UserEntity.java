/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.time.OffsetDateTime;
import org.openapis.openapi.utils.DateTimeDeserializer;
import org.openapis.openapi.utils.DateTimeSerializer;

/**
 * UserEntity - Create User
 */
public class UserEntity {
    /**
     * Is 2fa active for the user?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("active_2fa")
    public Boolean active2fa;
    public UserEntity withActive2fa(Boolean active2fa) {
        this.active2fa = active2fa;
        return this;
    }
    
    /**
     * List of group IDs of which this user is an administrator
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("admin_group_ids")
    public Integer[] adminGroupIds;
    public UserEntity withAdminGroupIds(Integer[] adminGroupIds) {
        this.adminGroupIds = adminGroupIds;
        return this;
    }
    
    /**
     * A list of allowed IPs if applicable.  Newline delimited
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowed_ips")
    public String allowedIps;
    public UserEntity withAllowedIps(String allowedIps) {
        this.allowedIps = allowedIps;
        return this;
    }
    
    /**
     * Number of api keys associated with this user
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("api_keys_count")
    public Integer apiKeysCount;
    public UserEntity withApiKeysCount(Integer apiKeysCount) {
        this.apiKeysCount = apiKeysCount;
        return this;
    }
    
    /**
     * DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("attachments_permission")
    public Boolean attachmentsPermission;
    public UserEntity withAttachmentsPermission(Boolean attachmentsPermission) {
        this.attachmentsPermission = attachmentsPermission;
        return this;
    }
    
    /**
     * Scheduled Date/Time at which user will be deactivated
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("authenticate_until")
    public OffsetDateTime authenticateUntil;
    public UserEntity withAuthenticateUntil(OffsetDateTime authenticateUntil) {
        this.authenticateUntil = authenticateUntil;
        return this;
    }
    
    /**
     * How is this user authenticated?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("authentication_method")
    public UserEntityAuthenticationMethodEnum authenticationMethod;
    public UserEntity withAuthenticationMethod(UserEntityAuthenticationMethodEnum authenticationMethod) {
        this.authenticationMethod = authenticationMethod;
        return this;
    }
    
    /**
     * URL holding the user's avatar
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("avatar_url")
    public String avatarUrl;
    public UserEntity withAvatarUrl(String avatarUrl) {
        this.avatarUrl = avatarUrl;
        return this;
    }
    
    /**
     * Allow this user to perform operations on the account, payments, and invoices?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("billing_permission")
    public Boolean billingPermission;
    public UserEntity withBillingPermission(Boolean billingPermission) {
        this.billingPermission = billingPermission;
        return this;
    }
    
    /**
     * Exempt this user from being disabled based on inactivity?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bypass_inactive_disable")
    public Boolean bypassInactiveDisable;
    public UserEntity withBypassInactiveDisable(Boolean bypassInactiveDisable) {
        this.bypassInactiveDisable = bypassInactiveDisable;
        return this;
    }
    
    /**
     * Allow this user to skip site-wide IP blacklists?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("bypass_site_allowed_ips")
    public Boolean bypassSiteAllowedIps;
    public UserEntity withBypassSiteAllowedIps(Boolean bypassSiteAllowedIps) {
        this.bypassSiteAllowedIps = bypassSiteAllowedIps;
        return this;
    }
    
    /**
     * User's company
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("company")
    public String company;
    public UserEntity withCompany(String company) {
        this.company = company;
        return this;
    }
    
    /**
     * When this user was created
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("created_at")
    public OffsetDateTime createdAt;
    public UserEntity withCreatedAt(OffsetDateTime createdAt) {
        this.createdAt = createdAt;
        return this;
    }
    
    /**
     * Can the user connect with WebDAV?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dav_permission")
    public Boolean davPermission;
    public UserEntity withDavPermission(Boolean davPermission) {
        this.davPermission = davPermission;
        return this;
    }
    
    /**
     * Number of days remaining until password expires
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("days_remaining_until_password_expire")
    public Integer daysRemainingUntilPasswordExpire;
    public UserEntity withDaysRemainingUntilPasswordExpire(Integer daysRemainingUntilPasswordExpire) {
        this.daysRemainingUntilPasswordExpire = daysRemainingUntilPasswordExpire;
        return this;
    }
    
    /**
     * Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("disabled")
    public Boolean disabled;
    public UserEntity withDisabled(Boolean disabled) {
        this.disabled = disabled;
        return this;
    }
    
    /**
     * User email address
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("email")
    public String email;
    public UserEntity withEmail(String email) {
        this.email = email;
        return this;
    }
    
    /**
     * Is this user managed by a SsoStrategy?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("externally_managed")
    public Boolean externallyManaged;
    public UserEntity withExternallyManaged(Boolean externallyManaged) {
        this.externallyManaged = externallyManaged;
        return this;
    }
    
    /**
     * User's first login time
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("first_login_at")
    public OffsetDateTime firstLoginAt;
    public UserEntity withFirstLoginAt(OffsetDateTime firstLoginAt) {
        this.firstLoginAt = firstLoginAt;
        return this;
    }
    
    /**
     * Can the user access with FTP/FTPS?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ftp_permission")
    public Boolean ftpPermission;
    public UserEntity withFtpPermission(Boolean ftpPermission) {
        this.ftpPermission = ftpPermission;
        return this;
    }
    
    /**
     * Comma-separated list of group IDs of which this user is a member
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("group_ids")
    public String groupIds;
    public UserEntity withGroupIds(String groupIds) {
        this.groupIds = groupIds;
        return this;
    }
    
    /**
     * Text to display to the user in the header of the UI
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("header_text")
    public String headerText;
    public UserEntity withHeaderText(String headerText) {
        this.headerText = headerText;
        return this;
    }
    
    /**
     * User ID
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    public Integer id;
    public UserEntity withId(Integer id) {
        this.id = id;
        return this;
    }
    
    /**
     * Preferred language
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("language")
    public String language;
    public UserEntity withLanguage(String language) {
        this.language = language;
        return this;
    }
    
    /**
     * User's most recent activity time, which is the latest of most recent login, most recent API use, enablement, or creation
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_active_at")
    public OffsetDateTime lastActiveAt;
    public UserEntity withLastActiveAt(OffsetDateTime lastActiveAt) {
        this.lastActiveAt = lastActiveAt;
        return this;
    }
    
    /**
     * User's most recent API use time
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_api_use_at")
    public OffsetDateTime lastApiUseAt;
    public UserEntity withLastApiUseAt(OffsetDateTime lastApiUseAt) {
        this.lastApiUseAt = lastApiUseAt;
        return this;
    }
    
    /**
     * User's most recent login time via WebDAV
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_dav_login_at")
    public OffsetDateTime lastDavLoginAt;
    public UserEntity withLastDavLoginAt(OffsetDateTime lastDavLoginAt) {
        this.lastDavLoginAt = lastDavLoginAt;
        return this;
    }
    
    /**
     * User's most recent login time via Desktop app
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_desktop_login_at")
    public OffsetDateTime lastDesktopLoginAt;
    public UserEntity withLastDesktopLoginAt(OffsetDateTime lastDesktopLoginAt) {
        this.lastDesktopLoginAt = lastDesktopLoginAt;
        return this;
    }
    
    /**
     * User's most recent login time via FTP
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_ftp_login_at")
    public OffsetDateTime lastFtpLoginAt;
    public UserEntity withLastFtpLoginAt(OffsetDateTime lastFtpLoginAt) {
        this.lastFtpLoginAt = lastFtpLoginAt;
        return this;
    }
    
    /**
     * User's most recent login time via any protocol
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_login_at")
    public OffsetDateTime lastLoginAt;
    public UserEntity withLastLoginAt(OffsetDateTime lastLoginAt) {
        this.lastLoginAt = lastLoginAt;
        return this;
    }
    
    /**
     * The most recent protocol and cipher used
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("last_protocol_cipher")
    public String lastProtocolCipher;
    public UserEntity withLastProtocolCipher(String lastProtocolCipher) {
        this.lastProtocolCipher = lastProtocolCipher;
        return this;
    }
    
    /**
     * User's most recent login time via Rest API
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_restapi_login_at")
    public OffsetDateTime lastRestapiLoginAt;
    public UserEntity withLastRestapiLoginAt(OffsetDateTime lastRestapiLoginAt) {
        this.lastRestapiLoginAt = lastRestapiLoginAt;
        return this;
    }
    
    /**
     * User's most recent login time via SFTP
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_sftp_login_at")
    public OffsetDateTime lastSftpLoginAt;
    public UserEntity withLastSftpLoginAt(OffsetDateTime lastSftpLoginAt) {
        this.lastSftpLoginAt = lastSftpLoginAt;
        return this;
    }
    
    /**
     * User's most recent login time via web
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("last_web_login_at")
    public OffsetDateTime lastWebLoginAt;
    public UserEntity withLastWebLoginAt(OffsetDateTime lastWebLoginAt) {
        this.lastWebLoginAt = lastWebLoginAt;
        return this;
    }
    
    /**
     * Time in the future that the user will no longer be locked out if applicable
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("lockout_expires")
    public OffsetDateTime lockoutExpires;
    public UserEntity withLockoutExpires(OffsetDateTime lockoutExpires) {
        this.lockoutExpires = lockoutExpires;
        return this;
    }
    
    /**
     * User's full name
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    public String name;
    public UserEntity withName(String name) {
        this.name = name;
        return this;
    }
    
    /**
     * Any internal notes on the user
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notes")
    public String notes;
    public UserEntity withNotes(String notes) {
        this.notes = notes;
        return this;
    }
    
    /**
     * Hour of the day at which daily notifications should be sent. Can be in range 0 to 23
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("notification_daily_send_time")
    public Integer notificationDailySendTime;
    public UserEntity withNotificationDailySendTime(Integer notificationDailySendTime) {
        this.notificationDailySendTime = notificationDailySendTime;
        return this;
    }
    
    /**
     * Enable integration with Office for the web?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("office_integration_enabled")
    public Boolean officeIntegrationEnabled;
    public UserEntity withOfficeIntegrationEnabled(Boolean officeIntegrationEnabled) {
        this.officeIntegrationEnabled = officeIntegrationEnabled;
        return this;
    }
    
    /**
     * Password expiration datetime
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("password_expire_at")
    public OffsetDateTime passwordExpireAt;
    public UserEntity withPasswordExpireAt(OffsetDateTime passwordExpireAt) {
        this.passwordExpireAt = passwordExpireAt;
        return this;
    }
    
    /**
     * Is user's password expired?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("password_expired")
    public Boolean passwordExpired;
    public UserEntity withPasswordExpired(Boolean passwordExpired) {
        this.passwordExpired = passwordExpired;
        return this;
    }
    
    /**
     * Last time the user's password was set
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("password_set_at")
    public OffsetDateTime passwordSetAt;
    public UserEntity withPasswordSetAt(OffsetDateTime passwordSetAt) {
        this.passwordSetAt = passwordSetAt;
        return this;
    }
    
    /**
     * Number of days to allow user to use the same password
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("password_validity_days")
    public Integer passwordValidityDays;
    public UserEntity withPasswordValidityDays(Integer passwordValidityDays) {
        this.passwordValidityDays = passwordValidityDays;
        return this;
    }
    
    /**
     * Number of public keys associated with this user
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("public_keys_count")
    public Integer publicKeysCount;
    public UserEntity withPublicKeysCount(Integer publicKeysCount) {
        this.publicKeysCount = publicKeysCount;
        return this;
    }
    
    /**
     * Should the user receive admin alerts such a certificate expiration notifications and overages?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("receive_admin_alerts")
    public Boolean receiveAdminAlerts;
    public UserEntity withReceiveAdminAlerts(Boolean receiveAdminAlerts) {
        this.receiveAdminAlerts = receiveAdminAlerts;
        return this;
    }
    
    /**
     * 2FA required setting
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("require_2fa")
    public UserEntityRequire2faEnum require2fa;
    public UserEntity withRequire2fa(UserEntityRequire2faEnum require2fa) {
        this.require2fa = require2fa;
        return this;
    }
    
    /**
     * Is a password change required upon next user login?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("require_password_change")
    public Boolean requirePasswordChange;
    public UserEntity withRequirePasswordChange(Boolean requirePasswordChange) {
        this.requirePasswordChange = requirePasswordChange;
        return this;
    }
    
    /**
     * Can this user access the REST API?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("restapi_permission")
    public Boolean restapiPermission;
    public UserEntity withRestapiPermission(Boolean restapiPermission) {
        this.restapiPermission = restapiPermission;
        return this;
    }
    
    /**
     * Does this user manage it's own credentials or is it a shared/bot user?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("self_managed")
    public Boolean selfManaged;
    public UserEntity withSelfManaged(Boolean selfManaged) {
        this.selfManaged = selfManaged;
        return this;
    }
    
    /**
     * Can the user access with SFTP?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sftp_permission")
    public Boolean sftpPermission;
    public UserEntity withSftpPermission(Boolean sftpPermission) {
        this.sftpPermission = sftpPermission;
        return this;
    }
    
    /**
     * Is the user an administrator for this site?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("site_admin")
    public Boolean siteAdmin;
    public UserEntity withSiteAdmin(Boolean siteAdmin) {
        this.siteAdmin = siteAdmin;
        return this;
    }
    
    /**
     * Skip Welcome page in the UI?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("skip_welcome_screen")
    public Boolean skipWelcomeScreen;
    public UserEntity withSkipWelcomeScreen(Boolean skipWelcomeScreen) {
        this.skipWelcomeScreen = skipWelcomeScreen;
        return this;
    }
    
    /**
     * SSL required setting
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("ssl_required")
    public UserEntitySslRequiredEnum sslRequired;
    public UserEntity withSslRequired(UserEntitySslRequiredEnum sslRequired) {
        this.sslRequired = sslRequired;
        return this;
    }
    
    /**
     * SSO (Single Sign On) strategy ID for the user, if applicable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sso_strategy_id")
    public Integer ssoStrategyId;
    public UserEntity withSsoStrategyId(Integer ssoStrategyId) {
        this.ssoStrategyId = ssoStrategyId;
        return this;
    }
    
    /**
     * Is the user subscribed to the newsletter?
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("subscribe_to_newsletter")
    public Boolean subscribeToNewsletter;
    public UserEntity withSubscribeToNewsletter(Boolean subscribeToNewsletter) {
        this.subscribeToNewsletter = subscribeToNewsletter;
        return this;
    }
    
    /**
     * User time zone
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("time_zone")
    public String timeZone;
    public UserEntity withTimeZone(String timeZone) {
        this.timeZone = timeZone;
        return this;
    }
    
    /**
     * Type(s) of 2FA methods in use.  Will be either `sms`, `totp`, `u2f`, `yubi`, or multiple values sorted alphabetically and joined by an underscore.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("type_of_2fa")
    public String typeOf2fa;
    public UserEntity withTypeOf2fa(String typeOf2fa) {
        this.typeOf2fa = typeOf2fa;
        return this;
    }
    
    /**
     * Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("user_root")
    public String userRoot;
    public UserEntity withUserRoot(String userRoot) {
        this.userRoot = userRoot;
        return this;
    }
    
    /**
     * User's username
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("username")
    public String username;
    public UserEntity withUsername(String username) {
        this.username = username;
        return this;
    }
    
}
