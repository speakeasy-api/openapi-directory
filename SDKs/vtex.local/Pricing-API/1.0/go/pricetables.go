// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/utils"
	"strings"
)

type priceTables struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newPriceTables(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *priceTables {
	return &priceTables{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// Getrulesforapricetable - Get rules for a price table
// This method will retrieve the rules from a specific Price Table.
//
// ## Response body example
//
// ```json
//
//	{
//	    "tradePolicyId": "b2c",
//	    "rules": [{
//	        "id": 0,
//	        "context": {
//	            "categories": {},
//	            "brands": {
//	                "2000009": "Whiskas"
//	            },
//	            "stockStatuses": null,
//	            "internalCategories": null,
//	            "markupRange": null,
//	            "dateRange": null
//	        },
//	        "percentualModifier": 15
//	    }]
//	}
//
// ```
func (s *priceTables) Getrulesforapricetable(ctx context.Context, request operations.GetrulesforapricetableRequest) (*operations.GetrulesforapricetableResponse, error) {
	baseURL := operations.GetrulesforapricetableServerList[0]
	if request.ServerURL != nil {
		baseURL = *request.ServerURL
	}

	url := utils.GenerateURL(ctx, baseURL, "/pricing/pipeline/catalog/{priceTableId}", request.PathParams, nil)

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request.Headers)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetrulesforapricetableResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *operations.Getrulesforapricetable200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Getrulesforapricetable200ApplicationJSONObject = out
		}
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 403:
		fallthrough
	case httpRes.StatusCode == 429:
	}

	return res, nil
}

// Listpricetables - List price tables
// This method will list all price tables.
//
// ## Response body example
//
// ```json
// [
//
//	"1",
//	"2",
//	"3",
//	"b2c",
//	"b2b",
//	"gold"
//
// ]
// ```
func (s *priceTables) Listpricetables(ctx context.Context, request operations.ListpricetablesRequest) (*operations.ListpricetablesResponse, error) {
	baseURL := operations.ListpricetablesServerList[0]
	if request.ServerURL != nil {
		baseURL = *request.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/pricing/tables"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request.Headers)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ListpricetablesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []string
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Listpricetables200ApplicationJSONStrings = out
		}
	}

	return res, nil
}

// Getallpricetablesandrules - Get all price tables and their rules
// This method will retrieve all price tables and their rules.
//
// ## Response body example
//
// ```json
// [
//
//	{
//	    "tradePolicyId": "2",
//	    "rules": [
//	        {
//	            "id": 0,
//	            "context": {
//	                "categories": {},
//	                "brands": {},
//	                "stockStatuses": null,
//	                "internalCategories": null,
//	                "markupRange": null,
//	                "dateRange": null
//	            },
//	            "percentualModifier": 20
//	        }
//	    ]
//	},
//	{
//	    "tradePolicyId": "b2c",
//	    "rules": [
//	        {
//	            "id": 0,
//	            "context": {
//	                "categories": {},
//	                "brands": {
//	                    "2000009": "Whiskas"
//	                },
//	                "stockStatuses": null,
//	                "internalCategories": null,
//	                "markupRange": null,
//	                "dateRange": null
//	            },
//	            "percentualModifier": 15
//	        }
//	    ]
//	}
//
// ]
// ```
func (s *priceTables) Getallpricetablesandrules(ctx context.Context, request operations.GetallpricetablesandrulesRequest) (*operations.GetallpricetablesandrulesResponse, error) {
	baseURL := operations.GetallpricetablesandrulesServerList[0]
	if request.ServerURL != nil {
		baseURL = *request.ServerURL
	}

	url := strings.TrimSuffix(baseURL, "/") + "/pricing/pipeline/catalog"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request.Headers)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetallpricetablesandrulesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out []operations.Getallpricetablesandrules200ApplicationJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.Getallpricetablesandrules200ApplicationJSONObjects = out
		}
	}

	return res, nil
}

// PutPricingPipelineCatalogPriceTableID - Update rules for a price table
// This method will update the rules from a specific Price Table. It will delete all the rules from the requested Price Table and create new rules based on the content of the request.
//
// ## Request body example
//
// ```json
//
//	{
//	    "rules": [
//	          {
//	               "id": 1,
//	               "context": {
//	                    "categories": {
//	                         "Category ID": "1",
//	                         "Category Name": "Alimentação"
//	                    },
//	                    "brands": {
//	                         "Brand ID": "2000002",
//	                         "Brand Name": "Whiskas"
//	                    },
//	                    "markupRange": {
//	                         "from": 0,
//	                         "to": 200
//	                    },
//	                    "dateRange": {
//	                         "from": "2022-01-23T19:00:00.000Z",
//	                         "to": "2023-10-26T00:00:00.000Z"
//	                    }
//	               },
//	               "percentualModifier": 0
//	          }
//	    ]
//	}
//
// ```
func (s *priceTables) PutPricingPipelineCatalogPriceTableID(ctx context.Context, request operations.PutPricingPipelineCatalogPriceTableIDRequest) (*operations.PutPricingPipelineCatalogPriceTableIDResponse, error) {
	baseURL := s.serverURL
	url := utils.GenerateURL(ctx, baseURL, "/pricing/pipeline/catalog/{priceTableId}", request.PathParams, nil)

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request.Headers)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutPricingPipelineCatalogPriceTableIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
	}

	return res, nil
}
