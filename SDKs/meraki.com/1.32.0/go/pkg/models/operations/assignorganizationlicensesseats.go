// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type AssignOrganizationLicensesSeatsRequestBody struct {
	// The ID of the SM license to assign seats from
	LicenseID string `json:"licenseId"`
	// The ID of the SM network to assign the seats to
	NetworkID string `json:"networkId"`
	// The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
	SeatCount int64 `json:"seatCount"`
}

type AssignOrganizationLicensesSeatsRequest struct {
	RequestBody    AssignOrganizationLicensesSeatsRequestBody `request:"mediaType=application/json"`
	OrganizationID string                                     `pathParam:"style=simple,explode=false,name=organizationId"`
}

type AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesPermanentlyQueuedLicenses struct {
	// The duration of the individual license
	DurationInDays *int64 `json:"durationInDays,omitempty"`
	// Permanently queued license ID
	ID *string `json:"id,omitempty"`
	// License key
	LicenseKey *string `json:"licenseKey,omitempty"`
	// License type
	LicenseType *string `json:"licenseType,omitempty"`
	// Order number
	OrderNumber *string `json:"orderNumber,omitempty"`
}

// AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum - The state of the license. All queued licenses have a status of `recentlyQueued`.
type AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum string

const (
	AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumActive         AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "active"
	AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumExpired        AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "expired"
	AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumExpiring       AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "expiring"
	AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumRecentlyQueued AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "recentlyQueued"
	AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumUnused         AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "unused"
	AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnumUnusedActive   AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum = "unusedActive"
)

func (e AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum) ToPointer() *AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum {
	return &e
}

func (e *AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "active":
		fallthrough
	case "expired":
		fallthrough
	case "expiring":
		fallthrough
	case "recentlyQueued":
		fallthrough
	case "unused":
		fallthrough
	case "unusedActive":
		*e = AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum: %v", v)
	}
}

type AssignOrganizationLicensesSeats200ApplicationJSONResultingLicenses struct {
	// The date the license started burning
	ActivationDate *string `json:"activationDate,omitempty"`
	// The date the license was claimed into the organization
	ClaimDate *string `json:"claimDate,omitempty"`
	// Serial number of the device the license is assigned to
	DeviceSerial *string `json:"deviceSerial,omitempty"`
	// The duration of the individual license
	DurationInDays *int64 `json:"durationInDays,omitempty"`
	// The date the license will expire
	ExpirationDate *string `json:"expirationDate,omitempty"`
	// The id of the head license this license is queued behind. If there is no head license, it returns nil.
	HeadLicenseID *string `json:"headLicenseId,omitempty"`
	// License ID
	ID *string `json:"id,omitempty"`
	// License key
	LicenseKey *string `json:"licenseKey,omitempty"`
	// License type
	LicenseType *string `json:"licenseType,omitempty"`
	// ID of the network the license is assigned to
	NetworkID *string `json:"networkId,omitempty"`
	// Order number
	OrderNumber *string `json:"orderNumber,omitempty"`
	// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
	PermanentlyQueuedLicenses []AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesPermanentlyQueuedLicenses `json:"permanentlyQueuedLicenses,omitempty"`
	// The number of seats of the license. Only applicable to SM licenses.
	SeatCount *int64 `json:"seatCount,omitempty"`
	// The state of the license. All queued licenses have a status of `recentlyQueued`.
	State *AssignOrganizationLicensesSeats200ApplicationJSONResultingLicensesStateEnum `json:"state,omitempty"`
	// The duration of the license plus all permanently queued licenses associated with it
	TotalDurationInDays *int64 `json:"totalDurationInDays,omitempty"`
}

// AssignOrganizationLicensesSeats200ApplicationJSON - Successful operation
type AssignOrganizationLicensesSeats200ApplicationJSON struct {
	// Resulting licenses from the move
	ResultingLicenses []AssignOrganizationLicensesSeats200ApplicationJSONResultingLicenses `json:"resultingLicenses,omitempty"`
}

type AssignOrganizationLicensesSeatsResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	AssignOrganizationLicensesSeats200ApplicationJSONObject *AssignOrganizationLicensesSeats200ApplicationJSON
}
