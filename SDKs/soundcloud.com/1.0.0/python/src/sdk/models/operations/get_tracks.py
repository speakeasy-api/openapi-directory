"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import access_enum as shared_access_enum
from ..shared import bpm as shared_bpm
from ..shared import created_at as shared_created_at
from ..shared import duration as shared_duration
from ..shared import error as shared_error
from typing import Any, Optional


@dataclasses.dataclass
class GetTracksSecurity:
    
    auth_header: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'apiKey', 'sub_type': 'header', 'field_name': 'Authorization' }})  
    client_id: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'apiKey', 'sub_type': 'query', 'field_name': 'client_id' }})  
    

@dataclasses.dataclass
class GetTracksRequest:
    
    q: str = dataclasses.field(metadata={'query_param': { 'field_name': 'q', 'style': 'form', 'explode': True }})
    r"""search"""  
    access: Optional[list[shared_access_enum.AccessEnum]] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'access', 'style': 'form', 'explode': False }})
    r"""Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details."""  
    bpm: Optional[shared_bpm.Bpm] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'bpm', 'style': 'deepObject', 'explode': True }})
    r"""Return tracks with a specified bpm[from], bpm[to]"""  
    created_at: Optional[shared_created_at.CreatedAt] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'created_at', 'style': 'deepObject', 'explode': True }})
    r"""(yyyy-mm-dd hh:mm:ss) return tracks created within the specified dates"""  
    duration: Optional[shared_duration.Duration] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'duration', 'style': 'deepObject', 'explode': True }})
    r"""Return tracks within a specified duration range"""  
    genres: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'genres', 'style': 'form', 'explode': True }})
    r"""A comma separated list of genres"""  
    ids: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'ids', 'style': 'form', 'explode': True }})
    r"""A comma separated list of track ids to filter on"""  
    limit: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'limit', 'style': 'form', 'explode': True }})
    r"""Number of results to return in the collection."""  
    linked_partitioning: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'linked_partitioning', 'style': 'form', 'explode': True }})
    r"""Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)"""  
    offset: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'offset', 'style': 'form', 'explode': True }})
    r"""Offset of first result. Deprecated, use `linked_partitioning` instead."""  
    tags: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'tags', 'style': 'form', 'explode': True }})
    r"""A comma separated list of tags"""  
    

@dataclasses.dataclass
class GetTracksResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    error: Optional[shared_error.Error] = dataclasses.field(default=None)
    r"""Bad Request"""  
    get_tracks_200_application_json_one_of: Optional[Any] = dataclasses.field(default=None)
    r"""Success"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    