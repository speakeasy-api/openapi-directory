// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetTracksTrackIDRelatedSecurity struct {
	ClientID string `security:"scheme,type=apiKey,subtype=query,name=client_id"`
}

type GetTracksTrackIDRelatedRequest struct {
	// Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	//
	Access []shared.AccessEnum `queryParam:"style=form,explode=false,name=access"`
	// Number of results to return in the collection.
	Limit *int64 `queryParam:"style=form,explode=true,name=limit"`
	// Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *bool `queryParam:"style=form,explode=true,name=linked_partitioning"`
	// Offset of first result. Deprecated, use `linked_partitioning` instead.
	//
	// Deprecated: this field will be removed in a future release, please migrate away from it as soon as possible.
	Offset *int64 `queryParam:"style=form,explode=true,name=offset"`
	// SoundCloud Track id
	TrackID int64 `pathParam:"style=simple,explode=false,name=track_id"`
}

type GetTracksTrackIDRelated200ApplicationJSONType string

const (
	GetTracksTrackIDRelated200ApplicationJSONTypeTracks       GetTracksTrackIDRelated200ApplicationJSONType = "Tracks"
	GetTracksTrackIDRelated200ApplicationJSONTypeArrayOfTrack GetTracksTrackIDRelated200ApplicationJSONType = "arrayOfTrack"
)

type GetTracksTrackIDRelated200ApplicationJSON struct {
	Tracks       *shared.Tracks
	ArrayOfTrack []shared.Track

	Type GetTracksTrackIDRelated200ApplicationJSONType
}

func CreateGetTracksTrackIDRelated200ApplicationJSONTracks(tracks shared.Tracks) GetTracksTrackIDRelated200ApplicationJSON {
	typ := GetTracksTrackIDRelated200ApplicationJSONTypeTracks

	return GetTracksTrackIDRelated200ApplicationJSON{
		Tracks: &tracks,
		Type:   typ,
	}
}

func CreateGetTracksTrackIDRelated200ApplicationJSONArrayOfTrack(arrayOfTrack []shared.Track) GetTracksTrackIDRelated200ApplicationJSON {
	typ := GetTracksTrackIDRelated200ApplicationJSONTypeArrayOfTrack

	return GetTracksTrackIDRelated200ApplicationJSON{
		ArrayOfTrack: arrayOfTrack,
		Type:         typ,
	}
}

func (u *GetTracksTrackIDRelated200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	tracks := new(shared.Tracks)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&tracks); err == nil {
		u.Tracks = tracks
		u.Type = GetTracksTrackIDRelated200ApplicationJSONTypeTracks
		return nil
	}

	arrayOfTrack := []shared.Track{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfTrack); err == nil {
		u.ArrayOfTrack = arrayOfTrack
		u.Type = GetTracksTrackIDRelated200ApplicationJSONTypeArrayOfTrack
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetTracksTrackIDRelated200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.Tracks != nil {
		return json.Marshal(u.Tracks)
	}

	if u.ArrayOfTrack != nil {
		return json.Marshal(u.ArrayOfTrack)
	}

	return nil, nil
}

type GetTracksTrackIDRelatedResponse struct {
	ContentType string
	// Unauthorized
	Error       *shared.Error
	StatusCode  int
	RawResponse *http.Response
	// Success
	GetTracksTrackIDRelated200ApplicationJSONOneOf *GetTracksTrackIDRelated200ApplicationJSON
}
