// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
	"time"
)

// PatchBundlesIDRequestBodyPermissionsEnum - Permissions that apply to Folders in this Share Link.
type PatchBundlesIDRequestBodyPermissionsEnum string

const (
	PatchBundlesIDRequestBodyPermissionsEnumRead        PatchBundlesIDRequestBodyPermissionsEnum = "read"
	PatchBundlesIDRequestBodyPermissionsEnumWrite       PatchBundlesIDRequestBodyPermissionsEnum = "write"
	PatchBundlesIDRequestBodyPermissionsEnumReadWrite   PatchBundlesIDRequestBodyPermissionsEnum = "read_write"
	PatchBundlesIDRequestBodyPermissionsEnumFull        PatchBundlesIDRequestBodyPermissionsEnum = "full"
	PatchBundlesIDRequestBodyPermissionsEnumNone        PatchBundlesIDRequestBodyPermissionsEnum = "none"
	PatchBundlesIDRequestBodyPermissionsEnumPreviewOnly PatchBundlesIDRequestBodyPermissionsEnum = "preview_only"
)

func (e PatchBundlesIDRequestBodyPermissionsEnum) ToPointer() *PatchBundlesIDRequestBodyPermissionsEnum {
	return &e
}

func (e *PatchBundlesIDRequestBodyPermissionsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read":
		fallthrough
	case "write":
		fallthrough
	case "read_write":
		fallthrough
	case "full":
		fallthrough
	case "none":
		fallthrough
	case "preview_only":
		*e = PatchBundlesIDRequestBodyPermissionsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchBundlesIDRequestBodyPermissionsEnum: %v", v)
	}
}

type PatchBundlesIDRequestBodyWatermarkAttachmentFile struct {
	Content                 []byte `multipartForm:"content"`
	WatermarkAttachmentFile string `multipartForm:"name=watermark_attachment_file"`
}

type PatchBundlesIDRequestBody struct {
	// ID of the clickwrap to use with this bundle.
	ClickwrapID *int `multipartForm:"name=clickwrap_id"`
	// Bundle code.  This code forms the end part of the Public URL.
	Code *string `multipartForm:"name=code"`
	// Public description
	Description *string `multipartForm:"name=description"`
	// Do not create subfolders for files uploaded to this share. Note: there are subtle security pitfalls with allowing anonymous uploads from multiple users to live in the same folder. We strongly discourage use of this option unless absolutely required.
	DontSeparateSubmissionsByFolder *bool `multipartForm:"name=dont_separate_submissions_by_folder"`
	// Bundle expiration date/time
	ExpiresAt *time.Time `multipartForm:"name=expires_at"`
	// Id of Form Field Set to use with this bundle
	FormFieldSetID *int `multipartForm:"name=form_field_set_id"`
	// ID of the associated inbox, if available.
	InboxID *int `multipartForm:"name=inbox_id"`
	// Maximum number of times bundle can be accessed
	MaxUses *int `multipartForm:"name=max_uses"`
	// Bundle internal note
	Note *string `multipartForm:"name=note"`
	// Password for this bundle.
	Password *string `multipartForm:"name=password"`
	// Template for creating submission subfolders. Can use the uploader's name, email address, ip, company, and any custom form data.
	PathTemplate *string `multipartForm:"name=path_template"`
	// A list of paths to include in this bundle.
	Paths []string `multipartForm:"name=paths"`
	// Permissions that apply to Folders in this Share Link.
	Permissions *PatchBundlesIDRequestBodyPermissionsEnum `multipartForm:"name=permissions"`
	// Restrict users to previewing files only?
	PreviewOnly *bool `multipartForm:"name=preview_only"`
	// Show a registration page that captures the downloader's name and email address?
	RequireRegistration *bool `multipartForm:"name=require_registration"`
	// Only allow access to recipients who have explicitly received the share via an email sent through the Files.com UI?
	RequireShareRecipient *bool `multipartForm:"name=require_share_recipient"`
	// Send delivery receipt to the uploader. Note: For writable share only
	SendEmailReceiptToUploader *bool `multipartForm:"name=send_email_receipt_to_uploader"`
	// BundleRegistrations can be saved without providing company?
	SkipCompany *bool `multipartForm:"name=skip_company"`
	// BundleRegistrations can be saved without providing email?
	SkipEmail *bool `multipartForm:"name=skip_email"`
	// BundleRegistrations can be saved without providing name?
	SkipName *bool `multipartForm:"name=skip_name"`
	// If true, will delete the file stored in watermark_attachment
	WatermarkAttachmentDelete *bool `multipartForm:"name=watermark_attachment_delete"`
	// Preview watermark image applied to all bundle items.
	WatermarkAttachmentFile *PatchBundlesIDRequestBodyWatermarkAttachmentFile `multipartForm:"file"`
}

type PatchBundlesIDRequest struct {
	RequestBody *PatchBundlesIDRequestBody `request:"mediaType=multipart/form-data"`
	// Bundle ID.
	ID int `pathParam:"style=simple,explode=false,name=id"`
}

type PatchBundlesIDResponse struct {
	// The Bundles object.
	BundleEntity *shared.BundleEntity
	ContentType  string
	StatusCode   int
	RawResponse  *http.Response
}
