/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class TasksClassic {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Adds files to a given task.
   *
   * @remarks
   * Adds files to a given task.
   */
  addFile(
    req: operations.AddFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.AddFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AddFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/files/input",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "fileDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AddFileResponse = new operations.AddFileResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a task.
   *
   * @remarks
   * Removes a task.
   */
  delete14(
    req: operations.Delete14Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete14Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete14Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/tasks/{taskId}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete14Response = new operations.Delete14Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Returns contacts of a given task.
   *
   * @remarks
   * Returns contacts of a given task.
   */
  getContacts1(
    req: operations.GetContacts1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContacts1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContacts1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/contacts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContacts1Response =
        new operations.GetContacts1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom fields of a given task.
   *
   * @remarks
   * Returns custom fields of a given task.
   */
  getCustomFields7(
    req: operations.GetCustomFields7Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFields7Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFields7Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFields7Response =
        new operations.GetCustomFields7Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns dates of a given task.
   *
   * @remarks
   * Returns dates of a given task.
   */
  getDates3(
    req: operations.GetDates3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDates3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDates3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/dates",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDates3Response =
        new operations.GetDates3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.projectDatesDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProjectDatesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns instructions of a given task.
   *
   * @remarks
   * Returns instructions of a given task.
   */
  getInstructions2(
    req: operations.GetInstructions2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetInstructions2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetInstructions2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/instructions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetInstructions2Response =
        new operations.GetInstructions2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.instructionsDTO = utils.objectToClass(
              httpRes?.data,
              shared.InstructionsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns progress of a given task.
   *
   * @remarks
   * Returns progress of a given task. Progress contains information about task's status (ie. opened or ready) and current phase (ie. translation). Workflow phase is defined as the first one which contains not ready jobs (ie. opened or started). When no such job exists then workflow phase is not included.
   */
  getProgress(
    req: operations.GetProgressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProgressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProgressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/progress",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProgressResponse =
        new operations.GetProgressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.taskProgressDTO = utils.objectToClass(
              httpRes?.data,
              shared.TaskProgressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns lists of files of a given task.
   *
   * @remarks
   * Returns several lists of files for a given task: input files divided by type, output files, bundles, files per job, preview files.
   */
  getTaskFiles(
    req: operations.GetTaskFilesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTaskFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTaskFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/files",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTaskFilesResponse =
        new operations.GetTaskFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.taskFilesDTO = utils.objectToClass(
              httpRes?.data,
              shared.TaskFilesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a task.
   *
   * @remarks
   * Starts a task.
   */
  start1(
    req: operations.Start1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Start1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Start1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/start",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Start1Response = new operations.Start1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Updates Client Task PO Number of a given task.
   *
   * @remarks
   * Updates Client Task PO Number of a given task.
   */
  updateClientTaskPONumber(
    req: operations.UpdateClientTaskPONumberRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateClientTaskPONumberResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateClientTaskPONumberRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/clientTaskPONumber",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stringDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateClientTaskPONumberResponse =
        new operations.UpdateClientTaskPONumberResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.stringDTO = utils.objectToClass(
              httpRes?.data,
              shared.StringDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates contacts of a given task.
   *
   * @remarks
   * Updates contacts of a given task.
   */
  updateContacts1(
    req: operations.UpdateContacts1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateContacts1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateContacts1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/contacts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "contactsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateContacts1Response =
        new operations.UpdateContacts1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactsDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates custom fields of a given task.
   *
   * @remarks
   * Updates custom fields of a given task.
   */
  updateCustomFields5(
    req: operations.UpdateCustomFields5Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomFields5Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomFields5Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/customFields",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomFields5Response =
        new operations.UpdateCustomFields5Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates dates of a given task.
   *
   * @remarks
   * Updates dates of a given task.
   */
  updateDates2(
    req: operations.UpdateDates2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDates2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDates2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/dates",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "projectDatesDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDates2Response =
        new operations.UpdateDates2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.projectDatesDTO = utils.objectToClass(
              httpRes?.data,
              shared.ProjectDatesDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates instructions of a given task.
   *
   * @remarks
   * Updates instructions of a given task.
   */
  updateInstructions3(
    req: operations.UpdateInstructions3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateInstructions3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateInstructions3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/tasks/{taskId}/instructions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "instructionsDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateInstructions3Response =
        new operations.UpdateInstructions3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.instructionsDTO = utils.objectToClass(
              httpRes?.data,
              shared.InstructionsDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates name of a given task.
   *
   * @remarks
   * Updates name of a given task.
   */
  updateName(
    req: operations.UpdateNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/tasks/{taskId}/name", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stringDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateNameResponse =
        new operations.UpdateNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.stringDTO = utils.objectToClass(
              httpRes?.data,
              shared.StringDTO
            );
          }
          break;
      }

      return res;
    });
  }
}
