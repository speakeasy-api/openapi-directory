/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Profile {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Bookmark an item under the active profile.
   *
   * Creates one if it doesn't exist, overwrites one if it does.
   *
   */
  bookmarkItem(
    req: operations.BookmarkItemRequest,
    security: operations.BookmarkItemSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BookmarkItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BookmarkItemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/bookmarks/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BookmarkItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BookmarkItemResponse =
        new operations.BookmarkItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bookmark = utils.objectToClass(httpRes?.data, shared.Bookmark);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unbookmark an item under the active profile.
   */
  deleteItemBookmark(
    req: operations.DeleteItemBookmarkRequest,
    security: operations.DeleteItemBookmarkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteItemBookmarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteItemBookmarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/bookmarks/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteItemBookmarkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteItemBookmarkResponse =
        new operations.DeleteItemBookmarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove the watched status of items under the active profile. Passing in
   * specific `itemId`s to the `item_ids` query parameter will cause only these
   * items to be removed. **If this list is missing all watched items will be
   * removed**
   *
   */
  deleteWatched(
    req: operations.DeleteWatchedRequest,
    security: operations.DeleteWatchedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWatchedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWatchedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/profile/watched";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWatchedSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWatchedResponse =
        new operations.DeleteWatchedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of bookmarked items under the active profile.
   */
  getBookmarkList(
    req: operations.GetBookmarkListRequest,
    security: operations.GetBookmarkListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBookmarkListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBookmarkListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/profile/bookmarks/list";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBookmarkListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBookmarkListResponse =
        new operations.GetBookmarkListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the map of bookmarked item ids (itemId => creationDate) under the active profile.
   */
  getBookmarks(
    req: operations.GetBookmarksRequest,
    security: operations.GetBookmarksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBookmarksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBookmarksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/profile/bookmarks";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBookmarksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBookmarksResponse =
        new operations.GetBookmarksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBookmarks200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of items which have been watched but not completed under the active
   * profile.
   *
   * Multiple episodes under the same show may be watched or in progress, however only a
   * single item belonging to a particular show will be included in the returned list.
   *
   * The next episode to continue watching for a particular show will be the most recent
   * incompletely watched episode, or the next episode following the most recently
   * completely watched episode. Based on the specified `show_item_type` type, either the next
   * episode, the season of the next episode, or the show will be included in the list.
   *
   */
  getContinueWatchingList(
    req: operations.GetContinueWatchingListRequest,
    security: operations.GetContinueWatchingListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContinueWatchingListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContinueWatchingListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/profile/continue-watching/list";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetContinueWatchingListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContinueWatchingListResponse =
        new operations.GetContinueWatchingListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the bookmark for an item under the active profile.
   */
  getItemBookmark(
    req: operations.GetItemBookmarkRequest,
    security: operations.GetItemBookmarkSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemBookmarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemBookmarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/bookmarks/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItemBookmarkSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemBookmarkResponse =
        new operations.GetItemBookmarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bookmark = utils.objectToClass(httpRes?.data, shared.Bookmark);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the rating info for an item under the active profile.
   */
  getItemRating(
    req: operations.GetItemRatingRequest,
    security: operations.GetItemRatingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemRatingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemRatingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/ratings/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItemRatingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemRatingResponse =
        new operations.GetItemRatingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userRating = utils.objectToClass(
              httpRes?.data,
              shared.UserRating
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the watched status info for an item under the active profile.
   */
  getItemWatchedStatus(
    req: operations.GetItemWatchedStatusRequest,
    security: operations.GetItemWatchedStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetItemWatchedStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetItemWatchedStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/watched/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetItemWatchedStatusSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetItemWatchedStatusResponse =
        new operations.GetItemWatchedStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.watched = utils.objectToClass(httpRes?.data, shared.Watched);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the next item to play given a source item id.
   *
   * For an unwatched show it returns the first episode available to the account.
   *
   * For a watched show it returns the last incompletely watched episode by the profile,
   * or the episode that immediately follows the last completely watched episode
   * or nothing.
   *
   * For an episode it always returns the immediately following episode, if available to
   * the account, or nothing.
   *
   * If the response does not contain a `next` property then no item was found.
   *
   */
  getNextPlaybackItem(
    req: operations.GetNextPlaybackItemRequest,
    security: operations.GetNextPlaybackItemSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetNextPlaybackItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetNextPlaybackItemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/items/{itemId}/next",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetNextPlaybackItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetNextPlaybackItemResponse =
        new operations.GetNextPlaybackItemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.nextPlaybackItem = utils.objectToClass(
              httpRes?.data,
              shared.NextPlaybackItem
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the details of the active profile, including watched, bookmarked and rated items.
   */
  getProfile(
    req: operations.GetProfileRequest,
    security: operations.GetProfileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/profile";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProfileResponse =
        new operations.GetProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.profileDetail = utils.objectToClass(
              httpRes?.data,
              shared.ProfileDetail
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the map of rated item ids (itemId => rating out of 10) under the active profile.
   */
  getRatings(
    req: operations.GetRatingsRequest,
    security: operations.GetRatingsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRatingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRatingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/profile/ratings";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetRatingsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRatingsResponse =
        new operations.GetRatingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRatings200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of rated items under the active profile.
   */
  getRatingsList(
    req: operations.GetRatingsListRequest,
    security: operations.GetRatingsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRatingsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRatingsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/profile/ratings/list";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetRatingsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRatingsListResponse =
        new operations.GetRatingsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the map of watched item ids (itemId => last playhead position) under the active profile.
   */
  getWatched(
    req: operations.GetWatchedRequest,
    security: operations.GetWatchedSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWatchedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWatchedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/account/profile/watched";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWatchedSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWatchedResponse =
        new operations.GetWatchedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWatched200ApplicationJSONObject = {};
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getWatched200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              shared.Watched,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of watched items under the active profile.
   */
  getWatchedList(
    req: operations.GetWatchedListRequest,
    security: operations.GetWatchedListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWatchedListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWatchedListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/account/profile/watched/list";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWatchedListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWatchedListResponse =
        new operations.GetWatchedListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.itemList = utils.objectToClass(httpRes?.data, shared.ItemList);
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rate an item under the active profile.
   *
   * Creates one if it doesn't exist, overwrites one if it does.
   *
   */
  rateItem(
    req: operations.RateItemRequest,
    security: operations.RateItemSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RateItemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RateItemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/ratings/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RateItemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RateItemResponse = new operations.RateItemResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userRating = utils.objectToClass(
              httpRes?.data,
              shared.UserRating
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Record the watched playhead position of a video under the active profile.
   *
   * Can be used later to resume a video from where it was last watched.
   *
   * Creates one if it doesn't exist, overwrites one if it does.
   *
   */
  setItemWatchedStatus(
    req: operations.SetItemWatchedStatusRequest,
    security: operations.SetItemWatchedStatusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SetItemWatchedStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SetItemWatchedStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/account/profile/watched/{itemId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SetItemWatchedStatusSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SetItemWatchedStatusResponse =
        new operations.SetItemWatchedStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.watched = utils.objectToClass(httpRes?.data, shared.Watched);
          }
          break;
        case httpRes?.status == 204:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceError = utils.objectToClass(
              httpRes?.data,
              shared.ServiceError
            );
          }
          break;
      }

      return res;
    });
  }
}
