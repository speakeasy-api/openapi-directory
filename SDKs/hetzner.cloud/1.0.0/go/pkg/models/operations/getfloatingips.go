// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// GetFloatingIpsSortEnum - Can be used multiple times. Choices id id:asc id:desc created created:asc created:desc
type GetFloatingIpsSortEnum string

const (
	GetFloatingIpsSortEnumID          GetFloatingIpsSortEnum = "id"
	GetFloatingIpsSortEnumIDAsc       GetFloatingIpsSortEnum = "id:asc"
	GetFloatingIpsSortEnumIDDesc      GetFloatingIpsSortEnum = "id:desc"
	GetFloatingIpsSortEnumCreated     GetFloatingIpsSortEnum = "created"
	GetFloatingIpsSortEnumCreatedAsc  GetFloatingIpsSortEnum = "created:asc"
	GetFloatingIpsSortEnumCreatedDesc GetFloatingIpsSortEnum = "created:desc"
)

func (e *GetFloatingIpsSortEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "id":
		fallthrough
	case "id:asc":
		fallthrough
	case "id:desc":
		fallthrough
	case "created":
		fallthrough
	case "created:asc":
		fallthrough
	case "created:desc":
		*e = GetFloatingIpsSortEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetFloatingIpsSortEnum: %s", s)
	}
}

type GetFloatingIpsRequest struct {
	// Can be used to filter Floating IPs by labels. The response will only contain Floating IPs matching the label selector.
	LabelSelector *string `queryParam:"style=form,explode=true,name=label_selector"`
	// Can be used to filter Floating IPs by their name. The response will only contain the Floating IP matching the specified name.
	Name *string `queryParam:"style=form,explode=true,name=name"`
	// Can be used multiple times. Choices id id:asc id:desc created created:asc created:desc
	Sort *GetFloatingIpsSortEnum `queryParam:"style=form,explode=true,name=sort"`
}

type GetFloatingIps200ApplicationJSONFloatingIpsDNSPtr struct {
	// DNS pointer for the specific IP address
	DNSPtr string `json:"dns_ptr"`
	// Single IPv4 or IPv6 address
	IP string `json:"ip"`
}

// GetFloatingIps200ApplicationJSONFloatingIpsHomeLocation - Location the Floating IP was created in. Routing is optimized for this Location.
type GetFloatingIps200ApplicationJSONFloatingIpsHomeLocation struct {
	// City the Location is closest to
	City string `json:"city"`
	// ISO 3166-1 alpha-2 code of the country the Location resides in
	Country string `json:"country"`
	// Description of the Location
	Description string `json:"description"`
	// ID of the Location
	ID float64 `json:"id"`
	// Latitude of the city closest to the Location
	Latitude float64 `json:"latitude"`
	// Longitude of the city closest to the Location
	Longitude float64 `json:"longitude"`
	// Unique identifier of the Location
	Name string `json:"name"`
	// Name of network zone this Location resides in
	NetworkZone string `json:"network_zone"`
}

// GetFloatingIps200ApplicationJSONFloatingIpsProtection - Protection configuration for the Resource
type GetFloatingIps200ApplicationJSONFloatingIpsProtection struct {
	// If true, prevents the Resource from being deleted
	Delete bool `json:"delete"`
}

// GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum - Type of the Floating IP
type GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum string

const (
	GetFloatingIps200ApplicationJSONFloatingIpsTypeEnumIpv4 GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum = "ipv4"
	GetFloatingIps200ApplicationJSONFloatingIpsTypeEnumIpv6 GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum = "ipv6"
)

func (e *GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "ipv4":
		fallthrough
	case "ipv6":
		*e = GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum: %s", s)
	}
}

type GetFloatingIps200ApplicationJSONFloatingIps struct {
	// Whether the IP is blocked
	Blocked bool `json:"blocked"`
	// Point in time when the Resource was created (in ISO-8601 format)
	Created string `json:"created"`
	// Description of the Resource
	Description string `json:"description"`
	// Array of reverse DNS entries
	DNSPtr []GetFloatingIps200ApplicationJSONFloatingIpsDNSPtr `json:"dns_ptr"`
	// Location the Floating IP was created in. Routing is optimized for this Location.
	HomeLocation GetFloatingIps200ApplicationJSONFloatingIpsHomeLocation `json:"home_location"`
	// ID of the Resource
	ID int64 `json:"id"`
	// IP address
	IP string `json:"ip"`
	// User-defined labels (key-value pairs)
	Labels map[string]string `json:"labels"`
	// Name of the Resource. Must be unique per Project.
	Name string `json:"name"`
	// Protection configuration for the Resource
	Protection GetFloatingIps200ApplicationJSONFloatingIpsProtection `json:"protection"`
	// ID of the Server the Floating IP is assigned to, null if it is not assigned at all
	Server int64 `json:"server"`
	// Type of the Floating IP
	Type GetFloatingIps200ApplicationJSONFloatingIpsTypeEnum `json:"type"`
}

type GetFloatingIps200ApplicationJSONMetaPagination struct {
	// ID of the last page available. Can be null if the current page is the last one.
	LastPage float64 `json:"last_page"`
	// ID of the next page. Can be null if the current page is the last one.
	NextPage float64 `json:"next_page"`
	// Current page number
	Page float64 `json:"page"`
	// Maximum number of items shown per page in the response
	PerPage float64 `json:"per_page"`
	// ID of the previous page. Can be null if the current page is the first one.
	PreviousPage float64 `json:"previous_page"`
	// The total number of entries that exist in the database for this query. Nullable if unknown.
	TotalEntries float64 `json:"total_entries"`
}

type GetFloatingIps200ApplicationJSONMeta struct {
	Pagination GetFloatingIps200ApplicationJSONMetaPagination `json:"pagination"`
}

// GetFloatingIps200ApplicationJSON - The `floating_ips` key in the reply contains an array of Floating IP objects with this structure
type GetFloatingIps200ApplicationJSON struct {
	FloatingIps []GetFloatingIps200ApplicationJSONFloatingIps `json:"floating_ips"`
	Meta        *GetFloatingIps200ApplicationJSONMeta         `json:"meta,omitempty"`
}

type GetFloatingIpsResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// The `floating_ips` key in the reply contains an array of Floating IP objects with this structure
	GetFloatingIps200ApplicationJSONObject *GetFloatingIps200ApplicationJSON
}
