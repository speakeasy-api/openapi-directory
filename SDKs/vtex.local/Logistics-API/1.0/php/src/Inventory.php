<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Inventory 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * List supply lots
     * 
     * Returns a list of the supply lots of an SKU in a specific warehouse.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSupplyLotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSupplyLotsResponse
     */
	public function getSupplyLots(
        \OpenAPI\OpenAPI\Models\Operations\GetSupplyLotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSupplyLotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}/supplyLots', \OpenAPI\OpenAPI\Models\Operations\GetSupplyLotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSupplyLotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * List inventory with dispatched reservations
     * 
     * Lists inventory with dispatched reservations. When the number of active reservations is more than 2000 the return is an error with status code 400 (BadRequest) and the message: Too many active reservations.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetinventorywithdispatchedreservationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetinventorywithdispatchedreservationsResponse
     */
	public function getinventorywithdispatchedreservations(
        \OpenAPI\OpenAPI\Models\Operations\GetinventorywithdispatchedreservationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetinventorywithdispatchedreservationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{itemId}/warehouses/{warehouseId}/dispatched', \OpenAPI\OpenAPI\Models\Operations\GetinventorywithdispatchedreservationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetinventorywithdispatchedreservationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getinventorywithdispatchedreservations200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\Getinventorywithdispatchedreservations200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List inventory by SKU
     * 
     * Lists your store's inventory by SKU ID
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\InventoryBySkuRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\InventoryBySkuResponse
     */
	public function inventoryBySku(
        \OpenAPI\OpenAPI\Models\Operations\InventoryBySkuRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\InventoryBySkuResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/skus/{skuId}', \OpenAPI\OpenAPI\Models\Operations\InventoryBySkuRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\InventoryBySkuResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inventoryBySku200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\InventoryBySku200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List inventory per dock
     * 
     * Lists inventory information per dock set up in your store.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\InventoryperdockRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\InventoryperdockResponse
     */
	public function inventoryperdock(
        \OpenAPI\OpenAPI\Models\Operations\InventoryperdockRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\InventoryperdockResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{skuId}/docks/{dockId}', \OpenAPI\OpenAPI\Models\Operations\InventoryperdockRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\InventoryperdockResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inventoryperdock200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\Inventoryperdock200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List inventory per dock and warehouse
     * 
     * Lists information of inventory per dock and warehouse.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\InventoryperdockandwarehouseRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\InventoryperdockandwarehouseResponse
     */
	public function inventoryperdockandwarehouse(
        \OpenAPI\OpenAPI\Models\Operations\InventoryperdockandwarehouseRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\InventoryperdockandwarehouseResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{skuId}/docks/{dockId}/warehouses/{warehouseId}', \OpenAPI\OpenAPI\Models\Operations\InventoryperdockandwarehouseRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\InventoryperdockandwarehouseResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inventoryperdockandwarehouse200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\Inventoryperdockandwarehouse200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List inventory per warehouse
     * 
     * Lists inventory information per warehouse on your store.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\InventoryperwarehouseRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\InventoryperwarehouseResponse
     */
	public function inventoryperwarehouse(
        \OpenAPI\OpenAPI\Models\Operations\InventoryperwarehouseRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\InventoryperwarehouseResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}', \OpenAPI\OpenAPI\Models\Operations\InventoryperwarehouseRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\InventoryperwarehouseResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->inventoryperwarehouse200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\Inventoryperwarehouse200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Save supply lot
     * 
     * Creates a new Supply Lot. A Supply Lot lets the store sell products that are not currently available in stock but whose arrival is already scheduled.
     * 
     * Check out our [documentation](https://help.vtex.com/en/tutorial/setting-up-future-inventory--UMSGjooqRfkRbeoh94kS4) about this feature.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SaveSupplyLotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SaveSupplyLotResponse
     */
	public function saveSupplyLot(
        \OpenAPI\OpenAPI\Models\Operations\SaveSupplyLotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SaveSupplyLotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}/supplyLots/{supplyLotId}', \OpenAPI\OpenAPI\Models\Operations\SaveSupplyLotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SaveSupplyLotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Transfer supply lot
     * 
     * Transfers an SKU from a Supply Lot to the currently available inventory.
     * 
     * Check out how this transfer works in further detail by reading our [documentation](https://help.vtex.com/pt/tutorial/configurar-estoque-futuro--UMSGjooqRfkRbeoh94kS4) about this feature.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\TransferSupplyLotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\TransferSupplyLotResponse
     */
	public function transferSupplyLot(
        \OpenAPI\OpenAPI\Models\Operations\TransferSupplyLotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\TransferSupplyLotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/items/{skuId}/warehouses/{warehouseId}/supplyLots/{supplyLotId}/transfer', \OpenAPI\OpenAPI\Models\Operations\TransferSupplyLotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TransferSupplyLotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Update inventory by SKU and warehouse
     * 
     * Updates inventory for a given SKU and warehouse.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateInventoryBySkuandWarehouseRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateInventoryBySkuandWarehouseResponse
     */
	public function updateInventoryBySkuandWarehouse(
        \OpenAPI\OpenAPI\Models\Operations\UpdateInventoryBySkuandWarehouseRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateInventoryBySkuandWarehouseResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/api/logistics/pvt/inventory/skus/{skuId}/warehouses/{warehouseId}', \OpenAPI\OpenAPI\Models\Operations\UpdateInventoryBySkuandWarehouseRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateInventoryBySkuandWarehouseResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
}