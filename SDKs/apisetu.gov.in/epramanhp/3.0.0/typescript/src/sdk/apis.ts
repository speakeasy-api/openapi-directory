/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class APIs {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Agriculture/ Agriculturist Certificate
   *
   * @remarks
   * API to verify Agriculture/ Agriculturist Certificate.
   */
  agcer(
    req: operations.AgcerRequestBody,
    security: operations.AgcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.AgcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.AgcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/agcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.AgcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.AgcerResponse = new operations.AgcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.agcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Agcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Backward Area Certificate
   *
   * @remarks
   * API to verify Backward Area Certificate.
   */
  bacer(
    req: operations.BacerRequestBody,
    security: operations.BacerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BacerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BacerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/bacer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BacerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BacerResponse = new operations.BacerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bacer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bacer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Bonafide Certificate
   *
   * @remarks
   * API to verify Bonafide Certificate.
   */
  bhcer(
    req: operations.BhcerRequestBody,
    security: operations.BhcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BhcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BhcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/bhcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BhcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BhcerResponse = new operations.BhcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bhcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Bhcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Character Certificate
   *
   * @remarks
   * API to verify Character Certificate.
   */
  chcer(
    req: operations.ChcerRequestBody,
    security: operations.ChcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ChcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/chcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ChcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChcerResponse = new operations.ChcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.chcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Chcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Dogra Class Certificate
   *
   * @remarks
   * API to verify Dogra Class Certificate.
   */
  dccer(
    req: operations.DccerRequestBody,
    security: operations.DccerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DccerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DccerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/dccer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DccerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DccerResponse = new operations.DccerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.dccer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Dccer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Freedom Fighter Certificate
   *
   * @remarks
   * API to verify Freedom Fighter Certificate.
   */
  ffcer(
    req: operations.FfcerRequestBody,
    security: operations.FfcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FfcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FfcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ffcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FfcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FfcerResponse = new operations.FfcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ffcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Ffcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Income Certificate
   *
   * @remarks
   * API to verify Income Certificate.
   */
  incer(
    req: operations.IncerRequestBody,
    security: operations.IncerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.IncerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IncerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/incer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.IncerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IncerResponse = new operations.IncerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.incer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Incer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Legal Heir Certificate
   *
   * @remarks
   * API to verify Legal Heir Certificate.
   */
  lhcer(
    req: operations.LhcerRequestBody,
    security: operations.LhcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LhcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LhcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/lhcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LhcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LhcerResponse = new operations.LhcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lhcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Lhcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Minority Certificate
   *
   * @remarks
   * API to verify Minority Certificate.
   */
  mncer(
    req: operations.MncerRequestBody,
    security: operations.MncerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.MncerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.MncerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/mncer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.MncerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.MncerResponse = new operations.MncerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mncer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Mncer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * OBC Certificate
   *
   * @remarks
   * API to verify OBC Certificate.
   */
  obcer(
    req: operations.ObcerRequestBody,
    security: operations.ObcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ObcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ObcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/obcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ObcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ObcerResponse = new operations.ObcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.obcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Obcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Passport/ Passport Verification
   *
   * @remarks
   * API to verify Passport/ Passport Verification.
   */
  psprt(
    req: operations.PsprtRequestBody,
    security: operations.PsprtSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PsprtResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PsprtRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/psprt/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PsprtSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PsprtResponse = new operations.PsprtResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.psprt504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Psprt504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Rural Area Certificate
   *
   * @remarks
   * API to verify Rural Area Certificate.
   */
  racer(
    req: operations.RacerRequestBody,
    security: operations.RacerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RacerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RacerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/racer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RacerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RacerResponse = new operations.RacerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.racer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Racer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Marriage Certificate
   *
   * @remarks
   * API to verify Marriage Certificate.
   */
  rmcer(
    req: operations.RmcerRequestBody,
    security: operations.RmcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RmcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RmcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/rmcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RmcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RmcerResponse = new operations.RmcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rmcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Rmcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * SC/ST  Certificate
   *
   * @remarks
   * API to verify SC/ST  Certificate.
   */
  shcer(
    req: operations.ShcerRequestBody,
    security: operations.ShcerSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ShcerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ShcerRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/shcer/certificate";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ShcerSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ShcerResponse = new operations.ShcerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer400ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer400ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer401ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer401ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer404ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer404ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 500:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer500ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer500ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 502:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer502ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer502ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer503ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 504:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.shcer504ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.Shcer504ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }
}
