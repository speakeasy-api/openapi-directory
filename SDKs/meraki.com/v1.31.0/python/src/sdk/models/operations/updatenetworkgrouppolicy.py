"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyBandwidthBandwidthLimits:
    r"""The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'."""
    
    limit_down: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('limitDown'), 'exclude': lambda f: f is None }})
    r"""The maximum download limit (integer, in Kbps). null indicates no limit"""  
    limit_up: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('limitUp'), 'exclude': lambda f: f is None }})
    r"""The maximum upload limit (integer, in Kbps). null indicates no limit"""  
    
class UpdateNetworkGroupPolicyRequestBodyBandwidthSettingsEnum(str, Enum):
    r"""How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'."""
    CUSTOM = 'custom'
    IGNORE = 'ignore'
    NETWORK_DEFAULT = 'network default'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyBandwidth:
    r"""The bandwidth settings for clients bound to your group policy."""
    
    bandwidth_limits: Optional[UpdateNetworkGroupPolicyRequestBodyBandwidthBandwidthLimits] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bandwidthLimits'), 'exclude': lambda f: f is None }})
    r"""The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'."""  
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyBandwidthSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'."""  
    
class UpdateNetworkGroupPolicyRequestBodyBonjourForwardingRulesServicesEnum(str, Enum):
    AFP = 'AFP'
    AIR_PLAY = 'AirPlay'
    ALL_SERVICES = 'All Services'
    BIT_TORRENT = 'BitTorrent'
    FTP = 'FTP'
    PRINTERS = 'Printers'
    SSH = 'SSH'
    SAMBA = 'Samba'
    SCANNERS = 'Scanners'
    I_CHAT = 'iChat'
    I_TUNES = 'iTunes'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyBonjourForwardingRules:
    
    services: list[UpdateNetworkGroupPolicyRequestBodyBonjourForwardingRulesServicesEnum] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('services') }})
    r"""A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'"""  
    vlan_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlanId') }})
    r"""The ID of the service VLAN. Required."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""A description for your Bonjour forwarding rule. Optional."""  
    
class UpdateNetworkGroupPolicyRequestBodyBonjourForwardingSettingsEnum(str, Enum):
    r"""How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'."""
    CUSTOM = 'custom'
    IGNORE = 'ignore'
    NETWORK_DEFAULT = 'network default'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyBonjourForwarding:
    r"""The Bonjour settings for your group policy. Only valid if your network has a wireless configuration."""
    
    rules: Optional[list[UpdateNetworkGroupPolicyRequestBodyBonjourForwardingRules]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rules'), 'exclude': lambda f: f is None }})
    r"""A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified."""  
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyBonjourForwardingSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'."""  
    
class UpdateNetworkGroupPolicyRequestBodyContentFilteringAllowedURLPatternsSettingsEnum(str, Enum):
    r"""How URL patterns are applied. Can be 'network default', 'append' or 'override'."""
    APPEND = 'append'
    NETWORK_DEFAULT = 'network default'
    OVERRIDE = 'override'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyContentFilteringAllowedURLPatterns:
    r"""Settings for allowed URL patterns"""
    
    patterns: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('patterns'), 'exclude': lambda f: f is None }})
    r"""A list of URL patterns that are allowed"""  
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyContentFilteringAllowedURLPatternsSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How URL patterns are applied. Can be 'network default', 'append' or 'override'."""  
    
class UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLCategoriesSettingsEnum(str, Enum):
    r"""How URL categories are applied. Can be 'network default', 'append' or 'override'."""
    APPEND = 'append'
    NETWORK_DEFAULT = 'network default'
    OVERRIDE = 'override'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLCategories:
    r"""Settings for blocked URL categories"""
    
    categories: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('categories'), 'exclude': lambda f: f is None }})
    r"""A list of URL categories to block"""  
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLCategoriesSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How URL categories are applied. Can be 'network default', 'append' or 'override'."""  
    
class UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLPatternsSettingsEnum(str, Enum):
    r"""How URL patterns are applied. Can be 'network default', 'append' or 'override'."""
    APPEND = 'append'
    NETWORK_DEFAULT = 'network default'
    OVERRIDE = 'override'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLPatterns:
    r"""Settings for blocked URL patterns"""
    
    patterns: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('patterns'), 'exclude': lambda f: f is None }})
    r"""A list of URL patterns that are blocked"""  
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLPatternsSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How URL patterns are applied. Can be 'network default', 'append' or 'override'."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyContentFiltering:
    r"""The content filtering settings for your group policy"""
    
    allowed_url_patterns: Optional[UpdateNetworkGroupPolicyRequestBodyContentFilteringAllowedURLPatterns] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowedUrlPatterns'), 'exclude': lambda f: f is None }})
    r"""Settings for allowed URL patterns"""  
    blocked_url_categories: Optional[UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLCategories] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blockedUrlCategories'), 'exclude': lambda f: f is None }})
    r"""Settings for blocked URL categories"""  
    blocked_url_patterns: Optional[UpdateNetworkGroupPolicyRequestBodyContentFilteringBlockedURLPatterns] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blockedUrlPatterns'), 'exclude': lambda f: f is None }})
    r"""Settings for blocked URL patterns"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL3FirewallRules:
    
    dest_cidr: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destCidr') }})
    r"""Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'."""  
    policy: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('policy') }})
    r"""'allow' or 'deny' traffic specified by this rule"""  
    protocol: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('protocol') }})
    r"""The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')"""  
    comment: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('comment'), 'exclude': lambda f: f is None }})
    r"""Description of the rule (optional)"""  
    dest_port: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('destPort'), 'exclude': lambda f: f is None }})
    r"""Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'"""  
    
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL7FirewallRulesPolicyEnum(str, Enum):
    r"""The policy applied to matching traffic. Must be 'deny'."""
    DENY = 'deny'

class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL7FirewallRulesTypeEnum(str, Enum):
    r"""Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'"""
    APPLICATION = 'application'
    APPLICATION_CATEGORY = 'applicationCategory'
    HOST = 'host'
    IP_RANGE = 'ipRange'
    PORT = 'port'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL7FirewallRules:
    
    policy: Optional[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL7FirewallRulesPolicyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('policy'), 'exclude': lambda f: f is None }})
    r"""The policy applied to matching traffic. Must be 'deny'."""  
    type: Optional[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL7FirewallRulesTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'"""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application."""  
    
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingSettingsEnum(str, Enum):
    r"""How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'."""
    CUSTOM = 'custom'
    IGNORE = 'ignore'
    NETWORK_DEFAULT = 'network default'

class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsTypeEnum(str, Enum):
    r"""The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'."""
    APPLICATION = 'application'
    APPLICATION_CATEGORY = 'applicationCategory'
    HOST = 'host'
    IP_RANGE = 'ipRange'
    LOCAL_NET = 'localNet'
    PORT = 'port'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions:
    
    type: UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitionsTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'."""  
    value: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value') }})
    r"""If \\"type\\" is 'host', 'port', 'ipRange' or 'localNet', then \\"value\\" must be a string, matching either
        a hostname (e.g. \"somesite.com\"), a port (e.g. 8080), or an IP range (\"192.1.0.0\",
        \"192.1.0.0/16\", or \"10.1.0.0/16:80\"). 'localNet' also supports CIDR notation, excluding
        custom ports.
         If \"type\" is 'application' or 'applicationCategory', then \"value\" must be an object
        with the structure { \"id\": \"meraki:layer7/...\" }, where \"id\" is the application category or
        application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
        endpoint).
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits:
    r"""The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'."""
    
    limit_down: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('limitDown'), 'exclude': lambda f: f is None }})
    r"""The maximum download limit (integer, in Kbps)."""  
    limit_up: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('limitUp'), 'exclude': lambda f: f is None }})
    r"""The maximum upload limit (integer, in Kbps)."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits:
    r"""An object describing the bandwidth settings for your rule."""
    
    bandwidth_limits: Optional[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimitsBandwidthLimits] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bandwidthLimits'), 'exclude': lambda f: f is None }})
    r"""The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'."""  
    settings: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRules:
    
    definitions: list[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesDefinitions] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('definitions') }})
    r"""A list of objects describing the definitions of your traffic shaping rule. At least one definition is required."""  
    dscp_tag_value: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dscpTagValue'), 'exclude': lambda f: f is None }})
    r"""The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
        For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
    """  
    pcp_tag_value: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pcpTagValue'), 'exclude': lambda f: f is None }})
    r"""The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
        null means 'Do not set PCP tag'.
    """  
    per_client_bandwidth_limits: Optional[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRulesPerClientBandwidthLimits] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('perClientBandwidthLimits'), 'exclude': lambda f: f is None }})
    r"""An object describing the bandwidth settings for your rule."""  
    priority: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('priority'), 'exclude': lambda f: f is None }})
    r"""A string, indicating the priority level for packets bound to your rule.
        Can be 'low', 'normal' or 'high'.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShaping:
    r"""The firewall and traffic shaping rules and settings for your policy."""
    
    l3_firewall_rules: Optional[list[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL3FirewallRules]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('l3FirewallRules'), 'exclude': lambda f: f is None }})
    r"""An ordered array of the L3 firewall rules"""  
    l7_firewall_rules: Optional[list[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingL7FirewallRules]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('l7FirewallRules'), 'exclude': lambda f: f is None }})
    r"""An ordered array of L7 firewall rules"""  
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'."""  
    traffic_shaping_rules: Optional[list[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShapingTrafficShapingRules]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trafficShapingRules'), 'exclude': lambda f: f is None }})
    r"""An array of traffic shaping rules. Rules are applied in the order that
        they are specified in. An empty list (or null) means no rules. Note that
        you are allowed a maximum of 8 rules.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingFriday:
    r"""The schedule object for Friday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingMonday:
    r"""The schedule object for Monday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingSaturday:
    r"""The schedule object for Saturday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingSunday:
    r"""The schedule object for Sunday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingThursday:
    r"""The schedule object for Thursday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingTuesday:
    r"""The schedule object for Tuesday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodySchedulingWednesday:
    r"""The schedule object for Wednesday."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed."""  
    to: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'exclude': lambda f: f is None }})
    r"""The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyScheduling:
    r"""The schedule for the group policy. Schedules are applied to days of the week."""
    
    enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled'), 'exclude': lambda f: f is None }})
    r"""Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed."""  
    friday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingFriday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('friday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Friday."""  
    monday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingMonday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('monday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Monday."""  
    saturday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingSaturday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('saturday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Saturday."""  
    sunday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingSunday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sunday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Sunday."""  
    thursday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingThursday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('thursday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Thursday."""  
    tuesday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingTuesday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tuesday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Tuesday."""  
    wednesday: Optional[UpdateNetworkGroupPolicyRequestBodySchedulingWednesday] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('wednesday'), 'exclude': lambda f: f is None }})
    r"""The schedule object for Wednesday."""  
    
class UpdateNetworkGroupPolicyRequestBodySplashAuthSettingsEnum(str, Enum):
    r"""Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration."""
    BYPASS = 'bypass'
    NETWORK_DEFAULT = 'network default'

class UpdateNetworkGroupPolicyRequestBodyVlanTaggingSettingsEnum(str, Enum):
    r"""How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'."""
    CUSTOM = 'custom'
    IGNORE = 'ignore'
    NETWORK_DEFAULT = 'network default'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBodyVlanTagging:
    r"""The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration."""
    
    settings: Optional[UpdateNetworkGroupPolicyRequestBodyVlanTaggingSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})
    r"""How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'."""  
    vlan_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlanId'), 'exclude': lambda f: f is None }})
    r"""The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequestBody:
    
    bandwidth: Optional[UpdateNetworkGroupPolicyRequestBodyBandwidth] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bandwidth'), 'exclude': lambda f: f is None }})
    r"""The bandwidth settings for clients bound to your group policy."""  
    bonjour_forwarding: Optional[UpdateNetworkGroupPolicyRequestBodyBonjourForwarding] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bonjourForwarding'), 'exclude': lambda f: f is None }})
    r"""The Bonjour settings for your group policy. Only valid if your network has a wireless configuration."""  
    content_filtering: Optional[UpdateNetworkGroupPolicyRequestBodyContentFiltering] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('contentFiltering'), 'exclude': lambda f: f is None }})
    r"""The content filtering settings for your group policy"""  
    firewall_and_traffic_shaping: Optional[UpdateNetworkGroupPolicyRequestBodyFirewallAndTrafficShaping] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('firewallAndTrafficShaping'), 'exclude': lambda f: f is None }})
    r"""The firewall and traffic shaping rules and settings for your policy."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name for your group policy."""  
    scheduling: Optional[UpdateNetworkGroupPolicyRequestBodyScheduling] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scheduling'), 'exclude': lambda f: f is None }})
    r"""The schedule for the group policy. Schedules are applied to days of the week."""  
    splash_auth_settings: Optional[UpdateNetworkGroupPolicyRequestBodySplashAuthSettingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('splashAuthSettings'), 'exclude': lambda f: f is None }})
    r"""Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration."""  
    vlan_tagging: Optional[UpdateNetworkGroupPolicyRequestBodyVlanTagging] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlanTagging'), 'exclude': lambda f: f is None }})
    r"""The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration."""  
    

@dataclasses.dataclass
class UpdateNetworkGroupPolicyRequest:
    
    group_policy_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'groupPolicyId', 'style': 'simple', 'explode': False }})  
    network_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'networkId', 'style': 'simple', 'explode': False }})  
    request_body: Optional[UpdateNetworkGroupPolicyRequestBody] = dataclasses.field(default=None, metadata={'request': { 'media_type': 'application/json' }})  
    

@dataclasses.dataclass
class UpdateNetworkGroupPolicyResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    update_network_group_policy_200_application_json_object: Optional[dict[str, Any]] = dataclasses.field(default=None)
    r"""Successful operation"""  
    