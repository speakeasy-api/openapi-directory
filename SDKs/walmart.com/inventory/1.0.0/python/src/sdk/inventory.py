"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Optional

class Inventory:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def get_inventory(self, request: operations.GetInventoryRequest) -> operations.GetInventoryResponse:
        r"""Inventory
        You can use this API to get the inventory for a given item.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v3/inventory'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetInventoryRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetInventoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetInventory200ApplicationJSON])
                res.get_inventory_200_application_json_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content

        return res

    def get_multi_node_inventory_for_all_sku_and_all_ship_nodes(self, request: operations.GetMultiNodeInventoryForAllSkuAndAllShipNodesRequest) -> operations.GetMultiNodeInventoryForAllSkuAndAllShipNodesResponse:
        r"""Multiple Item Inventory for All Ship Nodes
        This API will retrieve the inventory count for all of a seller's items across all ship nodes by item to ship node mapping. Inventory can be zero or non-zero. Please note that NextCursor value changes and it needs to be passed on from the previous call to next call.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v3/inventories'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetMultiNodeInventoryForAllSkuAndAllShipNodesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetMultiNodeInventoryForAllSkuAndAllShipNodesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetMultiNodeInventoryForAllSkuAndAllShipNodes200ApplicationJSON])
                res.get_multi_node_inventory_for_all_sku_and_all_ship_nodes_200_application_json_object = out

        return res

    def get_multi_node_inventory_for_sku_and_all_shipnodes(self, request: operations.GetMultiNodeInventoryForSkuAndAllShipnodesRequest) -> operations.GetMultiNodeInventoryForSkuAndAllShipnodesResponse:
        r"""Single Item Inventory by Ship Node
        This API will retrieve the inventory count for an item across all ship nodes or one specific ship node. You can specify the ship node for which you want to fetch the inventory
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetMultiNodeInventoryForSkuAndAllShipnodesRequest, base_url, '/v3/inventories/{sku}', request)
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetMultiNodeInventoryForSkuAndAllShipnodesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetMultiNodeInventoryForSkuAndAllShipnodesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetMultiNodeInventoryForSkuAndAllShipnodes200ApplicationJSON])
                res.get_multi_node_inventory_for_sku_and_all_shipnodes_200_application_json_object = out

        return res

    def get_wfs_inventory(self, request: operations.GetWFSInventoryRequest) -> operations.GetWFSInventoryResponse:
        r"""WFS Inventory
        You can use this API to get the current Available to Sell inventory quantities for all WFS items in your catalog. You can also query specific SKUs or filter to only items updated after a specific date in order to reduce the response size.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v3/fulfillment/inventory'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GetWFSInventoryRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetWFSInventoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetWFSInventory200ApplicationJSON])
                res.get_wfs_inventory_200_application_json_object = out

        return res

    def update_bulk_inventory(self, request: operations.UpdateBulkInventoryRequest) -> operations.UpdateBulkInventoryResponse:
        r"""Bulk Item Inventory Update
        Updates inventory for items in bulk. 
        Seller Can either use feed type \"inventory\" or \"MP_INVENTORY\" 
        * Inventory spec 1.4 feed type: inventory 
        * Inventory spec 1.5 feed type: MP_INVENTORY 
        
        Please Note: Multi Node Inventory Update Feed (feedType=MP_INVENTORY) only supports JSON Request and Responses. Refer to \"MultiNode_Bulk_Inventory_Update_Request.json\" for the corresponding request sample 
         
        Refer to the <a href=\"https://developer.walmart.com/doc/us/us-mp/us-mp-inventory/\">guide section</a> for more detailed guide around each of the feed types 
        
         Refer to the throttling limits before uploading the Feed Files.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v3/feeds'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.UpdateBulkInventoryRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateBulkInventoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UpdateBulkInventory200ApplicationJSON])
                res.update_bulk_inventory_200_application_json_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content

        return res

    def update_inventory_for_an_item_json(self, request: operations.UpdateInventoryForAnItemJSONRequest) -> operations.UpdateInventoryForAnItemJSONResponse:
        r"""Update inventory
        Updates the inventory for a given item.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v3/inventory'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.UpdateInventoryForAnItemJSONRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInventoryForAnItemJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UpdateInventoryForAnItemJSON200ApplicationJSON])
                res.update_inventory_for_an_item_json_200_application_json_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content

        return res

    def update_inventory_for_an_item_raw(self, request: operations.UpdateInventoryForAnItemRawRequest) -> operations.UpdateInventoryForAnItemRawResponse:
        r"""Update inventory
        Updates the inventory for a given item.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v3/inventory'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.UpdateInventoryForAnItemRawRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInventoryForAnItemRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UpdateInventoryForAnItemRaw200ApplicationJSON])
                res.update_inventory_for_an_item_raw_200_application_json_object = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content

        return res

    def update_multi_node_inventory(self, request: operations.UpdateMultiNodeInventoryRequest) -> operations.UpdateMultiNodeInventoryResponse:
        r"""Update Item Inventory per Ship Node
        This API will update the inventory for an item across one or more fulfillment centers, known as ship nodes.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateMultiNodeInventoryRequest, base_url, '/v3/inventories/{sku}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateMultiNodeInventoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.UpdateMultiNodeInventory200ApplicationJSON])
                res.update_multi_node_inventory_200_application_json_object = out

        return res

    