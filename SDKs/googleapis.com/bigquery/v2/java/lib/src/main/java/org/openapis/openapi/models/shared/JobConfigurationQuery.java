/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

public class JobConfigurationQuery {
    /**
     * [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("allowLargeResults")
    public Boolean allowLargeResults;
    public JobConfigurationQuery withAllowLargeResults(Boolean allowLargeResults) {
        this.allowLargeResults = allowLargeResults;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("clustering")
    public Clustering clustering;
    public JobConfigurationQuery withClustering(Clustering clustering) {
        this.clustering = clustering;
        return this;
    }
    
    /**
     * Connection properties.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("connectionProperties")
    public ConnectionProperty[] connectionProperties;
    public JobConfigurationQuery withConnectionProperties(ConnectionProperty[] connectionProperties) {
        this.connectionProperties = connectionProperties;
        return this;
    }
    
    /**
     * [Optional] Specifies whether the query should be executed as a continuous query. The default value is false.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("continuous")
    public Boolean continuous;
    public JobConfigurationQuery withContinuous(Boolean continuous) {
        this.continuous = continuous;
        return this;
    }
    
    /**
     * [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createDisposition")
    public String createDisposition;
    public JobConfigurationQuery withCreateDisposition(String createDisposition) {
        this.createDisposition = createDisposition;
        return this;
    }
    
    /**
     * If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("createSession")
    public Boolean createSession;
    public JobConfigurationQuery withCreateSession(Boolean createSession) {
        this.createSession = createSession;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("defaultDataset")
    public DatasetReference defaultDataset;
    public JobConfigurationQuery withDefaultDataset(DatasetReference defaultDataset) {
        this.defaultDataset = defaultDataset;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("destinationEncryptionConfiguration")
    public EncryptionConfiguration destinationEncryptionConfiguration;
    public JobConfigurationQuery withDestinationEncryptionConfiguration(EncryptionConfiguration destinationEncryptionConfiguration) {
        this.destinationEncryptionConfiguration = destinationEncryptionConfiguration;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("destinationTable")
    public TableReference destinationTable;
    public JobConfigurationQuery withDestinationTable(TableReference destinationTable) {
        this.destinationTable = destinationTable;
        return this;
    }
    
    /**
     * [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("flattenResults")
    public Boolean flattenResults;
    public JobConfigurationQuery withFlattenResults(Boolean flattenResults) {
        this.flattenResults = flattenResults;
        return this;
    }
    
    /**
     * [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maximumBillingTier")
    public Integer maximumBillingTier;
    public JobConfigurationQuery withMaximumBillingTier(Integer maximumBillingTier) {
        this.maximumBillingTier = maximumBillingTier;
        return this;
    }
    
    /**
     * [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maximumBytesBilled")
    public String maximumBytesBilled;
    public JobConfigurationQuery withMaximumBytesBilled(String maximumBytesBilled) {
        this.maximumBytesBilled = maximumBytesBilled;
        return this;
    }
    
    /**
     * Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("parameterMode")
    public String parameterMode;
    public JobConfigurationQuery withParameterMode(String parameterMode) {
        this.parameterMode = parameterMode;
        return this;
    }
    
    /**
     * [Deprecated] This property is deprecated.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("preserveNulls")
    public Boolean preserveNulls;
    public JobConfigurationQuery withPreserveNulls(Boolean preserveNulls) {
        this.preserveNulls = preserveNulls;
        return this;
    }
    
    /**
     * [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("priority")
    public String priority;
    public JobConfigurationQuery withPriority(String priority) {
        this.priority = priority;
        return this;
    }
    
    /**
     * [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("query")
    public String query;
    public JobConfigurationQuery withQuery(String query) {
        this.query = query;
        return this;
    }
    
    /**
     * Query parameters for standard SQL queries.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("queryParameters")
    public QueryParameter[] queryParameters;
    public JobConfigurationQuery withQueryParameters(QueryParameter[] queryParameters) {
        this.queryParameters = queryParameters;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("rangePartitioning")
    public RangePartitioning rangePartitioning;
    public JobConfigurationQuery withRangePartitioning(RangePartitioning rangePartitioning) {
        this.rangePartitioning = rangePartitioning;
        return this;
    }
    
    /**
     * Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schemaUpdateOptions")
    public String[] schemaUpdateOptions;
    public JobConfigurationQuery withSchemaUpdateOptions(String[] schemaUpdateOptions) {
        this.schemaUpdateOptions = schemaUpdateOptions;
        return this;
    }
    
    /**
     * [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("tableDefinitions")
    public java.util.Map<String, ExternalDataConfiguration> tableDefinitions;
    public JobConfigurationQuery withTableDefinitions(java.util.Map<String, ExternalDataConfiguration> tableDefinitions) {
        this.tableDefinitions = tableDefinitions;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("timePartitioning")
    public TimePartitioning timePartitioning;
    public JobConfigurationQuery withTimePartitioning(TimePartitioning timePartitioning) {
        this.timePartitioning = timePartitioning;
        return this;
    }
    
    /**
     * Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery's standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("useLegacySql")
    public Boolean useLegacySql;
    public JobConfigurationQuery withUseLegacySql(Boolean useLegacySql) {
        this.useLegacySql = useLegacySql;
        return this;
    }
    
    /**
     * [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("useQueryCache")
    public Boolean useQueryCache;
    public JobConfigurationQuery withUseQueryCache(Boolean useQueryCache) {
        this.useQueryCache = useQueryCache;
        return this;
    }
    
    /**
     * Describes user-defined function resources used in the query.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("userDefinedFunctionResources")
    public UserDefinedFunctionResource[] userDefinedFunctionResources;
    public JobConfigurationQuery withUserDefinedFunctionResources(UserDefinedFunctionResource[] userDefinedFunctionResources) {
        this.userDefinedFunctionResources = userDefinedFunctionResources;
        return this;
    }
    
    /**
     * [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("writeDisposition")
    public String writeDisposition;
    public JobConfigurationQuery withWriteDisposition(String writeDisposition) {
        this.writeDisposition = writeDisposition;
        return this;
    }
    
}
