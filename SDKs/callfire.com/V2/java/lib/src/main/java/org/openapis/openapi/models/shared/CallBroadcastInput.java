/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * CallBroadcastInput - Call broadcast can be used to send out a voice message to a group of numbers. It supports IVR scripting, scheduling, retry logic, playing pre-recorded sounds, answering machine detection
 */
public class CallBroadcastInput {
    /**
     * Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("answeringMachineConfig")
    public CallBroadcastAnsweringMachineConfigEnum answeringMachineConfig;

    public CallBroadcastInput withAnsweringMachineConfig(CallBroadcastAnsweringMachineConfigEnum answeringMachineConfig) {
        this.answeringMachineConfig = answeringMachineConfig;
        return this;
    }
    
    /**
     * IVR xml is a document which describes the dialplan to setup the IVR broadcast
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dialplanXml")
    public String dialplanXml;

    public CallBroadcastInput withDialplanXml(String dialplanXml) {
        this.dialplanXml = dialplanXml;
        return this;
    }
    
    /**
     * Phone number in E.164 format (11-digit) or short code for text. Example: 12132000384, 67076
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("fromNumber")
    public String fromNumber;

    public CallBroadcastInput withFromNumber(String fromNumber) {
        this.fromNumber = fromNumber;
        return this;
    }
    
    /**
     * A unique id of broadcast (readonly)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("id")
    public Long id;

    public CallBroadcastInput withId(Long id) {
        this.id = id;
        return this;
    }
    
    /**
     * Labels of a broadcast
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("labels")
    public String[] labels;

    public CallBroadcastInput withLabels(String[] labels) {
        this.labels = labels;
        return this;
    }
    
    /**
     * Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("localTimeRestriction")
    public LocalTimeRestriction localTimeRestriction;

    public CallBroadcastInput withLocalTimeRestriction(LocalTimeRestriction localTimeRestriction) {
        this.localTimeRestriction = localTimeRestriction;
        return this;
    }
    
    /**
     * Sets a maximum number of calls to be dialed by CallFire at once
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxActive")
    public Integer maxActive;

    public CallBroadcastInput withMaxActive(Integer maxActive) {
        this.maxActive = maxActive;
        return this;
    }
    
    /**
     * A maximum number of active transfers
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maxActiveTransfers")
    public Integer maxActiveTransfers;

    public CallBroadcastInput withMaxActiveTransfers(Integer maxActiveTransfers) {
        this.maxActiveTransfers = maxActiveTransfers;
        return this;
    }
    
    /**
     * A name of a broadcast
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("name")
    public String name;

    public CallBroadcastInput withName(String name) {
        this.name = name;
        return this;
    }
    
    /**
     * Recipients of a call broadcast, can be either existing contacts or a new ones
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("recipients")
    public Recipient[] recipients;

    public CallBroadcastInput withRecipients(Recipient[] recipients) {
        this.recipients = recipients;
        return this;
    }
    
    /**
     * If true resumes the unfinished campaign to the next day
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resumeNextDay")
    public Boolean resumeNextDay;

    public CallBroadcastInput withResumeNextDay(Boolean resumeNextDay) {
        this.resumeNextDay = resumeNextDay;
        return this;
    }
    
    /**
     * Retry configuration will help you to resend a call or text if it was not delivered first time
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("retryConfig")
    public RetryConfig retryConfig;

    public CallBroadcastInput withRetryConfig(RetryConfig retryConfig) {
        this.retryConfig = retryConfig;
        return this;
    }
    
    /**
     * A list of schedule objects which specifies a range of time when broadcast should be started and stopped. Supports the scheduling per day of week
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schedules")
    public Schedule[] schedules;

    public CallBroadcastInput withSchedules(Schedule[] schedules) {
        this.schedules = schedules;
        return this;
    }
    
    /**
     * A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sounds")
    public CallBroadcastSounds sounds;

    public CallBroadcastInput withSounds(CallBroadcastSounds sounds) {
        this.sounds = sounds;
        return this;
    }
    
    public CallBroadcastInput(){}
}
