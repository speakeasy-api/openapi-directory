/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["https://studio.twilio.com"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * This is the public Twilio REST API.
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Triggers a new Engagement for the Flow
   */
  createEngagement(
    req: operations.CreateEngagementRequest,
    security: operations.CreateEngagementSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEngagementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateEngagementRequest(req);
    }

    let baseURL: string = operations.CreateEngagementServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateEngagementSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateEngagementResponse =
        new operations.CreateEngagementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowEngagement = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowEngagement
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Triggers a new Execution for the Flow
   */
  createExecution(
    req: operations.CreateExecutionRequest,
    security: operations.CreateExecutionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateExecutionRequest(req);
    }

    let baseURL: string = operations.CreateExecutionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateExecutionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateExecutionResponse =
        new operations.CreateExecutionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowExecution = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowExecution
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete this Engagement and all Steps relating to it.
   */
  deleteEngagement(
    req: operations.DeleteEngagementRequest,
    security: operations.DeleteEngagementSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteEngagementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteEngagementRequest(req);
    }

    let baseURL: string = operations.DeleteEngagementServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteEngagementSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteEngagementResponse =
        new operations.DeleteEngagementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete the Execution and all Steps relating to it.
   */
  deleteExecution(
    req: operations.DeleteExecutionRequest,
    security: operations.DeleteExecutionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteExecutionRequest(req);
    }

    let baseURL: string = operations.DeleteExecutionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteExecutionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteExecutionResponse =
        new operations.DeleteExecutionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a specific Flow.
   */
  deleteFlow(
    req: operations.DeleteFlowRequest,
    security: operations.DeleteFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteFlowRequest(req);
    }

    let baseURL: string = operations.DeleteFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Flows/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteFlowResponse =
        new operations.DeleteFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Engagement
   */
  fetchEngagement(
    req: operations.FetchEngagementRequest,
    security: operations.FetchEngagementSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEngagementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEngagementRequest(req);
    }

    let baseURL: string = operations.FetchEngagementServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEngagementSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEngagementResponse =
        new operations.FetchEngagementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowEngagement = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowEngagement
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the most recent context for an Engagement.
   */
  fetchEngagementContext(
    req: operations.FetchEngagementContextRequest,
    security: operations.FetchEngagementContextSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchEngagementContextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchEngagementContextRequest(req);
    }

    let baseURL: string = operations.FetchEngagementContextServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Context",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchEngagementContextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchEngagementContextResponse =
        new operations.FetchEngagementContextResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowEngagementEngagementContext = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowEngagementEngagementContext
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve an Execution
   */
  fetchExecution(
    req: operations.FetchExecutionRequest,
    security: operations.FetchExecutionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchExecutionRequest(req);
    }

    let baseURL: string = operations.FetchExecutionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchExecutionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchExecutionResponse =
        new operations.FetchExecutionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowExecution = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowExecution
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the most recent context for an Execution.
   */
  fetchExecutionContext(
    req: operations.FetchExecutionContextRequest,
    security: operations.FetchExecutionContextSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchExecutionContextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchExecutionContextRequest(req);
    }

    let baseURL: string = operations.FetchExecutionContextServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Context",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchExecutionContextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchExecutionContextResponse =
        new operations.FetchExecutionContextResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowExecutionExecutionContext = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowExecutionExecutionContext
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Step.
   */
  fetchExecutionStep(
    req: operations.FetchExecutionStepRequest,
    security: operations.FetchExecutionStepSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchExecutionStepResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchExecutionStepRequest(req);
    }

    let baseURL: string = operations.FetchExecutionStepServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchExecutionStepSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchExecutionStepResponse =
        new operations.FetchExecutionStepResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowExecutionExecutionStep = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowExecutionExecutionStep
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the context for an Execution Step.
   */
  fetchExecutionStepContext(
    req: operations.FetchExecutionStepContextRequest,
    security: operations.FetchExecutionStepContextSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchExecutionStepContextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchExecutionStepContextRequest(req);
    }

    let baseURL: string = operations.FetchExecutionStepContextServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{StepSid}/Context",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchExecutionStepContextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchExecutionStepContextResponse =
        new operations.FetchExecutionStepContextResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowExecutionExecutionStepExecutionStepContext =
              utils.objectToClass(
                httpRes?.data,
                shared.StudioV1FlowExecutionExecutionStepExecutionStepContext
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a specific Flow.
   */
  fetchFlow(
    req: operations.FetchFlowRequest,
    security: operations.FetchFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchFlowRequest(req);
    }

    let baseURL: string = operations.FetchFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(baseURL, "/v1/Flows/{Sid}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchFlowResponse =
        new operations.FetchFlowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1Flow = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1Flow
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a Step.
   */
  fetchStep(
    req: operations.FetchStepRequest,
    security: operations.FetchStepSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchStepResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchStepRequest(req);
    }

    let baseURL: string = operations.FetchStepServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps/{Sid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchStepSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchStepResponse =
        new operations.FetchStepResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowEngagementStep = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowEngagementStep
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve the context for an Engagement Step.
   */
  fetchStepContext(
    req: operations.FetchStepContextRequest,
    security: operations.FetchStepContextSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.FetchStepContextResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FetchStepContextRequest(req);
    }

    let baseURL: string = operations.FetchStepContextServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps/{StepSid}/Context",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FetchStepContextSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FetchStepContextResponse =
        new operations.FetchStepContextResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowEngagementStepStepContext = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowEngagementStepStepContext
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Engagements for the Flow.
   */
  listEngagement(
    req: operations.ListEngagementRequest,
    security: operations.ListEngagementSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEngagementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEngagementRequest(req);
    }

    let baseURL: string = operations.ListEngagementServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEngagementSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEngagementResponse =
        new operations.ListEngagementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEngagementResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListEngagementListEngagementResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Executions for the Flow.
   */
  listExecution(
    req: operations.ListExecutionRequest,
    security: operations.ListExecutionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListExecutionRequest(req);
    }

    let baseURL: string = operations.ListExecutionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListExecutionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListExecutionResponse =
        new operations.ListExecutionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listExecutionResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListExecutionListExecutionResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Steps for an Execution.
   */
  listExecutionStep(
    req: operations.ListExecutionStepRequest,
    security: operations.ListExecutionStepSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListExecutionStepResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListExecutionStepRequest(req);
    }

    let baseURL: string = operations.ListExecutionStepServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListExecutionStepSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListExecutionStepResponse =
        new operations.ListExecutionStepResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listExecutionStepResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListExecutionStepListExecutionStepResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Flows.
   */
  listFlow(
    req: operations.ListFlowRequest,
    security: operations.ListFlowSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFlowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFlowRequest(req);
    }

    let baseURL: string = operations.ListFlowServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = baseURL.replace(/\/$/, "") + "/v1/Flows";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListFlowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListFlowResponse = new operations.ListFlowResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFlowResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListFlowListFlowResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of all Steps for an Engagement.
   */
  listStep(
    req: operations.ListStepRequest,
    security: operations.ListStepSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.ListStepResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListStepRequest(req);
    }

    let baseURL: string = operations.ListStepServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListStepSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListStepResponse = new operations.ListStepResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listStepResponse = utils.objectToClass(
              httpRes?.data,
              operations.ListStepListStepResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the status of an Execution to `ended`.
   */
  updateExecution(
    req: operations.UpdateExecutionRequest,
    security: operations.UpdateExecutionSecurity,
    serverURL?: string,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateExecutionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateExecutionRequest(req);
    }

    let baseURL: string = operations.UpdateExecutionServerList[0];
    if (serverURL) {
      baseURL = serverURL;
    }
    const url: string = utils.generateURL(
      baseURL,
      "/v1/Flows/{FlowSid}/Executions/{Sid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "form"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateExecutionSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateExecutionResponse =
        new operations.UpdateExecutionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.studioV1FlowExecution = utils.objectToClass(
              httpRes?.data,
              shared.StudioV1FlowExecution
            );
          }
          break;
      }

      return res;
    });
  }
}
