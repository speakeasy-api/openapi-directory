"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainVerificationDetail = exports.DomainVerificationDetailUsageEnum = exports.DomainVerificationDetailTypeEnum = exports.DomainVerificationDetailStatusEnum = exports.DomainVerificationDetailCertificateAuthorityAuthorization = exports.DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum = exports.DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum = void 0;
var utils_1 = require("../../../internal/utils");
var class_transformer_1 = require("class-transformer");
/**
 * * `ADD_CA_TO_CAA` - The system found a CAA record in the domain hierarchy, but it did not find our CA in the record's values. Add `godaddy.com` or `starfieldtech.com` to the CAA record's values.
 *
 * @remarks
 * * `CREATE_TARGET_DOMAIN_CAA` - Create a CAA record on the specified domain with `godaddy.com` or `starfieldtech.com` as the value. If the system finds a CAA record in the specified domain, it will stop scanning the domain hierarchy, thereby preventing potentially problematic parent domain paths from being scanned.
 * * `DISABLE_DNSSEC` - Disable DNSSEC on the domain if CAA lookups fail and a DNSSEC scan is being used as the method for determining if the specified domain can remain in the certificate request.
 * * `FIX_CRITICAL_TAG` - When setting the critical flag in a CAA record, you must ensure you're using a well-known tag, per RFC 6844.
 * * `VALIDATE_SOA` - Make sure all queryPaths for the specified domain have an SOA record pointing to a valid publicly-accessible nameserver and respond in a timely fashion.
 *
 */
var DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum;
(function (DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum) {
    DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum["AddCaToCaa"] = "ADD_CA_TO_CAA";
    DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum["CreateTargetDomainCaa"] = "CREATE_TARGET_DOMAIN_CAA";
    DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum["DisableDnssec"] = "DISABLE_DNSSEC";
    DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum["FixCriticalTag"] = "FIX_CRITICAL_TAG";
    DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum["ValidateSoa"] = "VALIDATE_SOA";
})(DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum = exports.DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum || (exports.DomainVerificationDetailCertificateAuthorityAuthorizationRecommendationsEnum = {}));
/**
 * Returns the status of the CAA Lookup for the specified domain:
 *
 * @remarks
 * * `PENDING` - The CAA lookup has not yet been attempted for the specified domain.
 * * `REMOVED_DNS_ERROR` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNS errors then prevented the system from determining if DNSSEC was enabled for the specified domain, and it had to be removed from the certificate request.
 * * `REMOVED_DNSSEC_ENABLED` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNSSEC was determined to be enabled for the specified domain, and it had to be removed from the certificate request.
 * * `REMOVED_NOT_FOUND_CA` - CAA records were found during the CAA lookup for the speicified domain, but `godaddy.com` or `starfieldtech.com` was not listed as a value, thereby not allowing us to issue a certificate with this domain. The specified domain was removed from the certificate request.
 * * `REMOVED_UNKNOWN_CRITICAL_TAG` - A CAA record was found during the CAA lookup with its Critical bit set, as outlined by RFC 6844, yet the Tag of the CAA record was not understood (as outlined by RFC 6844). The specified domain was removed from the certificate request.
 * * `SUCCESS_CAA` - The CAA lookup was successful for the specified domain, and the domain can remain in the certificate request.
 * * `SUCCESS_DNSSEC` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. The system detemined that DNSSEC was not enabled for the specified domain, so the domain is allowed to remain in the certificate request.
 *
 */
var DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum;
(function (DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum) {
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["Pending"] = "PENDING";
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["RemovedDnsError"] = "REMOVED_DNS_ERROR";
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["RemovedDnssecEnabled"] = "REMOVED_DNSSEC_ENABLED";
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["RemovedNotFoundCa"] = "REMOVED_NOT_FOUND_CA";
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["RemovedUnknownCriticalTag"] = "REMOVED_UNKNOWN_CRITICAL_TAG";
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["SuccessCaa"] = "SUCCESS_CAA";
    DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum["SuccessDnssec"] = "SUCCESS_DNSSEC";
})(DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum = exports.DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum || (exports.DomainVerificationDetailCertificateAuthorityAuthorizationStatusEnum = {}));
/**
 * Contains information about the last Certificate Authority Authorization (CAA) Lookup details for the specified domain.
 *
 * @remarks
 *
 * In order for a domain to be eligible to be included in the certificate, the entire domain hierarchy must be scanned for DNS CAA records, as outlined by RFC 6844.
 *
 * The absence of any CAA records found in the domain hierarchy indicates that the domain may be included in the certificate. Alternatively, if CAA records are found when scanning the domain hierarchy, the domain may be included in the certificate as long as `godaddy.com` or `starfieldtech.com` is found in the DNS record value. However, if CAA records are found, yet `godaddy.com` or `starfieldtech.com` is not found in any CAA record's value, then we must drop the domain from the certificate request.
 *
 * In the case where there are repeated DNS errors when scanning the domain hierarchy for CAA records, thus ending in an unsuccessful scan, then the domain can still be included in the certificate provided the primary domain is not setup with DNSSEC. Conversely, if DNSSEC is found to be setup on the primary domain when scanning following repeated CAA failures, the domain must be dropped from the certificate request. Finally, if DNS errors persist to the point where a successful DNSSEC query could not be obtained, then the domain must be dropped from the certificate request.
 *
 */
var DomainVerificationDetailCertificateAuthorityAuthorization = /** @class */ (function (_super) {
    __extends(DomainVerificationDetailCertificateAuthorityAuthorization, _super);
    function DomainVerificationDetailCertificateAuthorityAuthorization() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "completedAt" }),
        __metadata("design:type", String)
    ], DomainVerificationDetailCertificateAuthorityAuthorization.prototype, "completedAt", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "queryPaths" }),
        __metadata("design:type", Array)
    ], DomainVerificationDetailCertificateAuthorityAuthorization.prototype, "queryPaths", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "recommendations" }),
        __metadata("design:type", Array)
    ], DomainVerificationDetailCertificateAuthorityAuthorization.prototype, "recommendations", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "status" }),
        __metadata("design:type", String)
    ], DomainVerificationDetailCertificateAuthorityAuthorization.prototype, "status", void 0);
    return DomainVerificationDetailCertificateAuthorityAuthorization;
}(utils_1.SpeakeasyBase));
exports.DomainVerificationDetailCertificateAuthorityAuthorization = DomainVerificationDetailCertificateAuthorityAuthorization;
/**
 * Domain verification status:
 *
 * @remarks
 *   * `AWAITING` - Verification pending customer input
 *   * `INVALID` - SAN connected to a cancelled request
 *   * `COMPLETED` - Verification completed
 *   * `FAILED_VERIFICATION` - Verification failed
 *   * `PENDING_POSSIBLE_FRAUD` - Flagged for a system level fraud review
 *   * `VERIFIED_POSSIBLE_FRAUD` - Fraud detection reviewed but verified
 *   * `DROPPED` - SAN dropped from request
 *   * `REVOKED_CERT` - Certificate revoked
 *   * `DROPPED_GOOGLE_SAFE_BROWSING` - SAN dropped from request due to Google Safe Browsing check
 *   * `DROPPED_CERTIFICATE_AUTHORITY_AUTHORIZATION` - SAN dropped from request due to Certificate Authorization Authority DNS record check
 *
 */
var DomainVerificationDetailStatusEnum;
(function (DomainVerificationDetailStatusEnum) {
    DomainVerificationDetailStatusEnum["Completed"] = "COMPLETED";
    DomainVerificationDetailStatusEnum["FailedVerification"] = "FAILED_VERIFICATION";
    DomainVerificationDetailStatusEnum["VerifiedPossibleFraud"] = "VERIFIED_POSSIBLE_FRAUD";
    DomainVerificationDetailStatusEnum["Dropped"] = "DROPPED";
    DomainVerificationDetailStatusEnum["DroppedCertificateAuthorityAuthorization"] = "DROPPED_CERTIFICATE_AUTHORITY_AUTHORIZATION";
    DomainVerificationDetailStatusEnum["DroppedGoogleSafeBrowsing"] = "DROPPED_GOOGLE_SAFE_BROWSING";
    DomainVerificationDetailStatusEnum["Invalid"] = "INVALID";
    DomainVerificationDetailStatusEnum["Awaiting"] = "AWAITING";
    DomainVerificationDetailStatusEnum["PendingPossibleFraud"] = "PENDING_POSSIBLE_FRAUD";
    DomainVerificationDetailStatusEnum["RevokedCertificate"] = "REVOKED_CERTIFICATE";
})(DomainVerificationDetailStatusEnum = exports.DomainVerificationDetailStatusEnum || (exports.DomainVerificationDetailStatusEnum = {}));
/**
 * Domain verification type:
 *
 * @remarks
 *   * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMIN` - Domain verified using domain control verification email sent to admin@<your.domain.com>
 *   * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMINSTRATOR` - Domain verified using domain control verification email sent to administrator@<your.domain.com>
 *   * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_HOST_MASTER` - Domain verified using domain control verification email sent to hostmaster@<your.domain.com>
 *   * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_POST_MASTER` - Domain verified using domain control verification email sent to postmaster@<your.domain.com>
 *   * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_WEB_MASTER` - Domain verified using domain control verification email sent to webmaster@<your.domain.com>
 *   * `DOMAIN_ACCESS_EMAIL` - Domain verified using a domain access email
 *   * `DOMAIN_ACCESS_LETTER` - Customer completed a domain access letter which was used for domain verification
 *   * `DOMAIN_CONTROL_EMAIL` - Domain verified using HTML file or DNS zone file text value
 *   * `DOMAIN_ZONE_CONTROL` - DNS zone file containing a pre-generated text value used for domain verification
 *   * `MANUAL_DOMAIN_ACCESS_EMAIL` - DAE sent to an email address manually entered by a rep
 *   * `PREVIOUS_DOMAIN_ACCESS_EMAIL` - Customers domain access email for a prior certificate request was used for domain verification
 *   * `REGISTRATION_AUTHORITY_DOMAIN_ACCESS_LETTER` - Representative reviewed a customer provided domain access letter and verified domain
 *   * `REGISTRATION_AUTHORITY_DOMAIN_ZONE_CONTROL` - Representative verified domain using a manual domain zone control check
 *   * `REGISTRATION_AUTHORITY_OVERRIDE` - Representative verified domain using alternative methods
 *   * `REGISTRATION_AUTHORITY_WEBSITE_CONTROL` - Representative verified domain using a manual website control check
 *   * `CUSTOMER_OWNED` - Validated customer account information used for domain control verification
 *   * `WEBSITE_CONTROL` - HTML file in root website directory containing pre-generated value used for domain control verification
 *
 */
var DomainVerificationDetailTypeEnum;
(function (DomainVerificationDetailTypeEnum) {
    DomainVerificationDetailTypeEnum["DomainControlEmail"] = "DOMAIN_CONTROL_EMAIL";
    DomainVerificationDetailTypeEnum["AutoGeneratedDomainAccessEmailAdmin"] = "AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMIN";
    DomainVerificationDetailTypeEnum["AutoGeneratedDomainAccessEmailAdminstrator"] = "AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMINSTRATOR";
    DomainVerificationDetailTypeEnum["AutoGeneratedDomainAccessEmailHostMaster"] = "AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_HOST_MASTER";
    DomainVerificationDetailTypeEnum["AutoGeneratedDomainAccessEmailPostMaster"] = "AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_POST_MASTER";
    DomainVerificationDetailTypeEnum["AutoGeneratedDomainAccessEmailWebMaster"] = "AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_WEB_MASTER";
    DomainVerificationDetailTypeEnum["DomainAccessEmail"] = "DOMAIN_ACCESS_EMAIL";
    DomainVerificationDetailTypeEnum["DomainAccessLetter"] = "DOMAIN_ACCESS_LETTER";
    DomainVerificationDetailTypeEnum["DomainZoneControl"] = "DOMAIN_ZONE_CONTROL";
    DomainVerificationDetailTypeEnum["ManualDomainAccessEmail"] = "MANUAL_DOMAIN_ACCESS_EMAIL";
    DomainVerificationDetailTypeEnum["PreviousDomainAccessEmail"] = "PREVIOUS_DOMAIN_ACCESS_EMAIL";
    DomainVerificationDetailTypeEnum["RegistrationAuthorityDomainAccessLetter"] = "REGISTRATION_AUTHORITY_DOMAIN_ACCESS_LETTER";
    DomainVerificationDetailTypeEnum["RegistrationAuthorityDomainZoneControl"] = "REGISTRATION_AUTHORITY_DOMAIN_ZONE_CONTROL";
    DomainVerificationDetailTypeEnum["RegistrationAuthorityOverride"] = "REGISTRATION_AUTHORITY_OVERRIDE";
    DomainVerificationDetailTypeEnum["RegistrationAuthorityWebsiteControl"] = "REGISTRATION_AUTHORITY_WEBSITE_CONTROL";
    DomainVerificationDetailTypeEnum["CustomerOwned"] = "CUSTOMER_OWNED";
    DomainVerificationDetailTypeEnum["WebsiteControl"] = "WEBSITE_CONTROL";
})(DomainVerificationDetailTypeEnum = exports.DomainVerificationDetailTypeEnum || (exports.DomainVerificationDetailTypeEnum = {}));
/**
 * Type of domain name used for domain verification
 */
var DomainVerificationDetailUsageEnum;
(function (DomainVerificationDetailUsageEnum) {
    DomainVerificationDetailUsageEnum["CommonName"] = "COMMON_NAME";
    DomainVerificationDetailUsageEnum["SubjectAlternativeName"] = "SUBJECT_ALTERNATIVE_NAME";
})(DomainVerificationDetailUsageEnum = exports.DomainVerificationDetailUsageEnum || (exports.DomainVerificationDetailUsageEnum = {}));
/**
 * Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details.
 */
var DomainVerificationDetail = /** @class */ (function (_super) {
    __extends(DomainVerificationDetail, _super);
    function DomainVerificationDetail() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "certificateAuthorityAuthorization" }),
        (0, class_transformer_1.Type)(function () { return DomainVerificationDetailCertificateAuthorityAuthorization; }),
        __metadata("design:type", DomainVerificationDetailCertificateAuthorityAuthorization)
    ], DomainVerificationDetail.prototype, "certificateAuthorityAuthorization", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "createdAt" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "createdAt", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "dceToken" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "dceToken", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "domain" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "domain", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "domainEntityId" }),
        __metadata("design:type", Number)
    ], DomainVerificationDetail.prototype, "domainEntityId", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "modifiedAt" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "modifiedAt", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "status" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "status", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "type" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "type", void 0);
    __decorate([
        (0, utils_1.SpeakeasyMetadata)(),
        (0, class_transformer_1.Expose)({ name: "usage" }),
        __metadata("design:type", String)
    ], DomainVerificationDetail.prototype, "usage", void 0);
    return DomainVerificationDetail;
}(utils_1.SpeakeasyBase));
exports.DomainVerificationDetail = DomainVerificationDetail;
