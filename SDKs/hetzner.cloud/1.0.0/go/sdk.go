// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"net/http"
	"openapi/pkg/utils"
	"time"
)

// ServerList contains the list of servers available to the SDK
var ServerList = []string{
	"https://api.hetzner.cloud/v1",
}

// HTTPClient provides an interface for suplying the SDK with a custom HTTP client
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// String provides a helper function to return a pointer to a string
func String(s string) *string { return &s }

// Bool provides a helper function to return a pointer to a bool
func Bool(b bool) *bool { return &b }

// Int provides a helper function to return a pointer to an int
func Int(i int) *int { return &i }

// Int64 provides a helper function to return a pointer to an int64
func Int64(i int64) *int64 { return &i }

// Float32 provides a helper function to return a pointer to a float32
func Float32(f float32) *float32 { return &f }

// Float64 provides a helper function to return a pointer to a float64
func Float64(f float64) *float64 { return &f }

// SDK - This is the official API documentation for the Public Hetzner Cloud.
//
// ## Introduction
//
// The Hetzner Cloud API operates over HTTPS and uses JSON as its data format. The API is a RESTful API and utilizes HTTP methods and HTTP status codes to specify requests and responses.
//
// As an alternative to working directly with our API you may also consider to use:
// * Our CLI program [hcloud](https://github.com/hetznercloud/cli)
// * Our [library for Go](https://github.com/hetznercloud/hcloud-go)
// * Our [library for Python](https://github.com/hetznercloud/hcloud-python)
//
// Also you can find a [list of libraries, tools, and integrations on GitHub](https://github.com/hetznercloud/awesome-hcloud).
//
// If you are developing integrations based on our API and your product is Open Source you may be eligible for a free one time €50 (excl. VAT) credit on your account. Please contact us via the the support page on your Cloud Console and let us know the following:
// * The type of integration you would like to develop
// * Link to the GitHub repo you will use for the Project
// * Link to some other Open Source work you have already done (if you have done so)
//
// ## Getting Started
// To get started using the API you first need an API token. Sign in into the [Hetzner Cloud Console](https://console.hetzner.cloud/) choose a Project, go to `Security` → `API Tokens`, and generate a new token. Make sure to copy the token because it won’t be shown to you again. A token is bound to a Project, to interact with the API of another Project you have to create a new token inside the Project. Let’s say your new token is `jEheVytlAoFl7F8MqUQ7jAo2hOXASztX`.
//
// You’re now ready to do your first request against the API. To get a list of all Servers in your Project, issue the example request on the right side using [curl](https://curl.haxx.se/).
//
// Make sure to replace the token in the example command with the token you have just created. Since your Project probably does not contain any Servers yet, the example response will look like the response on the right side. We will almost always provide a resource root like `servers` inside the example response. A response can also contain a `meta` object with information like [Pagination](https://docs.hetzner.cloud/#overview-pagination).
//
// **Example Request**
// ```bash
//
//	curl -H "Authorization: Bearer jEheVytlAoFl7F8MqUQ7jAo2hOXASztX" \
//	    https://api.hetzner.cloud/v1/servers
//
// ```
//
// **Example Response**
// ```json
//
//	{
//	    "servers": [],
//	    "meta": {
//	        "pagination": {
//	            "page": 1,
//	            "per_page": 25,
//	            "previous_page": null,
//	            "next_page": null,
//	            "last_page": 1,
//	            "total_entries": 0
//	        }
//	    }
//	}
//
// ```
//
// ## Authentication
// All requests to the Hetzner Cloud API must be authenticated via a API token. Include your secret API token in every request you send to the API with the `Authorization` HTTP header.
//
// To create a new API token for your Project, switch into the [Hetzner Cloud Console](https://console.hetzner.cloud/) choose a Project, go to `Security` → `API Tokens`, and generate a new token.
//
// **Example Authorization header**
// ```html
// Authorization: Bearer LRK9DAWQ1ZAEFSrCNEEzLCUwhYX1U3g7wMg4dTlkkDC96fyDuyJ39nVbVjCKSDfj
// ```
//
// ## Errors
// Errors are indicated by HTTP status codes. Further, the response of the request which generated the error contains an error code, an error message, and, optionally, error details. The schema of the error details object depends on the error code.
//
// The error response contains the following keys:
//
// | Keys      | Meaning                                                               |
// |-----------|-----------------------------------------------------------------------|
// | `code`    | Short string indicating the type of error (machine-parsable)          |
// | `message` | Textual description on what has gone wrong                            |
// | `details` | An object providing for details on the error (schema depends on code) |
//
// **Example response**
// ```json
//
//	{
//	  "error": {
//	    "code": "invalid_input",
//	    "message": "invalid input in field 'broken_field': is too long",
//	    "details": {
//	      "fields": [
//	        {
//	          "name": "broken_field",
//	          "messages": ["is too long"]
//	        }
//	      ]
//	    }
//	  }
//	}
//
// ```
//
// ### Error Codes
//
// | Code                      | Description                                                                      |
// |---------------------------|----------------------------------------------------------------------------------|
// | `forbidden`               | Insufficient permissions for this request                                        |
// | `invalid_input`           | Error while parsing or processing the input                                      |
// | `json_error`              | Invalid JSON input in your request                                               |
// | `locked`                  | The item you are trying to access is locked (there is already an Action running) |
// | `not_found`               | Entity not found                                                                 |
// | `rate_limit_exceeded`     | Error when sending too many requests                                             |
// | `resource_limit_exceeded` | Error when exceeding the maximum quantity of a resource for an account           |
// | `resource_unavailable`    | The requested resource is currently unavailable                                  |
// | `service_error`           | Error within a service                                                           |
// | `uniqueness_error`        | One or more of the objects fields must be unique                                 |
// | `protected`               | The Action you are trying to start is protected for this resource                |
// | `maintenance`             | Cannot perform operation due to maintenance                                      |
// | `conflict`                | The resource has changed during the request, please retry                        |
// | `unsupported_error`       | The corresponding resource does not support the Action                           |
// | `token_readonly`          | The token is only allowed to perform GET requests                                |
// | `unavailable`             | A service or product is currently not available                                  |
//
// **invalid_input**
// ```json
//
//	{
//	  "error": {
//	    "code": "invalid_input",
//	    "message": "invalid input in field 'broken_field': is too long",
//	    "details": {
//	      "fields": [
//	        {
//	          "name": "broken_field",
//	          "messages": ["is too long"]
//	        }
//	      ]
//	    }
//	  }
//	}
//
// ```
//
// **uniqueness_error**
// ```json
//
//	{
//	  "error": {
//	    "code": "uniqueness_error",
//	    "message": "SSH key with the same fingerprint already exists",
//	    "details": {
//	      "fields": [
//	        {
//	          "name": "public_key"
//	        }
//	      ]
//	    }
//	  }
//	}
//
// ```
//
// **resource_limit_exceeded**
// ```json
//
//	{
//	  "error": {
//	    "code": "resource_limit_exceeded",
//	    "message": "project limit exceeded",
//	    "details": {
//	      "limits": [
//	        {
//	          "name": "project_limit"
//	        }
//	      ]
//	    }
//	  }
//	}
//
// ```
//
// ## Labels
// Labels are `key/value` pairs that can be attached to all resources.
//
// Valid label keys have two segments: an optional prefix and name, separated by a slash (`/`). The name segment is required and must be a string of 63 characters or less, beginning and ending with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between. The prefix is optional. If specified, the prefix must be a DNS subdomain: a series of DNS labels separated by dots (`.`), not longer than 253 characters in total, followed by a slash (`/`).
//
// Valid label values must be a string of 63 characters or less and must be empty or begin and end with an alphanumeric character (`[a-z0-9A-Z]`) with dashes (`-`), underscores (`_`), dots (`.`), and alphanumerics between.
//
// The `hetzner.cloud/` prefix is reserved and cannot be used.
//
// **Example Labels**
// ```json
//
//	{
//	  "labels": {
//	    "environment":"development",
//	    "service":"backend",
//	    "example.com/my":"label",
//	    "just-a-key":""
//	  }
//	}
//
// ```
//
// ## Label Selector
// For resources with labels, you can filter resources by their labels using the label selector query language.
//
// | Expression           | Meaning                                                             |
// |----------------------|---------------------------------------------------------------------|
// | `k==v` / `k=v`       | Value of key `k` does equal value `v`                               |
// | `k!=v`               | Value of key `k` does not equal value `v`                           |
// | `k`                  | Key `k` is present                                                  |
// | `!k`                 | Key `k` is not present                                              |
// | `k in (v1,v2,v3)`    | Value of key `k` is `v1`, `v2`, or `v3`                             |
// | `k notin (v1,v2,v3)` | Value of key `k` is neither `v1`, nor `v2`, nor `v3`                |
// | `k1==v,!k2`          | Value of key `k1` is `v` and key `k2` is not present                |
//
// ### Examples
// * Returns all resources that have a `env=production` label and that don't have a `type=database` label:
//
//	`env=production,type!=database`
//
// * Returns all resources that have a `env=testing` or `env=staging` label:
//
//	`env in (testing,staging)`
//
// * Returns all resources that don't have a `type` label:
//
//	`!type`
//
// ## Pagination
// Responses which return multiple items support pagination. If they do support pagination, it can be controlled with following query string parameters:
//
// * A `page` parameter specifies the page to fetch. The number of the first page is 1.
// * A `per_page` parameter specifies the number of items returned per page. The default value is 25, the maximum value is 50 except otherwise specified in the documentation.
//
// Responses contain a `Link` header with pagination information.
//
// Additionally, if the response body is JSON and the root object is an object, that object has a `pagination` object inside the `meta` object with pagination information:
//
// **Example Pagination**
// ```json
//
//	{
//	    "servers": [...],
//	    "meta": {
//	        "pagination": {
//	            "page": 2,
//	            "per_page": 25,
//	            "previous_page": 1,
//	            "next_page": 3,
//	            "last_page": 4,
//	            "total_entries": 100
//	        }
//	    }
//	}
//
// ```
//
// The keys `previous_page`, `next_page`, `last_page`, and `total_entries` may be `null` when on the first page, last page, or when the total number of entries is unknown.
//
// **Example Pagination Link header**
// ```bash
// Link: <https://api.hetzner.cloud/v1/actions?page=2&per_page=5>; rel="prev",
//
//	<https://api.hetzner.cloud/v1/actions?page=4&per_page=5>; rel="next",
//	<https://api.hetzner.cloud/v1/actions?page=6&per_page=5>; rel="last"
//
// ```
//
// Line breaks have been added for display purposes only and responses may only contain some of the above `rel` values.
//
// ## Rate Limiting
// All requests, whether they are authenticated or not, are subject to rate limiting. If you have reached your limit, your requests will be handled with a `429 Too Many Requests` error. Burst requests are allowed. Responses contain serveral headers which provide information about your current rate limit status.
//
// * The `RateLimit-Limit` header contains the total number of requests you can perform per hour.
// * The `RateLimit-Remaining` header contains the number of requests remaining in the current rate limit time frame.
// * The `RateLimit-Reset` header contains a UNIX timestamp of the point in time when your rate limit will have recovered and you will have the full number of requests available again.
//
// The default limit is 3600 requests per hour and per Project. The number of remaining requests increases gradually. For example, when your limit is 3600 requests per hour, the number of remaining requests will increase by 1 every second.
//
// ## Server Metadata
// Your Server can discover metadata about itself by doing a HTTP request to specific URLs. The following data is available:
//
// | Data              | Format | Contents                                                     |
// |-------------------|--------|--------------------------------------------------------------|
// | hostname          | text   | Name of the Server as set in the api                         |
// | instance-id       | number | ID of the server                                             |
// | public-ipv4       | text   | Primary public IPv4 address                                  |
// | private-networks  | yaml   | Details about the private networks the Server is attached to |
// | availability-zone | text   | Name of the availability zone that Server runs in            |
// | region            | text   | Network zone, e.g. eu-central                                |
//
// **Example: Summary**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata
// ```
//
// ```yaml
// availability-zone: hel1-dc2
// hostname: my-server
// instance-id: 42
// public-ipv4: 1.2.3.4
// region: eu-central
// ```
//
// **Example: Hostname**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata/hostname
// my-server
// ```
//
// **Example: Instance ID**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata/instance-id
// 42
// ```
//
// **Example: Public IPv4**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata/public-ipv4
// 1.2.3.4
// ```
//
// **Example: Private Networks**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata/private-networks
// ```
//
// ```json
//   - ip: 10.0.0.2
//     alias_ips: [10.0.0.3, 10.0.0.4]
//     interface_num: 1
//     mac_address: 86:00:00:2a:7d:e0
//     network_id: 1234
//     network_name: nw-test1
//     network: 10.0.0.0/8
//     subnet: 10.0.0.0/24
//     gateway: 10.0.0.1
//   - ip: 192.168.0.2
//     alias_ips: []
//     interface_num: 2
//     mac_address: 86:00:00:2a:7d:e1
//     network_id: 4321
//     network_name: nw-test2
//     network: 192.168.0.0/16
//     subnet: 192.168.0.0/24
//     gateway: 192.168.0.1
//
// ```
//
// **Example: Availability Zone**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata/availability-zone
// hel1-dc2
// ```
//
// **Example: Region**
// ```bash
// $ curl http://169.254.169.254/hetzner/v1/metadata/region
// eu-central
// ```
//
// ## Sorting
// Some responses which return multiple items support sorting. If they do support sorting the documentation states which fields can be used for sorting. You specify sorting with the `sort` query string parameter. You can sort by multiple fields. You can set the sort direction by appending `:asc` or `:desc` to the field name. By default, ascending sorting is used.
//
// **Example: Sorting**
// ```bash
// https://api.hetzner.cloud/v1/actions?sort=status
// https://api.hetzner.cloud/v1/actions?sort=status:asc
// https://api.hetzner.cloud/v1/actions?sort=status:desc
// https://api.hetzner.cloud/v1/actions?sort=status:asc&sort=command:desc
// ```
type SDK struct {
	// Actions - Actions show the results and progress of asynchronous requests to the API.
	Actions            *actions
	CertificateActions *certificateActions
	// Certificates - TLS/SSL Certificates prove the identity of a Server and are used to encrypt client traffic.
	Certificates *certificates
	// Datacenters - Each Datacenter represents a *virtual* Datacenter which is made up of possible many physical Datacenters where Servers are hosted.
	//
	// Datacenter names are composed from their Location and virtual Datacenter number, for example `fsn1-dc14` means virtual Datacenter `14` in Location `fsn1`.
	//
	// Right now there is only one Datacenter for each Location. The Datacenter numbers for `fsn`, `nbg` and `hel` are arbitrarily set to `14`, `3` and `2` for historic reasons and do not represent real physical Hetzner datacenters.
	//
	Datacenters     *datacenters
	FirewallActions *firewallActions
	// Firewalls - Firewalls can limit the network access to or from your resources.
	//
	// * When applying a firewall with no `in` rule all inbound traffic will be dropped. The default for `in` is `DROP`.
	// * When applying a firewall with no `out` rule all outbound traffic will be accepted. The default for `out` is `ACCEPT`.
	//
	Firewalls         *firewalls
	FloatingIPActions *floatingIPActions
	// FloatingIPs - Floating IPs help you to create highly available setups. You can assign a Floating IP to any Server. The Server can then use this IP. You can reassign it to a different Server at any time, or you can choose to unassign the IP from Servers all together.
	//
	// Floating IPs can be used globally. This means you can assign a Floating IP to a Server in one Location and later reassign it to a Server in a different Location. For optimal routing and latency Floating IPs should be used in the Location they were created in.
	//
	// For Floating IPs to work with your Server, you must configure them inside your operation system.
	//
	// Floating IPs of type `ipv4` use a single IPv4 address as their `ip` property. Floating IPs of type `ipv6` use a /64 network such as `fc00::/64` as their `ip` property. Any IP address within that network can be used on your host.
	//
	// Floating IPs are billed on a monthly basis.
	//
	FloatingIPs *floatingIPs
	// ISOs - ISOs are read-only Images of DVDs. While we recommend using our Image functionality to install your Servers we also provide some stock ISOs so you can install more exotic operating systems by yourself.
	//
	// On request our support uploads a private ISO just for you. These are marked with type `private` and only visible in your Project.
	//
	// To attach an ISO to your Server use `POST /servers/{id}/actions/attach_iso`.
	//
	ISOs         *isOs
	ImageActions *imageActions
	// Images - Images are blueprints for your VM disks. They can be of different types:
	//
	// ### System Images
	// Distribution Images maintained by us, e.g. “Ubuntu 20.04”
	//
	// ### Snapshot Images
	// Maintained by you, for example “Ubuntu 20.04 with my own settings”. These are billed per GB per month.
	//
	// ### Backup Images
	// Daily Backups of your Server. Will automatically be created for Servers which have backups enabled (`POST /servers/{id}/actions/enable_backup`)
	//
	// Bound to exactly one Server. If you delete the Server, you also delete all backups bound to it. You may convert backup Images to snapshot Images to keep them.
	//
	// These are billed at 20% of your instance price for 7 backup slots.
	//
	// ### App Images
	// Prebuild images with specific software configurations, e.g. “Wordpress”. All app images are created by us.
	//
	Images              *images
	LoadBalancerActions *loadBalancerActions
	// LoadBalancerTypes - Load Balancer types define kinds of Load Balancers offered. Each type has an hourly and a monthly cost. You will pay whichever amount is lower for your usage of this specific Load Balancer. Costs may differ between Locations.
	//
	// Currency for all amounts is €. All prices exclude VAT.
	//
	LoadBalancerTypes *loadBalancerTypes
	LoadBalancers     *loadBalancers
	// Locations - Datacenters are organized by Locations. Datacenters in the same Location are connected with very low latency links.
	Locations      *locations
	NetworkActions *networkActions
	// Networks - Networks is a private networks feature. These Networks are optional and they coexist with the public network that every Server has by default.
	//
	// They allow Servers to talk to each other over a dedicated network interface using private IP addresses not available publicly.
	//
	// The IP addresses are allocated and managed via the API, they must conform to [RFC1918](https://tools.ietf.org/html/rfc1918#section-3) standard. IPs and network interfaces defined under Networks do not provide public internet connectivity, you will need to use the already existing public network interface for that.
	//
	// Each network has a user selected `ip_range` which defines all available IP addresses which can be used for Subnets within the Network.
	//
	// To assign individual IPs to Servers you will need to create Network Subnets, described below.
	//
	// Currently Networks support IPv4 only.
	//
	// ### Subnets
	// Subnets divide the `ip_range` from the parent Network object into multiple Subnetworks that you can use for different specific purposes.
	//
	// For each subnet you need to specify its own `ip_range` which must be contained within the parent Network’s `ip_range`. Additionally each subnet must belong to one of the available Network Zones described below. Subnets can not have overlapping IP ranges.
	//
	// Currently there are three types of subnet:
	// * type `cloud` is used to connect cloud Resources into your Network.
	// * type `server` was used to connect only cloud Servers into your Network. This type is deprecated and is replaced by type cloud.
	// * type `vswitch` allows you to connect [Dedicated Server vSwitch](https://docs.hetzner.com/robot/dedicated-server/network/vswitch) - and all Dedicated Servers attached to it - into your Network
	//
	// Subnets of type `vswitch` must set a `vswitch_id` which is the ID of the existing vSwitch in Hetzner Robot that should be coupled.
	//
	// ### Network Zones
	// Network Zones are groups of Locations which have special high-speed network connections between them. The [Location object](https://docs.hetzner.cloud/#locations-get-a-location) contains the `network_zone` property each Location belongs to. Currently these network zones exist:
	//
	// |Network Zone|Contains Locations|
	// |------------|------------------|
	// |eu-central  | nbg1, fsn1, hel1 |
	// |us-east     | ash              |
	//
	// ### IP address management
	// When a cloud Server is attached to a network without the user specifying an IP it automatically gets an IP address assigned from a subnet of type `server` in the same network zone. If you specify the optional `ip` parameter when attaching then we will try to assign that IP. Keep in mind that the Server’s location must be covered by the Subnet’s Network Zone if you specify an IP, or that at least one Subnet with the zone covering Server’s location must exist.
	//
	// A cloud Server can also have more than one IP address in a Network by specifying aliases. For details see the [attach to network action](https://docs.hetzner.cloud/#server-actions-attach-a-server-to-a-network).
	//
	// The following IP addresses are reserved in networks and can not be used:
	//   * the first IP of the network `ip_range` as it will be used as a default gateway for the private Network interface.
	//   * `172.31.1.1` as it is being used as default gateway for our public Network interfaces.
	//
	// ### Coupling Dedicated Servers
	//
	// By using subnets of type `vswitch` you can couple the Cloud Networks with an existing [Dedicated Server vSwitch](https://docs.hetzner.com/robot/dedicated-server/network/vswitch) and enable dedicated and cloud servers to
	// talk to each other over the Network.
	// In order for this to work the dedicated servers may only use IPs from the subnet and must have a special network configuration. Please refer to [FAQ](https://docs.hetzner.com/cloud/networks/connect-dedi-vswitch). vSwitch Layer 2 features are not supported.
	//
	// ### Routes
	// Networks also support the notion of routes which are automatically applied to private traffic. A route makes sure that all packets for a given `destination` IP prefix will be sent to the address specified in its `gateway`.
	//
	Networks *networks
	// PlacementGroups - Placement groups are used to influence the location of interdependent virtual servers in our data centers. The distribution of the different instances within a group is based on a pattern specified in the type. By enforcing certain rules on the placement of instances within our infrastructure, availability can be influenced in a way that fits your needs best.
	//
	// In `spread` placement groups, all virtual servers will run on different physical servers. This decreases the probability that some instances might fail together.
	//
	PlacementGroups *placementGroups
	// Pricing - Returns prices for resources.
	Pricing          *pricing
	PrimaryIPActions *primaryIPActions
	// PrimaryIPs - Primary IPs help you to create more flexible networking setups. You can assign at most one Primary IP of type `ipv4` and one of type `ipv6` per Server. This Server then uses these IPs.
	//
	// You can only unassign a Primary IP from a Server when it's powered off. This Primary IP can then be assigned to a different powered off Server, or you can keep it around for later use.
	//
	// Primary IPs are bound to a specific Datacenter. You can not assign a Primary IP from one Datacenter to a Server in a different Datacenter. If you need this capability use Floating IPs instead.
	//
	// If your Server's operating system supports cloud-init there is no further configuration needed to make Primary IPs work.
	//
	// Primary IPs of type `ipv4` use a single IPv4 address as their `ip` property. Primary IPs of type `ipv6` use a /64 network such as `fc00::/64` as their `ip` property. Any IP address within that network can be used on your host.
	//
	// Primary IPs are billed on an hourly basis.
	//
	PrimaryIPs *primaryIPs
	// SSHKeys - SSH keys are public keys you provide to the cloud system. They can be injected into Servers at creation time. We highly recommend that you use keys instead of passwords to manage your Servers.
	SSHKeys       *sshKeys
	ServerActions *serverActions
	// ServerTypes - Server types define kinds of Servers offered. Each type has an hourly and a monthly cost. You will pay whichever cost is lower for your usage of this specific Server. Costs may differ between Locations.
	//
	// Currency for all amounts is €. All prices exclude VAT.
	//
	ServerTypes *serverTypes
	// Servers - Servers are virtual machines that can be provisioned.
	Servers       *servers
	VolumeActions *volumeActions
	// Volumes - A Volume is a highly-available, scalable, and SSD-based block storage for Servers.
	//
	// Pricing for Volumes depends on the Volume size and Location, not the actual used storage.
	//
	// Please see [Hetzner Docs](https://docs.hetzner.com/cloud/#Volumes) for more details about Volumes.
	//
	Volumes *volumes

	// Non-idiomatic field names below are to namespace fields from the fields names above to avoid name conflicts
	_defaultClient  HTTPClient
	_securityClient HTTPClient

	_serverURL  string
	_language   string
	_sdkVersion string
	_genVersion string
}

type SDKOption func(*SDK)

// WithServerURL allows the overriding of the default server URL
func WithServerURL(serverURL string) SDKOption {
	return func(sdk *SDK) {
		sdk._serverURL = serverURL
	}
}

// WithTemplatedServerURL allows the overriding of the default server URL with a templated URL populated with the provided parameters
func WithTemplatedServerURL(serverURL string, params map[string]string) SDKOption {
	return func(sdk *SDK) {
		if params != nil {
			serverURL = utils.ReplaceParameters(serverURL, params)
		}

		sdk._serverURL = serverURL
	}
}

// WithClient allows the overriding of the default HTTP client used by the SDK
func WithClient(client HTTPClient) SDKOption {
	return func(sdk *SDK) {
		sdk._defaultClient = client
	}
}

// New creates a new instance of the SDK with the provided options
func New(opts ...SDKOption) *SDK {
	sdk := &SDK{
		_language:   "go",
		_sdkVersion: "0.0.1",
		_genVersion: "internal",
	}
	for _, opt := range opts {
		opt(sdk)
	}

	// Use WithClient to override the default client if you would like to customize the timeout
	if sdk._defaultClient == nil {
		sdk._defaultClient = &http.Client{Timeout: 60 * time.Second}
	}
	if sdk._securityClient == nil {
		sdk._securityClient = sdk._defaultClient
	}

	if sdk._serverURL == "" {
		sdk._serverURL = ServerList[0]
	}

	sdk.Actions = newActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.CertificateActions = newCertificateActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Certificates = newCertificates(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Datacenters = newDatacenters(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.FirewallActions = newFirewallActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Firewalls = newFirewalls(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.FloatingIPActions = newFloatingIPActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.FloatingIPs = newFloatingIPs(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.ISOs = newISOs(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.ImageActions = newImageActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Images = newImages(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.LoadBalancerActions = newLoadBalancerActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.LoadBalancerTypes = newLoadBalancerTypes(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.LoadBalancers = newLoadBalancers(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Locations = newLocations(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.NetworkActions = newNetworkActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Networks = newNetworks(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.PlacementGroups = newPlacementGroups(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Pricing = newPricing(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.PrimaryIPActions = newPrimaryIPActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.PrimaryIPs = newPrimaryIPs(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.SSHKeys = newSSHKeys(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.ServerActions = newServerActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.ServerTypes = newServerTypes(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Servers = newServers(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.VolumeActions = newVolumeActions(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	sdk.Volumes = newVolumes(
		sdk._defaultClient,
		sdk._securityClient,
		sdk._serverURL,
		sdk._language,
		sdk._sdkVersion,
		sdk._genVersion,
	)

	return sdk
}
