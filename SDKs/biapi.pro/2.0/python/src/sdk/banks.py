"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class Banks:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_banks_categories_id_category_(self, request: operations.DeleteBanksCategoriesIDCategoryRequest) -> operations.DeleteBanksCategoriesIDCategoryResponse:
        r"""Delete the supplied category"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteBanksCategoriesIDCategoryRequest, base_url, '/banks/categories/{id_category}', request)
        
        query_params = utils.get_query_params(operations.DeleteBanksCategoriesIDCategoryRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteBanksCategoriesIDCategoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorCategory])
                res.connector_category = out

        return res

    def delete_categories_keywords_id_keyword_(self, request: operations.DeleteCategoriesKeywordsIDKeywordRequest) -> operations.DeleteCategoriesKeywordsIDKeywordResponse:
        r"""Delete a particular key-value pair on a transaction."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteCategoriesKeywordsIDKeywordRequest, base_url, '/categories/keywords/{id_keyword}', request)
        
        query_params = utils.get_query_params(operations.DeleteCategoriesKeywordsIDKeywordRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteCategoriesKeywordsIDKeywordResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Keyword])
                res.keyword = out

        return res

    def delete_connections_id_connection_sources_id_source_(self, request: operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest) -> operations.DeleteConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Disable a connection source
        This will make it so the specified source will not be synchronized anymore.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.DeleteConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def delete_connectors_id_connector_logos_id_logo_(self, request: operations.DeleteConnectorsIDConnectorLogosIDLogoRequest) -> operations.DeleteConnectorsIDConnectorLogosIDLogoResponse:
        r"""Delete a single Logo object."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteConnectorsIDConnectorLogosIDLogoRequest, base_url, '/connectors/{id_connector}/logos/{id_logo}', request)
        
        query_params = utils.get_query_params(operations.DeleteConnectorsIDConnectorLogosIDLogoRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteConnectorsIDConnectorLogosIDLogoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def delete_users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_(self, request: operations.DeleteUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest) -> operations.DeleteUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse:
        r"""Delete a clustered transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def delete_users_id_user_categories_full_id_full_(self, request: operations.DeleteUsersIDUserCategoriesFullIDFullRequest) -> operations.DeleteUsersIDUserCategoriesFullIDFullResponse:
        r"""Delete a user-created transaction category"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserCategoriesFullIDFullRequest, base_url, '/users/{id_user}/categories/full/{id_full}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserCategoriesFullIDFullRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserCategoriesFullIDFullResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Category])
                res.category = out

        return res

    def delete_users_id_user_connections(self, request: operations.DeleteUsersIDUserConnectionsRequest) -> operations.DeleteUsersIDUserConnectionsResponse:
        r"""Delete all connections"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def delete_users_id_user_connections_id_connection_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionResponse:
        r"""Delete a connection.
        This endpoint deletes a connection and all related accounts and transactions.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def delete_users_id_user_connections_id_connection_accounts(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionAccountsRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionAccountsResponse:
        r"""Delete all accounts"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out

        return res

    def delete_users_id_user_connections_id_connection_accounts_id_account_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountResponse:
        r"""Delete an account.
        It deletes a specific account.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out

        return res

    def delete_users_id_user_connections_id_connection_accounts_id_account_transactions(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsResponse:
        r"""Delete transactions"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Transaction])
                res.transaction = out

        return res

    def delete_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsResponse:
        r"""Delete all arbitrary key-value pairs of a transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionInformation])
                res.transaction_information = out

        return res

    def delete_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationResponse:
        r"""Delete a particular key-value pair on a transaction."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionInformation])
                res.transaction_information = out

        return res

    def delete_users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse:
        r"""Delete a clustered transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def delete_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Disable a connection source
        This will make it so the specified source will not be synchronized anymore.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def delete_users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_(self, request: operations.DeleteUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterRequest) -> operations.DeleteUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterResponse:
        r"""Delete a clustered transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def delete_users_id_user_transactionsclusters_id_transactionscluster_(self, request: operations.DeleteUsersIDUserTransactionsclustersIDTransactionsclusterRequest) -> operations.DeleteUsersIDUserTransactionsclustersIDTransactionsclusterResponse:
        r"""Delete a clustered transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteUsersIDUserTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.DeleteUsersIDUserTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteUsersIDUserTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def get_account_types(self, request: operations.GetAccountTypesRequest) -> operations.GetAccountTypesResponse:
        r"""Get account types"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/account_types'
        
        query_params = utils.get_query_params(operations.GetAccountTypesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAccountTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetAccountTypes200ApplicationJSON])
                res.get_account_types_200_application_json_object = out

        return res

    def get_account_types_id_account_type_(self, request: operations.GetAccountTypesIDAccountTypeRequest) -> operations.GetAccountTypesIDAccountTypeResponse:
        r"""Get an account type"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAccountTypesIDAccountTypeRequest, base_url, '/account_types/{id_account_type}', request)
        
        query_params = utils.get_query_params(operations.GetAccountTypesIDAccountTypeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAccountTypesIDAccountTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountType])
                res.account_type = out

        return res

    def get_banks(self, request: operations.GetBanksRequest) -> operations.GetBanksResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/banks'
        
        query_params = utils.get_query_params(operations.GetBanksRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanks200ApplicationJSON])
                res.get_banks_200_application_json_object = out

        return res

    def get_banks_id_bank_(self, request: operations.GetBanksIDBankRequest) -> operations.GetBanksIDBankResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDBankRequest, base_url, '/banks/{id_bank}', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDBankRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDBankResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_banks_id_connector_connections(self, request: operations.GetBanksIDConnectorConnectionsRequest) -> operations.GetBanksIDConnectorConnectionsResponse:
        r"""Get a subset of id_connection for a given bank. Different selection methode are possible
        By default, it selects a set of 3 connections with the 'diversity' method<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorConnectionsRequest, base_url, '/banks/{id_connector}/connections', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorConnections200ApplicationJSON])
                res.get_banks_id_connector_connections_200_application_json_object = out

        return res

    def get_banks_id_connector_logos(self, request: operations.GetBanksIDConnectorLogosRequest) -> operations.GetBanksIDConnectorLogosResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorLogosRequest, base_url, '/banks/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorLogos200ApplicationJSON])
                res.get_banks_id_connector_logos_200_application_json_object = out

        return res

    def get_banks_id_connector_logos_main(self, request: operations.GetBanksIDConnectorLogosMainRequest) -> operations.GetBanksIDConnectorLogosMainResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorLogosMainRequest, base_url, '/banks/{id_connector}/logos/main', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorLogosMainRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorLogosMainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorLogosMain200ApplicationJSON])
                res.get_banks_id_connector_logos_main_200_application_json_object = out

        return res

    def get_banks_id_connector_logos_thumbnail(self, request: operations.GetBanksIDConnectorLogosThumbnailRequest) -> operations.GetBanksIDConnectorLogosThumbnailResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorLogosThumbnailRequest, base_url, '/banks/{id_connector}/logos/thumbnail', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorLogosThumbnailRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorLogosThumbnailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorLogosThumbnail200ApplicationJSON])
                res.get_banks_id_connector_logos_thumbnail_200_application_json_object = out

        return res

    def get_banks_id_connector_sources(self, request: operations.GetBanksIDConnectorSourcesRequest) -> operations.GetBanksIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesRequest, base_url, '/banks/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorSources200ApplicationJSON])
                res.get_banks_id_connector_sources_200_application_json_object = out

        return res

    def get_banks_id_connector_sources_id_connector_source_fields(self, request: operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsRequest) -> operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsResponse:
        r"""Get fields specific to a domain and a source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsRequest, base_url, '/banks/{id_connector}/sources/{id_connector_source}/fields', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesIDConnectorSourceFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetBanksIDConnectorSourcesIDConnectorSourceFields200ApplicationJSON])
                res.get_banks_id_connector_sources_id_connector_source_fields_200_application_json_object = out

        return res

    def get_banks_id_connector_sources_id_source_(self, request: operations.GetBanksIDConnectorSourcesIDSourceRequest) -> operations.GetBanksIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetBanksIDConnectorSourcesIDSourceRequest, base_url, '/banks/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetBanksIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetBanksIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_categories(self, request: operations.GetCategoriesRequest) -> operations.GetCategoriesResponse:
        r"""Get all categories
        Ressource to get all existing categories<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/categories'
        
        query_params = utils.get_query_params(operations.GetCategoriesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetCategories200ApplicationJSON])
                res.get_categories_200_application_json_object = out

        return res

    def get_connections(self, request: operations.GetConnectionsRequest) -> operations.GetConnectionsResponse:
        r"""Get connections without a user"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connections'
        
        query_params = utils.get_query_params(operations.GetConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnections200ApplicationJSON])
                res.get_connections_200_application_json_object = out

        return res

    def get_connections_id_connection_logs(self, request: operations.GetConnectionsIDConnectionLogsRequest) -> operations.GetConnectionsIDConnectionLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectionsIDConnectionLogsRequest, base_url, '/connections/{id_connection}/logs', request)
        
        query_params = utils.get_query_params(operations.GetConnectionsIDConnectionLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsIDConnectionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectionsIDConnectionLogs200ApplicationJSON])
                res.get_connections_id_connection_logs_200_application_json_object = out

        return res

    def get_connections_id_connection_sources(self, request: operations.GetConnectionsIDConnectionSourcesRequest) -> operations.GetConnectionsIDConnectionSourcesResponse:
        r"""Get connection sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectionsIDConnectionSourcesRequest, base_url, '/connections/{id_connection}/sources', request)
        
        query_params = utils.get_query_params(operations.GetConnectionsIDConnectionSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectionsIDConnectionSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectionsIDConnectionSources200ApplicationJSON])
                res.get_connections_id_connection_sources_200_application_json_object = out

        return res

    def get_connectors(self, request: operations.GetConnectorsRequest) -> operations.GetConnectorsResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        query_params = utils.get_query_params(operations.GetConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectors200ApplicationJSON])
                res.get_connectors_200_application_json_object = out

        return res

    def get_connectors_id_connector_(self, request: operations.GetConnectorsIDConnectorRequest) -> operations.GetConnectorsIDConnectorResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorRequest, base_url, '/connectors/{id_connector}', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_connectors_id_connector_logos(self, request: operations.GetConnectorsIDConnectorLogosRequest) -> operations.GetConnectorsIDConnectorLogosResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorLogosRequest, base_url, '/connectors/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorLogos200ApplicationJSON])
                res.get_connectors_id_connector_logos_200_application_json_object = out

        return res

    def get_connectors_id_connector_logos_main(self, request: operations.GetConnectorsIDConnectorLogosMainRequest) -> operations.GetConnectorsIDConnectorLogosMainResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorLogosMainRequest, base_url, '/connectors/{id_connector}/logos/main', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorLogosMainRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorLogosMainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorLogosMain200ApplicationJSON])
                res.get_connectors_id_connector_logos_main_200_application_json_object = out

        return res

    def get_connectors_id_connector_logos_thumbnail(self, request: operations.GetConnectorsIDConnectorLogosThumbnailRequest) -> operations.GetConnectorsIDConnectorLogosThumbnailResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorLogosThumbnailRequest, base_url, '/connectors/{id_connector}/logos/thumbnail', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorLogosThumbnailRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorLogosThumbnailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorLogosThumbnail200ApplicationJSON])
                res.get_connectors_id_connector_logos_thumbnail_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources(self, request: operations.GetConnectorsIDConnectorSourcesRequest) -> operations.GetConnectorsIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesRequest, base_url, '/connectors/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorSources200ApplicationJSON])
                res.get_connectors_id_connector_sources_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources_id_connector_source_fields(self, request: operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsRequest) -> operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsResponse:
        r"""Get fields specific to a domain and a source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsRequest, base_url, '/connectors/{id_connector}/sources/{id_connector_source}/fields', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetConnectorsIDConnectorSourcesIDConnectorSourceFields200ApplicationJSON])
                res.get_connectors_id_connector_sources_id_connector_source_fields_200_application_json_object = out

        return res

    def get_connectors_id_connector_sources_id_source_(self, request: operations.GetConnectorsIDConnectorSourcesIDSourceRequest) -> operations.GetConnectorsIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetConnectorsIDConnectorSourcesIDSourceRequest, base_url, '/connectors/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetConnectorsIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetConnectorsIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_invoicing(self, request: operations.GetInvoicingRequest) -> operations.GetInvoicingResponse:
        r"""Get invoicing data for a given period (default is the current month).
        You can get all the invoicing data or just specific ones by using the available parameters.<br><br>If no parameters are specified, no invoicing data is returned.<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/invoicing'
        
        query_params = utils.get_query_params(operations.GetInvoicingRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetInvoicingResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_logs(self, request: operations.GetLogsRequest) -> operations.GetLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/logs'
        
        query_params = utils.get_query_params(operations.GetLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetLogs200ApplicationJSON])
                res.get_logs_200_application_json_object = out

        return res

    def get_providers(self, request: operations.GetProvidersRequest) -> operations.GetProvidersResponse:
        r"""Get list of connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/providers'
        
        query_params = utils.get_query_params(operations.GetProvidersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProviders200ApplicationJSON])
                res.get_providers_200_application_json_object = out

        return res

    def get_providers_id_connector_connections(self, request: operations.GetProvidersIDConnectorConnectionsRequest) -> operations.GetProvidersIDConnectorConnectionsResponse:
        r"""Get a random subset of provider's id_connection
        By default, it selects a set of 3 connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorConnectionsRequest, base_url, '/providers/{id_connector}/connections', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorConnections200ApplicationJSON])
                res.get_providers_id_connector_connections_200_application_json_object = out

        return res

    def get_providers_id_connector_logos(self, request: operations.GetProvidersIDConnectorLogosRequest) -> operations.GetProvidersIDConnectorLogosResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorLogosRequest, base_url, '/providers/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorLogos200ApplicationJSON])
                res.get_providers_id_connector_logos_200_application_json_object = out

        return res

    def get_providers_id_connector_logos_main(self, request: operations.GetProvidersIDConnectorLogosMainRequest) -> operations.GetProvidersIDConnectorLogosMainResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorLogosMainRequest, base_url, '/providers/{id_connector}/logos/main', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorLogosMainRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorLogosMainResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorLogosMain200ApplicationJSON])
                res.get_providers_id_connector_logos_main_200_application_json_object = out

        return res

    def get_providers_id_connector_logos_thumbnail(self, request: operations.GetProvidersIDConnectorLogosThumbnailRequest) -> operations.GetProvidersIDConnectorLogosThumbnailResponse:
        r"""Get all links to the files associated with this connector.
        This endpoint returns all links to files associated with this connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorLogosThumbnailRequest, base_url, '/providers/{id_connector}/logos/thumbnail', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorLogosThumbnailRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorLogosThumbnailResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorLogosThumbnail200ApplicationJSON])
                res.get_providers_id_connector_logos_thumbnail_200_application_json_object = out

        return res

    def get_providers_id_connector_sources(self, request: operations.GetProvidersIDConnectorSourcesRequest) -> operations.GetProvidersIDConnectorSourcesResponse:
        r"""Get list of connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesRequest, base_url, '/providers/{id_connector}/sources', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorSources200ApplicationJSON])
                res.get_providers_id_connector_sources_200_application_json_object = out

        return res

    def get_providers_id_connector_sources_id_connector_source_fields(self, request: operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsRequest) -> operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsResponse:
        r"""Get fields specific to a domain and a source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsRequest, base_url, '/providers/{id_connector}/sources/{id_connector_source}/fields', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesIDConnectorSourceFieldsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetProvidersIDConnectorSourcesIDConnectorSourceFields200ApplicationJSON])
                res.get_providers_id_connector_sources_id_connector_source_fields_200_application_json_object = out

        return res

    def get_providers_id_connector_sources_id_source_(self, request: operations.GetProvidersIDConnectorSourcesIDSourceRequest) -> operations.GetProvidersIDConnectorSourcesIDSourceResponse:
        r"""Get the connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDConnectorSourcesIDSourceRequest, base_url, '/providers/{id_connector}/sources/{id_source}', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def get_providers_id_provider_(self, request: operations.GetProvidersIDProviderRequest) -> operations.GetProvidersIDProviderResponse:
        r"""Get a connector"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetProvidersIDProviderRequest, base_url, '/providers/{id_provider}', request)
        
        query_params = utils.get_query_params(operations.GetProvidersIDProviderRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetProvidersIDProviderResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def get_psd2_registrations(self, request: operations.GetPsd2RegistrationsRequest) -> operations.GetPsd2RegistrationsResponse:
        r"""Get details on all psd2 registrations"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/psd2-registrations'
        
        query_params = utils.get_query_params(operations.GetPsd2RegistrationsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPsd2RegistrationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetPsd2Registrations200ApplicationJSON])
                res.get_psd2_registrations_200_application_json_object = out

        return res

    def get_psd2_registrations_id_psd2_registration_(self, request: operations.GetPsd2RegistrationsIDPsd2RegistrationRequest) -> operations.GetPsd2RegistrationsIDPsd2RegistrationResponse:
        r"""Get details for a given psd2 registration"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPsd2RegistrationsIDPsd2RegistrationRequest, base_url, '/psd2-registrations/{id_psd2-registration}', request)
        
        query_params = utils.get_query_params(operations.GetPsd2RegistrationsIDPsd2RegistrationRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPsd2RegistrationsIDPsd2RegistrationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Psd2Registration])
                res.psd2_registration = out

        return res

    def get_psd2_registrations_id_psd2registration_logs(self, request: operations.GetPsd2RegistrationsIDPsd2registrationLogsRequest) -> operations.GetPsd2RegistrationsIDPsd2registrationLogsResponse:
        r"""Get psd2 registration logs.
        Get logs of psd2 registration. By default, it selects logs for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetPsd2RegistrationsIDPsd2registrationLogsRequest, base_url, '/psd2-registrations/{id_psd2registration}/logs', request)
        
        query_params = utils.get_query_params(operations.GetPsd2RegistrationsIDPsd2registrationLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetPsd2RegistrationsIDPsd2registrationLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetPsd2RegistrationsIDPsd2registrationLogs200ApplicationJSON])
                res.get_psd2_registrations_id_psd2registration_logs_200_application_json_object = out

        return res

    def get_users_id_user_account_types(self, request: operations.GetUsersIDUserAccountTypesRequest) -> operations.GetUsersIDUserAccountTypesResponse:
        r"""Get account types"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserAccountTypesRequest, base_url, '/users/{id_user}/account_types', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserAccountTypesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserAccountTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserAccountTypes200ApplicationJSON])
                res.get_users_id_user_account_types_200_application_json_object = out

        return res

    def get_users_id_user_account_types_id_account_type_(self, request: operations.GetUsersIDUserAccountTypesIDAccountTypeRequest) -> operations.GetUsersIDUserAccountTypesIDAccountTypeResponse:
        r"""Get an account type"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserAccountTypesIDAccountTypeRequest, base_url, '/users/{id_user}/account_types/{id_account_type}', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserAccountTypesIDAccountTypeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserAccountTypesIDAccountTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AccountType])
                res.account_type = out

        return res

    def get_users_id_user_accounts_id_account_categories(self, request: operations.GetUsersIDUserAccountsIDAccountCategoriesRequest) -> operations.GetUsersIDUserAccountsIDAccountCategoriesResponse:
        r"""Get the category
        Ressource to get categories for the user's transactions<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserAccountsIDAccountCategoriesRequest, base_url, '/users/{id_user}/accounts/{id_account}/categories', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserAccountsIDAccountCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_users_id_user_accounts_id_account_transactionsclusters(self, request: operations.GetUsersIDUserAccountsIDAccountTransactionsclustersRequest) -> operations.GetUsersIDUserAccountsIDAccountTransactionsclustersResponse:
        r"""Get clustered transactions"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserAccountsIDAccountTransactionsclustersRequest, base_url, '/users/{id_user}/accounts/{id_account}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserAccountsIDAccountTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserAccountsIDAccountTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserAccountsIDAccountTransactionsclusters200ApplicationJSON])
                res.get_users_id_user_accounts_id_account_transactionsclusters_200_application_json_object = out

        return res

    def get_users_id_user_alerts(self, request: operations.GetUsersIDUserAlertsRequest) -> operations.GetUsersIDUserAlertsResponse:
        r"""Get alerts"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserAlertsRequest, base_url, '/users/{id_user}/alerts', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserAlertsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserAlertsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserAlerts200ApplicationJSON])
                res.get_users_id_user_alerts_200_application_json_object = out

        return res

    def get_users_id_user_categories(self, request: operations.GetUsersIDUserCategoriesRequest) -> operations.GetUsersIDUserCategoriesResponse:
        r"""Get the category
        Ressource to get categories for the user's transactions<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserCategoriesRequest, base_url, '/users/{id_user}/categories', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_users_id_user_categories_full(self, request: operations.GetUsersIDUserCategoriesFullRequest) -> operations.GetUsersIDUserCategoriesFullResponse:
        r"""Get the category
        Ressource to get categories<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserCategoriesFullRequest, base_url, '/users/{id_user}/categories/full', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserCategoriesFullRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserCategoriesFullResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserCategoriesFull200ApplicationJSON])
                res.get_users_id_user_categories_full_200_application_json_object = out

        return res

    def get_users_id_user_connections(self, request: operations.GetUsersIDUserConnectionsRequest) -> operations.GetUsersIDUserConnectionsResponse:
        r"""Get connections"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnections200ApplicationJSON])
                res.get_users_id_user_connections_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_accounts(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsResponse:
        r"""Get accounts list."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionAccounts200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_accounts_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_categories(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountCategoriesRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountCategoriesResponse:
        r"""Get the category
        Ressource to get categories for the user's transactions<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountCategoriesRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/categories', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_delta(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountDeltaRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountDeltaResponse:
        r"""Get deltas of accounts
        Get account delta between sums of transactions and difference of account balance for the given period.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountDeltaRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/delta', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountDeltaRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountDeltaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_logs(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountLogsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountLogsResponse:
        r"""Get accounts logs.
        Get logs of account. By default, it selects logs for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountLogsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountLogs200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_accounts_id_account_logs_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_sources(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountSourcesRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountSourcesResponse:
        r"""Get account sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountSourcesRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/sources', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountSources200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_accounts_id_account_sources_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_transactions(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsResponse:
        r"""Get transactions
        Get list of transactions.<br><br>By default, it selects transactions for the last month. You can use \"min_date\" and \"max_date\" to change boundary dates.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactions200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_accounts_id_account_transactions_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsResponse:
        r"""List all arbitrary key-value pairs on a transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformations200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations_id_information_(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationResponse:
        r"""Get a particular arbitrary key-value pair on a transaction"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations/{id_information}', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsIDInformationResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionInformation])
                res.transaction_information = out

        return res

    def get_users_id_user_connections_id_connection_accounts_id_account_transactionsclusters(self, request: operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersRequest) -> operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersResponse:
        r"""Get clustered transactions"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclusters200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_informations(self, request: operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionInformationsResponse:
        r"""Get connection additionnal informations
        <br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest, base_url, '/users/{id_user}/connections/{id_connection}/informations', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionInformationsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionInformationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionInformations200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_informations_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_logs(self, request: operations.GetUsersIDUserConnectionsIDConnectionLogsRequest) -> operations.GetUsersIDUserConnectionsIDConnectionLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionLogsRequest, base_url, '/users/{id_user}/connections/{id_connection}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionLogs200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_logs_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_sources(self, request: operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest) -> operations.GetUsersIDUserConnectionsIDConnectionSourcesResponse:
        r"""Get connection sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionSources200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_sources_200_application_json_object = out

        return res

    def get_users_id_user_connections_id_connection_transactionsclusters(self, request: operations.GetUsersIDUserConnectionsIDConnectionTransactionsclustersRequest) -> operations.GetUsersIDUserConnectionsIDConnectionTransactionsclustersResponse:
        r"""Get clustered transactions"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserConnectionsIDConnectionTransactionsclustersRequest, base_url, '/users/{id_user}/connections/{id_connection}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserConnectionsIDConnectionTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserConnectionsIDConnectionTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserConnectionsIDConnectionTransactionsclusters200ApplicationJSON])
                res.get_users_id_user_connections_id_connection_transactionsclusters_200_application_json_object = out

        return res

    def get_users_id_user_forecast(self, request: operations.GetUsersIDUserForecastRequest) -> operations.GetUsersIDUserForecastResponse:
        r"""Get forecast"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserForecastRequest, base_url, '/users/{id_user}/forecast', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserForecastResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def get_users_id_user_logs(self, request: operations.GetUsersIDUserLogsRequest) -> operations.GetUsersIDUserLogsResponse:
        r"""Get connection logs
        Get logs about connections.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserLogsRequest, base_url, '/users/{id_user}/logs', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserLogsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserLogsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserLogs200ApplicationJSON])
                res.get_users_id_user_logs_200_application_json_object = out

        return res

    def get_users_id_user_transactionsclusters(self, request: operations.GetUsersIDUserTransactionsclustersRequest) -> operations.GetUsersIDUserTransactionsclustersResponse:
        r"""Get clustered transactions"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetUsersIDUserTransactionsclustersRequest, base_url, '/users/{id_user}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.GetUsersIDUserTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetUsersIDUserTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GetUsersIDUserTransactionsclusters200ApplicationJSON])
                res.get_users_id_user_transactionsclusters_200_application_json_object = out

        return res

    def post_banks_categories(self, request: operations.PostBanksCategoriesRequest) -> operations.PostBanksCategoriesResponse:
        r"""Create bank categories
        It requires the name of the category to be created<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/banks/categories'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostBanksCategoriesRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostBanksCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorCategory])
                res.connector_category = out

        return res

    def post_banks_categories_id_category_(self, request: operations.PostBanksCategoriesIDCategoryRequest) -> operations.PostBanksCategoriesIDCategoryResponse:
        r"""Edit a bank categories
        Edit the name for the supplied category.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostBanksCategoriesIDCategoryRequest, base_url, '/banks/categories/{id_category}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostBanksCategoriesIDCategoryRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostBanksCategoriesIDCategoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorCategory])
                res.connector_category = out

        return res

    def post_categories_keywords(self, request: operations.PostCategoriesKeywordsRequest) -> operations.PostCategoriesKeywordsResponse:
        r"""Add a new keyword associated with a category in the database.
        If the keyword already exists the keyword is not added. Used for the categorization of transactions.<br><br>Form params: - id_category (integer): a reference towards the category associated with the keyword - keyword (string): the searched keyword - income (bool): 1 if the associated category represents an income else 0 - priority (integer): sets the priority for the keyword, used when categorizing<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/categories/keywords'
        
        query_params = utils.get_query_params(operations.PostCategoriesKeywordsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostCategoriesKeywordsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Keyword])
                res.keyword = out

        return res

    def post_categorize(self, request: operations.PostCategorizeRequestBody) -> operations.PostCategorizeResponse:
        r"""categorize transactions without storing them
        It requires an array of transaction dictionaries. Any fields of transactions that are not required will be kept in the response. The response contains the list of transactions with two more fields: id_category and state (it indicates how the transaction has been categorized)<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/categorize'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostCategorizeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.post_categorize_200_application_json_object = out

        return res

    def post_connections_id_connection_sources_id_source_(self, request: operations.PostConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PostConnectionsIDConnectionSourcesIDSourceResponse:
        r"""\\" 
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def post_connectors(self, request: operations.PostConnectorsRequest) -> operations.PostConnectorsResponse:
        r"""Request a new connector
        Send a request to add a new connector<br><br>
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def post_connectors_id_connector_logos(self, request: operations.PostConnectorsIDConnectorLogosRequest) -> operations.PostConnectorsIDConnectorLogosResponse:
        r"""Create a connector Logo
        This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostConnectorsIDConnectorLogosRequest, base_url, '/connectors/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.PostConnectorsIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostConnectorsIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def post_users_id_user_accounts_id_account_transactionsclusters(self, request: operations.PostUsersIDUserAccountsIDAccountTransactionsclustersRequest) -> operations.PostUsersIDUserAccountsIDAccountTransactionsclustersResponse:
        r"""Create clustered transaction
        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserAccountsIDAccountTransactionsclustersRequest, base_url, '/users/{id_user}/accounts/{id_account}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.PostUsersIDUserAccountsIDAccountTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserAccountsIDAccountTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def post_users_id_user_categories_full(self, request: operations.PostUsersIDUserCategoriesFullRequest) -> operations.PostUsersIDUserCategoriesFullResponse:
        r"""Create a new transaction category"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserCategoriesFullRequest, base_url, '/users/{id_user}/categories/full', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserCategoriesFullRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserCategoriesFullResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Category])
                res.category = out

        return res

    def post_users_id_user_connections(self, request: operations.PostUsersIDUserConnectionsRequest) -> operations.PostUsersIDUserConnectionsResponse:
        r"""Add a new connection.
        Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsRequest, base_url, '/users/{id_user}/connections', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def post_users_id_user_connections_id_connection_(self, request: operations.PostUsersIDUserConnectionsIDConnectionRequest) -> operations.PostUsersIDUserConnectionsIDConnectionResponse:
        r"""Update a connection.
        Give new parameters to change on the configuration of this connection (for example \"password\").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code \"wrongpass\" or \"websiteUnavailable\".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>It's possible to execute the update/synchronization in the background with a query parameter. If done in background this endpoint will respond with data that is not yet updated. To obtain updated data, polling is required as the the data will be filled in the background.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def post_users_id_user_connections_id_connection_accounts(self, request: operations.PostUsersIDUserConnectionsIDConnectionAccountsRequest) -> operations.PostUsersIDUserConnectionsIDConnectionAccountsResponse:
        r"""Create an account
        This endpoint creates an account related to a connection or not.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionAccountsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionAccountsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out

        return res

    def post_users_id_user_connections_id_connection_accounts_id_account_transactions(self, request: operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest) -> operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsResponse:
        r"""Create transactions
        Create transactions for the supplied account or the account whose id is given with form parameters. It requires an array of transaction dictionaries.<br><br><br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Transaction])
                res.transaction = out

        return res

    def post_users_id_user_connections_id_connection_accounts_id_account_transactionsclusters(self, request: operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersRequest) -> operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersResponse:
        r"""Create clustered transaction
        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def post_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""\\" 
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def post_users_id_user_connections_id_connection_transactionsclusters(self, request: operations.PostUsersIDUserConnectionsIDConnectionTransactionsclustersRequest) -> operations.PostUsersIDUserConnectionsIDConnectionTransactionsclustersResponse:
        r"""Create clustered transaction
        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserConnectionsIDConnectionTransactionsclustersRequest, base_url, '/users/{id_user}/connections/{id_connection}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.PostUsersIDUserConnectionsIDConnectionTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserConnectionsIDConnectionTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def post_users_id_user_transactionsclusters(self, request: operations.PostUsersIDUserTransactionsclustersRequest) -> operations.PostUsersIDUserTransactionsclustersResponse:
        r"""Create clustered transaction
        Form params : - next_date (date) required: Date of transaction - mean_amount (decimal) required: Mean Amount - wording (string) required: name of transaction - id_account (id) required: related account<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostUsersIDUserTransactionsclustersRequest, base_url, '/users/{id_user}/transactionsclusters', request)
        
        query_params = utils.get_query_params(operations.PostUsersIDUserTransactionsclustersRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostUsersIDUserTransactionsclustersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def put_connections_id_connection_sources_id_source_(self, request: operations.PutConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PutConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Update connection source
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def put_connectors(self, request: operations.PutConnectorsRequest) -> operations.PutConnectorsResponse:
        r"""Enable/disable several connectors"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/connectors'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def put_connectors_id_connector_(self, request: operations.PutConnectorsIDConnectorRequest) -> operations.PutConnectorsIDConnectorResponse:
        r"""Edit the provided connector
        <br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorRequest, base_url, '/connectors/{id_connector}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connector])
                res.connector = out

        return res

    def put_connectors_id_connector_logos(self, request: operations.PutConnectorsIDConnectorLogosRequest) -> operations.PutConnectorsIDConnectorLogosResponse:
        r"""Create or Update a connector Logo
        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorLogosRequest, base_url, '/connectors/{id_connector}/logos', request)
        
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorLogosRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorLogosResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def put_connectors_id_connector_logos_id_logo_(self, request: operations.PutConnectorsIDConnectorLogosIDLogoRequest) -> operations.PutConnectorsIDConnectorLogosIDLogoResponse:
        r"""Create or Update a connector Logo.
        This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorLogosIDLogoRequest, base_url, '/connectors/{id_connector}/logos/{id_logo}', request)
        
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorLogosIDLogoRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorLogosIDLogoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorLogo])
                res.connector_logo = out

        return res

    def put_connectors_id_connector_sources(self, request: operations.PutConnectorsIDConnectorSourcesRequest) -> operations.PutConnectorsIDConnectorSourcesResponse:
        r"""Edit several connector sources"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorSourcesRequest, base_url, '/connectors/{id_connector}/sources', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorSourcesRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorSourcesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def put_connectors_id_connector_sources_id_source_(self, request: operations.PutConnectorsIDConnectorSourcesIDSourceRequest) -> operations.PutConnectorsIDConnectorSourcesIDSourceResponse:
        r"""Edit the provided connector source"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutConnectorsIDConnectorSourcesIDSourceRequest, base_url, '/connectors/{id_connector}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutConnectorsIDConnectorSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutConnectorsIDConnectorSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectorSource])
                res.connector_source = out

        return res

    def put_users_id_user_accounts_id_account_transactionsclusters_id_transactionscluster_(self, request: operations.PutUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest) -> operations.PutUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse:
        r"""Edit a clustered transaction
        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def put_users_id_user_categories_full_id_full_(self, request: operations.PutUsersIDUserCategoriesFullIDFullRequest) -> operations.PutUsersIDUserCategoriesFullIDFullResponse:
        r"""Modify a user-created category"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserCategoriesFullIDFullRequest, base_url, '/users/{id_user}/categories/full/{id_full}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutUsersIDUserCategoriesFullIDFullRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserCategoriesFullIDFullResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Category])
                res.category = out

        return res

    def put_users_id_user_connections_id_connection_(self, request: operations.PutUsersIDUserConnectionsIDConnectionRequest) -> operations.PutUsersIDUserConnectionsIDConnectionResponse:
        r"""Force synchronisation of a connection.
        We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionRequest, base_url, '/users/{id_user}/connections/{id_connection}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Connection])
                res.connection = out

        return res

    def put_users_id_user_connections_id_connection_accounts(self, request: operations.PutUsersIDUserConnectionsIDConnectionAccountsRequest) -> operations.PutUsersIDUserConnectionsIDConnectionAccountsResponse:
        r"""Update many accounts at once"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionAccountsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionAccountsRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionAccountsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out

        return res

    def put_users_id_user_connections_id_connection_accounts_id_account_(self, request: operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountRequest) -> operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountResponse:
        r"""Update an account
        It updates a specific account<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Account])
                res.account = out

        return res

    def put_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_(self, request: operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionRequest) -> operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionResponse:
        r"""Edit a transaction meta-data"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Transaction])
                res.transaction = out

        return res

    def put_users_id_user_connections_id_connection_accounts_id_account_transactions_id_transaction_informations(self, request: operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest) -> operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsResponse:
        r"""Add or edit transaction arbitrary key-value pairs"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactions/{id_transaction}/informations', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsIDTransactionInformationsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionInformation])
                res.transaction_information = out

        return res

    def put_users_id_user_connections_id_connection_accounts_id_account_transactionsclusters_id_transactionscluster_(self, request: operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest) -> operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse:
        r"""Edit a clustered transaction
        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/connections/{id_connection}/accounts/{id_account}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionAccountsIDAccountTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def put_users_id_user_connections_id_connection_sources_id_source_(self, request: operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest) -> operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse:
        r"""Update connection source
        This endpoint is used to enable a source or force a synchronization on it.<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, base_url, '/users/{id_user}/connections/{id_connection}/sources/{id_source}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'multipart')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionSourcesIDSourceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionSource])
                res.connection_source = out

        return res

    def put_users_id_user_connections_id_connection_transactionsclusters_id_transactionscluster_(self, request: operations.PutUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterRequest) -> operations.PutUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterResponse:
        r"""Edit a clustered transaction
        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/connections/{id_connection}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserConnectionsIDConnectionTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    def put_users_id_user_transactionsclusters_id_transactionscluster_(self, request: operations.PutUsersIDUserTransactionsclustersIDTransactionsclusterRequest) -> operations.PutUsersIDUserTransactionsclustersIDTransactionsclusterResponse:
        r"""Edit a clustered transaction
        Form params : - next_date (date): Date of transaction - mean_amount (decimal): Mean Amount - wording (string): name of transaction - id_account (id): related account - id_category (id): related category - enabled (bool): is enabled<br><br>
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutUsersIDUserTransactionsclustersIDTransactionsclusterRequest, base_url, '/users/{id_user}/transactionsclusters/{id_transactionscluster}', request)
        
        query_params = utils.get_query_params(operations.PutUsersIDUserTransactionsclustersIDTransactionsclusterRequest, request)
        
        client = self._client
        
        http_res = client.request('PUT', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutUsersIDUserTransactionsclustersIDTransactionsclusterResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TransactionsCluster])
                res.transactions_cluster = out

        return res

    