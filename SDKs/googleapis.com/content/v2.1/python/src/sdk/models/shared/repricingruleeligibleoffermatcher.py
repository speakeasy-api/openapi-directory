"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import repricingruleeligibleoffermatcherstringmatcher as shared_repricingruleeligibleoffermatcherstringmatcher
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class RepricingRuleEligibleOfferMatcherMatcherOptionEnum(str, Enum):
    r"""Determines whether to use the custom matchers or the product feed attribute \\"repricing_rule_id\\" to specify offer-rule mapping."""
    MATCHER_OPTION_UNSPECIFIED = 'MATCHER_OPTION_UNSPECIFIED'
    MATCHER_OPTION_CUSTOM_FILTER = 'MATCHER_OPTION_CUSTOM_FILTER'
    MATCHER_OPTION_USE_FEED_ATTRIBUTE = 'MATCHER_OPTION_USE_FEED_ATTRIBUTE'
    MATCHER_OPTION_ALL_PRODUCTS = 'MATCHER_OPTION_ALL_PRODUCTS'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RepricingRuleEligibleOfferMatcher:
    r"""Matcher that specifies eligible offers. When the USE_FEED_ATTRIBUTE option is selected, only the repricing_rule_id attribute on the product feed is used to specify offer-rule mapping. When the CUSTOM_FILTER option is selected, only the *_matcher fields are used to filter the offers for offer-rule mapping. If the CUSTOM_FILTER option is selected, an offer needs to satisfy each custom filter matcher to be eligible for a rule. Size limit: the sum of the number of entries in all the matchers should not exceed 20. For example, there can be 15 product ids and 5 brands, but not 10 product ids and 11 brands."""
    
    brand_matcher: Optional[shared_repricingruleeligibleoffermatcherstringmatcher.RepricingRuleEligibleOfferMatcherStringMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('brandMatcher'), 'exclude': lambda f: f is None }})
    r"""Matcher by string attributes."""  
    item_group_id_matcher: Optional[shared_repricingruleeligibleoffermatcherstringmatcher.RepricingRuleEligibleOfferMatcherStringMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('itemGroupIdMatcher'), 'exclude': lambda f: f is None }})
    r"""Matcher by string attributes."""  
    matcher_option: Optional[RepricingRuleEligibleOfferMatcherMatcherOptionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('matcherOption'), 'exclude': lambda f: f is None }})
    r"""Determines whether to use the custom matchers or the product feed attribute \\"repricing_rule_id\\" to specify offer-rule mapping."""  
    offer_id_matcher: Optional[shared_repricingruleeligibleoffermatcherstringmatcher.RepricingRuleEligibleOfferMatcherStringMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('offerIdMatcher'), 'exclude': lambda f: f is None }})
    r"""Matcher by string attributes."""  
    skip_when_on_promotion: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('skipWhenOnPromotion'), 'exclude': lambda f: f is None }})
    r"""When true, the rule won't be applied to offers with active promotions."""  
    