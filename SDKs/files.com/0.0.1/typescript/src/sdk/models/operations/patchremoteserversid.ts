/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import * as shared from "../shared";
import { AxiosResponse } from "axios";

/**
 * Local permissions for files agent. read_only, write_only, or read_write
 */
export enum PatchRemoteServersIdRequestBodyFilesAgentPermissionSetEnum {
  ReadWrite = "read_write",
  ReadOnly = "read_only",
  WriteOnly = "write_only",
}

/**
 * Either personal or business_other account types
 */
export enum PatchRemoteServersIdRequestBodyOneDriveAccountTypeEnum {
  Personal = "personal",
  BusinessOther = "business_other",
}

/**
 * Remote server certificate
 */
export enum PatchRemoteServersIdRequestBodyServerCertificateEnum {
  RequireMatch = "require_match",
  AllowAny = "allow_any",
}

/**
 * Remote server type.
 */
export enum PatchRemoteServersIdRequestBodyServerTypeEnum {
  Ftp = "ftp",
  Sftp = "sftp",
  S3 = "s3",
  GoogleCloudStorage = "google_cloud_storage",
  Webdav = "webdav",
  Wasabi = "wasabi",
  BackblazeB2 = "backblaze_b2",
  OneDrive = "one_drive",
  Rackspace = "rackspace",
  Box = "box",
  Dropbox = "dropbox",
  GoogleDrive = "google_drive",
  Azure = "azure",
  Sharepoint = "sharepoint",
  S3Compatible = "s3_compatible",
  AzureFiles = "azure_files",
  FilesAgent = "files_agent",
  Filebase = "filebase",
}

/**
 * Should we require SSL?
 */
export enum PatchRemoteServersIdRequestBodySslEnum {
  IfAvailable = "if_available",
  Require = "require",
  RequireImplicit = "require_implicit",
  Never = "never",
}

export class PatchRemoteServersIdRequestBody extends SpeakeasyBase {
  /**
   * AWS Access Key.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=aws_access_key" })
  awsAccessKey?: string;

  /**
   * AWS secret key.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=aws_secret_key" })
  awsSecretKey?: string;

  /**
   * Azure Blob Storage secret key.
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_blob_storage_access_key",
  })
  azureBlobStorageAccessKey?: string;

  /**
   * Azure Blob Storage Account name
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_blob_storage_account",
  })
  azureBlobStorageAccount?: string;

  /**
   * Azure Blob Storage Container name
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_blob_storage_container",
  })
  azureBlobStorageContainer?: string;

  /**
   * Shared Access Signature (SAS) token
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_blob_storage_sas_token",
  })
  azureBlobStorageSasToken?: string;

  /**
   * Azure File Storage access key.
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_files_storage_access_key",
  })
  azureFilesStorageAccessKey?: string;

  /**
   * Azure File Storage Account name
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_files_storage_account",
  })
  azureFilesStorageAccount?: string;

  /**
   * Shared Access Signature (SAS) token
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_files_storage_sas_token",
  })
  azureFilesStorageSasToken?: string;

  /**
   * Azure File Storage Share name
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=azure_files_storage_share_name",
  })
  azureFilesStorageShareName?: string;

  /**
   * Backblaze B2 Cloud Storage applicationKey.
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=backblaze_b2_application_key",
  })
  backblazeB2ApplicationKey?: string;

  /**
   * Backblaze B2 Cloud Storage Bucket name
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=backblaze_b2_bucket" })
  backblazeB2Bucket?: string;

  /**
   * Backblaze B2 Cloud Storage keyID.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=backblaze_b2_key_id" })
  backblazeB2KeyId?: string;

  /**
   * Backblaze B2 Cloud Storage S3 Endpoint
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=backblaze_b2_s3_endpoint" })
  backblazeB2S3Endpoint?: string;

  /**
   * `true` if remote server only accepts connections from dedicated IPs
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=enable_dedicated_ips" })
  enableDedicatedIps?: boolean;

  /**
   * Filebase Access Key.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=filebase_access_key" })
  filebaseAccessKey?: string;

  /**
   * Filebase Bucket name
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=filebase_bucket" })
  filebaseBucket?: string;

  /**
   * Filebase secret key
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=filebase_secret_key" })
  filebaseSecretKey?: string;

  /**
   * Local permissions for files agent. read_only, write_only, or read_write
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=files_agent_permission_set",
  })
  filesAgentPermissionSet?: PatchRemoteServersIdRequestBodyFilesAgentPermissionSetEnum;

  /**
   * Agent local root path
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=files_agent_root" })
  filesAgentRoot?: string;

  /**
   * Google Cloud Storage bucket name
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=google_cloud_storage_bucket",
  })
  googleCloudStorageBucket?: string;

  /**
   * A JSON file that contains the private key. To generate see https://cloud.google.com/storage/docs/json_api/v1/how-tos/authorizing#APIKey
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=google_cloud_storage_credentials_json",
  })
  googleCloudStorageCredentialsJson?: string;

  /**
   * Google Cloud Project ID
   */
  @SpeakeasyMetadata({
    data: "multipart_form, name=google_cloud_storage_project_id",
  })
  googleCloudStorageProjectId?: string;

  /**
   * Hostname or IP address
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=hostname" })
  hostname?: string;

  /**
   * Max number of parallel connections.  Ignored for S3 connections (we will parallelize these as much as possible).
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=max_connections" })
  maxConnections?: number;

  /**
   * Internal name for your reference
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=name" })
  name?: string;

  /**
   * Either personal or business_other account types
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=one_drive_account_type" })
  oneDriveAccountType?: PatchRemoteServersIdRequestBodyOneDriveAccountTypeEnum;

  /**
   * Password if needed.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=password" })
  password?: string;

  /**
   * If true, we will ensure that all communications with this remote server are made through the primary region of the site.  This setting can also be overridden by a sitewide setting which will force it to true.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=pin_to_site_region" })
  pinToSiteRegion?: boolean;

  /**
   * Port for remote server.  Not needed for S3.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=port" })
  port?: number;

  /**
   * Private key if needed.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=private_key" })
  privateKey?: string;

  /**
   * Passphrase for private key if needed.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=private_key_passphrase" })
  privateKeyPassphrase?: string;

  /**
   * Rackspace API key from the Rackspace Cloud Control Panel.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=rackspace_api_key" })
  rackspaceApiKey?: string;

  /**
   * The name of the container (top level directory) where files will sync.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=rackspace_container" })
  rackspaceContainer?: string;

  /**
   * Three letter airport code for Rackspace region. See https://support.rackspace.com/how-to/about-regions/
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=rackspace_region" })
  rackspaceRegion?: string;

  /**
   * Rackspace username used to login to the Rackspace Cloud Control Panel.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=rackspace_username" })
  rackspaceUsername?: string;

  /**
   * Reset authenticated account
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=reset_authentication" })
  resetAuthentication?: boolean;

  /**
   * S3 bucket name
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_bucket" })
  s3Bucket?: string;

  /**
   * S3-compatible Access Key.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_compatible_access_key" })
  s3CompatibleAccessKey?: string;

  /**
   * S3-compatible Bucket name
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_compatible_bucket" })
  s3CompatibleBucket?: string;

  /**
   * S3-compatible endpoint
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_compatible_endpoint" })
  s3CompatibleEndpoint?: string;

  /**
   * S3-compatible endpoint
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_compatible_region" })
  s3CompatibleRegion?: string;

  /**
   * S3-compatible secret key
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_compatible_secret_key" })
  s3CompatibleSecretKey?: string;

  /**
   * S3 region
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=s3_region" })
  s3Region?: string;

  /**
   * Remote server certificate
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=server_certificate" })
  serverCertificate?: PatchRemoteServersIdRequestBodyServerCertificateEnum;

  /**
   * Remote server SSH Host Key. If provided, we will require that the server host key matches the provided key. Uses OpenSSH format similar to what would go into ~/.ssh/known_hosts
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=server_host_key" })
  serverHostKey?: string;

  /**
   * Remote server type.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=server_type" })
  serverType?: PatchRemoteServersIdRequestBodyServerTypeEnum;

  /**
   * Should we require SSL?
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=ssl" })
  ssl?: PatchRemoteServersIdRequestBodySslEnum;

  /**
   * SSL client certificate.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=ssl_certificate" })
  sslCertificate?: string;

  /**
   * Remote server username.  Not needed for S3 buckets.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=username" })
  username?: string;

  /**
   * Wasabi access key.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=wasabi_access_key" })
  wasabiAccessKey?: string;

  /**
   * Wasabi Bucket name
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=wasabi_bucket" })
  wasabiBucket?: string;

  /**
   * Wasabi region
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=wasabi_region" })
  wasabiRegion?: string;

  /**
   * Wasabi secret key.
   */
  @SpeakeasyMetadata({ data: "multipart_form, name=wasabi_secret_key" })
  wasabiSecretKey?: string;
}

export class PatchRemoteServersIdRequest extends SpeakeasyBase {
  @SpeakeasyMetadata({ data: "request, media_type=multipart/form-data" })
  requestBody?: PatchRemoteServersIdRequestBody;

  /**
   * Remote Server ID.
   */
  @SpeakeasyMetadata({ data: "pathParam, style=simple;explode=false;name=id" })
  id: number;
}

export class PatchRemoteServersIdResponse extends SpeakeasyBase {
  @SpeakeasyMetadata()
  contentType: string;

  /**
   * The RemoteServers object.
   */
  @SpeakeasyMetadata()
  remoteServerEntity?: shared.RemoteServerEntity;

  @SpeakeasyMetadata()
  statusCode: number;

  @SpeakeasyMetadata()
  rawResponse?: AxiosResponse;
}
