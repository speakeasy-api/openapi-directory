/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * To change the description use /examples/TagsDescriptions.json
 */
export class Clients {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a new person.
   *
   * @remarks
   * Creates a new person. Required fields are presented in the example. Other fields (from PUT) may also be specified here.
   */
  create2(
    req: shared.CustomerPersonDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.Create2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CustomerPersonDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/customers/persons";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Create2Response = new operations.Create2Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerPersonDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerPersonDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new client.
   *
   * @remarks
   * Creates a new client. All available fields are presented in PUT request.<p>
   *   Required fields:
   *   <ul>
   *     <li>name</li>
   *     <li>fullName</li>
   *     <li>contact -> emails -> primary</li>
   *   </ul>
   * </p>
   *
   */
  create3(
    req: shared.CustomerDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.Create3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CustomerDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/customers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Create3Response = new operations.Create3Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a person.
   *
   * @remarks
   * Removes a person.
   */
  delete3(
    req: operations.Delete3Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete3Response = new operations.Delete3Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a customer price list.
   *
   * @remarks
   * Removes a customer price list.
   */
  delete4(
    req: operations.Delete4Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete4Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete4Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/priceLists/{priceListId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete4Response = new operations.Delete4Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Removes a client.
   *
   * @remarks
   * Removes a client.
   */
  delete5(
    req: operations.Delete5Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Delete5Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Delete5Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Delete5Response = new operations.Delete5Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Generates a single use sign-in token.
   *
   * @remarks
   * Generates a single use sign-in token for the customer person found for given login or e-mail. Returns 'url' and 'token' which allows to sign-in to customer portal as this person. Token is valid for two minutes and can be used only once. To sign-in to customer portal you should post 'token' provided as the 'accessToken' form param to the 'url' using POST method.Detailed description is available in the Customer API <a href="/api-doc/customer-api/authentication">authentication</a>.
   */
  generateSingleUseSignInToken(
    req: shared.AccessTokenRequestDTO,
    config?: AxiosRequestConfig
  ): Promise<operations.GenerateSingleUseSignInTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.AccessTokenRequestDTO(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/customers/persons/accessToken";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GenerateSingleUseSignInTokenResponse =
        new operations.GenerateSingleUseSignInTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.accessTokenDTO = utils.objectToClass(
              httpRes?.data,
              shared.AccessTokenDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns address of a given client.
   *
   * @remarks
   * Returns address of a given client.
   */
  getAddress(
    req: operations.GetAddressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAddressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/address",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAddressResponse =
        new operations.GetAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.addressDTO = utils.objectToClass(
              httpRes?.data,
              shared.AddressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns persons' internal identifiers.
   *
   * @remarks
   * Returns persons' internal identifiers.
   */
  getAllIds1(
    req: operations.GetAllIds1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIds1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIds1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/customers/persons/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIds1Response =
        new operations.GetAllIds1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.getAllIds1DefaultApplicationVndXtrfV1PlusJsonInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns clients' internal identifiers.
   *
   * @remarks
   * Returns clients' internal identifiers.
   */
  getAllIds2(
    req: operations.GetAllIds2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllIds2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllIds2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/customers/ids";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllIds2Response =
        new operations.GetAllIds2Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/json;charset=UTF-8`
            )
          ) {
            res.getAllIds2DefaultApplicationJSONInt32Integers =
              utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of simple clients representations
   *
   * @remarks
   * Returns list of simple clients representations
   */
  getAllNamesWithIds(
    req: operations.GetAllNamesWithIdsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetAllNamesWithIdsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetAllNamesWithIdsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/customers";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAllNamesWithIdsResponse =
        new operations.GetAllNamesWithIdsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.entityWithNameDTOS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.entityWithNameDTOS = utils.objectToClass(
              httpRes?.data,
              shared.EntityWithNameDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns person details.
   *
   * @remarks
   * Returns person details.
   */
  getById1(
    req: operations.GetById1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById1Response = new operations.GetById1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerPersonDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerPersonDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns client details.
   *
   * @remarks
   * Returns client details.
   */
  getById2(
    req: operations.GetById2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetById2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetById2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetById2Response = new operations.GetById2Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns categories of a given client.
   *
   * @remarks
   * Returns categories of a given client.
   */
  getCategories(
    req: operations.GetCategoriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCategoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCategoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/categories",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCategoriesResponse =
        new operations.GetCategoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.categoriesDTO = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns contact of a given person.
   *
   * @remarks
   * Returns contact of a given person.
   */
  getContact(
    req: operations.GetContactRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContactResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContactRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}/contact",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContactResponse =
        new operations.GetContactResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.personContactDTO = utils.objectToClass(
              httpRes?.data,
              shared.PersonContactDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns contact of a given client.
   *
   * @remarks
   * Returns contact of a given client.
   */
  getContact1(
    req: operations.GetContact1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetContact1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetContact1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/contact",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetContact1Response =
        new operations.GetContact1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns correspondence address of a given client.
   *
   * @remarks
   * Returns correspondence address of a given client.
   */
  getCorrespondenceAddress(
    req: operations.GetCorrespondenceAddressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCorrespondenceAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCorrespondenceAddressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/correspondenceAddress",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCorrespondenceAddressResponse =
        new operations.GetCorrespondenceAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.addressDTO = utils.objectToClass(
              httpRes?.data,
              shared.AddressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom field of a given client.
   *
   * @remarks
   * Returns custom field of a given client.
   */
  getCustomField(
    req: operations.GetCustomFieldRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFieldResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFieldRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/customFields/{customFieldKey}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFieldResponse =
        new operations.GetCustomFieldResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom fields of a given person.
   *
   * @remarks
   * Returns custom fields of a given person.
   */
  getCustomFields(
    req: operations.GetCustomFieldsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFieldsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFieldsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFieldsResponse =
        new operations.GetCustomFieldsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns custom fields of a given client.
   *
   * @remarks
   * Returns custom fields of a given client.
   */
  getCustomFields1(
    req: operations.GetCustomFields1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomFields1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomFields1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/customFields",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomFields1Response =
        new operations.GetCustomFields1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns industries of a given client.
   *
   * @remarks
   * Returns industries of a given client.
   */
  getIndustries(
    req: operations.GetIndustriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetIndustriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetIndustriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/industries",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetIndustriesResponse =
        new operations.GetIndustriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.industriesDTO = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates address of a given client.
   *
   * @remarks
   * Updates address of a given client.
   */
  updateAddress(
    req: operations.UpdateAddressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateAddressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/address",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addressDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateAddressResponse =
        new operations.UpdateAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.addressDTO = utils.objectToClass(
              httpRes?.data,
              shared.AddressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates categories of a given client.
   *
   * @remarks
   * Updates categories of a given client.
   */
  updateCategories(
    req: operations.UpdateCategoriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCategoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCategoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/categories",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCategoriesResponse =
        new operations.UpdateCategoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.categoriesDTO = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates contact of a given person.
   *
   * @remarks
   * Updates contact of a given person. Sets that this person uses specific address and contact (not the one from customer).
   */
  updateContact(
    req: operations.UpdateContactRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateContactResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateContactRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}/contact",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "personContactDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateContactResponse =
        new operations.UpdateContactResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.personContactDTO = utils.objectToClass(
              httpRes?.data,
              shared.PersonContactDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates contact of a given client.
   *
   * @remarks
   * Updates contact of a given client.
   */
  updateContact1(
    req: operations.UpdateContact1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateContact1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateContact1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/contact",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "contactDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateContact1Response =
        new operations.UpdateContact1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.contactDTO = utils.objectToClass(
              httpRes?.data,
              shared.ContactDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates correspondence address of a given client.
   *
   * @remarks
   * Updates correspondence address of a given client.
   */
  updateCorrespondenceAddress(
    req: operations.UpdateCorrespondenceAddressRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCorrespondenceAddressResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCorrespondenceAddressRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/correspondenceAddress",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "addressDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCorrespondenceAddressResponse =
        new operations.UpdateCorrespondenceAddressResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.addressDTO = utils.objectToClass(
              httpRes?.data,
              shared.AddressDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates given custom field of a given client.
   *
   * @remarks
   * Updates given custom field of a given client.
   */
  updateCustomField(
    req: operations.UpdateCustomFieldRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomFieldResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomFieldRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/customFields/{customFieldKey}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "customFieldDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomFieldResponse =
        new operations.UpdateCustomFieldResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates custom fields of a given person.
   *
   * @remarks
   * Updates custom fields of a given person.
   */
  updateCustomFields(
    req: operations.UpdateCustomFieldsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomFieldsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomFieldsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}/customFields",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomFieldsResponse =
        new operations.UpdateCustomFieldsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates custom fields of a given client.
   *
   * @remarks
   * Updates custom fields of a given client.
   */
  updateCustomFields1(
    req: operations.UpdateCustomFields1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCustomFields1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCustomFields1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/customFields",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCustomFields1Response =
        new operations.UpdateCustomFields1Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customFieldsDTO = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.customFieldsDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomFieldDTO,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates industries of a given client.
   *
   * @remarks
   * Updates industries of a given client.
   */
  updateIndustries(
    req: operations.UpdateIndustriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateIndustriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateIndustriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}/industries",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateIndustriesResponse =
        new operations.UpdateIndustriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.industriesDTO = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing person.
   *
   * @remarks
   * Only specified fields will be changed. One may not specify embeddable fields here - use separate API calls for updating them.
   */
  update1(
    req: operations.Update1Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Update1Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Update1Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/persons/{personId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "customerPersonDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Update1Response = new operations.Update1Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerPersonDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerPersonDTO
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing client.
   *
   * @remarks
   * Only specified fields will be changed (id is required). One may not specify embeddable fields here - use separate API calls for updating them.
   */
  update2(
    req: operations.Update2Request,
    config?: AxiosRequestConfig
  ): Promise<operations.Update2Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.Update2Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/customers/{customerId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "customerDTO",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.Update2Response = new operations.Update2Response({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        default:
          if (
            utils.matchContentType(
              contentType,
              `application/vnd.xtrf-v1+json;charset=UTF-8`
            )
          ) {
            res.customerDTO = utils.objectToClass(
              httpRes?.data,
              shared.CustomerDTO
            );
          }
          break;
      }

      return res;
    });
  }
}
