/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Labor {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * CreateBreakType
   *
   * @remarks
   * Creates a new `BreakType`.
   *
   * A `BreakType` is a template for creating `Break` objects.
   * You must provide the following values in your request to this
   * endpoint:
   *
   * - `location_id`
   * - `break_name`
   * - `expected_duration`
   * - `is_paid`
   *
   * You can only have three `BreakType` instances per location. If you attempt to add a fourth
   * `BreakType` for a location, an `INVALID_REQUEST_ERROR` "Exceeded limit of 3 breaks per location."
   * is returned.
   */
  createBreakType(
    req: shared.CreateBreakTypeRequest,
    security: operations.CreateBreakTypeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBreakTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateBreakTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/labor/break-types";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateBreakTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBreakTypeResponse =
        new operations.CreateBreakTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createBreakTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateBreakTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * CreateShift
   *
   * @remarks
   * Creates a new `Shift`.
   *
   * A `Shift` represents a complete workday for a single employee.
   * You must provide the following values in your request to this
   * endpoint:
   *
   * - `location_id`
   * - `employee_id`
   * - `start_at`
   *
   * An attempt to create a new `Shift` can result in a `BAD_REQUEST` error when:
   * - The `status` of the new `Shift` is `OPEN` and the employee has another
   * shift with an `OPEN` status.
   * - The `start_at` date is in the future.
   * - The `start_at` or `end_at` date overlaps another shift for the same employee.
   * - The `Break` instances are set in the request and a break `start_at`
   * is before the `Shift.start_at`, a break `end_at` is after
   * the `Shift.end_at`, or both.
   */
  createShift(
    req: shared.CreateShiftRequest,
    security: operations.CreateShiftSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateShiftResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateShiftRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/labor/shifts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CreateShiftSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateShiftResponse =
        new operations.CreateShiftResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createShiftResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateShiftResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteBreakType
   *
   * @remarks
   * Deletes an existing `BreakType`.
   *
   * A `BreakType` can be deleted even if it is referenced from a `Shift`.
   */
  deleteBreakType(
    req: operations.DeleteBreakTypeRequest,
    security: operations.DeleteBreakTypeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBreakTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBreakTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/break-types/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteBreakTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBreakTypeResponse =
        new operations.DeleteBreakTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteBreakTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteBreakTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * DeleteShift
   *
   * @remarks
   * Deletes a `Shift`.
   */
  deleteShift(
    req: operations.DeleteShiftRequest,
    security: operations.DeleteShiftSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteShiftResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteShiftRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/shifts/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteShiftSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteShiftResponse =
        new operations.DeleteShiftResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteShiftResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteShiftResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetBreakType
   *
   * @remarks
   * Returns a single `BreakType` specified by `id`.
   */
  getBreakType(
    req: operations.GetBreakTypeRequest,
    security: operations.GetBreakTypeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBreakTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBreakTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/break-types/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBreakTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBreakTypeResponse =
        new operations.GetBreakTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBreakTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetBreakTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetEmployeeWage
   *
   * @remarks
   * Returns a single `EmployeeWage` specified by `id`.
   */
  getEmployeeWage(
    req: operations.GetEmployeeWageRequest,
    security: operations.GetEmployeeWageSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetEmployeeWageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetEmployeeWageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/employee-wages/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetEmployeeWageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetEmployeeWageResponse =
        new operations.GetEmployeeWageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getEmployeeWageResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetEmployeeWageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetShift
   *
   * @remarks
   * Returns a single `Shift` specified by `id`.
   */
  getShift(
    req: operations.GetShiftRequest,
    security: operations.GetShiftSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetShiftResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetShiftRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/shifts/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetShiftSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetShiftResponse = new operations.GetShiftResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getShiftResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetShiftResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * GetTeamMemberWage
   *
   * @remarks
   * Returns a single `TeamMemberWage` specified by `id `.
   */
  getTeamMemberWage(
    req: operations.GetTeamMemberWageRequest,
    security: operations.GetTeamMemberWageSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTeamMemberWageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTeamMemberWageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/team-member-wages/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTeamMemberWageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTeamMemberWageResponse =
        new operations.GetTeamMemberWageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTeamMemberWageResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTeamMemberWageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListBreakTypes
   *
   * @remarks
   * Returns a paginated list of `BreakType` instances for a business.
   */
  listBreakTypes(
    req: operations.ListBreakTypesRequest,
    security: operations.ListBreakTypesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBreakTypesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBreakTypesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/labor/break-types";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListBreakTypesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBreakTypesResponse =
        new operations.ListBreakTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBreakTypesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBreakTypesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListEmployeeWages
   *
   * @remarks
   * Returns a paginated list of `EmployeeWage` instances for a business.
   */
  listEmployeeWages(
    req: operations.ListEmployeeWagesRequest,
    security: operations.ListEmployeeWagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListEmployeeWagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListEmployeeWagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/labor/employee-wages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListEmployeeWagesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListEmployeeWagesResponse =
        new operations.ListEmployeeWagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listEmployeeWagesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListEmployeeWagesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListTeamMemberWages
   *
   * @remarks
   * Returns a paginated list of `TeamMemberWage` instances for a business.
   */
  listTeamMemberWages(
    req: operations.ListTeamMemberWagesRequest,
    security: operations.ListTeamMemberWagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTeamMemberWagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTeamMemberWagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/labor/team-member-wages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListTeamMemberWagesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTeamMemberWagesResponse =
        new operations.ListTeamMemberWagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTeamMemberWagesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTeamMemberWagesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * ListWorkweekConfigs
   *
   * @remarks
   * Returns a list of `WorkweekConfig` instances for a business.
   */
  listWorkweekConfigs(
    req: operations.ListWorkweekConfigsRequest,
    security: operations.ListWorkweekConfigsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkweekConfigsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkweekConfigsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v2/labor/workweek-configs";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListWorkweekConfigsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkweekConfigsResponse =
        new operations.ListWorkweekConfigsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkweekConfigsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListWorkweekConfigsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * SearchShifts
   *
   * @remarks
   * Returns a paginated list of `Shift` records for a business.
   * The list to be returned can be filtered by:
   * - Location IDs.
   * - Employee IDs.
   * - Shift status (`OPEN` and `CLOSED`).
   * - Shift start.
   * - Shift end.
   * - Workday details.
   *
   * The list can be sorted by:
   * - `start_at`.
   * - `end_at`.
   * - `created_at`.
   * - `updated_at`.
   */
  searchShifts(
    req: shared.SearchShiftsRequest,
    security: operations.SearchShiftsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchShiftsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.SearchShiftsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v2/labor/shifts/search";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SearchShiftsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchShiftsResponse =
        new operations.SearchShiftsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.searchShiftsResponse = utils.objectToClass(
              httpRes?.data,
              shared.SearchShiftsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateBreakType
   *
   * @remarks
   * Updates an existing `BreakType`.
   */
  updateBreakType(
    req: operations.UpdateBreakTypeRequest,
    security: operations.UpdateBreakTypeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBreakTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBreakTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/break-types/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateBreakTypeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateBreakTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBreakTypeResponse =
        new operations.UpdateBreakTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateBreakTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateBreakTypeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateShift
   *
   * @remarks
   * Updates an existing `Shift`.
   *
   * When adding a `Break` to a `Shift`, any earlier `Break` instances in the `Shift` have
   * the `end_at` property set to a valid RFC-3339 datetime string.
   *
   * When closing a `Shift`, all `Break` instances in the `Shift` must be complete with `end_at`
   * set on each `Break`.
   */
  updateShift(
    req: operations.UpdateShiftRequest,
    security: operations.UpdateShiftSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateShiftResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateShiftRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/shifts/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateShiftRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateShiftSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateShiftResponse =
        new operations.UpdateShiftResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateShiftResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateShiftResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * UpdateWorkweekConfig
   *
   * @remarks
   * Updates a `WorkweekConfig`.
   */
  updateWorkweekConfig(
    req: operations.UpdateWorkweekConfigRequest,
    security: operations.UpdateWorkweekConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkweekConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkweekConfigRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v2/labor/workweek-configs/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateWorkweekConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateWorkweekConfigSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkweekConfigResponse =
        new operations.UpdateWorkweekConfigResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateWorkweekConfigResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateWorkweekConfigResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
