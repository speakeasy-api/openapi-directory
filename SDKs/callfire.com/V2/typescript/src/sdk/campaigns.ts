/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Campaigns {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a specific sound
   *
   * @remarks
   * Deletes a single campaign sound instance for a specific campaign sound id, this operation does not delete sound completely, it sets sound status to ARCHIVED which means that sound will no longer appear in 'find' operation results, but still accessible via 'get' operation
   */
  deleteCampaignSound(
    req: operations.DeleteCampaignSoundRequest,
    security: operations.DeleteCampaignSoundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCampaignSoundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCampaignSoundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/campaigns/sounds/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteCampaignSoundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCampaignSoundResponse =
        new operations.DeleteCampaignSoundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find sounds
   *
   * @remarks
   * To find all campaign sounds which were created by user. Returns all sounds available to be used in campaigns
   */
  findCampaignSounds(
    req: operations.FindCampaignSoundsRequest,
    security: operations.FindCampaignSoundsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FindCampaignSoundsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FindCampaignSoundsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/campaigns/sounds";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FindCampaignSoundsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FindCampaignSoundsResponse =
        new operations.FindCampaignSoundsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.campaignSoundPage = utils.objectToClass(
              httpRes?.data,
              shared.CampaignSoundPage
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific batch
   *
   * @remarks
   * Returns a single Batch instance for a given batch id. This API is useful for determining the state of a validating batch
   */
  getCampaignBatch(
    req: operations.GetCampaignBatchRequest,
    security: operations.GetCampaignBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCampaignBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCampaignBatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/campaigns/batches/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCampaignBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCampaignBatchResponse =
        new operations.GetCampaignBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batch = utils.objectToClass(httpRes?.data, shared.Batch);
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Find a specific sound
   *
   * @remarks
   * Returns a single CampaignSound instance for a given sound id in campaign. This is a meta data to the sounds. No audio data is returned from this API
   */
  getCampaignSound(
    req: operations.GetCampaignSoundRequest,
    security: operations.GetCampaignSoundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCampaignSoundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCampaignSoundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/campaigns/sounds/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCampaignSoundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCampaignSoundResponse =
        new operations.GetCampaignSoundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.campaignSound = utils.objectToClass(
              httpRes?.data,
              shared.CampaignSound
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Download a MP3 sound
   *
   * @remarks
   * Download the MP3 version of a hosted file. This is an audio data endpoint. Returns binary response of the 'audio/mpeg' content type
   */
  getCampaignSoundDataMp3(
    req: operations.GetCampaignSoundDataMp3Request,
    security: operations.GetCampaignSoundDataMp3Security,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCampaignSoundDataMp3Response> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCampaignSoundDataMp3Request(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/campaigns/sounds/{id}.mp3",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCampaignSoundDataMp3Security(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCampaignSoundDataMp3Response =
        new operations.GetCampaignSoundDataMp3Response({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `audio/mpeg`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Download a WAV sound
   *
   * @remarks
   * Download the WAV version of the hosted file. This is an audio data endpoint. Returns binary response of the 'audio/mpeg' content type
   */
  getCampaignSoundDataWav(
    req: operations.GetCampaignSoundDataWavRequest,
    security: operations.GetCampaignSoundDataWavSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCampaignSoundDataWavResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCampaignSoundDataWavRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/campaigns/sounds/{id}.wav",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetCampaignSoundDataWavSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCampaignSoundDataWavResponse =
        new operations.GetCampaignSoundDataWavResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `audio/wav`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add sound via call
   *
   * @remarks
   * Use this API to create a sound via a phone call. Provide the required phone number in the CallCreateSound object inside the request, and user will receive a call shortly after with instructions on how to record a sound over the phone.
   */
  postCallCampaignSound(
    req: operations.PostCallCampaignSoundRequest,
    security: operations.PostCallCampaignSoundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostCallCampaignSoundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostCallCampaignSoundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/campaigns/sounds/calls";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "callCreateSound",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostCallCampaignSoundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostCallCampaignSoundResponse =
        new operations.PostCallCampaignSoundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.campaignSound = utils.objectToClass(
              httpRes?.data,
              shared.CampaignSound
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add sound via file
   *
   * @remarks
   * Create a campaign sound file via a supplied .mp3 or .wav file
   */
  postFileCampaignSound(
    req: operations.PostFileCampaignSoundRequest,
    security: operations.PostFileCampaignSoundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostFileCampaignSoundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostFileCampaignSoundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/campaigns/sounds/files";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostFileCampaignSoundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostFileCampaignSoundResponse =
        new operations.PostFileCampaignSoundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.campaignSound = utils.objectToClass(
              httpRes?.data,
              shared.CampaignSound
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add sound via text-to-speech
   *
   * @remarks
   * Use this API to create a sound file via a supplied string of text. Add a text in the TextToSpeech.message field, and pick a voice in the TextToSpeech.voice field. Available voices are: MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1
   */
  postTTSCampaignSound(
    req: operations.PostTTSCampaignSoundRequest,
    security: operations.PostTTSCampaignSoundSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostTTSCampaignSoundResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostTTSCampaignSoundRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/campaigns/sounds/tts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "textToSpeech",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostTTSCampaignSoundSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTTSCampaignSoundResponse =
        new operations.PostTTSCampaignSoundResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.campaignSound = utils.objectToClass(
              httpRes?.data,
              shared.CampaignSound
            );
          }
          break;
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a batch
   *
   * @remarks
   * Updates a single Batch instance, currently batch can only be turned "on/off"
   */
  updateCampaignBatch(
    req: operations.UpdateCampaignBatchRequest,
    security: operations.UpdateCampaignBatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCampaignBatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCampaignBatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/campaigns/batches/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.UpdateCampaignBatchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCampaignBatchResponse =
        new operations.UpdateCampaignBatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [400, 401, 403, 404, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
