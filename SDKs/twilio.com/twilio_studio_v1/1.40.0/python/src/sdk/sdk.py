"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://studio.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_engagement(self, request: operations.CreateEngagementRequest, security: operations.CreateEngagementSecurity, server_url: Optional[str] = None) -> operations.CreateEngagementResponse:
        r"""Triggers a new Engagement for the Flow"""
        base_url = operations.CREATE_ENGAGEMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateEngagementRequest, base_url, '/v1/Flows/{FlowSid}/Engagements', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateEngagementResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowEngagement])
                res.studio_v1_flow_engagement = out

        return res

    def create_execution(self, request: operations.CreateExecutionRequest, security: operations.CreateExecutionSecurity, server_url: Optional[str] = None) -> operations.CreateExecutionResponse:
        r"""Triggers a new Execution for the Flow"""
        base_url = operations.CREATE_EXECUTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateExecutionRequest, base_url, '/v1/Flows/{FlowSid}/Executions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateExecutionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowExecution])
                res.studio_v1_flow_execution = out

        return res

    def delete_engagement(self, request: operations.DeleteEngagementRequest, security: operations.DeleteEngagementSecurity, server_url: Optional[str] = None) -> operations.DeleteEngagementResponse:
        r"""Delete this Engagement and all Steps relating to it."""
        base_url = operations.DELETE_ENGAGEMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteEngagementRequest, base_url, '/v1/Flows/{FlowSid}/Engagements/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteEngagementResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_execution(self, request: operations.DeleteExecutionRequest, security: operations.DeleteExecutionSecurity, server_url: Optional[str] = None) -> operations.DeleteExecutionResponse:
        r"""Delete the Execution and all Steps relating to it."""
        base_url = operations.DELETE_EXECUTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteExecutionRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteExecutionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_flow(self, request: operations.DeleteFlowRequest, security: operations.DeleteFlowSecurity, server_url: Optional[str] = None) -> operations.DeleteFlowResponse:
        r"""Delete a specific Flow."""
        base_url = operations.DELETE_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteFlowRequest, base_url, '/v1/Flows/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_engagement(self, request: operations.FetchEngagementRequest, security: operations.FetchEngagementSecurity, server_url: Optional[str] = None) -> operations.FetchEngagementResponse:
        r"""Retrieve an Engagement"""
        base_url = operations.FETCH_ENGAGEMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEngagementRequest, base_url, '/v1/Flows/{FlowSid}/Engagements/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEngagementResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowEngagement])
                res.studio_v1_flow_engagement = out

        return res

    def fetch_engagement_context(self, request: operations.FetchEngagementContextRequest, security: operations.FetchEngagementContextSecurity, server_url: Optional[str] = None) -> operations.FetchEngagementContextResponse:
        r"""Retrieve the most recent context for an Engagement."""
        base_url = operations.FETCH_ENGAGEMENT_CONTEXT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEngagementContextRequest, base_url, '/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Context', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEngagementContextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowEngagementEngagementContext])
                res.studio_v1_flow_engagement_engagement_context = out

        return res

    def fetch_execution(self, request: operations.FetchExecutionRequest, security: operations.FetchExecutionSecurity, server_url: Optional[str] = None) -> operations.FetchExecutionResponse:
        r"""Retrieve an Execution"""
        base_url = operations.FETCH_EXECUTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchExecutionRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchExecutionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowExecution])
                res.studio_v1_flow_execution = out

        return res

    def fetch_execution_context(self, request: operations.FetchExecutionContextRequest, security: operations.FetchExecutionContextSecurity, server_url: Optional[str] = None) -> operations.FetchExecutionContextResponse:
        r"""Retrieve the most recent context for an Execution."""
        base_url = operations.FETCH_EXECUTION_CONTEXT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchExecutionContextRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Context', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchExecutionContextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowExecutionExecutionContext])
                res.studio_v1_flow_execution_execution_context = out

        return res

    def fetch_execution_step(self, request: operations.FetchExecutionStepRequest, security: operations.FetchExecutionStepSecurity, server_url: Optional[str] = None) -> operations.FetchExecutionStepResponse:
        r"""Retrieve a Step."""
        base_url = operations.FETCH_EXECUTION_STEP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchExecutionStepRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchExecutionStepResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowExecutionExecutionStep])
                res.studio_v1_flow_execution_execution_step = out

        return res

    def fetch_execution_step_context(self, request: operations.FetchExecutionStepContextRequest, security: operations.FetchExecutionStepContextSecurity, server_url: Optional[str] = None) -> operations.FetchExecutionStepContextResponse:
        r"""Retrieve the context for an Execution Step."""
        base_url = operations.FETCH_EXECUTION_STEP_CONTEXT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchExecutionStepContextRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{StepSid}/Context', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchExecutionStepContextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowExecutionExecutionStepExecutionStepContext])
                res.studio_v1_flow_execution_execution_step_execution_step_context = out

        return res

    def fetch_flow(self, request: operations.FetchFlowRequest, security: operations.FetchFlowSecurity, server_url: Optional[str] = None) -> operations.FetchFlowResponse:
        r"""Retrieve a specific Flow."""
        base_url = operations.FETCH_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFlowRequest, base_url, '/v1/Flows/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1Flow])
                res.studio_v1_flow = out

        return res

    def fetch_step(self, request: operations.FetchStepRequest, security: operations.FetchStepSecurity, server_url: Optional[str] = None) -> operations.FetchStepResponse:
        r"""Retrieve a Step."""
        base_url = operations.FETCH_STEP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchStepRequest, base_url, '/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchStepResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowEngagementStep])
                res.studio_v1_flow_engagement_step = out

        return res

    def fetch_step_context(self, request: operations.FetchStepContextRequest, security: operations.FetchStepContextSecurity, server_url: Optional[str] = None) -> operations.FetchStepContextResponse:
        r"""Retrieve the context for an Engagement Step."""
        base_url = operations.FETCH_STEP_CONTEXT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchStepContextRequest, base_url, '/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps/{StepSid}/Context', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchStepContextResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowEngagementStepStepContext])
                res.studio_v1_flow_engagement_step_step_context = out

        return res

    def list_engagement(self, request: operations.ListEngagementRequest, security: operations.ListEngagementSecurity, server_url: Optional[str] = None) -> operations.ListEngagementResponse:
        r"""Retrieve a list of all Engagements for the Flow."""
        base_url = operations.LIST_ENGAGEMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListEngagementRequest, base_url, '/v1/Flows/{FlowSid}/Engagements', request)
        
        query_params = utils.get_query_params(operations.ListEngagementRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEngagementResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListEngagementListEngagementResponse])
                res.list_engagement_response = out

        return res

    def list_execution(self, request: operations.ListExecutionRequest, security: operations.ListExecutionSecurity, server_url: Optional[str] = None) -> operations.ListExecutionResponse:
        r"""Retrieve a list of all Executions for the Flow."""
        base_url = operations.LIST_EXECUTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListExecutionRequest, base_url, '/v1/Flows/{FlowSid}/Executions', request)
        
        query_params = utils.get_query_params(operations.ListExecutionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListExecutionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListExecutionListExecutionResponse])
                res.list_execution_response = out

        return res

    def list_execution_step(self, request: operations.ListExecutionStepRequest, security: operations.ListExecutionStepSecurity, server_url: Optional[str] = None) -> operations.ListExecutionStepResponse:
        r"""Retrieve a list of all Steps for an Execution."""
        base_url = operations.LIST_EXECUTION_STEP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListExecutionStepRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps', request)
        
        query_params = utils.get_query_params(operations.ListExecutionStepRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListExecutionStepResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListExecutionStepListExecutionStepResponse])
                res.list_execution_step_response = out

        return res

    def list_flow(self, request: operations.ListFlowRequest, security: operations.ListFlowSecurity, server_url: Optional[str] = None) -> operations.ListFlowResponse:
        r"""Retrieve a list of all Flows."""
        base_url = operations.LIST_FLOW_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Flows'
        
        query_params = utils.get_query_params(operations.ListFlowRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFlowResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListFlowListFlowResponse])
                res.list_flow_response = out

        return res

    def list_step(self, request: operations.ListStepRequest, security: operations.ListStepSecurity, server_url: Optional[str] = None) -> operations.ListStepResponse:
        r"""Retrieve a list of all Steps for an Engagement."""
        base_url = operations.LIST_STEP_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListStepRequest, base_url, '/v1/Flows/{FlowSid}/Engagements/{EngagementSid}/Steps', request)
        
        query_params = utils.get_query_params(operations.ListStepRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListStepResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListStepListStepResponse])
                res.list_step_response = out

        return res

    def update_execution(self, request: operations.UpdateExecutionRequest, security: operations.UpdateExecutionSecurity, server_url: Optional[str] = None) -> operations.UpdateExecutionResponse:
        r"""Update the status of an Execution to `ended`."""
        base_url = operations.UPDATE_EXECUTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateExecutionRequest, base_url, '/v1/Flows/{FlowSid}/Executions/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateExecutionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.StudioV1FlowExecution])
                res.studio_v1_flow_execution = out

        return res

    