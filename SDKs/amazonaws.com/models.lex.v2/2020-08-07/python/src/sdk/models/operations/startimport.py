"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import botimportspecification as shared_botimportspecification
from ..shared import botlocaleimportspecification as shared_botlocaleimportspecification
from ..shared import customvocabularyimportspecification as shared_customvocabularyimportspecification
from ..shared import startimportresponse as shared_startimportresponse
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional

class StartImportRequestBodyMergeStrategyEnum(str, Enum):
    r"""The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is <code>FailOnConflict</code> existing resources are not overwritten and the import fails."""
    OVERWRITE = 'Overwrite'
    FAIL_ON_CONFLICT = 'FailOnConflict'
    APPEND = 'Append'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class StartImportRequestBodyResourceSpecification:
    r"""Provides information about the bot or bot locale that you want to import. You can specify the <code>botImportSpecification</code> or the <code>botLocaleImportSpecification</code>, but not both."""
    
    bot_import_specification: Optional[shared_botimportspecification.BotImportSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('botImportSpecification'), 'exclude': lambda f: f is None }})  
    bot_locale_import_specification: Optional[shared_botlocaleimportspecification.BotLocaleImportSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('botLocaleImportSpecification'), 'exclude': lambda f: f is None }})  
    custom_vocabulary_import_specification: Optional[shared_customvocabularyimportspecification.CustomVocabularyImportSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customVocabularyImportSpecification'), 'exclude': lambda f: f is None }})
    r"""Provides the parameters required for importing a custom vocabulary."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class StartImportRequestBody:
    
    import_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('importId') }})
    r"""The unique identifier for the import. It is included in the response from the <a href=\\"https://docs.aws.amazon.com/lexv2/latest/APIReference/API_CreateUploadUrl.html\\">CreateUploadUrl</a> operation."""  
    merge_strategy: StartImportRequestBodyMergeStrategyEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('mergeStrategy') }})
    r"""The strategy to use when there is a name conflict between the imported resource and an existing resource. When the merge strategy is <code>FailOnConflict</code> existing resources are not overwritten and the import fails."""  
    resource_specification: StartImportRequestBodyResourceSpecification = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resourceSpecification') }})
    r"""Provides information about the bot or bot locale that you want to import. You can specify the <code>botImportSpecification</code> or the <code>botLocaleImportSpecification</code>, but not both."""  
    file_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('filePassword'), 'exclude': lambda f: f is None }})
    r"""The password used to encrypt the zip archive that contains the resource definition. You should always encrypt the zip archive to protect it during transit between your site and Amazon Lex."""  
    

@dataclasses.dataclass
class StartImportRequest:
    
    request_body: StartImportRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class StartImportResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    conflict_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ConflictException"""  
    internal_server_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InternalServerException"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    resource_not_found_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ResourceNotFoundException"""  
    service_quota_exceeded_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceQuotaExceededException"""  
    start_import_response: Optional[shared_startimportresponse.StartImportResponse] = dataclasses.field(default=None)
    r"""Success"""  
    throttling_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ThrottlingException"""  
    validation_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ValidationException"""  
    