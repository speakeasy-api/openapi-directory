"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import conditionalspecification as shared_conditionalspecification
from ..shared import dialogcodehookinvocationsetting as shared_dialogcodehookinvocationsetting
from ..shared import dialogstate as shared_dialogstate
from ..shared import elicitationcodehookinvocationsetting as shared_elicitationcodehookinvocationsetting
from ..shared import fulfillmentupdatesspecification as shared_fulfillmentupdatesspecification
from ..shared import inputcontext as shared_inputcontext
from ..shared import outputcontext as shared_outputcontext
from ..shared import postfulfillmentstatusspecification as shared_postfulfillmentstatusspecification
from ..shared import promptspecification as shared_promptspecification
from ..shared import responsespecification as shared_responsespecification
from ..shared import sampleutterance as shared_sampleutterance
from ..shared import slotpriority as shared_slotpriority
from ..shared import updateintentresponse as shared_updateintentresponse
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBodyDialogCodeHook:
    r"""Settings that determine the Lambda function that Amazon Lex uses for processing user responses."""
    
    enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBodyFulfillmentCodeHook:
    r"""Determines if a Lambda function should be invoked for a specific intent."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})  
    enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled'), 'exclude': lambda f: f is None }})  
    fulfillment_updates_specification: Optional[shared_fulfillmentupdatesspecification.FulfillmentUpdatesSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fulfillmentUpdatesSpecification'), 'exclude': lambda f: f is None }})  
    post_fulfillment_status_specification: Optional[shared_postfulfillmentstatusspecification.PostFulfillmentStatusSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('postFulfillmentStatusSpecification'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBodyInitialResponseSetting:
    r"""Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots."""
    
    code_hook: Optional[shared_dialogcodehookinvocationsetting.DialogCodeHookInvocationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('codeHook'), 'exclude': lambda f: f is None }})
    r"""Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation."""  
    conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conditional'), 'exclude': lambda f: f is None }})
    r"""Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition."""  
    initial_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('initialResponse'), 'exclude': lambda f: f is None }})
    r"""Specifies a list of message groups that Amazon Lex uses to respond the user input."""  
    next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nextStep'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBodyIntentClosingSetting:
    r"""Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})  
    closing_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('closingResponse'), 'exclude': lambda f: f is None }})  
    conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conditional'), 'exclude': lambda f: f is None }})  
    next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nextStep'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBodyIntentConfirmationSetting:
    r"""Provides a prompt for making sure that the user is ready for the intent to be fulfilled."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})  
    code_hook: Optional[shared_dialogcodehookinvocationsetting.DialogCodeHookInvocationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('codeHook'), 'exclude': lambda f: f is None }})  
    confirmation_conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmationConditional'), 'exclude': lambda f: f is None }})  
    confirmation_next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmationNextStep'), 'exclude': lambda f: f is None }})  
    confirmation_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmationResponse'), 'exclude': lambda f: f is None }})
    r"""Specifies a list of message groups that Amazon Lex uses to respond the user input."""  
    declination_conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('declinationConditional'), 'exclude': lambda f: f is None }})  
    declination_next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('declinationNextStep'), 'exclude': lambda f: f is None }})  
    declination_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('declinationResponse'), 'exclude': lambda f: f is None }})  
    elicitation_code_hook: Optional[shared_elicitationcodehookinvocationsetting.ElicitationCodeHookInvocationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('elicitationCodeHook'), 'exclude': lambda f: f is None }})  
    failure_conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failureConditional'), 'exclude': lambda f: f is None }})
    r"""Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition."""  
    failure_next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failureNextStep'), 'exclude': lambda f: f is None }})  
    failure_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failureResponse'), 'exclude': lambda f: f is None }})
    r"""Specifies a list of message groups that Amazon Lex uses to respond the user input."""  
    prompt_specification: Optional[shared_promptspecification.PromptSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('promptSpecification'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBodyKendraConfiguration:
    r"""Provides configuration information for the AMAZON.KendraSearchIntent intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance."""
    
    kendra_index: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kendraIndex'), 'exclude': lambda f: f is None }})  
    query_filter_string: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('queryFilterString'), 'exclude': lambda f: f is None }})  
    query_filter_string_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('queryFilterStringEnabled'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateIntentRequestBody:
    
    intent_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intentName') }})
    r"""The new name for the intent."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The new description of the intent."""  
    dialog_code_hook: Optional[UpdateIntentRequestBodyDialogCodeHook] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dialogCodeHook'), 'exclude': lambda f: f is None }})
    r"""Settings that determine the Lambda function that Amazon Lex uses for processing user responses."""  
    fulfillment_code_hook: Optional[UpdateIntentRequestBodyFulfillmentCodeHook] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fulfillmentCodeHook'), 'exclude': lambda f: f is None }})
    r"""Determines if a Lambda function should be invoked for a specific intent."""  
    initial_response_setting: Optional[UpdateIntentRequestBodyInitialResponseSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('initialResponseSetting'), 'exclude': lambda f: f is None }})
    r"""Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots."""  
    input_contexts: Optional[list[shared_inputcontext.InputContext]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('inputContexts'), 'exclude': lambda f: f is None }})
    r"""A new list of contexts that must be active in order for Amazon Lex to consider the intent."""  
    intent_closing_setting: Optional[UpdateIntentRequestBodyIntentClosingSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intentClosingSetting'), 'exclude': lambda f: f is None }})
    r"""Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled."""  
    intent_confirmation_setting: Optional[UpdateIntentRequestBodyIntentConfirmationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intentConfirmationSetting'), 'exclude': lambda f: f is None }})
    r"""Provides a prompt for making sure that the user is ready for the intent to be fulfilled."""  
    kendra_configuration: Optional[UpdateIntentRequestBodyKendraConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kendraConfiguration'), 'exclude': lambda f: f is None }})
    r"""Provides configuration information for the AMAZON.KendraSearchIntent intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance."""  
    output_contexts: Optional[list[shared_outputcontext.OutputContext]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outputContexts'), 'exclude': lambda f: f is None }})
    r"""A new list of contexts that Amazon Lex activates when the intent is fulfilled."""  
    parent_intent_signature: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('parentIntentSignature'), 'exclude': lambda f: f is None }})
    r"""The signature of the new built-in intent to use as the parent of this intent."""  
    sample_utterances: Optional[list[shared_sampleutterance.SampleUtterance]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sampleUtterances'), 'exclude': lambda f: f is None }})
    r"""New utterances used to invoke the intent."""  
    slot_priorities: Optional[list[shared_slotpriority.SlotPriority]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slotPriorities'), 'exclude': lambda f: f is None }})
    r"""A new list of slots and their priorities that are contained by the intent."""  
    

@dataclasses.dataclass
class UpdateIntentRequest:
    
    bot_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'botId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the bot that contains the intent."""  
    bot_version: str = dataclasses.field(metadata={'path_param': { 'field_name': 'botVersion', 'style': 'simple', 'explode': False }})
    r"""The version of the bot that contains the intent. Must be <code>DRAFT</code>."""  
    intent_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'intentId', 'style': 'simple', 'explode': False }})
    r"""The unique identifier of the intent to update."""  
    locale_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'localeId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the language and locale where this intent is used. The string must match one of the supported locales. For more information, see <a href=\\"https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html\\">Supported languages</a>."""  
    request_body: UpdateIntentRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class UpdateIntentResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    conflict_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ConflictException"""  
    internal_server_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InternalServerException"""  
    precondition_failed_exception: Optional[Any] = dataclasses.field(default=None)
    r"""PreconditionFailedException"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    service_quota_exceeded_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceQuotaExceededException"""  
    throttling_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ThrottlingException"""  
    update_intent_response: Optional[shared_updateintentresponse.UpdateIntentResponse] = dataclasses.field(default=None)
    r"""Success"""  
    validation_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ValidationException"""  
    