// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
)

// scim - SCIM is a provisioning system that lets you manage users within your identity provider (IdP).
// For more information, see [System for Cross-domain Identity management](https://docs.docker.com/docker-hub/scim/).
type scim struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newScim(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *scim {
	return &scim{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// GetV2Scim20ResourceTypes - List resource types
// Returns all resource types supported for the SCIM configuration.
func (s *scim) GetV2Scim20ResourceTypes(ctx context.Context) (*operations.GetV2Scim20ResourceTypesResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/v2/scim/2.0/ResourceTypes"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20ResourceTypesResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ResourceTypes200ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ResourceTypes200ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ResourceTypes401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ResourceTypes401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ResourceTypes500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ResourceTypes500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// GetV2Scim20ResourceTypesName - Get a resource type
// Returns a resource type by name.
func (s *scim) GetV2Scim20ResourceTypesName(ctx context.Context, request operations.GetV2Scim20ResourceTypesNameRequest) (*operations.GetV2Scim20ResourceTypesNameResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v2/scim/2.0/ResourceTypes/{name}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20ResourceTypesNameResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *shared.ScimResourceType
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ScimResourceType = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ResourceTypesName401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ResourceTypesName401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ResourceTypesName404ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ResourceTypesName404ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ResourceTypesName500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ResourceTypesName500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// GetV2Scim20Schemas - List schemas
// Returns all schemas supported for the SCIM configuration.
func (s *scim) GetV2Scim20Schemas(ctx context.Context) (*operations.GetV2Scim20SchemasResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/v2/scim/2.0/Schemas"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20SchemasResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Schemas200ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Schemas200ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Schemas401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Schemas401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Schemas500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Schemas500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// GetV2Scim20SchemasID - Get a schema
// Returns a schema by ID.
func (s *scim) GetV2Scim20SchemasID(ctx context.Context, request operations.GetV2Scim20SchemasIDRequest) (*operations.GetV2Scim20SchemasIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v2/scim/2.0/Schemas/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20SchemasIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *shared.ScimSchema
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ScimSchema = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20SchemasID401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20SchemasID401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20SchemasID404ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20SchemasID404ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20SchemasID500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20SchemasID500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// GetV2Scim20ServiceProviderConfig - Get service provider config
// Returns a service provider config for Docker's configuration.
func (s *scim) GetV2Scim20ServiceProviderConfig(ctx context.Context) (*operations.GetV2Scim20ServiceProviderConfigResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/v2/scim/2.0/ServiceProviderConfig"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20ServiceProviderConfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *shared.ScimServiceProviderConfig
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ScimServiceProviderConfig = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ServiceProviderConfig401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ServiceProviderConfig401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20ServiceProviderConfig500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20ServiceProviderConfig500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// GetV2Scim20Users - List users
// List users, returns paginated users for an organization. Use `startIndex`
// and `count` query parameters to receive paginated results.
//
// **Sorting:**<br>
// Sorting lets you to specify the order of returned resources by specifying
// a combination of `sortBy` and `sortOrder` query parameters.
//
// The `sortBy` parameter specifies the attribute whose value will be used
// to order the returned responses. The `sortOrder` parameter defines the
// order in which the `sortBy` parameter is applied. Allowed values are
// "ascending" and "descending".
//
// **Filtering:**<br>
// You can request a subset of resources by specifying the `filter` query
// parameter containing a filter expression. Attribute names and attribute
// operators used in filters are case insensitive. The filter parameter
// must contain at least one valid expression. Each expression must contain
// an attribute name followed by an attribute operator and an optional
// value.
//
// Supported operators are listed below.
//
// - `eq` equal
// - `ne` not equal
// - `co` contains
// - `sw` starts with
// - `and` Logical "and"
// - `or` Logical "or"
// - `not` "Not" function
// - `()` Precedence grouping
func (s *scim) GetV2Scim20Users(ctx context.Context, request operations.GetV2Scim20UsersRequest) (*operations.GetV2Scim20UsersResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/v2/scim/2.0/Users"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20UsersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Users200ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Users200ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 400:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Users400ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Users400ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Users401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Users401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 403:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Users403ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Users403ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Users404ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Users404ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20Users500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20Users500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// GetV2Scim20UsersID - Get a user
// Returns a user by ID.
func (s *scim) GetV2Scim20UsersID(ctx context.Context, request operations.GetV2Scim20UsersIDRequest) (*operations.GetV2Scim20UsersIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v2/scim/2.0/Users/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetV2Scim20UsersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *shared.ScimUser
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ScimUser = out
		}
	case httpRes.StatusCode == 400:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20UsersID400ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20UsersID400ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20UsersID401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20UsersID401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 403:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20UsersID403ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20UsersID403ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20UsersID404ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20UsersID404ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.GetV2Scim20UsersID500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetV2Scim20UsersID500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// PostV2Scim20Users - Create user
// Creates a user. If the user already exists by email, they are assigned
// to the organization on the "company" team.
func (s *scim) PostV2Scim20Users(ctx context.Context, request operations.PostV2Scim20UsersRequestBody) (*operations.PostV2Scim20UsersResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/v2/scim/2.0/Users"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Request", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PostV2Scim20UsersResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 201:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *shared.ScimUser
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ScimUser = out
		}
	case httpRes.StatusCode == 400:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PostV2Scim20Users400ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostV2Scim20Users400ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PostV2Scim20Users401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostV2Scim20Users401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 403:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PostV2Scim20Users403ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostV2Scim20Users403ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PostV2Scim20Users404ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostV2Scim20Users404ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 409:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PostV2Scim20Users409ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostV2Scim20Users409ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PostV2Scim20Users500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PostV2Scim20Users500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}

// PutV2Scim20UsersID - Update a user
// Updates a user. Use this route to change the user's name, activate,
// and deactivate the user.
func (s *scim) PutV2Scim20UsersID(ctx context.Context, request operations.PutV2Scim20UsersIDRequest) (*operations.PutV2Scim20UsersIDResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v2/scim/2.0/Users/{id}", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "RequestBody", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	client := s.defaultClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.PutV2Scim20UsersIDResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *shared.ScimUser
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ScimUser = out
		}
	case httpRes.StatusCode == 400:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PutV2Scim20UsersID400ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PutV2Scim20UsersID400ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 401:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PutV2Scim20UsersID401ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PutV2Scim20UsersID401ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 403:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PutV2Scim20UsersID403ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PutV2Scim20UsersID403ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 404:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PutV2Scim20UsersID404ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PutV2Scim20UsersID404ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 409:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PutV2Scim20UsersID409ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PutV2Scim20UsersID409ApplicationScimPlusJSONObject = out
		}
	case httpRes.StatusCode == 500:
		switch {
		case utils.MatchContentType(contentType, `application/scim+json`):
			var out *operations.PutV2Scim20UsersID500ApplicationScimPlusJSON
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.PutV2Scim20UsersID500ApplicationScimPlusJSONObject = out
		}
	}

	return res, nil
}
