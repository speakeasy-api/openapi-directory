// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
)

// featureFlagAndSettingValuesUsingSDKKey - With these endpoints you can control how your existing Feature Flags and Settings should serve their values.
// You can turn Feature Flags on or off, update Setting values and also add, remove or change the order of Percentage and Targeting Rules.
//
// These endpoints are determining the Environment and Config by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in
// the `X-CONFIGCAT-SDKKEY` request header. To identify the desired Feature Flag or Setting to change,
// you can use either its `settingId` or `key` attribute. You can get those attributes
// from the [Feature Flag & Setting](#tag/Feature-Flags-and-Settings) endpoints.
type featureFlagAndSettingValuesUsingSDKKey struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newFeatureFlagAndSettingValuesUsingSDKKey(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *featureFlagAndSettingValuesUsingSDKKey {
	return &featureFlagAndSettingValuesUsingSDKKey{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// GetSettingValueBySdkkey - Get value
// This endpoint returns the value of a Feature Flag or Setting
// in a specified Environment identified by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in the `X-CONFIGCAT-SDKKEY` header.
//
// The most important attributes in the response are the `value`, `rolloutRules` and `percentageRules`.
// The `value` represents what the clients will get when the evaluation requests of our SDKs
// are not matching to any of the defined Targeting or Percentage Rules, or when there are no additional rules to evaluate.
//
// The `rolloutRules` and `percentageRules` attributes are representing the current
// Targeting and Percentage Rules configuration of the actual Feature Flag or Setting
// in an **ordered** collection, which means the order of the returned rules is matching to the
// evaluation order. You can read more about these rules [here](https://configcat.com/docs/advanced/targeting/).
func (s *featureFlagAndSettingValuesUsingSDKKey) GetSettingValueBySdkkey(ctx context.Context, request operations.GetSettingValueBySdkkeyRequest) (*operations.GetSettingValueBySdkkeyResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v1/settings/{settingKeyOrId}/value", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	utils.PopulateHeaders(ctx, req, request)

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.GetSettingValueBySdkkeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/hal+json`):
			var out *shared.SettingValueModelHaljson
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SettingValueModelHaljson = out
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.SettingValueModel
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SettingValueModel = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 429:
	}

	return res, nil
}

// ReplaceSettingValueBySdkkey - Replace value
// This endpoint replaces the value of a Feature Flag or Setting
// in a specified Environment identified by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in the `X-CONFIGCAT-SDKKEY` header.
//
// Only the `value`, `rolloutRules` and `percentageRules` attributes are modifiable by this endpoint.
//
// **Important:** As this endpoint is doing a complete replace, it's important to set every other attribute that you don't
// want to change to its original state. Not listing one means that it will reset.
//
// For example: We have the following resource.
// ```
//
//	{
//		"rolloutPercentageItems": [
//			{
//				"percentage": 30,
//				"value": true
//			},
//			{
//				"percentage": 70,
//				"value": false
//			}
//		],
//		"rolloutRules": [],
//		"value": false
//	}
//
// ```
// If we send a replace request body as below:
// ```
//
//	{
//		"value": true
//	}
//
// ```
// Then besides that the default served value is set to `true`, all the Percentage Rules are deleted.
// So we get a response like this:
// ```
//
//	{
//		"rolloutPercentageItems": [],
//		"rolloutRules": [],
//		"value": true
//	}
//
// ```
func (s *featureFlagAndSettingValuesUsingSDKKey) ReplaceSettingValueBySdkkey(ctx context.Context, request operations.ReplaceSettingValueBySdkkeyRequest) (*operations.ReplaceSettingValueBySdkkeyResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v1/settings/{settingKeyOrId}/value", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "UpdateSettingValueModel", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PUT", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.ReplaceSettingValueBySdkkeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/hal+json`):
			var out *shared.SettingValueModelHaljson
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SettingValueModelHaljson = out
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.SettingValueModel
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SettingValueModel = out
		}
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 429:
	}

	return res, nil
}

// UpdateSettingValueBySdkkey - Update value
// This endpoint updates the value of a Feature Flag or Setting
// with a collection of [JSON Patch](http://jsonpatch.com) operations in a specified Environment
// identified by the <a target="_blank" rel="noopener noreferrer" href="https://app.configcat.com/sdkkey">SDK key</a> passed in the `X-CONFIGCAT-SDKKEY` header.
//
// Only the `value`, `rolloutRules` and `percentageRules` attributes are modifiable by this endpoint.
//
// The advantage of using JSON Patch is that you can describe individual update operations on a resource
// without touching attributes that you don't want to change. It supports collection reordering, so it also
// can be used for reordering the targeting rules of a Feature Flag or Setting.
//
// For example: We have the following resource.
// ```
//
//	{
//		"rolloutPercentageItems": [
//			{
//				"percentage": 30,
//				"value": true
//			},
//			{
//				"percentage": 70,
//				"value": false
//			}
//		],
//		"rolloutRules": [],
//		"value": false
//	}
//
// ```
// If we send an update request body as below:
// ```
// [
//
//	{
//		"op": "replace",
//		"path": "/value",
//		"value": true
//	}
//
// ]
// ```
// Only the default served value is going to be set to `true` and all the Percentage Rules are remaining unchanged.
// So we get a response like this:
// ```
//
//	{
//		"rolloutPercentageItems": [
//			{
//				"percentage": 30,
//				"value": true
//			},
//			{
//				"percentage": 70,
//				"value": false
//			}
//		],
//		"rolloutRules": [],
//		"value": true
//	}
//
// ```
func (s *featureFlagAndSettingValuesUsingSDKKey) UpdateSettingValueBySdkkey(ctx context.Context, request operations.UpdateSettingValueBySdkkeyRequest) (*operations.UpdateSettingValueBySdkkeyResponse, error) {
	baseURL := s.serverURL
	url, err := utils.GenerateURL(ctx, baseURL, "/v1/settings/{settingKeyOrId}/value", request, nil)
	if err != nil {
		return nil, fmt.Errorf("error generating URL: %w", err)
	}

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "JSONPatchInput", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}
	if bodyReader == nil {
		return nil, fmt.Errorf("request body is required")
	}

	req, err := http.NewRequestWithContext(ctx, "PATCH", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	utils.PopulateHeaders(ctx, req, request)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := s.securityClient

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.UpdateSettingValueBySdkkeyResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/hal+json`):
			var out *shared.SettingValueModelHaljson
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SettingValueModelHaljson = out
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.SettingValueModel
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SettingValueModel = out
		}
	case httpRes.StatusCode == 204:
		fallthrough
	case httpRes.StatusCode == 400:
		fallthrough
	case httpRes.StatusCode == 401:
		fallthrough
	case httpRes.StatusCode == 404:
		fallthrough
	case httpRes.StatusCode == 429:
	}

	return res, nil
}
