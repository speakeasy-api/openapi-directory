<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Authentication 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Remove user access
     * 
     * This endpoint removes the token in use.<br><br>
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteAuthTokenResponse
     */
	public function deleteAuthToken(
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteAuthTokenResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/auth/token');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteAuthTokenResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Delete the user
     * 
     * This endpoint deletes the user.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserResponse
     */
	public function deleteUsersIdUser(
        \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}', \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteUsersIdUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->user = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\User', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate a user temporary token
     * 
     * This endpoint generates a new temporary token for the user.<br><br>In case the access_token is used by a trusted device, and you want to let another one (for example a web browser) access to user resources, use this service to create a token which will expire in 30 minutes.<br><br>Additionally, you can also generate a temporary single-use token by specifying 'type=singleAccess' as query parameter. A single-use token can only be used once no matter the endpoint being accessed.<br><br>
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAuthTokenCodeResponse
     */
	public function getAuthTokenCode(
    ): \OpenAPI\OpenAPI\Models\Operations\GetAuthTokenCodeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/auth/token/code');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAuthTokenCodeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getAuthTokenCode200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetAuthTokenCode200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the latest certificate of a type
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeResponse
     */
	public function getCertificateType(
        \OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/certificate/{type}', \OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCertificateTypeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Certificate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserResponse
     */
	public function getUsersIdUser(
        \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}', \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUsersIdUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->user = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\User', 'json');
            }
        }

        return $response;
    }
	
    /**
     * First step to establish an oAuth2 connection.
     * 
     * The route encapsulate 2 functionalities: 1. Create or update a connection through oAuth2 session.<br><br>2. Execute a transfer through OAuth2 session.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWebauthRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebauthResponse
     */
	public function getWebauth(
        \OpenAPI\OpenAPI\Models\Operations\GetWebauthRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebauthResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/webauth');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebauthResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Generate a jwt manage token
     * 
     * This endpoint generates a new jwt manage token. It requires an admin manage token to be used<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostAdminJwtRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostAdminJwtResponse
     */
	public function postAdminJwt(
        \OpenAPI\OpenAPI\Models\Operations\PostAdminJwtRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostAdminJwtResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/admin/jwt');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostAdminJwtResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postAdminJwt200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a new anonymous user
     * 
     * This endpoint creates a new temporary token related to a new anonymous user.<br><br>It will expire 30 minutes after.<br><br>Note: if you supply client_id and client_secret, or if you call this endpoint with the manage_token, the token will be permanent.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostAuthInitRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostAuthInitResponse
     */
	public function postAuthInit(
        \OpenAPI\OpenAPI\Models\Operations\PostAuthInitRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostAuthInitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/auth/init');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostAuthInitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postAuthInit200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostAuthInit200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate a user jwt token
     * 
     * This endpoint generates a new jwt token for the user. This token will last the time in minutes given by the config key auth.default_token_expire (permanent if this the parameter expire=False is given)<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostAuthJwtRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostAuthJwtResponse
     */
	public function postAuthJwt(
        \OpenAPI\OpenAPI\Models\Operations\PostAuthJwtRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostAuthJwtResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/auth/jwt');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostAuthJwtResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postAuthJwt200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostAuthJwt200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a new access token given an user id and client credentials
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostAuthRenewRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostAuthRenewResponse
     */
	public function postAuthRenew(
        \OpenAPI\OpenAPI\Models\Operations\PostAuthRenewRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostAuthRenewResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/auth/renew');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostAuthRenewResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postAuthRenew200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostAuthRenew200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Transform a temporary code to a access_token
     * 
     * In order to register a new user with the OAuth 2 process, the client has to call this endpoint to request a granted access_token with the received temporary code.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostAuthTokenAccessRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostAuthTokenAccessResponse
     */
	public function postAuthTokenAccess(
        \OpenAPI\OpenAPI\Models\Operations\PostAuthTokenAccessRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostAuthTokenAccessResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/auth/token/access');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "multipart");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostAuthTokenAccessResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postAuthTokenAccess200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostAuthTokenAccess200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a token
     * 
     * Create an access_token for this user and get it.<br><br>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTokenRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTokenResponse
     */
	public function postUsersIdUserToken(
        \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTokenRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTokenResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/users/{id_user}/token', \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTokenRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostUsersIdUserTokenResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postUsersIdUserToken200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}