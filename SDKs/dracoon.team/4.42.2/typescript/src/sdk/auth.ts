/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Authentication
 */
export class Auth {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Complete OpenID Connect authentication
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.14.0</h3>
   *
   * ### Description:
   * This is the second step of the OpenID Connect authentication.
   * The user hands over the authorization code and is logged in.
   *
   * ### Precondition:
   * Existing user with activated OpenID Connect authentication that is **NOT** locked.
   *
   * ### Postcondition:
   * User is logged in.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  completeOpenIdLogin(
    req: operations.CompleteOpenIdLoginRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CompleteOpenIdLoginResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CompleteOpenIdLoginRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/auth/openid/login";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CompleteOpenIdLoginResponse =
        new operations.CompleteOpenIdLoginResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.loginResponse = utils.objectToClass(
              httpRes?.data,
              shared.LoginResponse
            );
          }
          break;
        case [400, 401, 403, 404, 406, 502].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Initiate OpenID Connect authentication
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.14.0</h3>
   *
   * ### Description:
   * This is the first step of the OpenID Connect authentication.
   * The user is send to the OpenID Connect identity provider to authenticate himself and retrieve an authorization code.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * User is redirected to OpenID Connect identity provider to authenticate himself.
   *
   * ### Further Information:
   * None.
   *
   * @see {@link http://openid.net/developers/specs} - OpenID Specifications
   */
  initiateOpenIdLogin(
    req: operations.InitiateOpenIdLoginRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.InitiateOpenIdLoginResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.InitiateOpenIdLoginRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/auth/openid/login";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.InitiateOpenIdLoginResponse =
        new operations.InitiateOpenIdLoginResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [204, 302].includes(httpRes?.status):
          break;
        case [400, 401, 403, 404, 406, 502].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Authenticate user (Login)
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.13.0</h3>
   *
   * ### Description:
   * Authenticates user and provides an authentication token (`X-Sds-Auth-Token`) that is required for the most operations.
   *
   * ### Precondition:
   * Existing user that is **NOT** locked.
   *
   * ### Postcondition:
   * User is logged in.
   *
   * ### Further Information:
   * The provided token is valid for **two hours**, every usage resets this period to two full hours again.
   * Logging off invalidates the token.
   *
   * ### Available authentication methods:
   * <details open style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
   * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
   *
   * | Authentication Method (`authType`) | Description |
   * | :--- | :--- |
   * | `basic` | Log in with credentials stored in the database <br>Formerly known as `sql`.|
   * | `active_directory` | Log in with Active Directory credentials |
   * | `radius` | Log in with RADIUS username, PIN and token password.<br>Token (request parameter) may be set, otherwise this parameter is ignored. If token is set, password is optional. |
   * | `openid` | Please use `POST /auth/openid/login` API to login with OpenID Connect identity |
   *
   * </details>
   *
   * @see {@link https://tools.ietf.org/html/rfc2865} - Remote Authentication Dial In User Service (RADIUS)
   */
  login(
    req: shared.LoginRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.LoginResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.LoginRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/auth/login";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LoginResponse = new operations.LoginResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.loginResponse = utils.objectToClass(
              httpRes?.data,
              shared.LoginResponse
            );
          }
          break;
        case [400, 401, 403, 404, 406, 502].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
        case httpRes?.status == 412:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.radiusChallengeResponse = utils.objectToClass(
              httpRes?.data,
              shared.RadiusChallengeResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Ping
   *
   * @remarks
   * ### Description:
   * Test connection to DRACOON Core Service.
   *
   * ### Precondition:
   * None.
   *
   * ### Postcondition:
   * `200 OK` with current date string is returned if successful.
   *
   * ### Further Information:
   * None.
   */
  ping(config?: AxiosRequestConfig): Promise<operations.PingResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/auth/ping";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PingResponse = new operations.PingResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `text/plain`)) {
            res.ping200TextPlainString = JSON.stringify(httpRes?.data);
          }
          break;
        case httpRes?.status == 406:
          if (utils.matchContentType(contentType, `text/plain`)) {
            res.errorResponse = JSON.stringify(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Recover username
   *
   * @remarks
   * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.13.0</h3>
   *
   * ### Description:
   * Request an email with the user names of all accounts connected to the email.
   *
   * ### Precondition:
   * Valid email address.
   *
   * ### Postcondition:
   * An email is sent to the provided address, with a list of account user names connected to it.
   *
   * ### Further Information:
   * None.
   *
   */
  recoverUserName(
    req: shared.RecoverUserNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RecoverUserNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.RecoverUserNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/v4/auth/recover_username";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RecoverUserNameResponse =
        new operations.RecoverUserNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 404, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request password reset
   *
   * @remarks
   * ### Description:
   * Request an email with a password reset token for a certain user to reset password.
   *
   * ### Precondition:
   * Registered user account.
   *
   * ### Postcondition:
   * Provided user receives email with password reset token.
   *
   * ### Further Information:
   * None.
   */
  requestPasswordReset(
    req: shared.ResetPasswordRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RequestPasswordResetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ResetPasswordRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v4/auth/reset_password";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RequestPasswordResetResponse =
        new operations.RequestPasswordResetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [400, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reset password
   *
   * @remarks
   * ### Description:
   * Resets user's password.
   *
   * ### Precondition:
   * User received a password reset token.
   *
   * ### Postcondition:
   * User's password is reset to the provided password.
   *
   * ### Further Information:
   * Forbidden characters in passwords: [`&`, `'`, `<`, `>`]
   */
  resetPassword(
    req: operations.ResetPasswordRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ResetPasswordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ResetPasswordRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/auth/reset_password/{token}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resetPasswordWithTokenRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ResetPasswordResponse =
        new operations.ResetPasswordResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 400:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resetPassword400ApplicationJSONOneOf = httpRes?.data;
          }
          break;
        case [404, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validate information for password reset
   *
   * @remarks
   * ### Description:
   * Request all information for a password change dialogue e.g. real name of user.
   *
   * ### Precondition:
   * User received a password reset token.
   *
   * ### Postcondition:
   * Context information is returned.
   *
   * ### Further Information:
   * None.
   */
  validateResetPasswordToken(
    req: operations.ValidateResetPasswordTokenRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ValidateResetPasswordTokenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ValidateResetPasswordTokenRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v4/auth/reset_password/{token}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ValidateResetPasswordTokenResponse =
        new operations.ValidateResetPasswordTokenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resetPasswordTokenValidateResponse = utils.objectToClass(
              httpRes?.data,
              shared.ResetPasswordTokenValidateResponse
            );
          }
          break;
        case [400, 404, 406].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.errorResponse = utils.objectToClass(
              httpRes?.data,
              shared.ErrorResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
