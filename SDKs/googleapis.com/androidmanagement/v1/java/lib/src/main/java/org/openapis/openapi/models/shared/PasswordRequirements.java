/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * PasswordRequirements - Requirements for the password used to unlock a device.
 */
public class PasswordRequirements {
    /**
     * Number of incorrect device-unlock passwords that can be entered before a device is wiped. A value of 0 means there is no restriction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maximumFailedPasswordsForWipe")
    public Integer maximumFailedPasswordsForWipe;
    public PasswordRequirements withMaximumFailedPasswordsForWipe(Integer maximumFailedPasswordsForWipe) {
        this.maximumFailedPasswordsForWipe = maximumFailedPasswordsForWipe;
        return this;
    }
    
    /**
     * Password expiration timeout.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordExpirationTimeout")
    public String passwordExpirationTimeout;
    public PasswordRequirements withPasswordExpirationTimeout(String passwordExpirationTimeout) {
        this.passwordExpirationTimeout = passwordExpirationTimeout;
        return this;
    }
    
    /**
     * The length of the password history. After setting this field, the user won't be able to enter a new password that is the same as any password in the history. A value of 0 means there is no restriction.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordHistoryLength")
    public Integer passwordHistoryLength;
    public PasswordRequirements withPasswordHistoryLength(Integer passwordHistoryLength) {
        this.passwordHistoryLength = passwordHistoryLength;
        return this;
    }
    
    /**
     * The minimum allowed password length. A value of 0 means there is no restriction. Only enforced when password_quality is NUMERIC, NUMERIC_COMPLEX, ALPHABETIC, ALPHANUMERIC, or COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumLength")
    public Integer passwordMinimumLength;
    public PasswordRequirements withPasswordMinimumLength(Integer passwordMinimumLength) {
        this.passwordMinimumLength = passwordMinimumLength;
        return this;
    }
    
    /**
     * Minimum number of letters required in the password. Only enforced when password_quality is COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumLetters")
    public Integer passwordMinimumLetters;
    public PasswordRequirements withPasswordMinimumLetters(Integer passwordMinimumLetters) {
        this.passwordMinimumLetters = passwordMinimumLetters;
        return this;
    }
    
    /**
     * Minimum number of lower case letters required in the password. Only enforced when password_quality is COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumLowerCase")
    public Integer passwordMinimumLowerCase;
    public PasswordRequirements withPasswordMinimumLowerCase(Integer passwordMinimumLowerCase) {
        this.passwordMinimumLowerCase = passwordMinimumLowerCase;
        return this;
    }
    
    /**
     * Minimum number of non-letter characters (numerical digits or symbols) required in the password. Only enforced when password_quality is COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumNonLetter")
    public Integer passwordMinimumNonLetter;
    public PasswordRequirements withPasswordMinimumNonLetter(Integer passwordMinimumNonLetter) {
        this.passwordMinimumNonLetter = passwordMinimumNonLetter;
        return this;
    }
    
    /**
     * Minimum number of numerical digits required in the password. Only enforced when password_quality is COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumNumeric")
    public Integer passwordMinimumNumeric;
    public PasswordRequirements withPasswordMinimumNumeric(Integer passwordMinimumNumeric) {
        this.passwordMinimumNumeric = passwordMinimumNumeric;
        return this;
    }
    
    /**
     * Minimum number of symbols required in the password. Only enforced when password_quality is COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumSymbols")
    public Integer passwordMinimumSymbols;
    public PasswordRequirements withPasswordMinimumSymbols(Integer passwordMinimumSymbols) {
        this.passwordMinimumSymbols = passwordMinimumSymbols;
        return this;
    }
    
    /**
     * Minimum number of upper case letters required in the password. Only enforced when password_quality is COMPLEX.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordMinimumUpperCase")
    public Integer passwordMinimumUpperCase;
    public PasswordRequirements withPasswordMinimumUpperCase(Integer passwordMinimumUpperCase) {
        this.passwordMinimumUpperCase = passwordMinimumUpperCase;
        return this;
    }
    
    /**
     * The required password quality.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordQuality")
    public PasswordRequirementsPasswordQualityEnum passwordQuality;
    public PasswordRequirements withPasswordQuality(PasswordRequirementsPasswordQualityEnum passwordQuality) {
        this.passwordQuality = passwordQuality;
        return this;
    }
    
    /**
     * The scope that the password requirement applies to.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("passwordScope")
    public PasswordRequirementsPasswordScopeEnum passwordScope;
    public PasswordRequirements withPasswordScope(PasswordRequirementsPasswordScopeEnum passwordScope) {
        this.passwordScope = passwordScope;
        return this;
    }
    
    /**
     * The length of time after a device or work profile is unlocked using a strong form of authentication (password, PIN, pattern) that it can be unlocked using any other authentication method (e.g. fingerprint, trust agents, face). After the specified time period elapses, only strong forms of authentication can be used to unlock the device or work profile.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("requirePasswordUnlock")
    public PasswordRequirementsRequirePasswordUnlockEnum requirePasswordUnlock;
    public PasswordRequirements withRequirePasswordUnlock(PasswordRequirementsRequirePasswordUnlockEnum requirePasswordUnlock) {
        this.requirePasswordUnlock = requirePasswordUnlock;
        return this;
    }
    
    /**
     * Controls whether a unified lock is allowed for the device and the work profile, on devices running Android 9 and above with a work profile. This can be set only if password_scope is set to SCOPE_PROFILE, the policy will be rejected otherwise. If user has not set a separate work lock and this field is set to REQUIRE_SEPARATE_WORK_LOCK, a NonComplianceDetail is reported with nonComplianceReason set to USER_ACTION.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unifiedLockSettings")
    public PasswordRequirementsUnifiedLockSettingsEnum unifiedLockSettings;
    public PasswordRequirements withUnifiedLockSettings(PasswordRequirementsUnifiedLockSettingsEnum unifiedLockSettings) {
        this.unifiedLockSettings = unifiedLockSettings;
        return this;
    }
    
}
