"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from enum import Enum
from typing import Optional

class GetNamesSearchEmbedEnum(str, Enum):
    r"""A flag to indicate whether to embed the corresponding 'feature' into each matching name"""
    ZERO = '0'
    ONE = '1'

class GetNamesSearchExactSpellingEnum(str, Enum):
    r"""If the 'name' parameter is specified, 'exactSpelling' specifies whether to include only names that exactly match the search text (exactSpelling=1), or whether to also include names with similar spellings (exactSpelling=0)"""
    ZERO = '0'
    ONE = '1'

class GetNamesSearchOutputFormatEnum(str, Enum):
    r"""The format of the output."""
    JSON = 'json'
    XML = 'xml'
    KML = 'kml'
    CSV = 'csv'

class GetNamesSearchOutputSrsEnum(str, Enum):
    r"""The EPSG code of the spatial reference system (SRS) to use for output geometries."""
    FOUR_THOUSAND_THREE_HUNDRED_AND_TWENTY_SIX = '4326'
    FOUR_THOUSAND_TWO_HUNDRED_AND_SIXTY_NINE = '4269'
    THREE_THOUSAND_AND_FIVE = '3005'
    THREE_THOUSAND_EIGHT_HUNDRED_AND_FIFTY_SEVEN = '3857'
    TWENTY_SIX_THOUSAND_NINE_HUNDRED_AND_SEVEN = '26907'
    TWENTY_SIX_THOUSAND_NINE_HUNDRED_AND_EIGHT = '26908'
    TWENTY_SIX_THOUSAND_NINE_HUNDRED_AND_NINE = '26909'
    TWENTY_SIX_THOUSAND_NINE_HUNDRED_AND_TEN = '26910'
    TWENTY_SIX_THOUSAND_NINE_HUNDRED_AND_ELEVEN = '26911'

class GetNamesSearchOutputStyleEnum(str, Enum):
    r"""A flag indicating whether to include with each matching name a succinct list of attributes (summary), or a comprehensive list of attributes (detail)"""
    SUMMARY = 'summary'
    DETAIL = 'detail'

class GetNamesSearchSortByEnum(str, Enum):
    r"""The distance to move the accessPoint away from the curb and towards the inside of the parcel (in metres). Ignored if locationDescriptor not set to accessPoint."""
    RELEVANCE = 'relevance'
    NAME = 'name'
    FEATURE_TYPE = 'featureType'
    DECISION_DATE = 'decisionDate'


@dataclasses.dataclass
class GetNamesSearchRequest:
    
    name: str = dataclasses.field(metadata={'query_param': { 'field_name': 'name', 'style': 'form', 'explode': True }})
    r"""A filter to search based on the the text of the name itself.  Use the asterisk (*) as a wildcard character.  For example 'vancouv*'"""  
    output_format: GetNamesSearchOutputFormatEnum = dataclasses.field(metadata={'query_param': { 'field_name': 'outputFormat', 'style': 'form', 'explode': True }})
    r"""The format of the output."""  
    embed: Optional[GetNamesSearchEmbedEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'embed', 'style': 'form', 'explode': True }})
    r"""A flag to indicate whether to embed the corresponding 'feature' into each matching name"""  
    exact_spelling: Optional[GetNamesSearchExactSpellingEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'exactSpelling', 'style': 'form', 'explode': True }})
    r"""If the 'name' parameter is specified, 'exactSpelling' specifies whether to include only names that exactly match the search text (exactSpelling=1), or whether to also include names with similar spellings (exactSpelling=0)"""  
    feature_category: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'featureCategory', 'style': 'form', 'explode': True }})
    r"""A filter to limit the search to names associated with features of a certain 'category'  The value of this parameter should be a 'featureCategoryCode' value returned by the /featureCategories resource, or an asterisk (*) to request that all feature categories be included."""  
    feature_class: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'featureClass', 'style': 'form', 'explode': True }})
    r"""A filter to limit the search to names associated with features of a certain 'class'  The value of this parameter should be a 'featureClassCode' value returned by the /featureClasses resource, or an asterisk (*) to request that all feature classes be included."""  
    feature_type: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'featureType', 'style': 'form', 'explode': True }})
    r"""A filter to limit the search to names associated with features of a certain 'type'  The value of this parameter should be a 'featureTypeCode' value returned by the /featureTypes resource, or an asterisk (*) to request that all feature types be included"""  
    items_per_page: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'itemsPerPage', 'style': 'form', 'explode': True }})
    r"""The number of search results to return (1-200)"""  
    output_srs: Optional[GetNamesSearchOutputSrsEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'outputSRS', 'style': 'form', 'explode': True }})
    r"""The EPSG code of the spatial reference system (SRS) to use for output geometries."""  
    output_style: Optional[GetNamesSearchOutputStyleEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'outputStyle', 'style': 'form', 'explode': True }})
    r"""A flag indicating whether to include with each matching name a succinct list of attributes (summary), or a comprehensive list of attributes (detail)"""  
    sort_by: Optional[GetNamesSearchSortByEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'sortBy', 'style': 'form', 'explode': True }})
    r"""The distance to move the accessPoint away from the curb and towards the inside of the parcel (in metres). Ignored if locationDescriptor not set to accessPoint."""  
    start_index: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'startIndex', 'style': 'form', 'explode': True }})
    r"""The index of the first record to be returned (>= 1)"""  
    

@dataclasses.dataclass
class GetNamesSearchResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    