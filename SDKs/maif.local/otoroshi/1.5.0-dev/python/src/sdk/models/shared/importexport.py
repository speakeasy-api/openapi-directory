"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import canary as shared_canary
from ..shared import chaosconfig as shared_chaosconfig
from ..shared import clientconfig as shared_clientconfig
from ..shared import corssettings as shared_corssettings
from ..shared import exposedapi as shared_exposedapi
from ..shared import globalconfig as shared_globalconfig
from ..shared import gzip as shared_gzip
from ..shared import healthcheck as shared_healthcheck
from ..shared import importexportstats as shared_importexportstats
from ..shared import ipfiltering as shared_ipfiltering
from ..shared import redirectionsettings as shared_redirectionsettings
from ..shared import statsdconfig as shared_statsdconfig
from ..shared import target as shared_target
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from marshmallow import fields
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExportAdmins:
    r"""Administrator using FIDO U2F device to access Otoroshi"""
    
    created_at: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdAt') }})
    r"""The creation date of the user"""  
    label: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label') }})
    r"""The label for the user"""  
    password: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password') }})
    r"""The hashed password of the user"""  
    registration: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('registration') }})
    r"""The U2F registration slug"""  
    username: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('username') }})
    r"""The email address of the user"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExportAPIKeys:
    r"""An Otoroshi Api Key. An Api Key is defined for a group of services to allow usage of the same Api Key for multiple services."""
    
    authorized_entities: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authorizedEntities') }})
    r"""The group/service ids (prefixed by group_ or service_ on which the key is authorized"""  
    client_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clientId') }})
    r"""The unique id of the Api Key. Usually 16 random alpha numerical characters, but can be anything"""  
    client_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clientName') }})
    r"""The name of the api key, for humans ;-)"""  
    client_secret: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clientSecret') }})
    r"""The secret of the Api Key. Usually 64 random alpha numerical characters, but can be anything"""  
    enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled') }})
    r"""Whether or not the key is enabled. If disabled, resources won't be available to calls using this key"""  
    daily_quota: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dailyQuota'), 'exclude': lambda f: f is None }})
    r"""Authorized number of calls per day"""  
    metadata: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metadata'), 'exclude': lambda f: f is None }})
    r"""Bunch of metadata for the key"""  
    monthly_quota: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('monthlyQuota'), 'exclude': lambda f: f is None }})
    r"""Authorized number of calls per month"""  
    throttling_quota: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('throttlingQuota'), 'exclude': lambda f: f is None }})
    r"""Authorized number of calls per second, measured on 10 seconds"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExportErrorTemplates:
    r"""Error templates for a service descriptor"""
    
    messages: dict[str, str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('messages') }})
    r"""Map for custom messages"""  
    service_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serviceId') }})
    r"""The Id of the service for which the error template is enabled"""  
    template40x: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('template40x') }})
    r"""The html template for 40x errors"""  
    template50x: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('template50x') }})
    r"""The html template for 50x errors"""  
    template_build: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('templateBuild') }})
    r"""The html template for build page"""  
    template_maintenance: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('templateMaintenance') }})
    r"""The html template for maintenance page"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExportServiceDescriptors:
    r"""An otoroshi service descriptor. Represent a forward HTTP call on a domain to another location with some optional api management mecanism"""
    
    build_mode: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('buildMode') }})
    r"""Display a construction page when a user try to use the service"""  
    domain: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('domain') }})
    r"""The domain on which the service is available."""  
    enabled: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled') }})
    r"""Activate or deactivate your service. Once disabled, users will get an error page saying the service does not exist"""  
    enforce_secure_communication: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enforceSecureCommunication') }})
    r"""When enabled, Otoroshi will try to exchange headers with downstream service to ensure no one else can use the service from outside"""  
    env: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('env') }})
    r"""The line on which the service is available. Based on that value, the name of the line will be appended to the subdomain. For line prod, nothing will be appended. For example, if the subdomain is 'foo' and line is 'preprod', then the exposed service will be available at 'foo.preprod.mydomain'"""  
    force_https: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('forceHttps') }})
    r"""Will force redirection to https:// if not present"""  
    groups: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('groups') }})
    r"""Each service descriptor is attached to groups. A group can have one or more services. Each API key is linked to a group and allow access to every service in the group"""  
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""A unique random string to identify your service"""  
    maintenance_mode: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maintenanceMode') }})
    r"""Display a maintainance page when a user try to use the service"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""The name of your service. Only for debug and human readability purposes"""  
    private_app: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('privateApp') }})
    r"""When enabled, user will be allowed to use the service (UI) only if they are registered users of the private apps domain"""  
    root: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('root') }})
    r"""Otoroshi will append this root to any target choosen. If the specified root is '/api/foo', then a request to https://yyyyyyy/bar will actually hit https://xxxxxxxxx/api/foo/bar"""  
    subdomain: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subdomain') }})
    r"""The subdomain on which the service is available"""  
    targets: list[shared_target.Target] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targets') }})
    r"""The list of target that Otoroshi will proxy and expose through the subdomain defined before. Otoroshi will do round-robin load balancing between all those targets with circuit breaker mecanism to avoid cascading failures"""  
    additional_headers: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('additionalHeaders'), 'exclude': lambda f: f is None }})
    r"""Specify headers that will be added to each client request. Useful to add authentication"""  
    api: Optional[shared_exposedapi.ExposedAPI] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('api'), 'exclude': lambda f: f is None }})
    r"""The Open API configuration for your service (if one)"""  
    auth_config_ref: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authConfigRef'), 'exclude': lambda f: f is None }})
    r"""A reference to a global auth module config"""  
    canary: Optional[shared_canary.Canary] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Canary'), 'exclude': lambda f: f is None }})
    r"""The configuration of the canary mode for a service descriptor"""  
    chaos_config: Optional[shared_chaosconfig.ChaosConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('chaosConfig'), 'exclude': lambda f: f is None }})
    r"""Configuration for the faults that can be injected in requests"""  
    client_config: Optional[shared_clientconfig.ClientConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clientConfig'), 'exclude': lambda f: f is None }})
    r"""The configuration of the circuit breaker for a service descriptor"""  
    client_validator_ref: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clientValidatorRef'), 'exclude': lambda f: f is None }})
    r"""A reference to validation authority"""  
    cors: Optional[shared_corssettings.CorsSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cors'), 'exclude': lambda f: f is None }})
    r"""The configuration for cors support"""  
    gzip: Optional[shared_gzip.Gzip] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gzip'), 'exclude': lambda f: f is None }})
    r"""Configuration for gzip of service responses"""  
    headers_verification: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('headersVerification'), 'exclude': lambda f: f is None }})
    r"""Specify headers that will be verified after routing."""  
    health_check: Optional[shared_healthcheck.HealthCheck] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('healthCheck'), 'exclude': lambda f: f is None }})
    r"""The configuration for checking health of a service. Otoroshi will perform GET call on the URL to check if the service is still alive"""  
    ip_filtering: Optional[shared_ipfiltering.IPFiltering] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipFiltering'), 'exclude': lambda f: f is None }})
    r"""The filtering configuration block for a service of globally."""  
    jwt_verifier: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('jwtVerifier'), 'exclude': lambda f: f is None }})  
    local_host: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('localHost'), 'exclude': lambda f: f is None }})
    r"""The host used localy, mainly localhost:xxxx"""  
    local_scheme: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('localScheme'), 'exclude': lambda f: f is None }})
    r"""The scheme used localy, mainly http"""  
    matching_headers: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('matchingHeaders'), 'exclude': lambda f: f is None }})
    r"""Specify headers that MUST be present on client request to route it. Useful to implement versioning"""  
    matching_root: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('matchingRoot'), 'exclude': lambda f: f is None }})
    r"""The root path on which the service is available"""  
    metadata: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metadata'), 'exclude': lambda f: f is None }})
    r"""Just a bunch of random properties"""  
    override_host: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('overrideHost'), 'exclude': lambda f: f is None }})
    r"""Host header will be overriden with Host of the target"""  
    private_patterns: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('privatePatterns'), 'exclude': lambda f: f is None }})
    r"""If you define a public pattern that is a little bit too much, you can make some of public URL private again"""  
    public_patterns: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('publicPatterns'), 'exclude': lambda f: f is None }})
    r"""By default, every services are private only and you'll need an API key to access it. However, if you want to expose a public UI, you can define one or more public patterns (regex) to allow access to anybody. For example if you want to allow anybody on any URL, just use '/.*'"""  
    redirection: Optional[shared_redirectionsettings.RedirectionSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('redirection'), 'exclude': lambda f: f is None }})
    r"""The configuration for redirection per service"""  
    redirect_to_local: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('redirectToLocal'), 'exclude': lambda f: f is None }})
    r"""If you work locally with Otoroshi, you may want to use that feature to redirect one particuliar service to a local host. For example, you can relocate https://foo.preprod.bar.com to http://localhost:8080 to make some tests"""  
    sec_com_excluded_patterns: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('secComExcludedPatterns'), 'exclude': lambda f: f is None }})
    r"""URI patterns excluded from secured communications"""  
    sec_com_settings: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('secComSettings'), 'exclude': lambda f: f is None }})  
    send_otoroshi_headers_back: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sendOtoroshiHeadersBack'), 'exclude': lambda f: f is None }})
    r"""When enabled, Otoroshi will send headers to consumer like request id, client latency, overhead, etc ..."""  
    statsd_config: Optional[shared_statsdconfig.StatsdConfig] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('statsdConfig'), 'exclude': lambda f: f is None }})
    r"""The configuration for statsd metrics push"""  
    transformer_ref: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transformerRef'), 'exclude': lambda f: f is None }})
    r"""A reference to a request transformer"""  
    user_facing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('userFacing'), 'exclude': lambda f: f is None }})
    r"""The fact that this service will be seen by users and cannot be impacted by the Snow Monkey"""  
    x_forwarded_headers: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xForwardedHeaders'), 'exclude': lambda f: f is None }})
    r"""Send X-Forwarded-* headers"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExportServiceGroups:
    r"""An Otoroshi service group is just a group of service descriptor. It is useful to be able to define Api Keys for the whole group"""
    
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})
    r"""The unique id of the group. Usually 64 random alpha numerical characters, but can be anything"""  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})
    r"""The name of the group"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""The descriptoin of the group"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExportSimpleAdmins:
    r"""Administrator using just login/password tuple to access Otoroshi"""
    
    created_at: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdAt') }})
    r"""The creation date of the user"""  
    label: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label') }})
    r"""The label for the user"""  
    password: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password') }})
    r"""The hashed password of the user"""  
    username: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('username') }})
    r"""The email address of the user"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ImportExport:
    r"""The structure that can be imported to or exported from Otoroshi. It represent the memory state of Otoroshi"""
    
    admins: list[ImportExportAdmins] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('admins') }})
    r"""Current U2F admin at the time of export"""  
    api_keys: list[ImportExportAPIKeys] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('apiKeys') }})
    r"""Current apik keys at the time of export"""  
    config: shared_globalconfig.GlobalConfig = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config') }})
    r"""The global config object of Otoroshi, used to customize settings of the current Otoroshi instance"""  
    date_: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('date'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})  
    date_raw: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRaw') }})  
    error_templates: list[ImportExportErrorTemplates] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('errorTemplates') }})
    r"""Current error templates at the time of export"""  
    label: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label') }})  
    service_descriptors: list[ImportExportServiceDescriptors] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serviceDescriptors') }})
    r"""Current service descriptors at the time of export"""  
    service_groups: list[ImportExportServiceGroups] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serviceGroups') }})
    r"""Current service groups at the time of export"""  
    simple_admins: list[ImportExportSimpleAdmins] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('simpleAdmins') }})
    r"""Current simple admins at the time of export"""  
    stats: shared_importexportstats.ImportExportStats = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('stats') }})
    r"""Global stats for the current Otoroshi instances"""  
    app_config: Optional[dict[str, str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appConfig'), 'exclude': lambda f: f is None }})
    r"""Current env variables at the time of export"""  
    