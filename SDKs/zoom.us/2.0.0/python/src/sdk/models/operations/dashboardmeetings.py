"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from datetime import date, datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclasses.dataclass
class DashboardMeetingsSecurity:
    
    o_auth: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'oauth2', 'field_name': 'Authorization' }})  
    
class DashboardMeetingsIncludeFieldsEnum(str, Enum):
    r"""Set the value of this field to \\"tracking_fields\\" if you would like to include tracking fields of each meeting in the response."""
    TRACKING_FIELDS = 'tracking_fields'

class DashboardMeetingsTypeEnum(str, Enum):
    r"""Specify a value to get the response for the corresponding meeting type. The value of this field can be one of the following:<br> <br>`past` - Meeting that already occurred in the specified date range.<br>`pastOne` - Past meetings that were attended by only one user. <br>`live` - Live meetings.<br><br>
    
    If you do not provide this field, the default value will be `live` and thus, the API will only query responses for live meetings.
    """
    PAST = 'past'
    PAST_ONE = 'pastOne'
    LIVE = 'live'


@dataclasses.dataclass
class DashboardMeetingsRequest:
    
    from_: date = dataclasses.field(metadata={'query_param': { 'field_name': 'from', 'style': 'form', 'explode': True }})
    r"""Start date in 'yyyy-mm-dd' format. The date range defined by the \\"from\\" and \\"to\\" parameters should only be one month as the report includes only one month worth of data at once."""  
    to: date = dataclasses.field(metadata={'query_param': { 'field_name': 'to', 'style': 'form', 'explode': True }})
    r"""End date."""  
    include_fields: Optional[DashboardMeetingsIncludeFieldsEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'include_fields', 'style': 'form', 'explode': True }})
    r"""Set the value of this field to \\"tracking_fields\\" if you would like to include tracking fields of each meeting in the response."""  
    next_page_token: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'next_page_token', 'style': 'form', 'explode': True }})
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_size: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': True }})
    r"""The number of records returned within a single API call."""  
    type: Optional[DashboardMeetingsTypeEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'type', 'style': 'form', 'explode': True }})
    r"""Specify a value to get the response for the corresponding meeting type. The value of this field can be one of the following:<br> <br>`past` - Meeting that already occurred in the specified date range.<br>`pastOne` - Past meetings that were attended by only one user. <br>`live` - Live meetings.<br><br>
    
    If you do not provide this field, the default value will be `live` and thus, the API will only query responses for live meetings.
    """  
    

@dataclasses.dataclass
class DashboardMeetings200ApplicationXMLMetricsCustomKeys:
    
    key: Optional[str] = dataclasses.field(default=None)
    r"""Custom key associated with the meeting."""  
    value: Optional[str] = dataclasses.field(default=None)
    r"""Value of the custom key associated with the meeting."""  
    

@dataclasses.dataclass
class DashboardMeetings200ApplicationXMLMetricsTrackingFields:
    
    field: Optional[str] = dataclasses.field(default=None)
    r"""Label of the tracking field."""  
    value: Optional[str] = dataclasses.field(default=None)
    r"""Value of the tracking field."""  
    

@dataclasses.dataclass
class DashboardMeetings200ApplicationXMLMetrics:
    r"""Meeting metric details."""
    
    custom_keys: Optional[list[DashboardMeetings200ApplicationXMLMetricsCustomKeys]] = dataclasses.field(default=None)
    r"""Custom keys and values assigned to the meeting."""  
    dept: Optional[str] = dataclasses.field(default=None)
    r"""Department of the host."""  
    duration: Optional[str] = dataclasses.field(default=None)
    r"""Meeting duration. Formatted as hh:mm:ss, for example: `16:08` for 16 minutes and 8 seconds."""  
    email: Optional[str] = dataclasses.field(default=None)
    r"""Email address of the host."""  
    end_time: Optional[datetime] = dataclasses.field(default=None)
    r"""Meeting end time."""  
    has_3rd_party_audio: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not [third party audio](https://support.zoom.us/hc/en-us/articles/202470795-3rd-Party-Audio-Conference) was used in the meeting."""  
    has_pstn: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not the PSTN was used in the meeting."""  
    has_recording: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not the recording feature was used in the meeting."""  
    has_screen_share: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not screenshare feature was used in the meeting."""  
    has_sip: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not someone joined the meeting using SIP."""  
    has_video: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not video was used in the meeting."""  
    has_voip: Optional[bool] = dataclasses.field(default=None)
    r"""Indicates whether or not VoIP was used in the meeting."""  
    host: Optional[str] = dataclasses.field(default=None)
    r"""Host display name."""  
    id: Optional[int] = dataclasses.field(default=None)
    r"""[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in \\"**long**\\" format(represented as int64 data type in JSON), also known as the meeting number."""  
    in_room_participants: Optional[int] = dataclasses.field(default=None)
    r"""The number of Zoom Room participants in the meeting."""  
    participants: Optional[int] = dataclasses.field(default=None)
    r"""Meeting participant count."""  
    start_time: Optional[datetime] = dataclasses.field(default=None)
    r"""Meeting start time."""  
    topic: Optional[str] = dataclasses.field(default=None)
    r"""Meeting topic."""  
    tracking_fields: Optional[list[DashboardMeetings200ApplicationXMLMetricsTrackingFields]] = dataclasses.field(default=None)
    r"""Tracking fields and values assigned to the meeting."""  
    user_type: Optional[str] = dataclasses.field(default=None)
    r"""License type of the user."""  
    uuid: Optional[str] = dataclasses.field(default=None)
    r"""Meeting UUID. Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it."""  
    

@dataclasses.dataclass
class DashboardMeetings200ApplicationXML:
    r"""Pagination object."""
    
    from_: Optional[date] = dataclasses.field(default=None)
    r"""Start date for this report in 'yyyy-mm-dd' format."""  
    meetings: Optional[list[DashboardMeetings200ApplicationXMLMetrics]] = dataclasses.field(default=None)
    r"""Array of meeting objects."""  
    next_page_token: Optional[str] = dataclasses.field(default=None)
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_count: Optional[int] = dataclasses.field(default=None)
    r"""The number of pages returned for the request made."""  
    page_size: Optional[int] = dataclasses.field(default=None)
    r"""The number of records returned within a single API call."""  
    to: Optional[date] = dataclasses.field(default=None)
    r"""End date for this report in 'yyyy-mm-dd' format."""  
    total_records: Optional[int] = dataclasses.field(default=None)
    r"""The number of all records available across pages."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DashboardMeetings200ApplicationJSONMetricsCustomKeys:
    
    key: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('key'), 'exclude': lambda f: f is None }})
    r"""Custom key associated with the meeting."""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""Value of the custom key associated with the meeting."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DashboardMeetings200ApplicationJSONMetricsTrackingFields:
    
    field: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('field'), 'exclude': lambda f: f is None }})
    r"""Label of the tracking field."""  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""Value of the tracking field."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DashboardMeetings200ApplicationJSONMetrics:
    r"""Meeting metric details."""
    
    custom_keys: Optional[list[DashboardMeetings200ApplicationJSONMetricsCustomKeys]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom_keys'), 'exclude': lambda f: f is None }})
    r"""Custom keys and values assigned to the meeting."""  
    dept: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dept'), 'exclude': lambda f: f is None }})
    r"""Department of the host."""  
    duration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('duration'), 'exclude': lambda f: f is None }})
    r"""Meeting duration. Formatted as hh:mm:ss, for example: `16:08` for 16 minutes and 8 seconds."""  
    email: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('email'), 'exclude': lambda f: f is None }})
    r"""Email address of the host."""  
    end_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('end_time'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Meeting end time."""  
    has_3rd_party_audio: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_3rd_party_audio'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not [third party audio](https://support.zoom.us/hc/en-us/articles/202470795-3rd-Party-Audio-Conference) was used in the meeting."""  
    has_pstn: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_pstn'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not the PSTN was used in the meeting."""  
    has_recording: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_recording'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not the recording feature was used in the meeting."""  
    has_screen_share: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_screen_share'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not screenshare feature was used in the meeting."""  
    has_sip: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_sip'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not someone joined the meeting using SIP."""  
    has_video: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_video'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not video was used in the meeting."""  
    has_voip: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_voip'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not VoIP was used in the meeting."""  
    host: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host'), 'exclude': lambda f: f is None }})
    r"""Host display name."""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""[Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in \\"**long**\\" format(represented as int64 data type in JSON), also known as the meeting number."""  
    in_room_participants: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('in_room_participants'), 'exclude': lambda f: f is None }})
    r"""The number of Zoom Room participants in the meeting."""  
    participants: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('participants'), 'exclude': lambda f: f is None }})
    r"""Meeting participant count."""  
    start_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('start_time'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Meeting start time."""  
    topic: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('topic'), 'exclude': lambda f: f is None }})
    r"""Meeting topic."""  
    tracking_fields: Optional[list[DashboardMeetings200ApplicationJSONMetricsTrackingFields]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tracking_fields'), 'exclude': lambda f: f is None }})
    r"""Tracking fields and values assigned to the meeting."""  
    user_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user_type'), 'exclude': lambda f: f is None }})
    r"""License type of the user."""  
    uuid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uuid'), 'exclude': lambda f: f is None }})
    r"""Meeting UUID. Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class DashboardMeetings200ApplicationJSON:
    r"""Pagination object."""
    
    from_: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Start date for this report in 'yyyy-mm-dd' format."""  
    meetings: Optional[list[DashboardMeetings200ApplicationJSONMetrics]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meetings'), 'exclude': lambda f: f is None }})
    r"""Array of meeting objects."""  
    next_page_token: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('next_page_token'), 'exclude': lambda f: f is None }})
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('page_count'), 'exclude': lambda f: f is None }})
    r"""The number of pages returned for the request made."""  
    page_size: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('page_size'), 'exclude': lambda f: f is None }})
    r"""The number of records returned within a single API call."""  
    to: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""End date for this report in 'yyyy-mm-dd' format."""  
    total_records: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total_records'), 'exclude': lambda f: f is None }})
    r"""The number of all records available across pages."""  
    

@dataclasses.dataclass
class DashboardMeetingsResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    body: Optional[bytes] = dataclasses.field(default=None)  
    dashboard_meetings_200_application_json_object: Optional[DashboardMeetings200ApplicationJSON] = dataclasses.field(default=None)
    r"""**HTTP Status Code:** `200`<br>
    Meetings returned.<br>
    Only available for paid accounts that have dashboard feature enabled.
    """  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    