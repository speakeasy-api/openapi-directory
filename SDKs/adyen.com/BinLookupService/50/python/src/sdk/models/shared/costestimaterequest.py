"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import amount as shared_amount
from ..shared import costestimateassumptions as shared_costestimateassumptions
from ..shared import merchantdetails as shared_merchantdetails
from ..shared import recurring as shared_recurring
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class CostEstimateRequestShopperInteractionEnum(str, Enum):
    r"""Specifies the sales channel, through which the shopper gives their card details, and whether the shopper is a returning customer.
    For the web service API, Adyen assumes Ecommerce shopper interaction by default.
    
    This field has the following possible values:
    * `Ecommerce` - Online transactions where the cardholder is present (online). For better authorisation rates, we recommend sending the card security code (CSC) along with the request.
    * `ContAuth` - Card on file and/or subscription transactions, where the card holder is known to the merchant (returning customer). If the shopper is present (online), you can supply also the CSC to improve authorisation (one-click payment).
    * `Moto` - Mail-order and telephone-order transactions where the shopper is in contact with the merchant via email or telephone.
    * `POS` - Point-of-sale transactions where the shopper is physically present to make a payment using a secure payment terminal.
    """
    ECOMMERCE = 'Ecommerce'
    CONT_AUTH = 'ContAuth'
    MOTO = 'Moto'
    POS = 'POS'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CostEstimateRequest:
    
    amount: shared_amount.Amount = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount') }})  
    merchant_account: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('merchantAccount') }})
    r"""The merchant account identifier you want to process the (transaction) request with."""  
    assumptions: Optional[shared_costestimateassumptions.CostEstimateAssumptions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('assumptions'), 'exclude': lambda f: f is None }})  
    card_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cardNumber'), 'exclude': lambda f: f is None }})
    r"""The card number (4-19 characters) for PCI compliant use cases. Do not use any separators.
    
    > Either the `cardNumber` or `encryptedCardNumber` field must be provided in a payment request.
    """  
    encrypted_card_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryptedCardNumber'), 'exclude': lambda f: f is None }})
    r"""Encrypted data that stores card information for non PCI-compliant use cases. The encrypted data must be created with the Checkout Card Component or Secured Fields Component, and must contain the `encryptedCardNumber` field.
    
    > Either the `cardNumber` or `encryptedCardNumber` field must be provided in a payment request.
    """  
    merchant_details: Optional[shared_merchantdetails.MerchantDetails] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('merchantDetails'), 'exclude': lambda f: f is None }})  
    recurring: Optional[shared_recurring.Recurring] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recurring'), 'exclude': lambda f: f is None }})  
    selected_recurring_detail_reference: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selectedRecurringDetailReference'), 'exclude': lambda f: f is None }})
    r"""The `recurringDetailReference` you want to use for this cost estimate. The value `LATEST` can be used to select the most recently stored recurring detail."""  
    shopper_interaction: Optional[CostEstimateRequestShopperInteractionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('shopperInteraction'), 'exclude': lambda f: f is None }})
    r"""Specifies the sales channel, through which the shopper gives their card details, and whether the shopper is a returning customer.
    For the web service API, Adyen assumes Ecommerce shopper interaction by default.
    
    This field has the following possible values:
    * `Ecommerce` - Online transactions where the cardholder is present (online). For better authorisation rates, we recommend sending the card security code (CSC) along with the request.
    * `ContAuth` - Card on file and/or subscription transactions, where the card holder is known to the merchant (returning customer). If the shopper is present (online), you can supply also the CSC to improve authorisation (one-click payment).
    * `Moto` - Mail-order and telephone-order transactions where the shopper is in contact with the merchant via email or telephone.
    * `POS` - Point-of-sale transactions where the shopper is physically present to make a payment using a secure payment terminal.
    """  
    shopper_reference: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('shopperReference'), 'exclude': lambda f: f is None }})
    r"""Required for recurring payments.
    Your reference to uniquely identify this shopper, for example user ID or account ID. Minimum length: 3 characters.
    > Your reference must not include personally identifiable information (PII), for example name or email address.
    """  
    