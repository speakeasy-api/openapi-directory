// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type MessageStatusLinksWorkflow struct {
	DispatchUUID *string `json:"dispatch_uuid,omitempty"`
	// Please note GET is not currently supported
	Href *string `json:"href,omitempty"`
}

type MessageStatusLinks struct {
	Workflow *MessageStatusLinksWorkflow `json:"workflow,omitempty"`
}

type MessageStatusError struct {
	// The error code. See [our errors list](/api-errors/messages-olympus) for a list of possible errors
	Code *int64 `json:"code,omitempty"`
	// Text describing the error. See [our errors list](/api-errors/messages-olympus) for a list of possible errors
	Reason *string `json:"reason,omitempty"`
}

// MessageStatusStatusEnum - The status of the message.
type MessageStatusStatusEnum string

const (
	MessageStatusStatusEnumSubmitted     MessageStatusStatusEnum = "submitted"
	MessageStatusStatusEnumDelivered     MessageStatusStatusEnum = "delivered"
	MessageStatusStatusEnumRead          MessageStatusStatusEnum = "read"
	MessageStatusStatusEnumRejected      MessageStatusStatusEnum = "rejected"
	MessageStatusStatusEnumUndeliverable MessageStatusStatusEnum = "undeliverable"
)

func (e MessageStatusStatusEnum) ToPointer() *MessageStatusStatusEnum {
	return &e
}

func (e *MessageStatusStatusEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "submitted":
		fallthrough
	case "delivered":
		fallthrough
	case "read":
		fallthrough
	case "rejected":
		fallthrough
	case "undeliverable":
		*e = MessageStatusStatusEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageStatusStatusEnum: %v", v)
	}
}

// MessageStatusUsageCurrencyEnum - The charge currency in ISO 4217 format.
type MessageStatusUsageCurrencyEnum string

const (
	MessageStatusUsageCurrencyEnumEur MessageStatusUsageCurrencyEnum = "EUR"
)

func (e MessageStatusUsageCurrencyEnum) ToPointer() *MessageStatusUsageCurrencyEnum {
	return &e
}

func (e *MessageStatusUsageCurrencyEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EUR":
		*e = MessageStatusUsageCurrencyEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageStatusUsageCurrencyEnum: %v", v)
	}
}

type MessageStatusUsage struct {
	// The charge currency in ISO 4217 format.
	Currency *MessageStatusUsageCurrencyEnum `json:"currency,omitempty"`
	// The charge amount as a stringified number.
	Price *string `json:"price,omitempty"`
}

// MessageStatus - The callbacks for the message status are the same as defined in the Messaging API. The only difference will be that dispatch_uuid and link will be appended.
type MessageStatus struct {
	Links       *MessageStatusLinks `json:"_links,omitempty"`
	Error       *MessageStatusError `json:"error,omitempty"`
	From        *FromProperty       `json:"from,omitempty"`
	MessageUUID *string             `json:"message_uuid,omitempty"`
	// The status of the message.
	Status *MessageStatusStatusEnum `json:"status,omitempty"`
	// The datetime of when the event occurred.
	Timestamp *string             `json:"timestamp,omitempty"`
	To        *ToProperty         `json:"to,omitempty"`
	Usage     *MessageStatusUsage `json:"usage,omitempty"`
}
