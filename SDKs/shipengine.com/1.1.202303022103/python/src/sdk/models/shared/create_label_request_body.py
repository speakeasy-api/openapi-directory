"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import advanced_shipment_options as shared_advanced_shipment_options
from ..shared import customs_item as shared_customs_item
from ..shared import label_charge_event_enum as shared_label_charge_event_enum
from ..shared import order_source_name_enum as shared_order_source_name_enum
from ..shared import package as shared_package
from ..shared import shipment_item as shared_shipment_item
from ..shared import shipping_address as shared_shipping_address
from ..shared import tax_identifier as shared_tax_identifier
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class CreateLabelRequestBodyDisplaySchemeEnum(str, Enum):
    r"""The display format that the label should be shown in."""
    LABEL = 'label'
    QR_CODE = 'qr_code'
    LABEL_AND_QR_CODE = 'label_and_qr_code'

class CreateLabelRequestBodyLabelDownloadTypeEnum(str, Enum):
    r"""There are two different ways to [download a label](https://www.shipengine.com/docs/labels/downloading/):
    
    |Label Download Type | Description
    |--------------------|------------------------------
    |`url`               |You will receive a URL, which you can use to download the label in a separate request. The URL will remain valid for 90 days.<br><br>This is the default if `label_download_type` is unspecified.
    |`inline`            |You will receive the Base64-encoded label as part of the response. No need for a second request to download the label.
    """
    URL = 'url'
    INLINE = 'inline'

class CreateLabelRequestBodyLabelFormatEnum(str, Enum):
    r"""The possible file formats in which shipping labels can be downloaded.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats.
    
    |Label Format  | Supported Carriers
    |--------------|-----------------------------------
    |`pdf`         | All carriers
    |`png`         | `fedex` <br> `stamps_com` <br> `ups` <br> `usps`
    |`zpl`         | `access_worldwide` <br> `apc` <br> `asendia` <br> `dhl_global_mail` <br> `dhl_express` <br> `dhl_express_australia` <br> `dhl_express_canada` <br> `dhl_express_worldwide` <br> `dhl_express_uk` <br> `dpd` <br> `endicia` <br> `fedex` <br> `fedex_uk` <br> `firstmile` <br> `imex` <br> `newgistics` <br> `ontrac` <br> `rr_donnelley` <br> `stamps_com` <br> `ups` <br> `usps`
    """
    PDF = 'pdf'
    PNG = 'png'
    ZPL = 'zpl'

class CreateLabelRequestBodyLabelLayoutEnum(str, Enum):
    r"""The available layouts (sizes) in which shipping labels can be downloaded.  The label format determines which sizes are supported.  `4x6` is supported for all label formats, whereas `letter` (8.5\\" x 11\\") is only supported for `pdf` format."""
    FOURX6 = '4x6'
    LETTER = 'letter'

class CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum(str, Enum):
    r"""The possible delivery confirmation values"""
    NONE = 'none'
    DELIVERY = 'delivery'
    SIGNATURE = 'signature'
    ADULT_SIGNATURE = 'adult_signature'
    DIRECT_SIGNATURE = 'direct_signature'
    DELIVERY_MAILED = 'delivery_mailed'
    VERBAL_CONFIRMATION = 'verbal_confirmation'

class CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum(str, Enum):
    r"""The possible package contents values"""
    MERCHANDISE = 'merchandise'
    DOCUMENTS = 'documents'
    GIFT = 'gift'
    RETURNED_GOODS = 'returned_goods'
    SAMPLE = 'sample'

class CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum(str, Enum):
    r"""The possible non delivery values"""
    RETURN_TO_SENDER = 'return_to_sender'
    TREAT_AS_ABANDONED = 'treat_as_abandoned'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsInput:
    r"""Options for international shipments, such as customs declarations."""
    
    contents: CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsPackageContentsEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('contents') }})
    r"""The type of contents in this shipment.  This may impact import duties or customs treatment."""  
    non_delivery: CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsNonDeliveryEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('non_delivery') }})
    r"""Indicates what to do if a package is unable to be delivered."""  
    customs_items: Optional[list[shared_customs_item.CustomsItemInput]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customs_items'), 'exclude': lambda f: f is None }})
    r"""Customs declarations for each item in the shipment."""  
    
class CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum(str, Enum):
    r"""The possible insurance provider values"""
    NONE = 'none'
    SHIPSURANCE = 'shipsurance'
    CARRIER = 'carrier'
    THIRD_PARTY = 'third_party'

class CreateLabelRequestBodyPartialShipmentOriginTypeEnum(str, Enum):
    r"""Indicates if the package will be picked up or dropped off by the carrier"""
    PICKUP = 'pickup'
    DROP_OFF = 'drop_off'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateLabelRequestBodyPartialShipmentInput:
    r"""The information necessary to ship a package, such as the origin, the destination, the carrier service, and the package dimensions and weight."""
    
    advanced_options: shared_advanced_shipment_options.AdvancedShipmentOptions = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('advanced_options') }})
    r"""Advanced shipment options.  These are entirely optional."""  
    carrier_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('carrier_id') }})
    r"""The carrier account that is billed for the shipping charges"""  
    confirmation: CreateLabelRequestBodyPartialShipmentDeliveryConfirmationEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmation') }})
    r"""The type of delivery confirmation that is required for this shipment."""  
    customs: CreateLabelRequestBodyPartialShipmentInternationalShipmentOptionsInput = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customs') }})
    r"""Customs information.  This is usually only needed for international shipments."""  
    insurance_provider: CreateLabelRequestBodyPartialShipmentInsuranceProviderEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('insurance_provider') }})
    r"""The insurance provider to use for any insured packages in the shipment."""  
    packages: list[shared_package.PackageInput] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('packages') }})
    r"""The packages in the shipment.
    
    > **Note:** Some carriers only allow one package per shipment.  If you attempt to create a multi-package shipment for a carrier that doesn't allow it, an error will be returned.
    """  
    return_to: shared_shipping_address.ShippingAddress = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('return_to') }})
    r"""The return address for this shipment.  Defaults to the `ship_from` address."""  
    service_code: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('service_code') }})
    r"""The [carrier service](https://www.shipengine.com/docs/shipping/use-a-carrier-service/) used to ship the package, such as `fedex_ground`, `usps_first_class_mail`, `flat_rate_envelope`, etc."""  
    ship_date: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ship_date'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})
    r"""The date that the shipment was (or will be) shippped.  ShipEngine will take the day of week into consideration. For example, if the carrier does not operate on Sundays, then a package that would have shipped on Sunday will ship on Monday instead."""  
    ship_from: shared_shipping_address.ShippingAddress = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ship_from') }})
    r"""The shipment's origin address. If you frequently ship from the same location, consider [creating a warehouse](https://www.shipengine.com/docs/reference/create-warehouse/).  Then you can simply specify the `warehouse_id` rather than the complete address each time."""  
    ship_to: shared_shipping_address.ShippingAddress = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ship_to') }})
    r"""The recipient's mailing address"""  
    warehouse_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('warehouse_id') }})
    r"""The [warehouse](https://www.shipengine.com/docs/shipping/ship-from-a-warehouse/) that the shipment is being shipped from.  Either `warehouse_id` or `ship_from` must be specified."""  
    external_order_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('external_order_id'), 'exclude': lambda f: f is None }})
    r"""ID that the Order Source assigned"""  
    external_shipment_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('external_shipment_id'), 'exclude': lambda f: f is None }})
    r"""A unique user-defined key to identify a shipment.  This can be used to retrieve the shipment.
    
    > **Warning:** The `external_shipment_id` is limited to 50 characters. Any additional characters will be truncated.
    """  
    items: Optional[list[shared_shipment_item.ShipmentItem]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('items'), 'exclude': lambda f: f is None }})
    r"""Describe the packages included in this shipment as related to potential metadata that was imported from
    external order sources
    """  
    order_source_code: Optional[shared_order_source_name_enum.OrderSourceNameEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('order_source_code'), 'exclude': lambda f: f is None }})  
    origin_type: Optional[CreateLabelRequestBodyPartialShipmentOriginTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('origin_type'), 'exclude': lambda f: f is None }})
    r"""Indicates if the package will be picked up or dropped off by the carrier"""  
    shipment_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('shipment_number'), 'exclude': lambda f: f is None }})
    r"""A non-unique user-defined number used to identify a shipment.  If undefined, this will match the external_shipment_id of the shipment.
    
    > **Warning:** The `shipment_number` is limited to 50 characters. Any additional characters will be truncated.
    """  
    tax_identifiers: Optional[list[shared_tax_identifier.TaxIdentifier]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tax_identifiers'), 'exclude': lambda f: f is None }})  
    
class CreateLabelRequestBodyValidateAddressEnum(str, Enum):
    r"""The possible validate address values"""
    NO_VALIDATION = 'no_validation'
    VALIDATE_ONLY = 'validate_only'
    VALIDATE_AND_CLEAN = 'validate_and_clean'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateLabelRequestBodyInput:
    r"""A label represents the physical sticker that you affix to a package to ship it.  ShipEngine makes it easy for you to [create labels](https://www.shipengine.com/docs/labels/create-a-label/) and then download them in PDF, PNG, or ZPL format so you can print them."""
    
    shipment: CreateLabelRequestBodyPartialShipmentInput = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('shipment') }})
    r"""The shipment information used to generate the label"""  
    charge_event: Optional[shared_label_charge_event_enum.LabelChargeEventEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('charge_event'), 'exclude': lambda f: f is None }})
    r"""The label charge event."""  
    display_scheme: Optional[CreateLabelRequestBodyDisplaySchemeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('display_scheme'), 'exclude': lambda f: f is None }})
    r"""The display format that the label should be shown in."""  
    is_return_label: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_return_label'), 'exclude': lambda f: f is None }})
    r"""Indicates whether this is a return label.  You may also want to set the `rma_number` so you know what is being returned."""  
    label_download_type: Optional[CreateLabelRequestBodyLabelDownloadTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label_download_type'), 'exclude': lambda f: f is None }})  
    label_format: Optional[CreateLabelRequestBodyLabelFormatEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label_format'), 'exclude': lambda f: f is None }})
    r"""The file format that you want the label to be in.  We recommend `pdf` format because it is supported by all carriers, whereas some carriers do not support the `png` or `zpl` formats."""  
    label_image_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label_image_id'), 'exclude': lambda f: f is None }})
    r"""The label image resource that was used to create a custom label image."""  
    label_layout: Optional[CreateLabelRequestBodyLabelLayoutEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label_layout'), 'exclude': lambda f: f is None }})
    r"""The layout (size) that you want the label to be in.  The `label_format` determines which sizes are allowed.  `4x6` is supported for all label formats, whereas `letter` (8.5\\" x 11\\") is only supported for `pdf` format."""  
    outbound_label_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outbound_label_id'), 'exclude': lambda f: f is None }})
    r"""The `label_id` of the original (outgoing) label that the return label is for. This associates the two labels together, which is
    required by some carriers.
    """  
    rma_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('rma_number'), 'exclude': lambda f: f is None }})
    r"""An optional Return Merchandise Authorization number.  This field is useful for return labels.  You can set it to any string value."""  
    ship_from_service_point_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ship_from_service_point_id'), 'exclude': lambda f: f is None }})
    r"""A unique identifier for a carrier drop off point where a merchant plans to deliver packages. This will take precedence over a shipment's ship from address."""  
    ship_to_service_point_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ship_to_service_point_id'), 'exclude': lambda f: f is None }})
    r"""A unique identifier for a carrier service point where the shipment will be delivered by the carrier. This will take precedence over a shipment's ship to address."""  
    test_label: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('test_label'), 'exclude': lambda f: f is None }})
    r"""Indicate if this label is being used only for testing purposes. If true, then no charge will be added to your account."""  
    validate_address: Optional[CreateLabelRequestBodyValidateAddressEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('validate_address'), 'exclude': lambda f: f is None }})  
    