/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Retrieve and update user data.
 */
export class Users {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Change email address
   *
   * @remarks
   * Change the users' current email address.  A verification link will be emailed to the new email address to verify that the email account belongs to the user.  The email change will not take effect until the user clicks the link in the verification email.
   *
   */
  changeEmail(
    req: operations.ChangeEmailRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.ChangeEmailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ChangeEmailRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/email";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ChangeEmailResponse =
        new operations.ChangeEmailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Create an email alert
   */
  createAlert(
    req: operations.CreateAlertRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAlertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateAlertRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/alerts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateAlertResponse =
        new operations.CreateAlertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alert = utils.objectToClass(httpRes?.data, shared.Alert);
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Delete an email alert
   */
  deleteAlert(
    req: operations.DeleteAlertRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteAlertResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteAlertRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/me/alerts/{alert_id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteAlertResponse =
        new operations.DeleteAlertResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 403, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List current users' email alerts
   */
  getAlerts(
    config?: AxiosRequestConfig
  ): Promise<operations.GetAlertsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/alerts";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetAlertsResponse =
        new operations.GetAlertsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alerts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.alerts = utils.objectToClass(
              httpRes?.data,
              shared.Alert,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve current user
   */
  getCurrentUser(
    config?: AxiosRequestConfig
  ): Promise<operations.GetCurrentUserResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCurrentUserResponse =
        new operations.GetCurrentUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.currentUser = utils.objectToClass(
              httpRes?.data,
              shared.CurrentUser
            );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * List current users' groups
   */
  getCurrentUserGroups(
    req: operations.GetCurrentUserGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCurrentUserGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCurrentUserGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/groups";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCurrentUserGroupsResponse =
        new operations.GetCurrentUserGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groups = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groups = utils.objectToClass(
              httpRes?.data,
              shared.Group,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * List current users' posts
   *
   * @remarks
   * NOTE: In order to make it easier to see all a users&#39; posts, the current users&#39; location preferences are not applied when listing or searching posts from a single user.  If location based filtering of the posts is needed, the latitude, longitude and radius parameters may be used.
   *
   */
  getCurrentUserPosts(
    req: operations.GetCurrentUserPostsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCurrentUserPostsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCurrentUserPostsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/posts";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCurrentUserPostsResponse =
        new operations.GetCurrentUserPostsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCurrentUserPosts200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetCurrentUserPosts200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * List current users' post locations
   *
   * @remarks
   * Only the most recent 3 post locations are returned.
   */
  getPostLocations(
    config?: AxiosRequestConfig
  ): Promise<operations.GetPostLocationsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/post-locations";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPostLocationsResponse =
        new operations.GetPostLocationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getPostLocations200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getPostLocations200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.GetPostLocations200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a users' profile image
   *
   * @remarks
   * This is designed to be used as the src attribute of an HTML &lt;img&gt; tag to show the profile image of the given user.
   *
   */
  getProfileImageFile(
    req: operations.GetProfileImageFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProfileImageFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProfileImageFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{user_id}/profile-image",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProfileImageFileResponse =
        new operations.GetProfileImageFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [302, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * List current users' profile images
   */
  getProfileImages(
    config?: AxiosRequestConfig
  ): Promise<operations.GetProfileImagesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/profile-images";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProfileImagesResponse =
        new operations.GetProfileImagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProfileImages200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getProfileImages200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.GetProfileImages200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a user
   */
  getUser(
    req: operations.GetUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/users/{user_id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserResponse = new operations.GetUserResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.user = utils.objectToClass(httpRes?.data, shared.User);
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve user display info
   *
   * @remarks
   * Retrieve a user and information related to the user (eg. recent posts) that is useful for displaying a more detailed view of the user.
   *
   */
  getUserAndRelatedData(
    req: operations.GetUserAndRelatedDataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserAndRelatedDataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserAndRelatedDataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{user_id}/display",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserAndRelatedDataResponse =
        new operations.GetUserAndRelatedDataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUserAndRelatedData200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetUserAndRelatedData200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 404:
          break;
      }

      return res;
    });
  }

  /**
   * List current users' group notices
   */
  getUserGroupNotices(
    req: operations.GetUserGroupNoticesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserGroupNoticesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserGroupNoticesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/notices";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserGroupNoticesResponse =
        new operations.GetUserGroupNoticesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupNotices = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groupNotices = utils.objectToClass(
              httpRes?.data,
              shared.GroupNotice,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * List posts by a user
   *
   * @remarks
   * NOTE: In order to make it easier to see all a users&#39; posts, the current users&#39; location preferences are not applied when listing or searching posts from a single user.  If location based filtering of the posts is needed, the latitude, longitude and radius parameters may be used.
   *
   */
  getUserPosts(
    req: operations.GetUserPostsRequest,
    security: operations.GetUserPostsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserPostsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserPostsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{user_id}/posts",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetUserPostsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserPostsResponse =
        new operations.GetUserPostsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUserPosts200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetUserPosts200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Remove feedback on a user
   *
   * @remarks
   * Allows the current user to remove feedback that they left on a user.
   *
   */
  removeUserFeedback(
    req: operations.RemoveUserFeedbackRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveUserFeedbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveUserFeedbackRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{user_id}/feedback",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveUserFeedbackResponse =
        new operations.RemoveUserFeedbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.removeUserFeedback200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RemoveUserFeedback200ApplicationJSON
              );
          }
          break;
        case [400, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Report a user
   */
  reportUser(
    req: operations.ReportUserRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.ReportUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ReportUserRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/report";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ReportUserResponse =
        new operations.ReportUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Resend account verification email
   */
  resendAccountVerificationEmail(
    config?: AxiosRequestConfig
  ): Promise<operations.ResendAccountVerificationEmailResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/users/me/resend-verification";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ResendAccountVerificationEmailResponse =
        new operations.ResendAccountVerificationEmailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 400].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Save a post location for the current user
   *
   * @remarks
   * Creates or updates a post location for the current user. Updates will happen when the name of the post location matches a previous post location.
   *
   */
  savePostLocation(
    req: operations.SavePostLocationRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.SavePostLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SavePostLocationRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/post-locations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SavePostLocationResponse =
        new operations.SavePostLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.savePostLocation200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.savePostLocation200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.SavePostLocation200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search current users' posts
   *
   * @remarks
   * Searching posts takes the same arguments as listing posts except for the addition of the search and sort_by parameters.
   *
   */
  searchCurrentUserPosts(
    req: operations.SearchCurrentUserPostsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchCurrentUserPostsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SearchCurrentUserPostsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/posts/search";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchCurrentUserPostsResponse =
        new operations.SearchCurrentUserPostsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.searchCurrentUserPosts200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SearchCurrentUserPosts200ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Search posts by a user
   *
   * @remarks
   * Searching posts takes the same arguments as listing posts except for the addition of the search and sort_by parameters.
   *
   */
  searchUserPosts(
    req: operations.SearchUserPostsRequest,
    security: operations.SearchUserPostsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchUserPostsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SearchUserPostsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{user_id}/posts/search",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SearchUserPostsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchUserPostsResponse =
        new operations.SearchUserPostsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.searchUserPosts200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SearchUserPosts200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Send password reset email
   */
  sendPasswordResetEmail(
    config?: AxiosRequestConfig
  ): Promise<operations.SendPasswordResetEmailResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/reset-password";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SendPasswordResetEmailResponse =
        new operations.SendPasswordResetEmailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Set users' email address as not bouncing
   *
   * @remarks
   * Resets an email address bouncing state to false.  The users' email address may be automatically marked as bouncing again if further emails sent to it are bounced.
   *
   */
  setEmailNotBouncing(
    config?: AxiosRequestConfig
  ): Promise<operations.SetEmailNotBouncingResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/users/me/email/not-bouncing";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SetEmailNotBouncingResponse =
        new operations.SetEmailNotBouncingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.currentUser = utils.objectToClass(
              httpRes?.data,
              shared.CurrentUser
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Set a profile image
   *
   * @remarks
   * Profile images must be at least 90 pixels wide and tall.  And if the image used is not square it will be automatically cropped to be square.
   *
   */
  setProfileImage(
    req: operations.SetProfileImageRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.SetProfileImageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SetProfileImageRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/profile-image";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SetProfileImageResponse =
        new operations.SetProfileImageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.setProfileImage200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.SetProfileImage200ApplicationJSON
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Submit feedback on a user
   *
   * @remarks
   * Allows the current user to submit feedback on a user.  The current user can only leave feedback on a user if the feedback allowed property on that user is set to true (see User definition for more details). And the system will only store the most recent feedback submission that the current user has submitted on a user. If the current user submits feedback multiple times, the newest feedback will overwrite the older feedback. This allows users to update their feedback as long as the feedback allowed property allows it.
   *
   */
  submitUserFeedback(
    req: operations.SubmitUserFeedbackRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SubmitUserFeedbackResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SubmitUserFeedbackRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{user_id}/feedback",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SubmitUserFeedbackResponse =
        new operations.SubmitUserFeedbackResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.submitUserFeedback200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.SubmitUserFeedback200ApplicationJSON
              );
          }
          break;
        case [400, 404].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Update current user
   *
   * @remarks
   * Update the current user.  All fields are optional so requests can update just one or multiple user properties at a time.
   *
   */
  updateCurrentUser(
    req: operations.UpdateCurrentUserRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCurrentUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCurrentUserRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCurrentUserResponse =
        new operations.UpdateCurrentUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.currentUser = utils.objectToClass(
              httpRes?.data,
              shared.CurrentUser
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }

  /**
   * Update location
   *
   * @remarks
   * Update the current users' location. The location is used to determine which posts are shown to the user (both public posts and group posts).
   *
   */
  updateLocation(
    req: operations.UpdateLocationRequestBody,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateLocationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateLocationRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/users/me/location";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateLocationResponse =
        new operations.UpdateLocationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.currentUser = utils.objectToClass(
              httpRes?.data,
              shared.CurrentUser
            );
          }
          break;
        case httpRes?.status == 400:
          break;
      }

      return res;
    });
  }
}
