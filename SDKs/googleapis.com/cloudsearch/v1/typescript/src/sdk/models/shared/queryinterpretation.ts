/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { Expose } from "class-transformer";

export enum QueryInterpretationInterpretationTypeEnum {
  None = "NONE",
  Blend = "BLEND",
  Replace = "REPLACE",
}

/**
 * The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.
 */
export enum QueryInterpretationReasonEnum {
  Unspecified = "UNSPECIFIED",
  QueryHasNaturalLanguageIntent = "QUERY_HAS_NATURAL_LANGUAGE_INTENT",
  NotEnoughResultsFoundForUserQuery = "NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY",
}

export class QueryInterpretation extends SpeakeasyBase {
  @SpeakeasyMetadata()
  @Expose({ name: "interpretationType" })
  interpretationType?: QueryInterpretationInterpretationTypeEnum;

  /**
   * The interpretation of the query used in search. For example, queries with natural language intent like "email from john" will be interpreted as "from:john source:mail". This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "interpretedQuery" })
  interpretedQuery?: string;

  /**
   * The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "reason" })
  reason?: QueryInterpretationReasonEnum;
}
