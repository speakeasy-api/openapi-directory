/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Ipam {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  ipamAggregatesCreate(
    req: shared.WritableAggregateInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamAggregatesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableAggregateInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/aggregates/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamAggregatesCreateResponse =
        new operations.IpamAggregatesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aggregate = utils.objectToClass(
              httpRes?.data,
              shared.Aggregate
            );
          }
          break;
      }

      return res;
    });
  }

  ipamAggregatesDelete(
    req: operations.IpamAggregatesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamAggregatesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamAggregatesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/aggregates/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamAggregatesDeleteResponse =
        new operations.IpamAggregatesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamAggregatesList(
    req: operations.IpamAggregatesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamAggregatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamAggregatesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/aggregates/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamAggregatesListResponse =
        new operations.IpamAggregatesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamAggregatesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.IpamAggregatesList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  ipamAggregatesPartialUpdate(
    req: operations.IpamAggregatesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamAggregatesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamAggregatesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/aggregates/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableAggregateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamAggregatesPartialUpdateResponse =
        new operations.IpamAggregatesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aggregate = utils.objectToClass(
              httpRes?.data,
              shared.Aggregate
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamAggregatesRead(
    req: operations.IpamAggregatesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamAggregatesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamAggregatesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/aggregates/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamAggregatesReadResponse =
        new operations.IpamAggregatesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aggregate = utils.objectToClass(
              httpRes?.data,
              shared.Aggregate
            );
          }
          break;
      }

      return res;
    });
  }

  ipamAggregatesUpdate(
    req: operations.IpamAggregatesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamAggregatesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamAggregatesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/aggregates/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableAggregateInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamAggregatesUpdateResponse =
        new operations.IpamAggregatesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.aggregate = utils.objectToClass(
              httpRes?.data,
              shared.Aggregate
            );
          }
          break;
      }

      return res;
    });
  }

  ipamIpAddressesCreate(
    req: shared.WritableIPAddressInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamIpAddressesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableIPAddressInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/ip-addresses/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamIpAddressesCreateResponse =
        new operations.IpamIpAddressesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipAddress = utils.objectToClass(
              httpRes?.data,
              shared.IPAddress
            );
          }
          break;
      }

      return res;
    });
  }

  ipamIpAddressesDelete(
    req: operations.IpamIpAddressesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamIpAddressesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamIpAddressesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/ip-addresses/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamIpAddressesDeleteResponse =
        new operations.IpamIpAddressesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamIpAddressesList(
    req: operations.IpamIpAddressesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamIpAddressesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamIpAddressesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/ip-addresses/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamIpAddressesListResponse =
        new operations.IpamIpAddressesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamIpAddressesList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.IpamIpAddressesList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  ipamIpAddressesPartialUpdate(
    req: operations.IpamIpAddressesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamIpAddressesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamIpAddressesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/ip-addresses/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableIPAddressInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamIpAddressesPartialUpdateResponse =
        new operations.IpamIpAddressesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipAddress = utils.objectToClass(
              httpRes?.data,
              shared.IPAddress
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamIpAddressesRead(
    req: operations.IpamIpAddressesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamIpAddressesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamIpAddressesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/ip-addresses/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamIpAddressesReadResponse =
        new operations.IpamIpAddressesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipAddress = utils.objectToClass(
              httpRes?.data,
              shared.IPAddress
            );
          }
          break;
      }

      return res;
    });
  }

  ipamIpAddressesUpdate(
    req: operations.IpamIpAddressesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamIpAddressesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamIpAddressesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/ip-addresses/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableIPAddressInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamIpAddressesUpdateResponse =
        new operations.IpamIpAddressesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipAddress = utils.objectToClass(
              httpRes?.data,
              shared.IPAddress
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
   * returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
   * however results will not be paginated.
   *
   * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
   * invoked in parallel, which results in a race condition where multiple insertions can occur.
   */
  ipamPrefixesAvailableIpsCreate(
    req: operations.IpamPrefixesAvailableIpsCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesAvailableIpsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesAvailableIpsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/prefixes/{id}/available-ips/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesAvailableIpsCreateResponse =
        new operations.IpamPrefixesAvailableIpsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.availableIPS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.availableIPS = utils.objectToClass(
              httpRes?.data,
              shared.AvailableIP,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs
   * returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed,
   * however results will not be paginated.
   *
   * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
   * invoked in parallel, which results in a race condition where multiple insertions can occur.
   */
  ipamPrefixesAvailableIpsRead(
    req: operations.IpamPrefixesAvailableIpsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesAvailableIpsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesAvailableIpsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/prefixes/{id}/available-ips/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesAvailableIpsReadResponse =
        new operations.IpamPrefixesAvailableIpsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.availableIPS = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.availableIPS = utils.objectToClass(
              httpRes?.data,
              shared.AvailableIP,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * A convenience method for returning available child prefixes within a parent.
   *
   * @remarks
   * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
   * invoked in parallel, which results in a race condition where multiple insertions can occur.
   */
  ipamPrefixesAvailablePrefixesCreate(
    req: operations.IpamPrefixesAvailablePrefixesCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesAvailablePrefixesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesAvailablePrefixesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/prefixes/{id}/available-prefixes/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writablePrefixInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesAvailablePrefixesCreateResponse =
        new operations.IpamPrefixesAvailablePrefixesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.availablePrefixes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.availablePrefixes = utils.objectToClass(
              httpRes?.data,
              shared.AvailablePrefix,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * A convenience method for returning available child prefixes within a parent.
   *
   * @remarks
   * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being
   * invoked in parallel, which results in a race condition where multiple insertions can occur.
   */
  ipamPrefixesAvailablePrefixesRead(
    req: operations.IpamPrefixesAvailablePrefixesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesAvailablePrefixesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesAvailablePrefixesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/prefixes/{id}/available-prefixes/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesAvailablePrefixesReadResponse =
        new operations.IpamPrefixesAvailablePrefixesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.availablePrefixes = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.availablePrefixes = utils.objectToClass(
              httpRes?.data,
              shared.AvailablePrefix,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  ipamPrefixesCreate(
    req: shared.WritablePrefixInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritablePrefixInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/prefixes/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesCreateResponse =
        new operations.IpamPrefixesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.prefix = utils.objectToClass(httpRes?.data, shared.Prefix);
          }
          break;
      }

      return res;
    });
  }

  ipamPrefixesDelete(
    req: operations.IpamPrefixesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/prefixes/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesDeleteResponse =
        new operations.IpamPrefixesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamPrefixesList(
    req: operations.IpamPrefixesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/prefixes/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesListResponse =
        new operations.IpamPrefixesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamPrefixesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IpamPrefixesList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  ipamPrefixesPartialUpdate(
    req: operations.IpamPrefixesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/prefixes/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writablePrefixInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesPartialUpdateResponse =
        new operations.IpamPrefixesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.prefix = utils.objectToClass(httpRes?.data, shared.Prefix);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamPrefixesRead(
    req: operations.IpamPrefixesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/prefixes/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesReadResponse =
        new operations.IpamPrefixesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.prefix = utils.objectToClass(httpRes?.data, shared.Prefix);
          }
          break;
      }

      return res;
    });
  }

  ipamPrefixesUpdate(
    req: operations.IpamPrefixesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamPrefixesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamPrefixesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/prefixes/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writablePrefixInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamPrefixesUpdateResponse =
        new operations.IpamPrefixesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.prefix = utils.objectToClass(httpRes?.data, shared.Prefix);
          }
          break;
      }

      return res;
    });
  }

  ipamRirsCreate(
    req: shared.RIRInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRirsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.RIRInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/rirs/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRirsCreateResponse =
        new operations.IpamRirsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rir = utils.objectToClass(httpRes?.data, shared.Rir);
          }
          break;
      }

      return res;
    });
  }

  ipamRirsDelete(
    req: operations.IpamRirsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRirsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRirsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/rirs/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRirsDeleteResponse =
        new operations.IpamRirsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamRirsList(
    req: operations.IpamRirsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRirsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRirsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/rirs/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRirsListResponse =
        new operations.IpamRirsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamRirsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IpamRirsList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  ipamRirsPartialUpdate(
    req: operations.IpamRirsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRirsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRirsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/rirs/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rirInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRirsPartialUpdateResponse =
        new operations.IpamRirsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rir = utils.objectToClass(httpRes?.data, shared.Rir);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamRirsRead(
    req: operations.IpamRirsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRirsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRirsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/rirs/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRirsReadResponse =
        new operations.IpamRirsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rir = utils.objectToClass(httpRes?.data, shared.Rir);
          }
          break;
      }

      return res;
    });
  }

  ipamRirsUpdate(
    req: operations.IpamRirsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRirsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRirsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/rirs/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "rirInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRirsUpdateResponse =
        new operations.IpamRirsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.rir = utils.objectToClass(httpRes?.data, shared.Rir);
          }
          break;
      }

      return res;
    });
  }

  ipamRolesCreate(
    req: shared.RoleInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRolesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.RoleInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/roles/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRolesCreateResponse =
        new operations.IpamRolesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.role = utils.objectToClass(httpRes?.data, shared.Role);
          }
          break;
      }

      return res;
    });
  }

  ipamRolesDelete(
    req: operations.IpamRolesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRolesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRolesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/roles/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRolesDeleteResponse =
        new operations.IpamRolesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamRolesList(
    req: operations.IpamRolesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRolesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRolesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/roles/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRolesListResponse =
        new operations.IpamRolesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamRolesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IpamRolesList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  ipamRolesPartialUpdate(
    req: operations.IpamRolesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRolesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRolesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/roles/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "roleInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRolesPartialUpdateResponse =
        new operations.IpamRolesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.role = utils.objectToClass(httpRes?.data, shared.Role);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamRolesRead(
    req: operations.IpamRolesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRolesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRolesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/roles/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRolesReadResponse =
        new operations.IpamRolesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.role = utils.objectToClass(httpRes?.data, shared.Role);
          }
          break;
      }

      return res;
    });
  }

  ipamRolesUpdate(
    req: operations.IpamRolesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamRolesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamRolesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/roles/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "roleInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamRolesUpdateResponse =
        new operations.IpamRolesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.role = utils.objectToClass(httpRes?.data, shared.Role);
          }
          break;
      }

      return res;
    });
  }

  ipamServicesCreate(
    req: shared.WritableServiceInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamServicesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableServiceInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/services/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamServicesCreateResponse =
        new operations.IpamServicesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  ipamServicesDelete(
    req: operations.IpamServicesDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamServicesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamServicesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/services/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamServicesDeleteResponse =
        new operations.IpamServicesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamServicesList(
    req: operations.IpamServicesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamServicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamServicesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/services/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamServicesListResponse =
        new operations.IpamServicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamServicesList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IpamServicesList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  ipamServicesPartialUpdate(
    req: operations.IpamServicesPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamServicesPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamServicesPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/services/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableServiceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamServicesPartialUpdateResponse =
        new operations.IpamServicesPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamServicesRead(
    req: operations.IpamServicesReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamServicesReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamServicesReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/services/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamServicesReadResponse =
        new operations.IpamServicesReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  ipamServicesUpdate(
    req: operations.IpamServicesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamServicesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamServicesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/services/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableServiceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamServicesUpdateResponse =
        new operations.IpamServicesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  ipamVlanGroupsCreate(
    req: shared.WritableVLANGroupInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlanGroupsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableVLANGroupInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/vlan-groups/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlanGroupsCreateResponse =
        new operations.IpamVlanGroupsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlanGroup = utils.objectToClass(
              httpRes?.data,
              shared.VLANGroup
            );
          }
          break;
      }

      return res;
    });
  }

  ipamVlanGroupsDelete(
    req: operations.IpamVlanGroupsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlanGroupsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlanGroupsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/vlan-groups/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlanGroupsDeleteResponse =
        new operations.IpamVlanGroupsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamVlanGroupsList(
    req: operations.IpamVlanGroupsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlanGroupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlanGroupsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/vlan-groups/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlanGroupsListResponse =
        new operations.IpamVlanGroupsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamVlanGroupsList200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.IpamVlanGroupsList200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  ipamVlanGroupsPartialUpdate(
    req: operations.IpamVlanGroupsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlanGroupsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlanGroupsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/vlan-groups/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableVLANGroupInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlanGroupsPartialUpdateResponse =
        new operations.IpamVlanGroupsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlanGroup = utils.objectToClass(
              httpRes?.data,
              shared.VLANGroup
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamVlanGroupsRead(
    req: operations.IpamVlanGroupsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlanGroupsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlanGroupsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/vlan-groups/{id}/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlanGroupsReadResponse =
        new operations.IpamVlanGroupsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlanGroup = utils.objectToClass(
              httpRes?.data,
              shared.VLANGroup
            );
          }
          break;
      }

      return res;
    });
  }

  ipamVlanGroupsUpdate(
    req: operations.IpamVlanGroupsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlanGroupsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlanGroupsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/ipam/vlan-groups/{id}/",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableVLANGroupInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlanGroupsUpdateResponse =
        new operations.IpamVlanGroupsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlanGroup = utils.objectToClass(
              httpRes?.data,
              shared.VLANGroup
            );
          }
          break;
      }

      return res;
    });
  }

  ipamVlansCreate(
    req: shared.WritableVLANInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlansCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableVLANInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/vlans/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlansCreateResponse =
        new operations.IpamVlansCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlan = utils.objectToClass(httpRes?.data, shared.Vlan);
          }
          break;
      }

      return res;
    });
  }

  ipamVlansDelete(
    req: operations.IpamVlansDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlansDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlansDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vlans/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlansDeleteResponse =
        new operations.IpamVlansDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamVlansList(
    req: operations.IpamVlansListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlansListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlansListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/vlans/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlansListResponse =
        new operations.IpamVlansListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamVlansList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IpamVlansList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  ipamVlansPartialUpdate(
    req: operations.IpamVlansPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlansPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlansPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vlans/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableVLANInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlansPartialUpdateResponse =
        new operations.IpamVlansPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlan = utils.objectToClass(httpRes?.data, shared.Vlan);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamVlansRead(
    req: operations.IpamVlansReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlansReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlansReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vlans/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlansReadResponse =
        new operations.IpamVlansReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlan = utils.objectToClass(httpRes?.data, shared.Vlan);
          }
          break;
      }

      return res;
    });
  }

  ipamVlansUpdate(
    req: operations.IpamVlansUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVlansUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVlansUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vlans/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableVLANInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVlansUpdateResponse =
        new operations.IpamVlansUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vlan = utils.objectToClass(httpRes?.data, shared.Vlan);
          }
          break;
      }

      return res;
    });
  }

  ipamVrfsCreate(
    req: shared.WritableVRFInput,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVrfsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.WritableVRFInput(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/vrfs/";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVrfsCreateResponse =
        new operations.IpamVrfsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vrf = utils.objectToClass(httpRes?.data, shared.Vrf);
          }
          break;
      }

      return res;
    });
  }

  ipamVrfsDelete(
    req: operations.IpamVrfsDeleteRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVrfsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVrfsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vrfs/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVrfsDeleteResponse =
        new operations.IpamVrfsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamVrfsList(
    req: operations.IpamVrfsListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVrfsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVrfsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/ipam/vrfs/";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVrfsListResponse =
        new operations.IpamVrfsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ipamVrfsList200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IpamVrfsList200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  ipamVrfsPartialUpdate(
    req: operations.IpamVrfsPartialUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVrfsPartialUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVrfsPartialUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vrfs/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableVRFInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVrfsPartialUpdateResponse =
        new operations.IpamVrfsPartialUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vrf = utils.objectToClass(httpRes?.data, shared.Vrf);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Call to super to allow for caching
   */
  ipamVrfsRead(
    req: operations.IpamVrfsReadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVrfsReadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVrfsReadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vrfs/{id}/", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVrfsReadResponse =
        new operations.IpamVrfsReadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vrf = utils.objectToClass(httpRes?.data, shared.Vrf);
          }
          break;
      }

      return res;
    });
  }

  ipamVrfsUpdate(
    req: operations.IpamVrfsUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IpamVrfsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IpamVrfsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/ipam/vrfs/{id}/", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "writableVRFInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IpamVrfsUpdateResponse =
        new operations.IpamVrfsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.vrf = utils.objectToClass(httpRes?.data, shared.Vrf);
          }
          break;
      }

      return res;
    });
  }
}
