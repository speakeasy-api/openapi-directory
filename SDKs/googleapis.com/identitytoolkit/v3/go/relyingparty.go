// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package sdk

import (
	"context"
	"fmt"
	"net/http"
	"openapi/pkg/models/operations"
	"openapi/pkg/models/shared"
	"openapi/pkg/utils"
	"strings"
)

type relyingparty struct {
	defaultClient  HTTPClient
	securityClient HTTPClient
	serverURL      string
	language       string
	sdkVersion     string
	genVersion     string
}

func newRelyingparty(defaultClient, securityClient HTTPClient, serverURL, language, sdkVersion, genVersion string) *relyingparty {
	return &relyingparty{
		defaultClient:  defaultClient,
		securityClient: securityClient,
		serverURL:      serverURL,
		language:       language,
		sdkVersion:     sdkVersion,
		genVersion:     genVersion,
	}
}

// IdentitytoolkitRelyingpartyCreateAuthURI - Creates the URI used by the IdP to authenticate the user.
func (s *relyingparty) IdentitytoolkitRelyingpartyCreateAuthURI(ctx context.Context, request operations.IdentitytoolkitRelyingpartyCreateAuthURIRequest, security operations.IdentitytoolkitRelyingpartyCreateAuthURISecurity) (*operations.IdentitytoolkitRelyingpartyCreateAuthURIResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/createAuthUri"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyCreateAuthURIRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyCreateAuthURIResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.CreateAuthURIResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.CreateAuthURIResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyDeleteAccount - Delete user account.
func (s *relyingparty) IdentitytoolkitRelyingpartyDeleteAccount(ctx context.Context, request operations.IdentitytoolkitRelyingpartyDeleteAccountRequest, security operations.IdentitytoolkitRelyingpartyDeleteAccountSecurity) (*operations.IdentitytoolkitRelyingpartyDeleteAccountResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/deleteAccount"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyDeleteAccountRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyDeleteAccountResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DeleteAccountResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.DeleteAccountResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyDownloadAccount - Batch download user accounts.
func (s *relyingparty) IdentitytoolkitRelyingpartyDownloadAccount(ctx context.Context, request operations.IdentitytoolkitRelyingpartyDownloadAccountRequest, security operations.IdentitytoolkitRelyingpartyDownloadAccountSecurity) (*operations.IdentitytoolkitRelyingpartyDownloadAccountResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/downloadAccount"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyDownloadAccountRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyDownloadAccountResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.DownloadAccountResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.DownloadAccountResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyEmailLinkSignin - Reset password for a user.
func (s *relyingparty) IdentitytoolkitRelyingpartyEmailLinkSignin(ctx context.Context, request operations.IdentitytoolkitRelyingpartyEmailLinkSigninRequest, security operations.IdentitytoolkitRelyingpartyEmailLinkSigninSecurity) (*operations.IdentitytoolkitRelyingpartyEmailLinkSigninResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/emailLinkSignin"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyEmailLinkSigninRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyEmailLinkSigninResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.EmailLinkSigninResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.EmailLinkSigninResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyGetAccountInfo - Returns the account info.
func (s *relyingparty) IdentitytoolkitRelyingpartyGetAccountInfo(ctx context.Context, request operations.IdentitytoolkitRelyingpartyGetAccountInfoRequest, security operations.IdentitytoolkitRelyingpartyGetAccountInfoSecurity) (*operations.IdentitytoolkitRelyingpartyGetAccountInfoResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/getAccountInfo"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyGetAccountInfoRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyGetAccountInfoResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GetAccountInfoResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetAccountInfoResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyGetOobConfirmationCode - Get a code for user action confirmation.
func (s *relyingparty) IdentitytoolkitRelyingpartyGetOobConfirmationCode(ctx context.Context, request operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeRequest, security operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeSecurity) (*operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/getOobConfirmationCode"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "Relyingparty", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyGetOobConfirmationCodeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GetOobConfirmationCodeResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetOobConfirmationCodeResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyGetProjectConfig - Get project configuration.
func (s *relyingparty) IdentitytoolkitRelyingpartyGetProjectConfig(ctx context.Context, request operations.IdentitytoolkitRelyingpartyGetProjectConfigRequest, security operations.IdentitytoolkitRelyingpartyGetProjectConfigSecurity) (*operations.IdentitytoolkitRelyingpartyGetProjectConfigResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/getProjectConfig"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyGetProjectConfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IdentitytoolkitRelyingpartyGetProjectConfigResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IdentitytoolkitRelyingpartyGetProjectConfigResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyGetPublicKeys - Get token signing public key.
func (s *relyingparty) IdentitytoolkitRelyingpartyGetPublicKeys(ctx context.Context, request operations.IdentitytoolkitRelyingpartyGetPublicKeysRequest, security operations.IdentitytoolkitRelyingpartyGetPublicKeysSecurity) (*operations.IdentitytoolkitRelyingpartyGetPublicKeysResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/publicKeys"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyGetPublicKeysResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out map[string]string
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IdentitytoolkitRelyingpartyGetPublicKeysResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyGetRecaptchaParam - Get recaptcha secure param.
func (s *relyingparty) IdentitytoolkitRelyingpartyGetRecaptchaParam(ctx context.Context, request operations.IdentitytoolkitRelyingpartyGetRecaptchaParamRequest, security operations.IdentitytoolkitRelyingpartyGetRecaptchaParamSecurity) (*operations.IdentitytoolkitRelyingpartyGetRecaptchaParamResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/getRecaptchaParam"

	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyGetRecaptchaParamResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.GetRecaptchaParamResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.GetRecaptchaParamResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyResetPassword - Reset password for a user.
func (s *relyingparty) IdentitytoolkitRelyingpartyResetPassword(ctx context.Context, request operations.IdentitytoolkitRelyingpartyResetPasswordRequest, security operations.IdentitytoolkitRelyingpartyResetPasswordSecurity) (*operations.IdentitytoolkitRelyingpartyResetPasswordResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/resetPassword"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyResetPasswordRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyResetPasswordResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.ResetPasswordResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.ResetPasswordResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartySendVerificationCode - Send SMS verification code.
func (s *relyingparty) IdentitytoolkitRelyingpartySendVerificationCode(ctx context.Context, request operations.IdentitytoolkitRelyingpartySendVerificationCodeRequest, security operations.IdentitytoolkitRelyingpartySendVerificationCodeSecurity) (*operations.IdentitytoolkitRelyingpartySendVerificationCodeResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/sendVerificationCode"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartySendVerificationCodeRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartySendVerificationCodeResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IdentitytoolkitRelyingpartySendVerificationCodeResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IdentitytoolkitRelyingpartySendVerificationCodeResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartySetAccountInfo - Set account info for a user.
func (s *relyingparty) IdentitytoolkitRelyingpartySetAccountInfo(ctx context.Context, request operations.IdentitytoolkitRelyingpartySetAccountInfoRequest, security operations.IdentitytoolkitRelyingpartySetAccountInfoSecurity) (*operations.IdentitytoolkitRelyingpartySetAccountInfoResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/setAccountInfo"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartySetAccountInfoRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartySetAccountInfoResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.SetAccountInfoResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SetAccountInfoResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartySetProjectConfig - Set project configuration.
func (s *relyingparty) IdentitytoolkitRelyingpartySetProjectConfig(ctx context.Context, request operations.IdentitytoolkitRelyingpartySetProjectConfigRequest, security operations.IdentitytoolkitRelyingpartySetProjectConfigSecurity) (*operations.IdentitytoolkitRelyingpartySetProjectConfigResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/setProjectConfig"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartySetProjectConfigRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartySetProjectConfigResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IdentitytoolkitRelyingpartySetProjectConfigResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IdentitytoolkitRelyingpartySetProjectConfigResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartySignOutUser - Sign out user.
func (s *relyingparty) IdentitytoolkitRelyingpartySignOutUser(ctx context.Context, request operations.IdentitytoolkitRelyingpartySignOutUserRequest, security operations.IdentitytoolkitRelyingpartySignOutUserSecurity) (*operations.IdentitytoolkitRelyingpartySignOutUserResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/signOutUser"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartySignOutUserRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartySignOutUserResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IdentitytoolkitRelyingpartySignOutUserResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IdentitytoolkitRelyingpartySignOutUserResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartySignupNewUser - Signup new user.
func (s *relyingparty) IdentitytoolkitRelyingpartySignupNewUser(ctx context.Context, request operations.IdentitytoolkitRelyingpartySignupNewUserRequest, security operations.IdentitytoolkitRelyingpartySignupNewUserSecurity) (*operations.IdentitytoolkitRelyingpartySignupNewUserResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/signupNewUser"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartySignupNewUserRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartySignupNewUserResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.SignupNewUserResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.SignupNewUserResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyUploadAccount - Batch upload existing user accounts.
func (s *relyingparty) IdentitytoolkitRelyingpartyUploadAccount(ctx context.Context, request operations.IdentitytoolkitRelyingpartyUploadAccountRequest, security operations.IdentitytoolkitRelyingpartyUploadAccountSecurity) (*operations.IdentitytoolkitRelyingpartyUploadAccountResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/uploadAccount"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyUploadAccountRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyUploadAccountResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.UploadAccountResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.UploadAccountResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyVerifyAssertion - Verifies the assertion returned by the IdP.
func (s *relyingparty) IdentitytoolkitRelyingpartyVerifyAssertion(ctx context.Context, request operations.IdentitytoolkitRelyingpartyVerifyAssertionRequest, security operations.IdentitytoolkitRelyingpartyVerifyAssertionSecurity) (*operations.IdentitytoolkitRelyingpartyVerifyAssertionResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/verifyAssertion"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyVerifyAssertionRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyVerifyAssertionResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VerifyAssertionResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VerifyAssertionResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyVerifyCustomToken - Verifies the developer asserted ID token.
func (s *relyingparty) IdentitytoolkitRelyingpartyVerifyCustomToken(ctx context.Context, request operations.IdentitytoolkitRelyingpartyVerifyCustomTokenRequest, security operations.IdentitytoolkitRelyingpartyVerifyCustomTokenSecurity) (*operations.IdentitytoolkitRelyingpartyVerifyCustomTokenResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/verifyCustomToken"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyVerifyCustomTokenRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyVerifyCustomTokenResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VerifyCustomTokenResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VerifyCustomTokenResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyVerifyPassword - Verifies the user entered password.
func (s *relyingparty) IdentitytoolkitRelyingpartyVerifyPassword(ctx context.Context, request operations.IdentitytoolkitRelyingpartyVerifyPasswordRequest, security operations.IdentitytoolkitRelyingpartyVerifyPasswordSecurity) (*operations.IdentitytoolkitRelyingpartyVerifyPasswordResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/verifyPassword"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyVerifyPasswordRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyVerifyPasswordResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.VerifyPasswordResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.VerifyPasswordResponse = out
		}
	}

	return res, nil
}

// IdentitytoolkitRelyingpartyVerifyPhoneNumber - Verifies ownership of a phone number and creates/updates the user account accordingly.
func (s *relyingparty) IdentitytoolkitRelyingpartyVerifyPhoneNumber(ctx context.Context, request operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberRequest, security operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberSecurity) (*operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse, error) {
	baseURL := s.serverURL
	url := strings.TrimSuffix(baseURL, "/") + "/verifyPhoneNumber"

	bodyReader, reqContentType, err := utils.SerializeRequestBody(ctx, request, "IdentitytoolkitRelyingpartyVerifyPhoneNumberRequest", "json")
	if err != nil {
		return nil, fmt.Errorf("error serializing request body: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bodyReader)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}

	req.Header.Set("Content-Type", reqContentType)

	if err := utils.PopulateQueryParams(ctx, req, request, nil); err != nil {
		return nil, fmt.Errorf("error populating query params: %w", err)
	}

	client := utils.ConfigureSecurityClient(s.defaultClient, security)

	httpRes, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	if httpRes == nil {
		return nil, fmt.Errorf("error sending request: no response")
	}
	defer httpRes.Body.Close()

	contentType := httpRes.Header.Get("Content-Type")

	res := &operations.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse{
		StatusCode:  httpRes.StatusCode,
		ContentType: contentType,
		RawResponse: httpRes,
	}
	switch {
	case httpRes.StatusCode == 200:
		switch {
		case utils.MatchContentType(contentType, `application/json`):
			var out *shared.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse
			if err := utils.UnmarshalJsonFromResponseBody(httpRes.Body, &out); err != nil {
				return nil, err
			}

			res.IdentitytoolkitRelyingpartyVerifyPhoneNumberResponse = out
		}
	}

	return res, nil
}
