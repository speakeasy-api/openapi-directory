// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// CallBroadcastAnsweringMachineConfigEnum - Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately
type CallBroadcastAnsweringMachineConfigEnum string

const (
	CallBroadcastAnsweringMachineConfigEnumAmOnly        CallBroadcastAnsweringMachineConfigEnum = "AM_ONLY"
	CallBroadcastAnsweringMachineConfigEnumAmAndLive     CallBroadcastAnsweringMachineConfigEnum = "AM_AND_LIVE"
	CallBroadcastAnsweringMachineConfigEnumLiveWithAmd   CallBroadcastAnsweringMachineConfigEnum = "LIVE_WITH_AMD"
	CallBroadcastAnsweringMachineConfigEnumLiveImmediate CallBroadcastAnsweringMachineConfigEnum = "LIVE_IMMEDIATE"
)

func (e *CallBroadcastAnsweringMachineConfigEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "AM_ONLY":
		fallthrough
	case "AM_AND_LIVE":
		fallthrough
	case "LIVE_WITH_AMD":
		fallthrough
	case "LIVE_IMMEDIATE":
		*e = CallBroadcastAnsweringMachineConfigEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CallBroadcastAnsweringMachineConfigEnum: %s", s)
	}
}

// CallBroadcastInput - Call broadcast can be used to send out a voice message to a group of numbers. It supports IVR scripting, scheduling, retry logic, playing pre-recorded sounds, answering machine detection
type CallBroadcastInput struct {
	// Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately
	AnsweringMachineConfig *CallBroadcastAnsweringMachineConfigEnum `json:"answeringMachineConfig,omitempty"`
	// IVR xml is a document which describes the dialplan to setup the IVR broadcast
	DialplanXML *string `json:"dialplanXml,omitempty"`
	// Phone number in E.164 format (11-digit) or short code for text. Example: 12132000384, 67076
	FromNumber *string `json:"fromNumber,omitempty"`
	// A unique id of broadcast (readonly)
	ID *int64 `json:"id,omitempty"`
	// Labels of a broadcast
	Labels []string `json:"labels,omitempty"`
	// Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number
	LocalTimeRestriction *LocalTimeRestriction `json:"localTimeRestriction,omitempty"`
	// Sets a maximum number of calls to be dialed by CallFire at once
	MaxActive *int `json:"maxActive,omitempty"`
	// A maximum number of active transfers
	MaxActiveTransfers *int `json:"maxActiveTransfers,omitempty"`
	// A name of a broadcast
	Name *string `json:"name,omitempty"`
	// Recipients of a call broadcast, can be either existing contacts or a new ones
	Recipients []Recipient `json:"recipients,omitempty"`
	// If true resumes the unfinished campaign to the next day
	ResumeNextDay *bool `json:"resumeNextDay,omitempty"`
	// Retry configuration will help you to resend a call or text if it was not delivered first time
	RetryConfig *RetryConfig `json:"retryConfig,omitempty"`
	// A list of schedule objects which specifies a range of time when broadcast should be started and stopped. Supports the scheduling per day of week
	Schedules []Schedule `json:"schedules,omitempty"`
	// A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign
	Sounds *CallBroadcastSounds `json:"sounds,omitempty"`
}

// CallBroadcastStatusEnum - A status of a broadcast (read only). SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived
type CallBroadcastStatusEnum string

const (
	CallBroadcastStatusEnumTest              CallBroadcastStatusEnum = "TEST"
	CallBroadcastStatusEnumSetup             CallBroadcastStatusEnum = "SETUP"
	CallBroadcastStatusEnumStartPending      CallBroadcastStatusEnum = "START_PENDING"
	CallBroadcastStatusEnumRunning           CallBroadcastStatusEnum = "RUNNING"
	CallBroadcastStatusEnumScheduled         CallBroadcastStatusEnum = "SCHEDULED"
	CallBroadcastStatusEnumStopped           CallBroadcastStatusEnum = "STOPPED"
	CallBroadcastStatusEnumSuspended         CallBroadcastStatusEnum = "SUSPENDED"
	CallBroadcastStatusEnumFinished          CallBroadcastStatusEnum = "FINISHED"
	CallBroadcastStatusEnumArchived          CallBroadcastStatusEnum = "ARCHIVED"
	CallBroadcastStatusEnumValidatingStart   CallBroadcastStatusEnum = "VALIDATING_START"
	CallBroadcastStatusEnumValidatingEmail   CallBroadcastStatusEnum = "VALIDATING_EMAIL"
	CallBroadcastStatusEnumBlockedSuspicious CallBroadcastStatusEnum = "BLOCKED_SUSPICIOUS"
	CallBroadcastStatusEnumDeclined          CallBroadcastStatusEnum = "DECLINED"
	CallBroadcastStatusEnumApproved          CallBroadcastStatusEnum = "APPROVED"
)

func (e *CallBroadcastStatusEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "TEST":
		fallthrough
	case "SETUP":
		fallthrough
	case "START_PENDING":
		fallthrough
	case "RUNNING":
		fallthrough
	case "SCHEDULED":
		fallthrough
	case "STOPPED":
		fallthrough
	case "SUSPENDED":
		fallthrough
	case "FINISHED":
		fallthrough
	case "ARCHIVED":
		fallthrough
	case "VALIDATING_START":
		fallthrough
	case "VALIDATING_EMAIL":
		fallthrough
	case "BLOCKED_SUSPICIOUS":
		fallthrough
	case "DECLINED":
		fallthrough
	case "APPROVED":
		*e = CallBroadcastStatusEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for CallBroadcastStatusEnum: %s", s)
	}
}

// CallBroadcast - Call broadcast can be used to send out a voice message to a group of numbers. It supports IVR scripting, scheduling, retry logic, playing pre-recorded sounds, answering machine detection
type CallBroadcast struct {
	// Specifies which action should be taken if answering machine was detected, default value: AM_AND_LIVE. Available values: AM_ONLY - run AMD (Answering Machine Detection), hang up if LA (Live Answer); AM_AND_LIVE - run AMD, play separate live vs. machine sound; LIVE_WITH_AMD, run AMD, hang up if machine answers; LIVE_IMMEDIATE - no AMD, play live sound immediately
	AnsweringMachineConfig *CallBroadcastAnsweringMachineConfigEnum `json:"answeringMachineConfig,omitempty"`
	// IVR xml is a document which describes the dialplan to setup the IVR broadcast
	DialplanXML *string `json:"dialplanXml,omitempty"`
	// Phone number in E.164 format (11-digit) or short code for text. Example: 12132000384, 67076
	FromNumber *string `json:"fromNumber,omitempty"`
	// A unique id of broadcast (readonly)
	ID *int64 `json:"id,omitempty"`
	// Labels of a broadcast
	Labels []string `json:"labels,omitempty"`
	// The time when a given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000 for Sat, 05 Jan 1985 14:03:37 GMT
	LastModified *int64 `json:"lastModified,omitempty"`
	// Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number
	LocalTimeRestriction *LocalTimeRestriction `json:"localTimeRestriction,omitempty"`
	// Sets a maximum number of calls to be dialed by CallFire at once
	MaxActive *int `json:"maxActive,omitempty"`
	// A maximum number of active transfers
	MaxActiveTransfers *int `json:"maxActiveTransfers,omitempty"`
	// A name of a broadcast
	Name *string `json:"name,omitempty"`
	// Recipients of a call broadcast, can be either existing contacts or a new ones
	Recipients []Recipient `json:"recipients,omitempty"`
	// If true resumes the unfinished campaign to the next day
	ResumeNextDay *bool `json:"resumeNextDay,omitempty"`
	// Retry configuration will help you to resend a call or text if it was not delivered first time
	RetryConfig *RetryConfig `json:"retryConfig,omitempty"`
	// A list of schedule objects which specifies a range of time when broadcast should be started and stopped. Supports the scheduling per day of week
	Schedules []Schedule `json:"schedules,omitempty"`
	// A set of sounds assigned to a voice broadcast to play according to an answering machine configuration. You can add the existing sounds from the account's sound library or to provide a text which will be converted into a speech. There are four sound options available for a Voice Broadcast campaign
	Sounds *CallBroadcastSounds `json:"sounds,omitempty"`
	// A status of a broadcast (read only). SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived
	Status *CallBroadcastStatusEnum `json:"status,omitempty"`
}
