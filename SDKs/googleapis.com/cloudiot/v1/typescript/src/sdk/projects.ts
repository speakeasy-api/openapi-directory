/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Associates the device with the gateway.
   */
  cloudiotProjectsLocationsRegistriesBindDeviceToGateway(
    req: operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewayRequest,
    security: operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewayRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}:bindDeviceToGateway",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "bindDeviceToGatewayRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewaySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewayResponse =
        new operations.CloudiotProjectsLocationsRegistriesBindDeviceToGatewayResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bindDeviceToGatewayResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a device registry that contains devices.
   */
  cloudiotProjectsLocationsRegistriesCreate(
    req: operations.CloudiotProjectsLocationsRegistriesCreateRequest,
    security: operations.CloudiotProjectsLocationsRegistriesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CloudiotProjectsLocationsRegistriesCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/registries",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deviceRegistry",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesCreateResponse =
        new operations.CloudiotProjectsLocationsRegistriesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceRegistry = utils.objectToClass(
              httpRes?.data,
              shared.DeviceRegistry
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the last few versions of the device configuration in descending order (i.e.: newest first).
   */
  cloudiotProjectsLocationsRegistriesDevicesConfigVersionsList(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/configVersions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesConfigVersionsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeviceConfigVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDeviceConfigVersionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a device in a device registry.
   */
  cloudiotProjectsLocationsRegistriesDevicesCreate(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesCreateRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/devices", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "device",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesCreateResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.device = utils.objectToClass(httpRes?.data, shared.Device);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a device.
   */
  cloudiotProjectsLocationsRegistriesDevicesDelete(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesDeleteRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesDeleteResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesDeleteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets details about a device.
   */
  cloudiotProjectsLocationsRegistriesDevicesGet(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesGetRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CloudiotProjectsLocationsRegistriesDevicesGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesGetResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.device = utils.objectToClass(httpRes?.data, shared.Device);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies the configuration for the device, which is eventually sent from the Cloud IoT Core servers. Returns the modified configuration version and its metadata.
   */
  cloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfig(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:modifyCloudToDeviceConfig",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "modifyCloudToDeviceConfigRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesModifyCloudToDeviceConfigResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deviceConfig = utils.objectToClass(
              httpRes?.data,
              shared.DeviceConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a device.
   */
  cloudiotProjectsLocationsRegistriesDevicesPatch(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesPatchRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesPatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "device",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesPatchResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.device = utils.objectToClass(httpRes?.data, shared.Device);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends a command to the specified device. In order for a device to be able to receive commands, it must: 1) be connected to Cloud IoT Core using the MQTT protocol, and 2) be subscribed to the group of MQTT topics specified by /devices/{device-id}/commands/#. This subscription will receive commands at the top-level topic /devices/{device-id}/commands as well as commands for subfolders, like /devices/{device-id}/commands/subfolder. Note that subscribing to specific subfolders is not supported. If the command could not be delivered to the device, this method will return an error; in particular, if the device is not subscribed, this method will return FAILED_PRECONDITION. Otherwise, this method will return OK. If the subscription is QoS 1, at least once delivery will be guaranteed; for QoS 0, no acknowledgment will be expected from the device.
   */
  cloudiotProjectsLocationsRegistriesDevicesSendCommandToDevice(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:sendCommandToDevice",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "sendCommandToDeviceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesSendCommandToDeviceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.sendCommandToDeviceResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the last few versions of the device state in descending order (i.e.: newest first).
   */
  cloudiotProjectsLocationsRegistriesDevicesStatesList(
    req: operations.CloudiotProjectsLocationsRegistriesDevicesStatesListRequest,
    security: operations.CloudiotProjectsLocationsRegistriesDevicesStatesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesDevicesStatesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesDevicesStatesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}/states", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesDevicesStatesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesDevicesStatesListResponse =
        new operations.CloudiotProjectsLocationsRegistriesDevicesStatesListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeviceStatesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDeviceStatesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List devices in a device registry.
   */
  cloudiotProjectsLocationsRegistriesGroupsDevicesList(
    req: operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListRequest,
    security: operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/devices", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListResponse =
        new operations.CloudiotProjectsLocationsRegistriesGroupsDevicesListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDevicesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDevicesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
   */
  cloudiotProjectsLocationsRegistriesGroupsGetIamPolicy(
    req: operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicyRequest,
    security: operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:getIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getIamPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicyResponse =
        new operations.CloudiotProjectsLocationsRegistriesGroupsGetIamPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any existing policy.
   */
  cloudiotProjectsLocationsRegistriesGroupsSetIamPolicy(
    req: operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicyRequest,
    security: operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:setIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setIamPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicyResponse =
        new operations.CloudiotProjectsLocationsRegistriesGroupsSetIamPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a NOT_FOUND error.
   */
  cloudiotProjectsLocationsRegistriesGroupsTestIamPermissions(
    req: operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsRequest,
    security: operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:testIamPermissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testIamPermissionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsResponse =
        new operations.CloudiotProjectsLocationsRegistriesGroupsTestIamPermissionsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testIamPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestIamPermissionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists device registries.
   */
  cloudiotProjectsLocationsRegistriesList(
    req: operations.CloudiotProjectsLocationsRegistriesListRequest,
    security: operations.CloudiotProjectsLocationsRegistriesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CloudiotProjectsLocationsRegistriesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/registries",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CloudiotProjectsLocationsRegistriesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesListResponse =
        new operations.CloudiotProjectsLocationsRegistriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDeviceRegistriesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDeviceRegistriesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the association between the device and the gateway.
   */
  cloudiotProjectsLocationsRegistriesUnbindDeviceFromGateway(
    req: operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewayRequest,
    security: operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewaySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewayResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewayRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}:unbindDeviceFromGateway",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "unbindDeviceFromGatewayRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewaySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewayResponse =
        new operations.CloudiotProjectsLocationsRegistriesUnbindDeviceFromGatewayResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.unbindDeviceFromGatewayResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
      }

      return res;
    });
  }
}
