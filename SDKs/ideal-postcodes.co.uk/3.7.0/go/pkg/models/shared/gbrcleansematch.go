// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// GbrCleanseMatchLocalityMatchEnum - Match indicator for the locality
type GbrCleanseMatchLocalityMatchEnum string

const (
	GbrCleanseMatchLocalityMatchEnumFull      GbrCleanseMatchLocalityMatchEnum = "FULL"
	GbrCleanseMatchLocalityMatchEnumPartial   GbrCleanseMatchLocalityMatchEnum = "PARTIAL"
	GbrCleanseMatchLocalityMatchEnumIncorrect GbrCleanseMatchLocalityMatchEnum = "INCORRECT"
	GbrCleanseMatchLocalityMatchEnumMissing   GbrCleanseMatchLocalityMatchEnum = "MISSING"
	GbrCleanseMatchLocalityMatchEnumNa        GbrCleanseMatchLocalityMatchEnum = "NA"
)

func (e *GbrCleanseMatchLocalityMatchEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FULL":
		fallthrough
	case "PARTIAL":
		fallthrough
	case "INCORRECT":
		fallthrough
	case "MISSING":
		fallthrough
	case "NA":
		*e = GbrCleanseMatchLocalityMatchEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GbrCleanseMatchLocalityMatchEnum: %s", s)
	}
}

type GbrCleanseMatchMatchType string

const (
	GbrCleanseMatchMatchTypePafAddress      GbrCleanseMatchMatchType = "PafAddress"
	GbrCleanseMatchMatchTypeMrAddress       GbrCleanseMatchMatchType = "MrAddress"
	GbrCleanseMatchMatchTypeNybAddress      GbrCleanseMatchMatchType = "NybAddress"
	GbrCleanseMatchMatchTypePafAliasAddress GbrCleanseMatchMatchType = "PafAliasAddress"
	GbrCleanseMatchMatchTypeWelshPafAddress GbrCleanseMatchMatchType = "WelshPafAddress"
)

type GbrCleanseMatchMatch struct {
	PafAddress      *PafAddress
	MrAddress       *MrAddress
	NybAddress      *NybAddress
	PafAliasAddress *PafAliasAddress
	WelshPafAddress *WelshPafAddress

	Type GbrCleanseMatchMatchType
}

func CreateGbrCleanseMatchMatchPafAddress(pafAddress PafAddress) GbrCleanseMatchMatch {
	typ := GbrCleanseMatchMatchTypePafAddress

	return GbrCleanseMatchMatch{
		PafAddress: &pafAddress,
		Type:       typ,
	}
}

func CreateGbrCleanseMatchMatchMrAddress(mrAddress MrAddress) GbrCleanseMatchMatch {
	typ := GbrCleanseMatchMatchTypeMrAddress

	return GbrCleanseMatchMatch{
		MrAddress: &mrAddress,
		Type:      typ,
	}
}

func CreateGbrCleanseMatchMatchNybAddress(nybAddress NybAddress) GbrCleanseMatchMatch {
	typ := GbrCleanseMatchMatchTypeNybAddress

	return GbrCleanseMatchMatch{
		NybAddress: &nybAddress,
		Type:       typ,
	}
}

func CreateGbrCleanseMatchMatchPafAliasAddress(pafAliasAddress PafAliasAddress) GbrCleanseMatchMatch {
	typ := GbrCleanseMatchMatchTypePafAliasAddress

	return GbrCleanseMatchMatch{
		PafAliasAddress: &pafAliasAddress,
		Type:            typ,
	}
}

func CreateGbrCleanseMatchMatchWelshPafAddress(welshPafAddress WelshPafAddress) GbrCleanseMatchMatch {
	typ := GbrCleanseMatchMatchTypeWelshPafAddress

	return GbrCleanseMatchMatch{
		WelshPafAddress: &welshPafAddress,
		Type:            typ,
	}
}

func (u *GbrCleanseMatchMatch) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	pafAddress := new(PafAddress)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&pafAddress); err == nil {
		u.PafAddress = pafAddress
		u.Type = GbrCleanseMatchMatchTypePafAddress
		return nil
	}

	mrAddress := new(MrAddress)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&mrAddress); err == nil {
		u.MrAddress = mrAddress
		u.Type = GbrCleanseMatchMatchTypeMrAddress
		return nil
	}

	nybAddress := new(NybAddress)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&nybAddress); err == nil {
		u.NybAddress = nybAddress
		u.Type = GbrCleanseMatchMatchTypeNybAddress
		return nil
	}

	pafAliasAddress := new(PafAliasAddress)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&pafAliasAddress); err == nil {
		u.PafAliasAddress = pafAliasAddress
		u.Type = GbrCleanseMatchMatchTypePafAliasAddress
		return nil
	}

	welshPafAddress := new(WelshPafAddress)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&welshPafAddress); err == nil {
		u.WelshPafAddress = welshPafAddress
		u.Type = GbrCleanseMatchMatchTypeWelshPafAddress
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GbrCleanseMatchMatch) MarshalJSON() ([]byte, error) {
	if u.PafAddress != nil {
		return json.Marshal(u.PafAddress)
	}

	if u.MrAddress != nil {
		return json.Marshal(u.MrAddress)
	}

	if u.NybAddress != nil {
		return json.Marshal(u.NybAddress)
	}

	if u.PafAliasAddress != nil {
		return json.Marshal(u.PafAliasAddress)
	}

	if u.WelshPafAddress != nil {
		return json.Marshal(u.WelshPafAddress)
	}

	return nil, nil
}

// GbrCleanseMatchOrganisationMatchEnum - Match indicator for the organisation
type GbrCleanseMatchOrganisationMatchEnum string

const (
	GbrCleanseMatchOrganisationMatchEnumFull      GbrCleanseMatchOrganisationMatchEnum = "FULL"
	GbrCleanseMatchOrganisationMatchEnumPartial   GbrCleanseMatchOrganisationMatchEnum = "PARTIAL"
	GbrCleanseMatchOrganisationMatchEnumIncorrect GbrCleanseMatchOrganisationMatchEnum = "INCORRECT"
	GbrCleanseMatchOrganisationMatchEnumMissing   GbrCleanseMatchOrganisationMatchEnum = "MISSING"
	GbrCleanseMatchOrganisationMatchEnumNa        GbrCleanseMatchOrganisationMatchEnum = "NA"
)

func (e *GbrCleanseMatchOrganisationMatchEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FULL":
		fallthrough
	case "PARTIAL":
		fallthrough
	case "INCORRECT":
		fallthrough
	case "MISSING":
		fallthrough
	case "NA":
		*e = GbrCleanseMatchOrganisationMatchEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GbrCleanseMatchOrganisationMatchEnum: %s", s)
	}
}

// GbrCleanseMatchPostTownMatchEnum - Match indicator for the post_town
type GbrCleanseMatchPostTownMatchEnum string

const (
	GbrCleanseMatchPostTownMatchEnumFull      GbrCleanseMatchPostTownMatchEnum = "FULL"
	GbrCleanseMatchPostTownMatchEnumPartial   GbrCleanseMatchPostTownMatchEnum = "PARTIAL"
	GbrCleanseMatchPostTownMatchEnumIncorrect GbrCleanseMatchPostTownMatchEnum = "INCORRECT"
	GbrCleanseMatchPostTownMatchEnumMissing   GbrCleanseMatchPostTownMatchEnum = "MISSING"
	GbrCleanseMatchPostTownMatchEnumNa        GbrCleanseMatchPostTownMatchEnum = "NA"
)

func (e *GbrCleanseMatchPostTownMatchEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FULL":
		fallthrough
	case "PARTIAL":
		fallthrough
	case "INCORRECT":
		fallthrough
	case "MISSING":
		fallthrough
	case "NA":
		*e = GbrCleanseMatchPostTownMatchEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GbrCleanseMatchPostTownMatchEnum: %s", s)
	}
}

// GbrCleanseMatchPostcodeMatchEnum - Match indicator for the postcode
type GbrCleanseMatchPostcodeMatchEnum string

const (
	GbrCleanseMatchPostcodeMatchEnumFull      GbrCleanseMatchPostcodeMatchEnum = "FULL"
	GbrCleanseMatchPostcodeMatchEnumPartial   GbrCleanseMatchPostcodeMatchEnum = "PARTIAL"
	GbrCleanseMatchPostcodeMatchEnumIncorrect GbrCleanseMatchPostcodeMatchEnum = "INCORRECT"
	GbrCleanseMatchPostcodeMatchEnumMissing   GbrCleanseMatchPostcodeMatchEnum = "MISSING"
	GbrCleanseMatchPostcodeMatchEnumNa        GbrCleanseMatchPostcodeMatchEnum = "NA"
)

func (e *GbrCleanseMatchPostcodeMatchEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FULL":
		fallthrough
	case "PARTIAL":
		fallthrough
	case "INCORRECT":
		fallthrough
	case "MISSING":
		fallthrough
	case "NA":
		*e = GbrCleanseMatchPostcodeMatchEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GbrCleanseMatchPostcodeMatchEnum: %s", s)
	}
}

// GbrCleanseMatchPremiseMatchEnum - Match indicator for the premise
type GbrCleanseMatchPremiseMatchEnum string

const (
	GbrCleanseMatchPremiseMatchEnumFull      GbrCleanseMatchPremiseMatchEnum = "FULL"
	GbrCleanseMatchPremiseMatchEnumPartial   GbrCleanseMatchPremiseMatchEnum = "PARTIAL"
	GbrCleanseMatchPremiseMatchEnumIncorrect GbrCleanseMatchPremiseMatchEnum = "INCORRECT"
	GbrCleanseMatchPremiseMatchEnumMissing   GbrCleanseMatchPremiseMatchEnum = "MISSING"
	GbrCleanseMatchPremiseMatchEnumNa        GbrCleanseMatchPremiseMatchEnum = "NA"
)

func (e *GbrCleanseMatchPremiseMatchEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FULL":
		fallthrough
	case "PARTIAL":
		fallthrough
	case "INCORRECT":
		fallthrough
	case "MISSING":
		fallthrough
	case "NA":
		*e = GbrCleanseMatchPremiseMatchEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GbrCleanseMatchPremiseMatchEnum: %s", s)
	}
}

// GbrCleanseMatchThoroughfareMatchEnum - Match indicator for the street
type GbrCleanseMatchThoroughfareMatchEnum string

const (
	GbrCleanseMatchThoroughfareMatchEnumFull      GbrCleanseMatchThoroughfareMatchEnum = "FULL"
	GbrCleanseMatchThoroughfareMatchEnumPartial   GbrCleanseMatchThoroughfareMatchEnum = "PARTIAL"
	GbrCleanseMatchThoroughfareMatchEnumIncorrect GbrCleanseMatchThoroughfareMatchEnum = "INCORRECT"
	GbrCleanseMatchThoroughfareMatchEnumMissing   GbrCleanseMatchThoroughfareMatchEnum = "MISSING"
	GbrCleanseMatchThoroughfareMatchEnumNa        GbrCleanseMatchThoroughfareMatchEnum = "NA"
)

func (e *GbrCleanseMatchThoroughfareMatchEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "FULL":
		fallthrough
	case "PARTIAL":
		fallthrough
	case "INCORRECT":
		fallthrough
	case "MISSING":
		fallthrough
	case "NA":
		*e = GbrCleanseMatchThoroughfareMatchEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for GbrCleanseMatchThoroughfareMatchEnum: %s", s)
	}
}

type GbrCleanseMatch struct {
	// A confidence score represented as number between 1 and 0. 1 indicates a full match. 0 indicates no complete matching elements.
	//
	Confidence float64 `json:"confidence"`
	// The number of addresses we matched to the input. We return the closest match by default.
	//
	Count float64 `json:"count"`
	// A score represented as number between 1 and 0. Fit compares the address elements present in your query against the matching address elements. It does not incorporate elements you have not presented in the score. A partial address (e.g. 12 Pye Green Road) will have a fit of 1 even though it is missing post town and postcode. Its confidence score will be less than 1 however because it is missing some crucial elements.
	//
	Fit float64 `json:"fit"`
	// Match indicator for the locality
	LocalityMatch GbrCleanseMatchLocalityMatchEnum `json:"locality_match"`
	// Nearest matching address
	Match GbrCleanseMatchMatch `json:"match"`
	// Match indicator for the organisation
	OrganisationMatch GbrCleanseMatchOrganisationMatchEnum `json:"organisation_match"`
	// Match indicator for the post_town
	PostTownMatch GbrCleanseMatchPostTownMatchEnum `json:"post_town_match"`
	// Match indicator for the postcode
	PostcodeMatch GbrCleanseMatchPostcodeMatchEnum `json:"postcode_match"`
	// Match indicator for the premise
	PremiseMatch GbrCleanseMatchPremiseMatchEnum `json:"premise_match"`
	// Originally submitted query
	Query string `json:"query"`
	// Match indicator for the street
	ThoroughfareMatch GbrCleanseMatchThoroughfareMatchEnum `json:"thoroughfare_match"`
}
