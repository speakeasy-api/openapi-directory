/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  /**
   * Sandbox server for integrators
   */
  "https://sandbox.gerermesaffaires.com/api/v1/",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * Sécurisez vos données en interfaçant votre logiciel métier avec le service en ligne GererMesAffaires
 *
 * @see {@link https://api.gerermesaffaires.com/} - Documentation fonctionnelle des API GererMesAffaires
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * Remove a customer space from partner
   */
  deleteBusinessGroupsIdSpacesSpaceId(
    req: operations.DeleteBusinessGroupsIdSpacesSpaceIdRequest,
    security: operations.DeleteBusinessGroupsIdSpacesSpaceIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBusinessGroupsIdSpacesSpaceIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBusinessGroupsIdSpacesSpaceIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/business-groups/{id}/spaces/{spaceId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteBusinessGroupsIdSpacesSpaceIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBusinessGroupsIdSpacesSpaceIdResponse =
        new operations.DeleteBusinessGroupsIdSpacesSpaceIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Space (only space not delivered to customer)
   */
  deleteSpacesId(
    req: operations.DeleteSpacesIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdResponse =
        new operations.DeleteSpacesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a contact detail for a company entity
   */
  deleteSpacesIdCompanyEntitiesPersonIdDetailsDesignation(
    req: operations.DeleteSpacesIdCompanyEntitiesPersonIdDetailsDesignationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdCompanyEntitiesPersonIdDetailsDesignationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesIdCompanyEntitiesPersonIdDetailsDesignationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities/{personId}/details/{designation}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdCompanyEntitiesPersonIdDetailsDesignationResponse =
        new operations.DeleteSpacesIdCompanyEntitiesPersonIdDetailsDesignationResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete access to a folder for a group
   */
  deleteSpacesIdGroupsGroupIdFoldersFolderId(
    req: operations.DeleteSpacesIdGroupsGroupIdFoldersFolderIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdGroupsGroupIdFoldersFolderIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesIdGroupsGroupIdFoldersFolderIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/{groupId}/folders/{folderId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdGroupsGroupIdFoldersFolderIdResponse =
        new operations.DeleteSpacesIdGroupsGroupIdFoldersFolderIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a person of a group
   */
  deleteSpacesIdGroupsGroupIdPersonsMemberId(
    req: operations.DeleteSpacesIdGroupsGroupIdPersonsMemberIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdGroupsGroupIdPersonsMemberIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesIdGroupsGroupIdPersonsMemberIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/{groupId}/persons/{memberId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdGroupsGroupIdPersonsMemberIdResponse =
        new operations.DeleteSpacesIdGroupsGroupIdPersonsMemberIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a person
   */
  deleteSpacesIdPersonsPersonId(
    req: operations.DeleteSpacesIdPersonsPersonIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdPersonsPersonIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesIdPersonsPersonIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdPersonsPersonIdResponse =
        new operations.DeleteSpacesIdPersonsPersonIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a contact detail for a person
   */
  deleteSpacesIdPersonsPersonIdDetailsDesignation(
    req: operations.DeleteSpacesIdPersonsPersonIdDetailsDesignationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdPersonsPersonIdDetailsDesignationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesIdPersonsPersonIdDetailsDesignationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/details/{designation}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdPersonsPersonIdDetailsDesignationResponse =
        new operations.DeleteSpacesIdPersonsPersonIdDetailsDesignationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a status of the space
   */
  deleteSpacesIdStatusCode(
    req: operations.DeleteSpacesIdStatusCodeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdStatusCodeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesIdStatusCodeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/status/{code}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdStatusCodeResponse =
        new operations.DeleteSpacesIdStatusCodeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a trigger for the space id
   */
  deleteSpacesIdTriggersName(
    req: operations.DeleteSpacesIdTriggersNameRequest,
    security: operations.DeleteSpacesIdTriggersNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesIdTriggersNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesIdTriggersNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/triggers/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSpacesIdTriggersNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesIdTriggersNameResponse =
        new operations.DeleteSpacesIdTriggersNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a common folder
   */
  deleteSpacesSpaceIdCommonFoldersId(
    req: operations.DeleteSpacesSpaceIdCommonFoldersIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdCommonFoldersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdCommonFoldersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/common-folders/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdCommonFoldersIdResponse =
        new operations.DeleteSpacesSpaceIdCommonFoldersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a bank statement
   */
  deleteSpacesSpaceIdFoldersFolderIdBankStatementsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/bank-statements/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a contractual document
   */
  deleteSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/contractual-documents/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a corporate tax declaration
   */
  deleteSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/corporate-tax-declarations/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete an expense proof
   */
  deleteSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/expense-proofs/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete an expense report
   */
  deleteSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/expense-reports/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete an invoice document
   */
  deleteSpacesSpaceIdFoldersFolderIdInvoicesDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/invoices/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a tax declaration
   */
  deleteSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/other-taxes/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a payroll
   */
  deleteSpacesSpaceIdFoldersFolderIdPayrollsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/payrolls/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a payslip
   */
  deleteSpacesSpaceIdFoldersFolderIdPayslipsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/payslips/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a social contract
   */
  deleteSpacesSpaceIdFoldersFolderIdSocialContractsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/social-contracts/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a social declaration
   */
  deleteSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/social-declarations/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a VAT declaration
   */
  deleteSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/vat-declarations/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete an AccountingYear
   */
  deleteSpacesSpaceIdFoldersIdAccountingYear(
    req: operations.DeleteSpacesSpaceIdFoldersIdAccountingYearRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdAccountingYearResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdAccountingYearRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/accounting-year",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdAccountingYearResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdAccountingYearResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Bank data
   */
  deleteSpacesSpaceIdFoldersIdBank(
    req: operations.DeleteSpacesSpaceIdFoldersIdBankRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdBankResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdBankRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/bank",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdBankResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdBankResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a customer
   */
  deleteSpacesSpaceIdFoldersIdCustomer(
    req: operations.DeleteSpacesSpaceIdFoldersIdCustomerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdCustomerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdCustomerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/customer",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdCustomerResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdCustomerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Employee data
   */
  deleteSpacesSpaceIdFoldersIdEmployee(
    req: operations.DeleteSpacesSpaceIdFoldersIdEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/employee",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdEmployeeResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Insurance data
   */
  deleteSpacesSpaceIdFoldersIdInsurance(
    req: operations.DeleteSpacesSpaceIdFoldersIdInsuranceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdInsuranceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdInsuranceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/insurance",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdInsuranceResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdInsuranceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and Loan data
   */
  deleteSpacesSpaceIdFoldersIdLoan(
    req: operations.DeleteSpacesSpaceIdFoldersIdLoanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdLoanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdLoanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/loan",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdLoanResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdLoanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a password
   */
  deleteSpacesSpaceIdFoldersIdPasswordsPasswordId(
    req: operations.DeleteSpacesSpaceIdFoldersIdPasswordsPasswordIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersIdPasswordsPasswordIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/passwords/{passwordId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a nominative social declaration in a folder social
   */
  deleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclaration(
    req: operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationRequest,
    security: operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payrolls/{payrollId}/nominative-social-declaration",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a secondary portfolio of a customer contract
   */
  deleteSpacesSpaceIdFoldersIdPortfolioPortfolioId(
    req: operations.DeleteSpacesSpaceIdFoldersIdPortfolioPortfolioIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdPortfolioPortfolioIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersIdPortfolioPortfolioIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/portfolio/{portfolioId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdPortfolioPortfolioIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdPortfolioPortfolioIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a Professional Vehicle
   */
  deleteSpacesSpaceIdFoldersIdProfessionalVehicle(
    req: operations.DeleteSpacesSpaceIdFoldersIdProfessionalVehicleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdProfessionalVehicleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersIdProfessionalVehicleRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/professional-vehicle",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdProfessionalVehicleResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdProfessionalVehicleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a provider
   */
  deleteSpacesSpaceIdFoldersIdProvider(
    req: operations.DeleteSpacesSpaceIdFoldersIdProviderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdProviderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdProviderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/provider",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdProviderResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdProviderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a document from a required document
   */
  deleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentId(
    req: operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdRequest,
    security: operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}/documents/{documentId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidDocumentsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a social regime
   */
  deleteSpacesSpaceIdFoldersIdSocialRegimes(
    req: operations.DeleteSpacesSpaceIdFoldersIdSocialRegimesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdSocialRegimesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdSocialRegimesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-regimes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdSocialRegimesResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdSocialRegimesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a Folder (except Name, Class, ModificationDate and ArchivalDate) and tax contract data
   */
  deleteSpacesSpaceIdFoldersIdTaxContract(
    req: operations.DeleteSpacesSpaceIdFoldersIdTaxContractRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdTaxContractResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdTaxContractRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/tax-contract",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdTaxContractResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdTaxContractResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete a class document
   */
  deleteSpacesSpaceIdFoldersIdDocumentClass(
    req: operations.DeleteSpacesSpaceIdFoldersIdDocumentClassRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdFoldersIdDocumentClassResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdFoldersIdDocumentClassRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/{documentClass}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdFoldersIdDocumentClassResponse =
        new operations.DeleteSpacesSpaceIdFoldersIdDocumentClassResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete the invitation of a person in a space
   */
  deleteSpacesSpaceIdPersonsIdGuestInSpace(
    req: operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceRequest,
    security: operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/guest-in-space",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceResponse =
        new operations.DeleteSpacesSpaceIdPersonsIdGuestInSpaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * delete the invitation of a person in a space
   */
  deleteSpacesSpaceIdPersonsIdInvitation(
    req: operations.DeleteSpacesSpaceIdPersonsIdInvitationRequest,
    security: operations.DeleteSpacesSpaceIdPersonsIdInvitationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSpacesSpaceIdPersonsIdInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSpacesSpaceIdPersonsIdInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/invitation",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteSpacesSpaceIdPersonsIdInvitationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSpacesSpaceIdPersonsIdInvitationResponse =
        new operations.DeleteSpacesSpaceIdPersonsIdInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Returns predefined folders and workbooks of the Box for all the spaces
   */
  getBoxMenus(
    config?: AxiosRequestConfig
  ): Promise<operations.GetBoxMenusResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/box/menus";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBoxMenusResponse =
        new operations.GetBoxMenusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBoxMenus200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetBoxMenus200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of groups custom ordered by name
   */
  getBusinessGroups(
    req: operations.GetBusinessGroupsRequest,
    security: operations.GetBusinessGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBusinessGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBusinessGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/business-groups";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBusinessGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBusinessGroupsResponse =
        new operations.GetBusinessGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBusinessGroups200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getBusinessGroups200ApplicationJSONAllOfs = utils.objectToClass(
              httpRes?.data,
              shared.BusinessGroup,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of groups custom for managers
   */
  getBusinessGroupsAll(
    req: operations.GetBusinessGroupsAllRequest,
    security: operations.GetBusinessGroupsAllSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBusinessGroupsAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBusinessGroupsAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/business-groups/all";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBusinessGroupsAllSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBusinessGroupsAllResponse =
        new operations.GetBusinessGroupsAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBusinessGroupsAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getBusinessGroupsAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.BusinessGroup,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a group
   */
  getBusinessGroupsId(
    req: operations.GetBusinessGroupsIdRequest,
    security: operations.GetBusinessGroupsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBusinessGroupsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBusinessGroupsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/business-groups/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBusinessGroupsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBusinessGroupsIdResponse =
        new operations.GetBusinessGroupsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBusinessGroupsId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetBusinessGroupsId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns spaces of the business group with id
   */
  getBusinessGroupsIdSpaces(
    req: operations.GetBusinessGroupsIdSpacesRequest,
    security: operations.GetBusinessGroupsIdSpacesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBusinessGroupsIdSpacesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBusinessGroupsIdSpacesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/business-groups/{id}/spaces",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetBusinessGroupsIdSpacesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBusinessGroupsIdSpacesResponse =
        new operations.GetBusinessGroupsIdSpacesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBusinessGroupsIdSpaces200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getBusinessGroupsIdSpaces200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetBusinessGroupsIdSpaces200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns predefined folders and workbooks of the Hub for all the spaces of the business group
   */
  getHubBusinessGroupsIdMenus(
    req: operations.GetHubBusinessGroupsIdMenusRequest,
    security: operations.GetHubBusinessGroupsIdMenusSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHubBusinessGroupsIdMenusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHubBusinessGroupsIdMenusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hub/business-groups/{Id}/menus",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetHubBusinessGroupsIdMenusSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHubBusinessGroupsIdMenusResponse =
        new operations.GetHubBusinessGroupsIdMenusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getHubBusinessGroupsIdMenus200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetHubBusinessGroupsIdMenus200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns predefined folders and workbooks of the Hub for all the spaces
   */
  getHubMenus(
    config?: AxiosRequestConfig
  ): Promise<operations.GetHubMenusResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hub/menus";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHubMenusResponse =
        new operations.GetHubMenusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getHubMenus200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetHubMenus200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns predefined folders and workbooks of the Hub for all the spaces and customer spaces
   */
  getHubMenusAll(
    config?: AxiosRequestConfig
  ): Promise<operations.GetHubMenusAllResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hub/menus/all";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHubMenusAllResponse =
        new operations.GetHubMenusAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getHubMenusAll200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetHubMenusAll200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns predefined folders and workbooks of the Hub for the space
   */
  getHubSpacesSpaceIdMenus(
    req: operations.GetHubSpacesSpaceIdMenusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHubSpacesSpaceIdMenusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHubSpacesSpaceIdMenusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hub/spaces/{spaceId}/menus",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHubSpacesSpaceIdMenusResponse =
        new operations.GetHubSpacesSpaceIdMenusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getHubSpacesSpaceIdMenus200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetHubSpacesSpaceIdMenus200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns predefined entries
   */
  getMenus(config?: AxiosRequestConfig): Promise<operations.GetMenusResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/menus";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMenusResponse = new operations.GetMenusResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getMenus200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetMenus200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns status of member
   */
  getProfile(
    req: operations.GetProfileRequest,
    security: operations.GetProfileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProfileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProfileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetProfileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProfileResponse =
        new operations.GetProfileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProfile200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetProfile200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns status of member
   */
  getProfileIdFile(
    req: operations.GetProfileIdFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProfileIdFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProfileIdFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile/id-file";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProfileIdFileResponse =
        new operations.GetProfileIdFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProfileIdFile200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetProfileIdFile200ApplicationJSON
            );
          }
          if (utils.matchContentType(contentType, `multipart/form-data`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the method to get the validation code or the link to register after invitation
   */
  getRegistration(
    req: operations.GetRegistrationRequest,
    security: operations.GetRegistrationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRegistrationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRegistrationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/registration";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetRegistrationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRegistrationResponse =
        new operations.GetRegistrationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRegistration200ApplicationJSONOneOf = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns member id of user logged
   */
  getSession(
    config?: AxiosRequestConfig
  ): Promise<operations.GetSessionResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/session";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSessionResponse =
        new operations.GetSessionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.session = utils.objectToClass(httpRes?.data, shared.Session);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns spaces of my group
   */
  getSpaces(
    req: operations.GetSpacesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/spaces";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesResponse =
        new operations.GetSpacesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpaces200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpaces200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.GetSpaces200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all spaces
   */
  getSpacesAll(
    req: operations.GetSpacesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/spaces/all";

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesAllResponse =
        new operations.GetSpacesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesAll200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesAll200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.GetSpacesAll200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a space
   */
  getSpacesId(
    req: operations.GetSpacesIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdResponse =
        new operations.GetSpacesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesId200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetSpacesId200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of accounting years for the space {id}
   */
  getSpacesIdAccountingYear(
    req: operations.GetSpacesIdAccountingYearRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdAccountingYearResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdAccountingYearRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/accounting-year",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdAccountingYearResponse =
        new operations.GetSpacesIdAccountingYearResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdAccountingYear200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdAccountingYear200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdAccountingYear200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of collective decisions for the space {id}
   */
  getSpacesIdCollectiveDecision(
    req: operations.GetSpacesIdCollectiveDecisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdCollectiveDecisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdCollectiveDecisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/collective-decision",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdCollectiveDecisionResponse =
        new operations.GetSpacesIdCollectiveDecisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdCollectiveDecision200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdCollectiveDecision200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdCollectiveDecision200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of company entities
   */
  getSpacesIdCompanyEntities(
    req: operations.GetSpacesIdCompanyEntitiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdCompanyEntitiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdCompanyEntitiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdCompanyEntitiesResponse =
        new operations.GetSpacesIdCompanyEntitiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdCompanyEntities200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdCompanyEntities200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.CompanyEntity,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of company entities even company entities archived
   */
  getSpacesIdCompanyEntitiesAll(
    req: operations.GetSpacesIdCompanyEntitiesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdCompanyEntitiesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdCompanyEntitiesAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdCompanyEntitiesAllResponse =
        new operations.GetSpacesIdCompanyEntitiesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdCompanyEntitiesAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdCompanyEntitiesAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.CompanyEntity,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a compay entity
   */
  getSpacesIdCompanyEntitiesCompanyId(
    req: operations.GetSpacesIdCompanyEntitiesCompanyIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdCompanyEntitiesCompanyIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdCompanyEntitiesCompanyIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities/{companyId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdCompanyEntitiesCompanyIdResponse =
        new operations.GetSpacesIdCompanyEntitiesCompanyIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.companyEntity = utils.objectToClass(
              httpRes?.data,
              shared.CompanyEntity
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all details of a company entity
   */
  getSpacesIdCompanyEntitiesPersonIdDetails(
    req: operations.GetSpacesIdCompanyEntitiesPersonIdDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdCompanyEntitiesPersonIdDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdCompanyEntitiesPersonIdDetailsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities/{personId}/details",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdCompanyEntitiesPersonIdDetailsResponse =
        new operations.GetSpacesIdCompanyEntitiesPersonIdDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdCompanyEntitiesPersonIdDetails200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdCompanyEntitiesPersonIdDetails200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdCompanyEntitiesPersonIdDetails200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * return the access of a person in a customer contract
   */
  getSpacesIdFoldersFolderIdPersonsMemberId(
    req: operations.GetSpacesIdFoldersFolderIdPersonsMemberIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdFoldersFolderIdPersonsMemberIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdFoldersFolderIdPersonsMemberIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/folders/{folderId}/persons/{memberId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdFoldersFolderIdPersonsMemberIdResponse =
        new operations.GetSpacesIdFoldersFolderIdPersonsMemberIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdFoldersFolderIdPersonsMemberId200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdFoldersFolderIdPersonsMemberId200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdFoldersFolderIdPersonsMemberId200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of groups
   */
  getSpacesIdGroups(
    req: operations.GetSpacesIdGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/groups", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdGroupsResponse =
        new operations.GetSpacesIdGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdGroups200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdGroups200ApplicationJSONAllOfs = utils.objectToClass(
              httpRes?.data,
              shared.Group,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of groups even archived of the space
   */
  getSpacesIdGroupsAll(
    req: operations.GetSpacesIdGroupsAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdGroupsAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdGroupsAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdGroupsAllResponse =
        new operations.GetSpacesIdGroupsAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdGroupsAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdGroupsAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Group, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a group
   */
  getSpacesIdGroupsGroupId(
    req: operations.GetSpacesIdGroupsGroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdGroupsGroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdGroupsGroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/{groupId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdGroupsGroupIdResponse =
        new operations.GetSpacesIdGroupsGroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdGroupsGroupId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdGroupsGroupId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns legal information of a space (except private)
   */
  getSpacesIdLegal(
    req: operations.GetSpacesIdLegalRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdLegalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdLegalRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/legal", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdLegalResponse =
        new operations.GetSpacesIdLegalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.legal = utils.objectToClass(httpRes?.data, shared.Legal);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a space with the logo
   */
  getSpacesIdLogo(
    req: operations.GetSpacesIdLogoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdLogoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdLogoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/logo", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdLogoResponse =
        new operations.GetSpacesIdLogoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.space = utils.objectToClass(httpRes?.data, shared.Space);
          }
          if (utils.matchContentType(contentType, `multipart/form-data`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of persons
   */
  getSpacesIdPersons(
    req: operations.GetSpacesIdPersonsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/persons", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsResponse =
        new operations.GetSpacesIdPersonsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersons200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdPersons200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Person, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of persons even persons archived
   */
  getSpacesIdPersonsAll(
    req: operations.GetSpacesIdPersonsAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsAllResponse =
        new operations.GetSpacesIdPersonsAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersonsAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdPersonsAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Person, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a person
   */
  getSpacesIdPersonsPersonId(
    req: operations.GetSpacesIdPersonsPersonIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsPersonIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsPersonIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsPersonIdResponse =
        new operations.GetSpacesIdPersonsPersonIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersonsPersonId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdPersonsPersonId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all details of a person
   */
  getSpacesIdPersonsPersonIdDetails(
    req: operations.GetSpacesIdPersonsPersonIdDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsPersonIdDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsPersonIdDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/details",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsPersonIdDetailsResponse =
        new operations.GetSpacesIdPersonsPersonIdDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersonsPersonIdDetails200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdPersonsPersonIdDetails200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdPersonsPersonIdDetails200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of folders with exceptionnal access of the person personId
   */
  getSpacesIdPersonsPersonIdFolders(
    req: operations.GetSpacesIdPersonsPersonIdFoldersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsPersonIdFoldersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsPersonIdFoldersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/folders",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsPersonIdFoldersResponse =
        new operations.GetSpacesIdPersonsPersonIdFoldersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersonsPersonIdFolders200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdPersonsPersonIdFolders200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Folder, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of groups of the person personId
   */
  getSpacesIdPersonsPersonIdGroups(
    req: operations.GetSpacesIdPersonsPersonIdGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsPersonIdGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsPersonIdGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/groups",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsPersonIdGroupsResponse =
        new operations.GetSpacesIdPersonsPersonIdGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersonsPersonIdGroups200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdPersonsPersonIdGroups200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Group, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of portfolios of the person personId
   */
  getSpacesIdPersonsPersonIdPortfolios(
    req: operations.GetSpacesIdPersonsPersonIdPortfoliosRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdPersonsPersonIdPortfoliosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdPersonsPersonIdPortfoliosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/portfolios",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdPersonsPersonIdPortfoliosResponse =
        new operations.GetSpacesIdPersonsPersonIdPortfoliosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdPersonsPersonIdPortfolios200ApplicationJSONAnies =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdPersonsPersonIdPortfolios200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdPersonsPersonIdPortfolios200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of professionalvehicles for the space {id}
   */
  getSpacesIdProfessionalVehicles(
    req: operations.GetSpacesIdProfessionalVehiclesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdProfessionalVehiclesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdProfessionalVehiclesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/professional-vehicles",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdProfessionalVehiclesResponse =
        new operations.GetSpacesIdProfessionalVehiclesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdProfessionalVehicles200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdProfessionalVehicles200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdProfessionalVehicles200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns state of activation of logs
   */
  getSpacesIdSettingsNf203Logs(
    req: operations.GetSpacesIdSettingsNf203LogsRequest,
    security: operations.GetSpacesIdSettingsNf203LogsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdSettingsNf203LogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdSettingsNf203LogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/settings/nf203/logs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSpacesIdSettingsNf203LogsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdSettingsNf203LogsResponse =
        new operations.GetSpacesIdSettingsNf203LogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdSettingsNf203Logs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdSettingsNf203Logs200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all status of the space
   */
  getSpacesIdStatus(
    req: operations.GetSpacesIdStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/status", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdStatusResponse =
        new operations.GetSpacesIdStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdStatus200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdStatus200ApplicationJSONAllOfs = utils.objectToClass(
              httpRes?.data,
              operations.GetSpacesIdStatus200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of tax contracts for the space {id}
   */
  getSpacesIdTaxContracts(
    req: operations.GetSpacesIdTaxContractsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdTaxContractsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdTaxContractsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/tax-contracts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdTaxContractsResponse =
        new operations.GetSpacesIdTaxContractsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdTaxContracts200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdTaxContracts200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesIdTaxContracts200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of triggers for the space {id}
   */
  getSpacesIdTriggers(
    req: operations.GetSpacesIdTriggersRequest,
    security: operations.GetSpacesIdTriggersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesIdTriggersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesIdTriggersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/triggers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetSpacesIdTriggersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesIdTriggersResponse =
        new operations.GetSpacesIdTriggersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesIdTriggers200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesIdTriggers200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Trigger, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the company entity
   */
  getSpacesSpaceIdCompanyEntitiesIdFollowUps(
    req: operations.GetSpacesSpaceIdCompanyEntitiesIdFollowUpsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdCompanyEntitiesIdFollowUpsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdCompanyEntitiesIdFollowUpsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/company-entities/{id}/follow-ups",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdCompanyEntitiesIdFollowUpsResponse =
        new operations.GetSpacesSpaceIdCompanyEntitiesIdFollowUpsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdCompanyEntitiesIdFollowUps200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdCompanyEntitiesIdFollowUps200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Folder, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and customer data
   */
  getSpacesSpaceIdCustomers(
    req: operations.GetSpacesSpaceIdCustomersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdCustomersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdCustomersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/customers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdCustomersResponse =
        new operations.GetSpacesSpaceIdCustomersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdCustomers200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdCustomers200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Customer,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and customer data (even archived)
   */
  getSpacesSpaceIdCustomersAll(
    req: operations.GetSpacesSpaceIdCustomersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdCustomersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdCustomersAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/customers/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdCustomersAllResponse =
        new operations.GetSpacesSpaceIdCustomersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdCustomersAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdCustomersAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Customer,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns documents of the folder
   */
  getSpacesSpaceIdDocuments(
    req: operations.GetSpacesSpaceIdDocumentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsResponse =
        new operations.GetSpacesSpaceIdDocumentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocuments200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdDocuments200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocuments200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * read the data of a document
   */
  getSpacesSpaceIdDocumentsDocumentIdExtend(
    req: operations.GetSpacesSpaceIdDocumentsDocumentIdExtendRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsDocumentIdExtendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsDocumentIdExtendRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/extend",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsDocumentIdExtendResponse =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdExtendResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsDocumentIdExtend200ApplicationJSONAnies =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdDocumentsDocumentIdExtend200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsDocumentIdExtend200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns versions of the document
   */
  getSpacesSpaceIdDocumentsDocumentIdFolders(
    req: operations.GetSpacesSpaceIdDocumentsDocumentIdFoldersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsDocumentIdFoldersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsDocumentIdFoldersRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/folders",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsDocumentIdFoldersResponse =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdFoldersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsDocumentIdFolders200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsDocumentIdFolders200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * returns the number of pages and the price of the pdf to send by mail
   */
  getSpacesSpaceIdDocumentsDocumentIdMailingprice(
    req: operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceRequest,
    security: operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/mailingprice",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceResponse =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdMailingpriceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsDocumentIdMailingprice200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsDocumentIdMailingprice200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns versions of the document
   */
  getSpacesSpaceIdDocumentsDocumentIdVersions(
    req: operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/versions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsResponse =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsDocumentIdVersions200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdDocumentsDocumentIdVersions200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Document,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns current version of the document
   */
  getSpacesSpaceIdDocumentsDocumentIdVersionsCurrent(
    req: operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsCurrentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsCurrentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsCurrentRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/versions/current",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsCurrentResponse =
        new operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsCurrentResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsDocumentIdVersionsCurrent200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsDocumentIdVersionsCurrent200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns accesses of one document
   */
  getSpacesSpaceIdDocumentsIdAccess(
    req: operations.GetSpacesSpaceIdDocumentsIdAccessRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsIdAccessResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsIdAccessRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{id}/access",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsIdAccessResponse =
        new operations.GetSpacesSpaceIdDocumentsIdAccessResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsIdAccess200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsIdAccess200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the document with the accounting property
   */
  getSpacesSpaceIdDocumentsIdAccounting(
    req: operations.GetSpacesSpaceIdDocumentsIdAccountingRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsIdAccountingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsIdAccountingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{id}/accounting",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsIdAccountingResponse =
        new operations.GetSpacesSpaceIdDocumentsIdAccountingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsIdAccounting200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsIdAccounting200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns content of one document
   */
  getSpacesSpaceIdDocumentsIdDownload(
    req: operations.GetSpacesSpaceIdDocumentsIdDownloadRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdDocumentsIdDownloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdDocumentsIdDownloadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{id}/download",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdDocumentsIdDownloadResponse =
        new operations.GetSpacesSpaceIdDocumentsIdDownloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `multipart/form-data`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdDocumentsIdDownload200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdDocumentsIdDownload200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folders with Id and employee data
   */
  getSpacesSpaceIdEmployees(
    req: operations.GetSpacesSpaceIdEmployeesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdEmployeesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdEmployeesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/employees",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdEmployeesResponse =
        new operations.GetSpacesSpaceIdEmployeesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdEmployees200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdEmployees200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Employee,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folders with Id and employee data (even archived)
   */
  getSpacesSpaceIdEmployeesAll(
    req: operations.GetSpacesSpaceIdEmployeesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdEmployeesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdEmployeesAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/employees/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdEmployeesAllResponse =
        new operations.GetSpacesSpaceIdEmployeesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdEmployeesAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdEmployeesAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Employee,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folders with Id and employer data
   */
  getSpacesSpaceIdEmployers(
    req: operations.GetSpacesSpaceIdEmployersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdEmployersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdEmployersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/employers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdEmployersResponse =
        new operations.GetSpacesSpaceIdEmployersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdEmployers200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdEmployers200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Employee,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folders with Id and employer data (even archived)
   */
  getSpacesSpaceIdEmployersAll(
    req: operations.GetSpacesSpaceIdEmployersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdEmployersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdEmployersAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/employers/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdEmployersAllResponse =
        new operations.GetSpacesSpaceIdEmployersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdEmployersAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdEmployersAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Employee,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * read the data of a space
   */
  getSpacesSpaceIdExtend(
    req: operations.GetSpacesSpaceIdExtendRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdExtendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdExtendRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/extend",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdExtendResponse =
        new operations.GetSpacesSpaceIdExtendResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdExtend200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdExtend200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folders of the space
   */
  getSpacesSpaceIdFolders(
    req: operations.GetSpacesSpaceIdFoldersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersResponse =
        new operations.GetSpacesSpaceIdFoldersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFolders200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFolders200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Folder, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folders of the space (even archived)
   */
  getSpacesSpaceIdFoldersAll(
    req: operations.GetSpacesSpaceIdFoldersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersAllResponse =
        new operations.GetSpacesSpaceIdFoldersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Folder, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * get a nominative social declaration
   */
  getSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentId(
    req: operations.GetSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/nominative-social-declarations/{documentId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentIdResponse =
        new operations.GetSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersFolderIdNominativeSocialDeclarationsDocumentId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id
   */
  getSpacesSpaceIdFoldersId(
    req: operations.GetSpacesSpaceIdFoldersIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdResponse =
        new operations.GetSpacesSpaceIdFoldersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns accountings documents of the folder (results and taxation or accountingyear)
   */
  getSpacesSpaceIdFoldersIdAccountings(
    req: operations.GetSpacesSpaceIdFoldersIdAccountingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdAccountingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdAccountingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/accountings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdAccountingsResponse =
        new operations.GetSpacesSpaceIdFoldersIdAccountingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdAccountings200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdAccountings200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Accounting,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * journal of accountings document delivered to a customer
   */
  getSpacesSpaceIdFoldersIdAccountingsJournal(
    req: operations.GetSpacesSpaceIdFoldersIdAccountingsJournalRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdAccountingsJournalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdAccountingsJournalRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/accountings-journal",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdAccountingsJournalResponse =
        new operations.GetSpacesSpaceIdFoldersIdAccountingsJournalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdAccountingsJournal200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdAccountingsJournal200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdAccountingsJournal200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and bank data
   */
  getSpacesSpaceIdFoldersIdBank(
    req: operations.GetSpacesSpaceIdFoldersIdBankRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdBankResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdBankRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/bank",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdBankResponse =
        new operations.GetSpacesSpaceIdFoldersIdBankResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.bank = utils.objectToClass(httpRes?.data, shared.Bank);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns bank statements of the folder bank
   */
  getSpacesSpaceIdFoldersIdBankStatements(
    req: operations.GetSpacesSpaceIdFoldersIdBankStatementsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdBankStatementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdBankStatementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/bank-statements",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdBankStatementsResponse =
        new operations.GetSpacesSpaceIdFoldersIdBankStatementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdBankStatements200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdBankStatements200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.BankStatement,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns common folders of a folder
   */
  getSpacesSpaceIdFoldersIdCommonFolders(
    req: operations.GetSpacesSpaceIdFoldersIdCommonFoldersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdCommonFoldersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdCommonFoldersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/common-folders",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdCommonFoldersResponse =
        new operations.GetSpacesSpaceIdFoldersIdCommonFoldersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdCommonFolders200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdCommonFolders200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Folder, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns common folders (even archived) of a folder
   */
  getSpacesSpaceIdFoldersIdCommonFoldersAll(
    req: operations.GetSpacesSpaceIdFoldersIdCommonFoldersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdCommonFoldersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdCommonFoldersAllRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/common-folders/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdCommonFoldersAllResponse =
        new operations.GetSpacesSpaceIdFoldersIdCommonFoldersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdCommonFoldersAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdCommonFoldersAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Folder, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all contracting partners of a contract
   */
  getSpacesSpaceIdFoldersIdContractingPartner(
    req: operations.GetSpacesSpaceIdFoldersIdContractingPartnerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdContractingPartnerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdContractingPartnerRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/contracting-partner",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdContractingPartnerResponse =
        new operations.GetSpacesSpaceIdFoldersIdContractingPartnerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdContractingPartner200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdContractingPartner200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdContractingPartner200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns collector space of a contract
   */
  getSpacesSpaceIdFoldersIdContractingPartnerSpace(
    req: operations.GetSpacesSpaceIdFoldersIdContractingPartnerSpaceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdContractingPartnerSpaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdFoldersIdContractingPartnerSpaceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/contracting-partner/space",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdContractingPartnerSpaceResponse =
        new operations.GetSpacesSpaceIdFoldersIdContractingPartnerSpaceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdContractingPartnerSpace200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdContractingPartnerSpace200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdContractingPartnerSpace200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns documents of the folder
   */
  getSpacesSpaceIdFoldersIdContractualDocuments(
    req: operations.GetSpacesSpaceIdFoldersIdContractualDocumentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdContractualDocumentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdContractualDocumentsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/contractual-documents",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdContractualDocumentsResponse =
        new operations.GetSpacesSpaceIdFoldersIdContractualDocumentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdContractualDocuments200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdContractualDocuments200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.ContractualDocument,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and contractual-relationship data
   */
  getSpacesSpaceIdFoldersIdContractualRelationship(
    req: operations.GetSpacesSpaceIdFoldersIdContractualRelationshipRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdContractualRelationshipResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdFoldersIdContractualRelationshipRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/contractual-relationship",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdContractualRelationshipResponse =
        new operations.GetSpacesSpaceIdFoldersIdContractualRelationshipResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.contractualRelationship = utils.objectToClass(
              httpRes?.data,
              shared.ContractualRelationship
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns corporate tax declarations
   */
  getSpacesSpaceIdFoldersIdCoporateTaxDeclarations(
    req: operations.GetSpacesSpaceIdFoldersIdCoporateTaxDeclarationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdCoporateTaxDeclarationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdFoldersIdCoporateTaxDeclarationsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/coporate-tax-declarations",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdCoporateTaxDeclarationsResponse =
        new operations.GetSpacesSpaceIdFoldersIdCoporateTaxDeclarationsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdCoporateTaxDeclarations200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdCoporateTaxDeclarations200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.CorporateTaxDeclaration,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and customer data
   */
  getSpacesSpaceIdFoldersIdCustomer(
    req: operations.GetSpacesSpaceIdFoldersIdCustomerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdCustomerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdCustomerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/customer",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdCustomerResponse =
        new operations.GetSpacesSpaceIdFoldersIdCustomerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdCustomer200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdCustomer200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * journal of documents delivered to a customer
   */
  getSpacesSpaceIdFoldersIdDeliveriesJournal(
    req: operations.GetSpacesSpaceIdFoldersIdDeliveriesJournalRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdDeliveriesJournalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdDeliveriesJournalRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/deliveries-journal",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdDeliveriesJournalResponse =
        new operations.GetSpacesSpaceIdFoldersIdDeliveriesJournalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdDeliveriesJournal200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdDeliveriesJournal200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdDeliveriesJournal200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns documents of the folder
   */
  getSpacesSpaceIdFoldersIdDocuments(
    req: operations.GetSpacesSpaceIdFoldersIdDocumentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdDocumentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdDocumentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/documents",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdDocumentsResponse =
        new operations.GetSpacesSpaceIdFoldersIdDocumentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdDocuments200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdDocuments200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Document,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and employee data
   */
  getSpacesSpaceIdFoldersIdEmployee(
    req: operations.GetSpacesSpaceIdFoldersIdEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/employee",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdEmployeeResponse =
        new operations.GetSpacesSpaceIdFoldersIdEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.employee = utils.objectToClass(httpRes?.data, shared.Employee);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns expense proofs of the folder (social, followup or exchange)
   */
  getSpacesSpaceIdFoldersIdExpenseProofs(
    req: operations.GetSpacesSpaceIdFoldersIdExpenseProofsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdExpenseProofsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdExpenseProofsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-proofs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdExpenseProofsResponse =
        new operations.GetSpacesSpaceIdFoldersIdExpenseProofsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdExpenseProofs200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdExpenseProofs200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.ExpenseProof,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns expense reports of the folder (social or followup)
   */
  getSpacesSpaceIdFoldersIdExpenseReports(
    req: operations.GetSpacesSpaceIdFoldersIdExpenseReportsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdExpenseReportsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdExpenseReportsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-reports",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdExpenseReportsResponse =
        new operations.GetSpacesSpaceIdFoldersIdExpenseReportsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdExpenseReports200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdExpenseReports200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.ExpenseReport,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns expense proofs linked to the expenseReportId
   */
  getSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofs(
    req: operations.GetSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-reports/{expenseReportId}/expense-proofs",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofsResponse =
        new operations.GetSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofs200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdExpenseReportsExpenseReportIdExpenseProofs200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.ExpenseProof,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and insurance data
   */
  getSpacesSpaceIdFoldersIdInsurance(
    req: operations.GetSpacesSpaceIdFoldersIdInsuranceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdInsuranceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdInsuranceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/insurance",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdInsuranceResponse =
        new operations.GetSpacesSpaceIdFoldersIdInsuranceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.insurance = utils.objectToClass(
              httpRes?.data,
              shared.Insurance
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns invoices of the folder (customer, provider, accountingyear or root folders customers or providers)
   */
  getSpacesSpaceIdFoldersIdInvoices(
    req: operations.GetSpacesSpaceIdFoldersIdInvoicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdInvoicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdInvoicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/invoices",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdInvoicesResponse =
        new operations.GetSpacesSpaceIdFoldersIdInvoicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdInvoices200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdInvoices200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Invoice, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns legal entity of a follow up folder
   */
  getSpacesSpaceIdFoldersIdLegalEntity(
    req: operations.GetSpacesSpaceIdFoldersIdLegalEntityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdLegalEntityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdLegalEntityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/legal-entity",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdLegalEntityResponse =
        new operations.GetSpacesSpaceIdFoldersIdLegalEntityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdLegalEntity200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdLegalEntity200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and loan data
   */
  getSpacesSpaceIdFoldersIdLoan(
    req: operations.GetSpacesSpaceIdFoldersIdLoanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdLoanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdLoanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/loan",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdLoanResponse =
        new operations.GetSpacesSpaceIdFoldersIdLoanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.loan = utils.objectToClass(httpRes?.data, shared.Loan);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns messages of the folder
   */
  getSpacesSpaceIdFoldersIdMessages(
    req: operations.GetSpacesSpaceIdFoldersIdMessagesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdMessagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdMessagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/messages",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdMessagesResponse =
        new operations.GetSpacesSpaceIdFoldersIdMessagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdMessages200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdMessages200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Message, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns message with Id
   */
  getSpacesSpaceIdFoldersIdMessagesMessageId(
    req: operations.GetSpacesSpaceIdFoldersIdMessagesMessageIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdMessagesMessageIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdMessagesMessageIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/messages/{messageId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdMessagesMessageIdResponse =
        new operations.GetSpacesSpaceIdFoldersIdMessagesMessageIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdMessagesMessageId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdMessagesMessageId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns nominative social declarations of the folder social
   */
  getSpacesSpaceIdFoldersIdNominativeSocialDeclarations(
    req: operations.GetSpacesSpaceIdFoldersIdNominativeSocialDeclarationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdNominativeSocialDeclarationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdFoldersIdNominativeSocialDeclarationsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/nominative-social-declarations",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdNominativeSocialDeclarationsResponse =
        new operations.GetSpacesSpaceIdFoldersIdNominativeSocialDeclarationsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdNominativeSocialDeclarations200ApplicationJSONAnies =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdNominativeSocialDeclarations200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdNominativeSocialDeclarations200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns other taxes declarations
   */
  getSpacesSpaceIdFoldersIdOtherTaxes(
    req: operations.GetSpacesSpaceIdFoldersIdOtherTaxesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdOtherTaxesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdOtherTaxesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/other-taxes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdOtherTaxesResponse =
        new operations.GetSpacesSpaceIdFoldersIdOtherTaxesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdOtherTaxes200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdOtherTaxes200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.OtherTax,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns identifiers/passwords of the folder
   */
  getSpacesSpaceIdFoldersIdPasswords(
    req: operations.GetSpacesSpaceIdFoldersIdPasswordsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdPasswordsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdPasswordsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/passwords",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdPasswordsResponse =
        new operations.GetSpacesSpaceIdFoldersIdPasswordsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdPasswords200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdPasswords200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdPasswords200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns password with Id
   */
  getSpacesSpaceIdFoldersIdPasswordsPasswordId(
    req: operations.GetSpacesSpaceIdFoldersIdPasswordsPasswordIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdPasswordsPasswordIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/passwords/{passwordId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse =
        new operations.GetSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdPasswordsPasswordId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdPasswordsPasswordId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns payrolls of the folder social
   */
  getSpacesSpaceIdFoldersIdPayrolls(
    req: operations.GetSpacesSpaceIdFoldersIdPayrollsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdPayrollsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdPayrollsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payrolls",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdPayrollsResponse =
        new operations.GetSpacesSpaceIdFoldersIdPayrollsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdPayrolls200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdPayrolls200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Payroll, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns payslips of the folder employee
   */
  getSpacesSpaceIdFoldersIdPayslips(
    req: operations.GetSpacesSpaceIdFoldersIdPayslipsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdPayslipsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdPayslipsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payslips",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdPayslipsResponse =
        new operations.GetSpacesSpaceIdFoldersIdPayslipsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdPayslips200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdPayslips200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.PaySlip, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and provider data
   */
  getSpacesSpaceIdFoldersIdProvider(
    req: operations.GetSpacesSpaceIdFoldersIdProviderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdProviderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdProviderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/provider",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdProviderResponse =
        new operations.GetSpacesSpaceIdFoldersIdProviderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.provider = utils.objectToClass(httpRes?.data, shared.Provider);
          }
          break;
      }

      return res;
    });
  }

  /**
   * list of the required documents for a person
   */
  getSpacesSpaceIdFoldersIdRequiredDocuments(
    req: operations.GetSpacesSpaceIdFoldersIdRequiredDocumentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdRequiredDocumentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdRequiredDocumentsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/required-documents",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdRequiredDocumentsResponse =
        new operations.GetSpacesSpaceIdFoldersIdRequiredDocumentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdRequiredDocuments200ApplicationJSONObjects =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdRequiredDocuments200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdRequiredDocuments200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns sections of the folder
   */
  getSpacesSpaceIdFoldersIdSections(
    req: operations.GetSpacesSpaceIdFoldersIdSectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdSectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdSectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/sections",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdSectionsResponse =
        new operations.GetSpacesSpaceIdFoldersIdSectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdSections200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdSections200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdSections200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns social contracts of the folder employee
   */
  getSpacesSpaceIdFoldersIdSocialContracts(
    req: operations.GetSpacesSpaceIdFoldersIdSocialContractsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdSocialContractsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdSocialContractsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-contracts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdSocialContractsResponse =
        new operations.GetSpacesSpaceIdFoldersIdSocialContractsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdSocialContracts200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdSocialContracts200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SocialContract,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns social declarations
   */
  getSpacesSpaceIdFoldersIdSocialDeclarations(
    req: operations.GetSpacesSpaceIdFoldersIdSocialDeclarationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdSocialDeclarationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdSocialDeclarationsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-declarations",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdSocialDeclarationsResponse =
        new operations.GetSpacesSpaceIdFoldersIdSocialDeclarationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdSocialDeclarations200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdSocialDeclarations200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SocialDeclaration,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and social regime data
   */
  getSpacesSpaceIdFoldersIdSocialRegimes(
    req: operations.GetSpacesSpaceIdFoldersIdSocialRegimesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdSocialRegimesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdSocialRegimesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-regimes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdSocialRegimesResponse =
        new operations.GetSpacesSpaceIdFoldersIdSocialRegimesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.socialRegime = utils.objectToClass(
              httpRes?.data,
              shared.SocialRegime
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns sum of invoices of the folder (customer, provider, accountingyear or root folders customers or providers)
   */
  getSpacesSpaceIdFoldersIdSumInvoices(
    req: operations.GetSpacesSpaceIdFoldersIdSumInvoicesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdSumInvoicesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdSumInvoicesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/sum-invoices",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdSumInvoicesResponse =
        new operations.GetSpacesSpaceIdFoldersIdSumInvoicesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdSumInvoices200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdFoldersIdSumInvoices200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns vat declarations
   */
  getSpacesSpaceIdFoldersIdVatDeclarations(
    req: operations.GetSpacesSpaceIdFoldersIdVatDeclarationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdVatDeclarationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdVatDeclarationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/vat-declarations",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdVatDeclarationsResponse =
        new operations.GetSpacesSpaceIdFoldersIdVatDeclarationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdVatDeclarations200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdVatDeclarations200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.VATDeclaration,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns document of documentClass (without specific data) of the folder
   */
  getSpacesSpaceIdFoldersIdDocumentClass(
    req: operations.GetSpacesSpaceIdFoldersIdDocumentClassRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdFoldersIdDocumentClassResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdFoldersIdDocumentClassRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/{documentClass}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdFoldersIdDocumentClassResponse =
        new operations.GetSpacesSpaceIdFoldersIdDocumentClassResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdFoldersIdDocumentClass200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdFoldersIdDocumentClass200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Document,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of bank folders for a legal-entity
   */
  getSpacesSpaceIdLegalEntitiesIdBanks(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdBanksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdBanksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdBanksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/banks",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdBanksResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdBanksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdBanks200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdBanks200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Bank, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the banks even archived
   */
  getSpacesSpaceIdLegalEntitiesIdBanksAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdBanksAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdBanksAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdBanksAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/banks/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdBanksAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdBanksAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdBanksAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdBanksAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Bank, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all contract folders of the legal entity
   */
  getSpacesSpaceIdLegalEntitiesIdContracts(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdContractsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdContractsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdContractsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/contracts",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdContractsResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdContractsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdContracts200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdContracts200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Contract,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the others contract with legal entity
   */
  getSpacesSpaceIdLegalEntitiesIdContractualRelationships(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/contractual-relationships",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdContractualRelationships200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdContractualRelationships200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.ContractualRelationship,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the others contract with legal entity (even archived)
   */
  getSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAllRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/contractual-relationships/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAllResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdContractualRelationshipsAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.ContractualRelationship,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the customer
   */
  getSpacesSpaceIdLegalEntitiesIdCustomers(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdCustomersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdCustomersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdCustomersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/customers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdCustomersResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdCustomersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdCustomers200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdCustomers200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Customer,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the customers (even archived)
   */
  getSpacesSpaceIdLegalEntitiesIdCustomersAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdCustomersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdCustomersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdCustomersAllRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/customers/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdCustomersAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdCustomersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdCustomersAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdCustomersAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Customer,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of insurance folders for a legal-entity
   */
  getSpacesSpaceIdLegalEntitiesIdInsurances(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/insurances",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdInsurances200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdInsurances200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Insurance,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the insurances even archived
   */
  getSpacesSpaceIdLegalEntitiesIdInsurancesAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesAllRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/insurances/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdInsurancesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdInsurancesAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdInsurancesAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Insurance,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the loan
   */
  getSpacesSpaceIdLegalEntitiesIdLoans(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdLoansRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdLoansResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdLoansRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/loans",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdLoansResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdLoansResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdLoans200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdLoans200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Loan, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the loans even archived
   */
  getSpacesSpaceIdLegalEntitiesIdLoansAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdLoansAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdLoansAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdLoansAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/loans/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdLoansAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdLoansAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdLoansAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdLoansAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Loan, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of providers folders for a legal-entity
   */
  getSpacesSpaceIdLegalEntitiesIdProviders(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdProvidersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/providers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdProvidersResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdProviders200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdProviders200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Provider,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the providers even archived
   */
  getSpacesSpaceIdLegalEntitiesIdProvidersAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdProvidersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdProvidersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdProvidersAllRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/providers/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdProvidersAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdProvidersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdProvidersAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdProvidersAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Provider,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of social regimes folders for a legal-entity
   */
  getSpacesSpaceIdLegalEntitiesIdSocialRegimes(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/social-regimes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdSocialRegimes200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdSocialRegimes200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SocialRegime,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the social regimes even archived
   */
  getSpacesSpaceIdLegalEntitiesIdSocialRegimesAll(
    req: operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesAllRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/social-regimes/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesAllResponse =
        new operations.GetSpacesSpaceIdLegalEntitiesIdSocialRegimesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLegalEntitiesIdSocialRegimesAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLegalEntitiesIdSocialRegimesAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SocialRegime,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of all loan folders of the space
   */
  getSpacesSpaceIdLoans(
    req: operations.GetSpacesSpaceIdLoansRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLoansResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLoansRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/loans",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLoansResponse =
        new operations.GetSpacesSpaceIdLoansResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLoans200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLoans200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Loan, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns list of all loan folders even archived of the space
   */
  getSpacesSpaceIdLoansAll(
    req: operations.GetSpacesSpaceIdLoansAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdLoansAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdLoansAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/loans/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdLoansAllResponse =
        new operations.GetSpacesSpaceIdLoansAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdLoansAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdLoansAll200ApplicationJSONAllOfs =
              utils.objectToClass(httpRes?.data, shared.Loan, resFieldDepth);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the employee
   */
  getSpacesSpaceIdPersonsIdEmployees(
    req: operations.GetSpacesSpaceIdPersonsIdEmployeesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdPersonsIdEmployeesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdPersonsIdEmployeesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/employees",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdPersonsIdEmployeesResponse =
        new operations.GetSpacesSpaceIdPersonsIdEmployeesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdPersonsIdEmployees200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdPersonsIdEmployees200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Employee,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of all employees (even archived)
   */
  getSpacesSpaceIdPersonsIdEmployeesAll(
    req: operations.GetSpacesSpaceIdPersonsIdEmployeesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdPersonsIdEmployeesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdPersonsIdEmployeesAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/employees/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdPersonsIdEmployeesAllResponse =
        new operations.GetSpacesSpaceIdPersonsIdEmployeesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdPersonsIdEmployeesAll200ApplicationJSONAllOfs =
              [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdPersonsIdEmployeesAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Employee,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder exchange of the person
   */
  getSpacesSpaceIdPersonsIdExchange(
    req: operations.GetSpacesSpaceIdPersonsIdExchangeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdPersonsIdExchangeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdPersonsIdExchangeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/exchange",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdPersonsIdExchangeResponse =
        new operations.GetSpacesSpaceIdPersonsIdExchangeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdPersonsIdExchange200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdPersonsIdExchange200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder of the person
   */
  getSpacesSpaceIdPersonsIdFollowUps(
    req: operations.GetSpacesSpaceIdPersonsIdFollowUpsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdPersonsIdFollowUpsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdPersonsIdFollowUpsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/follow-ups",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdPersonsIdFollowUpsResponse =
        new operations.GetSpacesSpaceIdPersonsIdFollowUpsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.followUp = utils.objectToClass(httpRes?.data, shared.FollowUp);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns invitation of a person
   */
  getSpacesSpaceIdPersonsIdInvitation(
    req: operations.GetSpacesSpaceIdPersonsIdInvitationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdPersonsIdInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdPersonsIdInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/invitation",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdPersonsIdInvitationResponse =
        new operations.GetSpacesSpaceIdPersonsIdInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `*/*`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folderId with the access of the person
   */
  getSpacesSpaceIdPersonsMemberIdFoldersId(
    req: operations.GetSpacesSpaceIdPersonsMemberIdFoldersIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdPersonsMemberIdFoldersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdPersonsMemberIdFoldersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{memberId}/folders/{id}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdPersonsMemberIdFoldersIdResponse =
        new operations.GetSpacesSpaceIdPersonsMemberIdFoldersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdPersonsMemberIdFoldersId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetSpacesSpaceIdPersonsMemberIdFoldersId200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and provider data
   */
  getSpacesSpaceIdProviders(
    req: operations.GetSpacesSpaceIdProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdProvidersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/providers",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdProvidersResponse =
        new operations.GetSpacesSpaceIdProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdProviders200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdProviders200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Provider,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and provider data (even archived)
   */
  getSpacesSpaceIdProvidersAll(
    req: operations.GetSpacesSpaceIdProvidersAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdProvidersAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdProvidersAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/providers/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdProvidersAllResponse =
        new operations.GetSpacesSpaceIdProvidersAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdProvidersAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdProvidersAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.Provider,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and social regime data
   */
  getSpacesSpaceIdSocialRegimes(
    req: operations.GetSpacesSpaceIdSocialRegimesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdSocialRegimesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdSocialRegimesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/social-regimes",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdSocialRegimesResponse =
        new operations.GetSpacesSpaceIdSocialRegimesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdSocialRegimes200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdSocialRegimes200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SocialRegime,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns folder with Id and social regime data (even archived)
   */
  getSpacesSpaceIdSocialRegimesAll(
    req: operations.GetSpacesSpaceIdSocialRegimesAllRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdSocialRegimesAllResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdSocialRegimesAllRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/social-regimes/all",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdSocialRegimesAllResponse =
        new operations.GetSpacesSpaceIdSocialRegimesAllResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdSocialRegimesAll200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdSocialRegimesAll200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SocialRegime,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns CSV Invoicings of the spaces for the account of the spaceId
   */
  getSpacesSpaceIdSpacesInvoicings(
    req: operations.GetSpacesSpaceIdSpacesInvoicingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSpacesSpaceIdSpacesInvoicingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSpacesSpaceIdSpacesInvoicingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/spaces-invoicings",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSpacesSpaceIdSpacesInvoicingsResponse =
        new operations.GetSpacesSpaceIdSpacesInvoicingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSpacesSpaceIdSpacesInvoicings200ApplicationJSONAllOfs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.getSpacesSpaceIdSpacesInvoicings200ApplicationJSONAllOfs =
              utils.objectToClass(
                httpRes?.data,
                shared.SpacesInvoicing,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies an object
   */
  patchBusinessGroups(
    req: operations.PatchBusinessGroupsRequestBody,
    security: operations.PatchBusinessGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchBusinessGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchBusinessGroupsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/business-groups";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchBusinessGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchBusinessGroupsResponse =
        new operations.PatchBusinessGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify email of profile
   */
  patchProfileEmail(
    req: any,
    security: operations.PatchProfileEmailSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchProfileEmailResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile/email";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchProfileEmailSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchProfileEmailResponse =
        new operations.PatchProfileEmailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify mobile of profile
   */
  patchProfileMobile(
    req: any,
    security: operations.PatchProfileMobileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchProfileMobileResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile/mobile";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchProfileMobileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchProfileMobileResponse =
        new operations.PatchProfileMobileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify infos of profile
   */
  patchProfileJson(
    req: operations.PatchProfileApplicationJSON,
    security: operations.PatchProfileJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchProfileJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchProfileApplicationJSON(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchProfileJsonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchProfileJsonResponse =
        new operations.PatchProfileJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify infos of profile
   */
  patchProfileMultipart(
    req: operations.PatchProfileMultipartFormData1,
    security: operations.PatchProfileMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchProfileMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchProfileMultipartFormData1(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchProfileMultipartSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchProfileMultipartResponse =
        new operations.PatchProfileMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Space (except private)
   */
  patchSpacesId(
    req: operations.PatchSpacesIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdResponse =
        new operations.PatchSpacesIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a company entity
   */
  patchSpacesIdCompanyEntitiesCompanyId(
    req: operations.PatchSpacesIdCompanyEntitiesCompanyIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdCompanyEntitiesCompanyIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdCompanyEntitiesCompanyIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities/{companyId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdCompanyEntitiesCompanyIdResponse =
        new operations.PatchSpacesIdCompanyEntitiesCompanyIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Add/Modify/Delete a person in a customer contract (except manager)
   */
  patchSpacesIdFoldersFolderIdPersonsMemberId(
    req: operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/folders/{folderId}/persons/{memberId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdResponse =
        new operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * open an access
   */
  patchSpacesIdFoldersFolderIdPersonsMemberIdActiveaccess(
    req: operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdActiveaccessRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdActiveaccessResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdActiveaccessRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/folders/{folderId}/persons/{memberId}/activeaccess",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdActiveaccessResponse =
        new operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdActiveaccessResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * close an access
   */
  patchSpacesIdFoldersFolderIdPersonsMemberIdUnactiveaccess(
    req: operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdUnactiveaccessRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdUnactiveaccessResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdUnactiveaccessRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/folders/{folderId}/persons/{memberId}/unactiveaccess",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdUnactiveaccessResponse =
        new operations.PatchSpacesIdFoldersFolderIdPersonsMemberIdUnactiveaccessResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a group
   */
  patchSpacesIdGroupsGroupId(
    req: operations.PatchSpacesIdGroupsGroupIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdGroupsGroupIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdGroupsGroupIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/{groupId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdGroupsGroupIdResponse =
        new operations.PatchSpacesIdGroupsGroupIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Add access to a folder for a group
   */
  patchSpacesIdGroupsGroupIdFoldersFolderId(
    req: operations.PatchSpacesIdGroupsGroupIdFoldersFolderIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdGroupsGroupIdFoldersFolderIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdGroupsGroupIdFoldersFolderIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/{groupId}/folders/{folderId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdGroupsGroupIdFoldersFolderIdResponse =
        new operations.PatchSpacesIdGroupsGroupIdFoldersFolderIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Add a person to a group
   */
  patchSpacesIdGroupsGroupIdPersonsMemberId(
    req: operations.PatchSpacesIdGroupsGroupIdPersonsMemberIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdGroupsGroupIdPersonsMemberIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdGroupsGroupIdPersonsMemberIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/groups/{groupId}/persons/{memberId}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdGroupsGroupIdPersonsMemberIdResponse =
        new operations.PatchSpacesIdGroupsGroupIdPersonsMemberIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify legal information of a Space (except private)
   */
  patchSpacesIdLegal(
    req: operations.PatchSpacesIdLegalRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdLegalResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdLegalRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/legal", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "legal",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdLegalResponse =
        new operations.PatchSpacesIdLegalResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify the role of a person
   */
  patchSpacesIdPersonsMemberIdPlayer(
    req: operations.PatchSpacesIdPersonsMemberIdPlayerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdPersonsMemberIdPlayerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdPersonsMemberIdPlayerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{memberId}/player",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdPersonsMemberIdPlayerResponse =
        new operations.PatchSpacesIdPersonsMemberIdPlayerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a person
   */
  patchSpacesIdPersonsPersonId(
    req: operations.PatchSpacesIdPersonsPersonIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdPersonsPersonIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesIdPersonsPersonIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdPersonsPersonIdResponse =
        new operations.PatchSpacesIdPersonsPersonIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Add/Modify/Delete a person in a portfolio (except manager)
   */
  patchSpacesIdPortfoliosPortfolioIdPersonsMemberId(
    req: operations.PatchSpacesIdPortfoliosPortfolioIdPersonsMemberIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesIdPortfoliosPortfolioIdPersonsMemberIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesIdPortfoliosPortfolioIdPersonsMemberIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/portfolios/{portfolioId}/persons/{memberId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesIdPortfoliosPortfolioIdPersonsMemberIdResponse =
        new operations.PatchSpacesIdPortfoliosPortfolioIdPersonsMemberIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a common folder
   */
  patchSpacesSpaceIdCommonFoldersId(
    req: operations.PatchSpacesSpaceIdCommonFoldersIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdCommonFoldersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdCommonFoldersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/common-folders/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdCommonFoldersIdResponse =
        new operations.PatchSpacesSpaceIdCommonFoldersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a doc
   */
  patchSpacesSpaceIdDocumentsDocumentId(
    req: operations.PatchSpacesSpaceIdDocumentsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdDocumentsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdDocumentsDocumentIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdDocumentsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdDocumentsDocumentIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a bank statement
   */
  patchSpacesSpaceIdFoldersFolderIdBankStatementsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/bank-statements/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdBankStatementsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a contractual document
   */
  patchSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/contractual-documents/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdContractualDocumentsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a coporate tax declaration
   */
  patchSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/corporate-tax-declarations/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdCorporateTaxDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify an expense report
   */
  patchSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/expense-proofs/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdExpenseProofsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify an expense report
   */
  patchSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/expense-reports/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdExpenseReportsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a invoice
   */
  patchSpacesSpaceIdFoldersFolderIdInvoicesDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/invoices/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdInvoicesDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify an other tax declaration
   */
  patchSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/other-taxes/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdOtherTaxesDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a payroll
   */
  patchSpacesSpaceIdFoldersFolderIdPayrollsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/payrolls/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a payslip
   */
  patchSpacesSpaceIdFoldersFolderIdPayslipsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/payslips/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdPayslipsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a social contract
   */
  patchSpacesSpaceIdFoldersFolderIdSocialContractsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/social-contracts/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdSocialContractsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a social declaration
   */
  patchSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/social-declarations/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdSocialDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify a vat declaration
   */
  patchSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentId(
    req: operations.PatchSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/vat-declarations/{documentId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdResponse =
        new operations.PatchSpacesSpaceIdFoldersFolderIdVatDeclarationsDocumentIdResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate)
   */
  patchSpacesSpaceIdFoldersId(
    req: operations.PatchSpacesSpaceIdFoldersIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdResponse =
        new operations.PatchSpacesSpaceIdFoldersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and AccountingYear data
   */
  patchSpacesSpaceIdFoldersIdAccountingYear(
    req: operations.PatchSpacesSpaceIdFoldersIdAccountingYearRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdAccountingYearResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdAccountingYearRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/accounting-year",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdAccountingYearResponse =
        new operations.PatchSpacesSpaceIdFoldersIdAccountingYearResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Bank data
   */
  patchSpacesSpaceIdFoldersIdBank(
    req: operations.PatchSpacesSpaceIdFoldersIdBankRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdBankResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdBankRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/bank",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdBankResponse =
        new operations.PatchSpacesSpaceIdFoldersIdBankResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Collective Decision data
   */
  patchSpacesSpaceIdFoldersIdCollectiveDecision(
    req: operations.PatchSpacesSpaceIdFoldersIdCollectiveDecisionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdCollectiveDecisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdCollectiveDecisionRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/collective-decision",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdCollectiveDecisionResponse =
        new operations.PatchSpacesSpaceIdFoldersIdCollectiveDecisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Customer data
   */
  patchSpacesSpaceIdFoldersIdCustomer(
    req: operations.PatchSpacesSpaceIdFoldersIdCustomerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdCustomerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdCustomerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/customer",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdCustomerResponse =
        new operations.PatchSpacesSpaceIdFoldersIdCustomerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Detach a doc of a folder
   */
  patchSpacesSpaceIdFoldersIdDocumentsDocumentIdDetach(
    req: operations.PatchSpacesSpaceIdFoldersIdDocumentsDocumentIdDetachRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdDocumentsDocumentIdDetachResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersIdDocumentsDocumentIdDetachRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/documents/{documentId}/detach",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "patch",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdDocumentsDocumentIdDetachResponse =
        new operations.PatchSpacesSpaceIdFoldersIdDocumentsDocumentIdDetachResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Employee data
   */
  patchSpacesSpaceIdFoldersIdEmployee(
    req: operations.PatchSpacesSpaceIdFoldersIdEmployeeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdEmployeeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdEmployeeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/employee",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdEmployeeResponse =
        new operations.PatchSpacesSpaceIdFoldersIdEmployeeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Insurance data
   */
  patchSpacesSpaceIdFoldersIdInsurance(
    req: operations.PatchSpacesSpaceIdFoldersIdInsuranceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdInsuranceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdInsuranceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/insurance",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdInsuranceResponse =
        new operations.PatchSpacesSpaceIdFoldersIdInsuranceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Loan data
   */
  patchSpacesSpaceIdFoldersIdLoan(
    req: operations.PatchSpacesSpaceIdFoldersIdLoanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdLoanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdLoanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/loan",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdLoanResponse =
        new operations.PatchSpacesSpaceIdFoldersIdLoanResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Message
   */
  patchSpacesSpaceIdFoldersIdMessagesMessageId(
    req: operations.PatchSpacesSpaceIdFoldersIdMessagesMessageIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdMessagesMessageIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdMessagesMessageIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/messages/{messageId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdMessagesMessageIdResponse =
        new operations.PatchSpacesSpaceIdFoldersIdMessagesMessageIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Password
   */
  patchSpacesSpaceIdFoldersIdPasswordsPasswordId(
    req: operations.PatchSpacesSpaceIdFoldersIdPasswordsPasswordIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersIdPasswordsPasswordIdRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/passwords/{passwordId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse =
        new operations.PatchSpacesSpaceIdFoldersIdPasswordsPasswordIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Professional Vehicle data
   */
  patchSpacesSpaceIdFoldersIdProfessionalVehicle(
    req: operations.PatchSpacesSpaceIdFoldersIdProfessionalVehicleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdProfessionalVehicleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersIdProfessionalVehicleRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/professional-vehicle",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdProfessionalVehicleResponse =
        new operations.PatchSpacesSpaceIdFoldersIdProfessionalVehicleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Provider data
   */
  patchSpacesSpaceIdFoldersIdProvider(
    req: operations.PatchSpacesSpaceIdFoldersIdProviderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdProviderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdProviderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/provider",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdProviderResponse =
        new operations.PatchSpacesSpaceIdFoldersIdProviderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify the status of a requireddocument
   */
  patchSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentid(
    req: operations.PatchSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PatchSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidResponse =
        new operations.PatchSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Social Regime data
   */
  patchSpacesSpaceIdFoldersIdSocialRegimes(
    req: operations.PatchSpacesSpaceIdFoldersIdSocialRegimesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdSocialRegimesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdSocialRegimesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-regimes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdSocialRegimesResponse =
        new operations.PatchSpacesSpaceIdFoldersIdSocialRegimesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify a Folder (except Name, Class, ModificationDate and ArchivalDate) and Tax Contract data
   */
  patchSpacesSpaceIdFoldersIdTaxContract(
    req: operations.PatchSpacesSpaceIdFoldersIdTaxContractRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdFoldersIdTaxContractResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdFoldersIdTaxContractRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/tax-contract",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdFoldersIdTaxContractResponse =
        new operations.PatchSpacesSpaceIdFoldersIdTaxContractResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify the invitation of a person to collect documents
   */
  patchSpacesSpaceIdPersonsIdCallForDocument(
    req: operations.PatchSpacesSpaceIdPersonsIdCallForDocumentRequest,
    security: operations.PatchSpacesSpaceIdPersonsIdCallForDocumentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdPersonsIdCallForDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdPersonsIdCallForDocumentRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/call-for-document",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "modifyCollect",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PatchSpacesSpaceIdPersonsIdCallForDocumentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdPersonsIdCallForDocumentResponse =
        new operations.PatchSpacesSpaceIdPersonsIdCallForDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * invite a person in a space
   */
  patchSpacesSpaceIdPersonsIdGuestInSpace(
    req: operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceRequest,
    security: operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/guest-in-space",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "modifyInvitation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceResponse =
        new operations.PatchSpacesSpaceIdPersonsIdGuestInSpaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * modify an invitation
   */
  patchSpacesSpaceIdPersonsIdInvitation(
    req: operations.PatchSpacesSpaceIdPersonsIdInvitationRequest,
    security: operations.PatchSpacesSpaceIdPersonsIdInvitationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdPersonsIdInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdPersonsIdInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/invitation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchSpacesSpaceIdPersonsIdInvitationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdPersonsIdInvitationResponse =
        new operations.PatchSpacesSpaceIdPersonsIdInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Modify an access
   */
  patchSpacesSpaceIdPersonsMemberIdFoldersId(
    req: operations.PatchSpacesSpaceIdPersonsMemberIdFoldersIdRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchSpacesSpaceIdPersonsMemberIdFoldersIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchSpacesSpaceIdPersonsMemberIdFoldersIdRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{memberId}/folders/{id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchSpacesSpaceIdPersonsMemberIdFoldersIdResponse =
        new operations.PatchSpacesSpaceIdPersonsMemberIdFoldersIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Adds a group (only for managers and ADN collaborators)
   */
  postBusinessGroups(
    req: operations.PostBusinessGroupsRequestBody,
    security: operations.PostBusinessGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostBusinessGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostBusinessGroupsRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/business-groups";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostBusinessGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostBusinessGroupsResponse =
        new operations.PostBusinessGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postBusinessGroups201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostBusinessGroups201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * send an invitation to manager the private space of personId
   */
  postBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpace(
    req: operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceRequest,
    security: operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/business-groups/{id}/spaces/{spaceId}/legal-entities/{personId}/customers/{folderId}/guest-in-space",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceResponse =
        new operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpaceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpace201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdGuestInSpace201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Space in a group
   */
  postBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpaces(
    req: operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesRequest,
    security: operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/business-groups/{id}/spaces/{spaceId}/legal-entities/{personId}/customers/{folderId}/spaces",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesResponse =
        new operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpacesResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpaces201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostBusinessGroupsIdSpacesSpaceIdLegalEntitiesPersonIdCustomersFolderIdSpaces201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document (this document is analyzed to be saved in the correct folder and correct space)
   */
  postHubDocumentsJson(
    req: operations.PostHubDocumentsApplicationJSON,
    security: operations.PostHubDocumentsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubDocumentsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubDocumentsApplicationJSON(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hub/documents";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubDocumentsJsonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubDocumentsJsonResponse =
        new operations.PostHubDocumentsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubDocumentsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubDocumentsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document (this document is analyzed to be saved in the correct folder and correct space)
   */
  postHubDocumentsMultipart(
    req: operations.PostHubDocumentsMultipartFormData1,
    security: operations.PostHubDocumentsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubDocumentsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubDocumentsMultipartFormData1(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hub/documents";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubDocumentsMultipartSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubDocumentsMultipartResponse =
        new operations.PostHubDocumentsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubDocumentsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubDocumentsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payslip (this document is analyzed to be saved in the correct folder and correct space)
   */
  postHubPayslipsJson(
    req: operations.PostHubPayslipsApplicationJSON,
    security: operations.PostHubPayslipsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubPayslipsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubPayslipsApplicationJSON(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hub/payslips";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubPayslipsJsonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubPayslipsJsonResponse =
        new operations.PostHubPayslipsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubPayslipsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubPayslipsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payslip (this document is analyzed to be saved in the correct folder and correct space)
   */
  postHubPayslipsMultipart(
    req: operations.PostHubPayslipsMultipartFormData1,
    security: operations.PostHubPayslipsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubPayslipsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubPayslipsMultipartFormData1(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hub/payslips";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubPayslipsMultipartSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubPayslipsMultipartResponse =
        new operations.PostHubPayslipsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubPayslipsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubPayslipsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a space (this document is analyzed to be saved in the correct folder)
   */
  postHubSpacesSpaceIdDocumentsJson(
    req: operations.PostHubSpacesSpaceIdDocumentsJsonRequest,
    security: operations.PostHubSpacesSpaceIdDocumentsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubSpacesSpaceIdDocumentsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubSpacesSpaceIdDocumentsJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hub/spaces/{spaceId}/documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubSpacesSpaceIdDocumentsJsonSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubSpacesSpaceIdDocumentsJsonResponse =
        new operations.PostHubSpacesSpaceIdDocumentsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubSpacesSpaceIdDocumentsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubSpacesSpaceIdDocumentsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a space (this document is analyzed to be saved in the correct folder)
   */
  postHubSpacesSpaceIdDocumentsMultipart(
    req: operations.PostHubSpacesSpaceIdDocumentsMultipartRequest,
    security: operations.PostHubSpacesSpaceIdDocumentsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubSpacesSpaceIdDocumentsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubSpacesSpaceIdDocumentsMultipartRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hub/spaces/{spaceId}/documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubSpacesSpaceIdDocumentsMultipartSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubSpacesSpaceIdDocumentsMultipartResponse =
        new operations.PostHubSpacesSpaceIdDocumentsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubSpacesSpaceIdDocumentsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubSpacesSpaceIdDocumentsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payslip in a space (this document is analyzed to be saved in the correct folder)
   */
  postHubSpacesSpaceIdPayslipsJson(
    req: operations.PostHubSpacesSpaceIdPayslipsJsonRequest,
    security: operations.PostHubSpacesSpaceIdPayslipsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubSpacesSpaceIdPayslipsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubSpacesSpaceIdPayslipsJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hub/spaces/{spaceId}/payslips",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubSpacesSpaceIdPayslipsJsonSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubSpacesSpaceIdPayslipsJsonResponse =
        new operations.PostHubSpacesSpaceIdPayslipsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubSpacesSpaceIdPayslipsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubSpacesSpaceIdPayslipsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payslip in a space (this document is analyzed to be saved in the correct folder)
   */
  postHubSpacesSpaceIdPayslipsMultipart(
    req: operations.PostHubSpacesSpaceIdPayslipsMultipartRequest,
    security: operations.PostHubSpacesSpaceIdPayslipsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostHubSpacesSpaceIdPayslipsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostHubSpacesSpaceIdPayslipsMultipartRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hub/spaces/{spaceId}/payslips",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostHubSpacesSpaceIdPayslipsMultipartSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostHubSpacesSpaceIdPayslipsMultipartResponse =
        new operations.PostHubSpacesSpaceIdPayslipsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postHubSpacesSpaceIdPayslipsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostHubSpacesSpaceIdPayslipsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * add a document to the target menuId
   */
  postMenusMenuIdDocumentsJson(
    req: operations.PostMenusMenuIdDocumentsJsonRequest,
    security: operations.PostMenusMenuIdDocumentsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostMenusMenuIdDocumentsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostMenusMenuIdDocumentsJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/menus/{menuId}/documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostMenusMenuIdDocumentsJsonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostMenusMenuIdDocumentsJsonResponse =
        new operations.PostMenusMenuIdDocumentsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postMenusMenuIdDocumentsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostMenusMenuIdDocumentsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * add a document to the target menuId
   */
  postMenusMenuIdDocumentsMultipart(
    req: operations.PostMenusMenuIdDocumentsMultipartRequest,
    security: operations.PostMenusMenuIdDocumentsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostMenusMenuIdDocumentsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostMenusMenuIdDocumentsMultipartRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/menus/{menuId}/documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostMenusMenuIdDocumentsMultipartSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostMenusMenuIdDocumentsMultipartResponse =
        new operations.PostMenusMenuIdDocumentsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postMenusMenuIdDocumentsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostMenusMenuIdDocumentsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * create infos of profile
   */
  postProfileJson(
    req: operations.PostProfileApplicationJSON,
    security: operations.PostProfileJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostProfileJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostProfileApplicationJSON(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostProfileJsonSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostProfileJsonResponse =
        new operations.PostProfileJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * create infos of profile
   */
  postProfileMultipart(
    req: operations.PostProfileMultipartFormData1,
    security: operations.PostProfileMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostProfileMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostProfileMultipartFormData1(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/profile";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostProfileMultipartSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostProfileMultipartResponse =
        new operations.PostProfileMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * complete the invitation
   */
  postRegistration(
    req: operations.PostRegistrationRequestBody,
    security: operations.PostRegistrationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRegistrationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRegistrationRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/registration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostRegistrationSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRegistrationResponse =
        new operations.PostRegistrationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postRegistration201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.PostRegistration201ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Space in my group
   */
  postSpaces(
    req: operations.PostSpacesRequestBody,
    security: operations.PostSpacesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/spaces";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesResponse =
        new operations.PostSpacesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpaces201ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.PostSpaces201ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a accounting year for the space id
   */
  postSpacesIdAccountingYear(
    req: operations.PostSpacesIdAccountingYearRequest,
    security: operations.PostSpacesIdAccountingYearSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdAccountingYearResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdAccountingYearRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/accounting-year",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdAccountingYearSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdAccountingYearResponse =
        new operations.PostSpacesIdAccountingYearResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdAccountingYear201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdAccountingYear201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a colletive decision for the space id
   */
  postSpacesIdCollectiveDecision(
    req: operations.PostSpacesIdCollectiveDecisionRequest,
    security: operations.PostSpacesIdCollectiveDecisionSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdCollectiveDecisionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdCollectiveDecisionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/collective-decision",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdCollectiveDecisionSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdCollectiveDecisionResponse =
        new operations.PostSpacesIdCollectiveDecisionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdCollectiveDecision201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdCollectiveDecision201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Company Entity in a Space
   */
  postSpacesIdCompanyEntities(
    req: operations.PostSpacesIdCompanyEntitiesRequest,
    security: operations.PostSpacesIdCompanyEntitiesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdCompanyEntitiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdCompanyEntitiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdCompanyEntitiesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdCompanyEntitiesResponse =
        new operations.PostSpacesIdCompanyEntitiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdCompanyEntities201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdCompanyEntities201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace or Add a contact detail for a person
   */
  postSpacesIdCompanyEntitiesPersonIdDetails(
    req: operations.PostSpacesIdCompanyEntitiesPersonIdDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdCompanyEntitiesPersonIdDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdCompanyEntitiesPersonIdDetailsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/company-entities/{personId}/details",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdCompanyEntitiesPersonIdDetailsResponse =
        new operations.PostSpacesIdCompanyEntitiesPersonIdDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * create an archive with documents
   */
  postSpacesIdDocumentsDownload(
    req: operations.PostSpacesIdDocumentsDownloadRequest,
    security: operations.PostSpacesIdDocumentsDownloadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdDocumentsDownloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdDocumentsDownloadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/documents/download",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdDocumentsDownloadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdDocumentsDownloadResponse =
        new operations.PostSpacesIdDocumentsDownloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdDocumentsDownload201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdDocumentsDownload201ApplicationJSON
              );
          }
          if (utils.matchContentType(contentType, `multipart/form-data`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * invite a owner in a space
   */
  postSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpace(
    req: operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceRequest,
    security: operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/folders/{folderId}/persons/{personId}/guest-in-space",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "invitationPerson",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceResponse =
        new operations.PostSpacesIdFoldersFolderIdPersonsPersonIdGuestInSpaceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Add a group in a Space
   */
  postSpacesIdGroups(
    req: operations.PostSpacesIdGroupsRequest,
    security: operations.PostSpacesIdGroupsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/groups", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdGroupsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdGroupsResponse =
        new operations.PostSpacesIdGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdGroups201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdGroups201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a Person in a Space
   */
  postSpacesIdPersons(
    req: operations.PostSpacesIdPersonsRequest,
    security: operations.PostSpacesIdPersonsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdPersonsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdPersonsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/persons", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdPersonsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdPersonsResponse =
        new operations.PostSpacesIdPersonsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdPersons201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdPersons201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace or Add a contact detail for a person
   */
  postSpacesIdPersonsPersonIdDetails(
    req: operations.PostSpacesIdPersonsPersonIdDetailsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdPersonsPersonIdDetailsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdPersonsPersonIdDetailsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/details",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdPersonsPersonIdDetailsResponse =
        new operations.PostSpacesIdPersonsPersonIdDetailsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Create a portfolio for the person personId
   */
  postSpacesIdPersonsPersonIdPortfolios(
    req: operations.PostSpacesIdPersonsPersonIdPortfoliosRequest,
    security: operations.PostSpacesIdPersonsPersonIdPortfoliosSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdPersonsPersonIdPortfoliosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdPersonsPersonIdPortfoliosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/persons/{personId}/portfolios",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdPersonsPersonIdPortfoliosSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdPersonsPersonIdPortfoliosResponse =
        new operations.PostSpacesIdPersonsPersonIdPortfoliosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdPersonsPersonIdPortfolios201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdPersonsPersonIdPortfolios201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a professional vehicle for the space
   */
  postSpacesIdProfessionalVehicles(
    req: operations.PostSpacesIdProfessionalVehiclesRequest,
    security: operations.PostSpacesIdProfessionalVehiclesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdProfessionalVehiclesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdProfessionalVehiclesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/professional-vehicles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdProfessionalVehiclesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdProfessionalVehiclesResponse =
        new operations.PostSpacesIdProfessionalVehiclesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdProfessionalVehicles201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdProfessionalVehicles201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enable/Disable logs
   */
  postSpacesIdSettingsNf203Logs(
    req: operations.PostSpacesIdSettingsNf203LogsRequest,
    security: operations.PostSpacesIdSettingsNf203LogsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdSettingsNf203LogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdSettingsNf203LogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/settings/nf203/logs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdSettingsNf203LogsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdSettingsNf203LogsResponse =
        new operations.PostSpacesIdSettingsNf203LogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Replace or Add a status
   */
  postSpacesIdStatus(
    req: operations.PostSpacesIdStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/spaces/{id}/status", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdStatusResponse =
        new operations.PostSpacesIdStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Create a tax contract for the space
   */
  postSpacesIdTaxContracts(
    req: operations.PostSpacesIdTaxContractsRequest,
    security: operations.PostSpacesIdTaxContractsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdTaxContractsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdTaxContractsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/tax-contracts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdTaxContractsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdTaxContractsResponse =
        new operations.PostSpacesIdTaxContractsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesIdTaxContracts201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesIdTaxContracts201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a trigger for the space id
   */
  postSpacesIdTriggersName(
    req: operations.PostSpacesIdTriggersNameRequest,
    security: operations.PostSpacesIdTriggersNameSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesIdTriggersNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesIdTriggersNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{id}/triggers/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesIdTriggersNameSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesIdTriggersNameResponse =
        new operations.PostSpacesIdTriggersNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          break;
      }

      return res;
    });
  }

  /**
   * Add a data to a document
   */
  postSpacesSpaceIdDocumentsDocumentIdExtend(
    req: operations.PostSpacesSpaceIdDocumentsDocumentIdExtendRequest,
    security: operations.PostSpacesSpaceIdDocumentsDocumentIdExtendSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdDocumentsDocumentIdExtendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdDocumentsDocumentIdExtendRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/extend",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdExtendSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdDocumentsDocumentIdExtendResponse =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdExtendResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdDocumentsDocumentIdExtend201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdDocumentsDocumentIdExtend201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * send by mail a document
   */
  postSpacesSpaceIdDocumentsDocumentIdMailing(
    req: operations.PostSpacesSpaceIdDocumentsDocumentIdMailingRequest,
    security: operations.PostSpacesSpaceIdDocumentsDocumentIdMailingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdDocumentsDocumentIdMailingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdDocumentsDocumentIdMailingRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/mailing",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdMailingSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdDocumentsDocumentIdMailingResponse =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdMailingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdDocumentsDocumentIdMailing200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdDocumentsDocumentIdMailing200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a version to a document and set it as current
   */
  postSpacesSpaceIdDocumentsDocumentIdVersionsJson(
    req: operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonRequest,
    security: operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/versions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonResponse =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJsonResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdDocumentsDocumentIdVersionsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a version to a document and set it as current
   */
  postSpacesSpaceIdDocumentsDocumentIdVersionsMultipart(
    req: operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartRequest,
    security: operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/documents/{documentId}/versions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartResponse =
        new operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdDocumentsDocumentIdVersionsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdDocumentsDocumentIdVersionsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a data to a space
   */
  postSpacesSpaceIdExtend(
    req: operations.PostSpacesSpaceIdExtendRequest,
    security: operations.PostSpacesSpaceIdExtendSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdExtendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdExtendRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/extend",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdExtendSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdExtendResponse =
        new operations.PostSpacesSpaceIdExtendResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdExtend201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdExtend201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * recalculate a payroll
   */
  postSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefresh(
    req: operations.PostSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefreshRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefreshResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefreshRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{folderId}/payrolls/{documentId}/refresh",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefreshResponse =
        new operations.PostSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefreshResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefresh201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersFolderIdPayrollsDocumentIdRefresh201ApplicationJSON
              );
          }
          break;
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Add a bank statement in a folder bank
   */
  postSpacesSpaceIdFoldersIdBankStatementsJson(
    req: operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/bank-statements",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdBankStatementsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdBankStatementsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdBankStatementsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a bank statement in a folder bank
   */
  postSpacesSpaceIdFoldersIdBankStatementsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/bank-statements",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdBankStatementsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdBankStatementsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a common folder in another folder
   */
  postSpacesSpaceIdFoldersIdCommonFolders(
    req: operations.PostSpacesSpaceIdFoldersIdCommonFoldersRequest,
    security: operations.PostSpacesSpaceIdFoldersIdCommonFoldersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdCommonFoldersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdCommonFoldersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/common-folders",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdCommonFoldersSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdCommonFoldersResponse =
        new operations.PostSpacesSpaceIdFoldersIdCommonFoldersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdCommonFolders201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdCommonFolders201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a folder
   */
  postSpacesSpaceIdFoldersIdContractualDocumentsJson(
    req: operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/contractual-documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJsonResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdContractualDocumentsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdContractualDocumentsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a folder
   */
  postSpacesSpaceIdFoldersIdContractualDocumentsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/contractual-documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdContractualDocumentsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdContractualDocumentsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a corporate tax declaration
   */
  postSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJson(
    req: operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/coporate-tax-declarations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJsonResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a corporate tax declaration
   */
  postSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/coporate-tax-declarations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdCoporateTaxDeclarationsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a folder
   */
  postSpacesSpaceIdFoldersIdDocumentsJson(
    req: operations.PostSpacesSpaceIdFoldersIdDocumentsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdDocumentsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdDocumentsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdDocumentsJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdDocumentsJsonSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdDocumentsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdDocumentsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdDocumentsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdDocumentsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a folder
   */
  postSpacesSpaceIdFoldersIdDocumentsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/documents",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdDocumentsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdDocumentsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdDocumentsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a expense proof in a folder followup or exchange
   */
  postSpacesSpaceIdFoldersIdExpenseProofsJson(
    req: operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-proofs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdExpenseProofsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdExpenseProofsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdExpenseProofsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a expense proof in a folder followup or exchange
   */
  postSpacesSpaceIdFoldersIdExpenseProofsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-proofs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdExpenseProofsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdExpenseProofsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a expense report in a folder followup
   */
  postSpacesSpaceIdFoldersIdExpenseReportsJson(
    req: operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-reports",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdExpenseReportsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdExpenseReportsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdExpenseReportsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a expense report in a folder followup
   */
  postSpacesSpaceIdFoldersIdExpenseReportsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/expense-reports",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdExpenseReportsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdExpenseReportsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a invoice in a folder of a customer or a provider
   */
  postSpacesSpaceIdFoldersIdInvoicesJson(
    req: operations.PostSpacesSpaceIdFoldersIdInvoicesJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdInvoicesJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdInvoicesJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdInvoicesJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/invoices",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdInvoicesJsonSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdInvoicesJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdInvoicesJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdInvoicesJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdInvoicesJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a invoice in a folder of a customer or a provider
   */
  postSpacesSpaceIdFoldersIdInvoicesMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/invoices",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdInvoicesMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdInvoicesMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdInvoicesMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Write a message in the journal of a folder
   */
  postSpacesSpaceIdFoldersIdMessages(
    req: operations.PostSpacesSpaceIdFoldersIdMessagesRequest,
    security: operations.PostSpacesSpaceIdFoldersIdMessagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdMessagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdMessagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/messages",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdMessagesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdMessagesResponse =
        new operations.PostSpacesSpaceIdFoldersIdMessagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Add a tax declaration
   */
  postSpacesSpaceIdFoldersIdOtherTaxesJson(
    req: operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/other-taxes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdOtherTaxesJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdOtherTaxesJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdOtherTaxesJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a tax declaration
   */
  postSpacesSpaceIdFoldersIdOtherTaxesMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/other-taxes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdOtherTaxesMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdOtherTaxesMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Write a identifier/password in aa folder
   */
  postSpacesSpaceIdFoldersIdPasswords(
    req: operations.PostSpacesSpaceIdFoldersIdPasswordsRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPasswordsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPasswordsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdPasswordsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/passwords",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdPasswordsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPasswordsResponse =
        new operations.PostSpacesSpaceIdFoldersIdPasswordsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Add a nominative social declaration in a folder social
   */
  postSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJson(
    req: operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payrolls/{payrollId}/nominative-social-declaration",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJsonResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a nominative social declaration in a folder social
   */
  postSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payrolls/{payrollId}/nominative-social-declaration",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdPayrollsPayrollIdNominativeSocialDeclarationMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payroll in a folder social
   */
  postSpacesSpaceIdFoldersIdPayrollsJson(
    req: operations.PostSpacesSpaceIdFoldersIdPayrollsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPayrollsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPayrollsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdPayrollsJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payrolls",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdPayrollsJsonSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPayrollsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdPayrollsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdPayrollsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payroll in a folder social
   */
  postSpacesSpaceIdFoldersIdPayrollsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payrolls",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdPayrollsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdPayrollsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdPayrollsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payslip in a folder employee
   */
  postSpacesSpaceIdFoldersIdPayslipsJson(
    req: operations.PostSpacesSpaceIdFoldersIdPayslipsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPayslipsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPayslipsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdPayslipsJsonRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payslips",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdFoldersIdPayslipsJsonSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPayslipsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdPayslipsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdPayslipsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdPayslipsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a payslip in a folder employee
   */
  postSpacesSpaceIdFoldersIdPayslipsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/payslips",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdPayslipsMultipartResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdPayslipsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdPayslipsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a required document to a line
   */
  postSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJson(
    req: operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJsonResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a required document to a line
   */
  postSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/required-documents/{requireddocumentid}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdRequiredDocumentsRequireddocumentidMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a social contract in a folder employee
   */
  postSpacesSpaceIdFoldersIdSocialContractsJson(
    req: operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-contracts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdSocialContractsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdSocialContractsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdSocialContractsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a social contract in a folder employee
   */
  postSpacesSpaceIdFoldersIdSocialContractsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-contracts",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdSocialContractsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdSocialContractsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a social declaration
   */
  postSpacesSpaceIdFoldersIdSocialDeclarationsJson(
    req: operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-declarations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJsonResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdSocialDeclarationsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a social declaration
   */
  postSpacesSpaceIdFoldersIdSocialDeclarationsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/social-declarations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdSocialDeclarationsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdSocialDeclarationsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a vat declaration
   */
  postSpacesSpaceIdFoldersIdVatDeclarationsJson(
    req: operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/vat-declarations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdVatDeclarationsJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdVatDeclarationsJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a vat declaration
   */
  postSpacesSpaceIdFoldersIdVatDeclarationsMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/vat-declarations",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdVatDeclarationsMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdVatDeclarationsMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a folder
   */
  postSpacesSpaceIdFoldersIdDocumentClassJson(
    req: operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonRequest,
    security: operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/{documentClass}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonResponse =
        new operations.PostSpacesSpaceIdFoldersIdDocumentClassJsonResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdDocumentClassJSON201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdDocumentClassJson201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a document in a folder
   */
  postSpacesSpaceIdFoldersIdDocumentClassMultipart(
    req: operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartRequest,
    security: operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/folders/{id}/{documentClass}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartResponse =
        new operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipartResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdFoldersIdDocumentClassMultipart201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdFoldersIdDocumentClassMultipart201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a bank
   */
  postSpacesSpaceIdLegalEntitiesIdBanks(
    req: operations.PostSpacesSpaceIdLegalEntitiesIdBanksRequest,
    security: operations.PostSpacesSpaceIdLegalEntitiesIdBanksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdLegalEntitiesIdBanksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdLegalEntitiesIdBanksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/banks",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdLegalEntitiesIdBanksSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdLegalEntitiesIdBanksResponse =
        new operations.PostSpacesSpaceIdLegalEntitiesIdBanksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdLegalEntitiesIdBanks201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdLegalEntitiesIdBanks201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a customer
   */
  postSpacesSpaceIdLegalEntitiesIdCustomers(
    req: operations.PostSpacesSpaceIdLegalEntitiesIdCustomersRequest,
    security: operations.PostSpacesSpaceIdLegalEntitiesIdCustomersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdLegalEntitiesIdCustomersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdLegalEntitiesIdCustomersRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/customers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdLegalEntitiesIdCustomersSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdLegalEntitiesIdCustomersResponse =
        new operations.PostSpacesSpaceIdLegalEntitiesIdCustomersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdLegalEntitiesIdCustomers201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdLegalEntitiesIdCustomers201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a insurance
   */
  postSpacesSpaceIdLegalEntitiesIdInsurances(
    req: operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesRequest,
    security: operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/insurances",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesResponse =
        new operations.PostSpacesSpaceIdLegalEntitiesIdInsurancesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdLegalEntitiesIdInsurances201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdLegalEntitiesIdInsurances201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a loan
   */
  postSpacesSpaceIdLegalEntitiesIdLoans(
    req: operations.PostSpacesSpaceIdLegalEntitiesIdLoansRequest,
    security: operations.PostSpacesSpaceIdLegalEntitiesIdLoansSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdLegalEntitiesIdLoansResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdLegalEntitiesIdLoansRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/loans",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdLegalEntitiesIdLoansSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdLegalEntitiesIdLoansResponse =
        new operations.PostSpacesSpaceIdLegalEntitiesIdLoansResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdLegalEntitiesIdLoans201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdLegalEntitiesIdLoans201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a provider
   */
  postSpacesSpaceIdLegalEntitiesIdProviders(
    req: operations.PostSpacesSpaceIdLegalEntitiesIdProvidersRequest,
    security: operations.PostSpacesSpaceIdLegalEntitiesIdProvidersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdLegalEntitiesIdProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdLegalEntitiesIdProvidersRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/providers",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdLegalEntitiesIdProvidersSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdLegalEntitiesIdProvidersResponse =
        new operations.PostSpacesSpaceIdLegalEntitiesIdProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdLegalEntitiesIdProviders201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdLegalEntitiesIdProviders201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a social regime
   */
  postSpacesSpaceIdLegalEntitiesIdSocialRegimes(
    req: operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesRequest,
    security: operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/legal-entities/{id}/social-regimes",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesResponse =
        new operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdLegalEntitiesIdSocialRegimes201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdLegalEntitiesIdSocialRegimes201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * invite a person to collect documents
   */
  postSpacesSpaceIdPersonsIdCallForDocument(
    req: operations.PostSpacesSpaceIdPersonsIdCallForDocumentRequest,
    security: operations.PostSpacesSpaceIdPersonsIdCallForDocumentSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdPersonsIdCallForDocumentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdPersonsIdCallForDocumentRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/call-for-document",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "callForDocument",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdPersonsIdCallForDocumentSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdPersonsIdCallForDocumentResponse =
        new operations.PostSpacesSpaceIdPersonsIdCallForDocumentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdPersonsIdCallForDocument201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdPersonsIdCallForDocument201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a folder for a employee
   */
  postSpacesSpaceIdPersonsIdEmployees(
    req: operations.PostSpacesSpaceIdPersonsIdEmployeesRequest,
    security: operations.PostSpacesSpaceIdPersonsIdEmployeesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdPersonsIdEmployeesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdPersonsIdEmployeesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/employees",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdPersonsIdEmployeesSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdPersonsIdEmployeesResponse =
        new operations.PostSpacesSpaceIdPersonsIdEmployeesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdPersonsIdEmployees201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdPersonsIdEmployees201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * invite a person in a space
   */
  postSpacesSpaceIdPersonsIdGuestInSpace(
    req: operations.PostSpacesSpaceIdPersonsIdGuestInSpaceRequest,
    security: operations.PostSpacesSpaceIdPersonsIdGuestInSpaceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdPersonsIdGuestInSpaceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdPersonsIdGuestInSpaceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/guest-in-space",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "guestInSpace",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdPersonsIdGuestInSpaceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdPersonsIdGuestInSpaceResponse =
        new operations.PostSpacesSpaceIdPersonsIdGuestInSpaceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * create an invitation in a space for a person
   */
  postSpacesSpaceIdPersonsIdInvitation(
    req: operations.PostSpacesSpaceIdPersonsIdInvitationRequest,
    security: operations.PostSpacesSpaceIdPersonsIdInvitationSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdPersonsIdInvitationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostSpacesSpaceIdPersonsIdInvitationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/invitation",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostSpacesSpaceIdPersonsIdInvitationSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdPersonsIdInvitationResponse =
        new operations.PostSpacesSpaceIdPersonsIdInvitationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdPersonsIdInvitation201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdPersonsIdInvitation201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * send the invitation of a person in a space
   */
  postSpacesSpaceIdPersonsIdInvitationInvitationIdSend(
    req: operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendRequest,
    security: operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/spaces/{spaceId}/persons/{id}/invitation/{invitationId}/send",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendResponse =
        new operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSendResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.postSpacesSpaceIdPersonsIdInvitationInvitationIdSend201ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.PostSpacesSpaceIdPersonsIdInvitationInvitationIdSend201ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
