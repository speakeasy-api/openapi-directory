<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class BillingPreviewRun 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Retrieve a billing preview run
     * 
     * Retrieves a preview of future invoice items for multiple customer accounts through a billing preview run. If you have the Invoice Settlement feature enabled,  you can also retrieve a preview of future credit memo items. The Invoice Settlement feature is generally available as of Zuora Billing Release 296 (March 2021). This feature includes Unapplied Payments, Credit and Debit Memo, and Invoice Item Settlement. If you want to enable Invoice Settlement, see [Invoice Settlement Enablement and Checklist Guide](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement/Invoice_Settlement_Migration_Checklist_and_Guide) for more information. 
     * 
     * A billing preview run asynchronously generates a downloadable CSV file containing a preview of invoice item data and credit memo item data for a batch of customer accounts.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GETBillingPreviewRunRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GETBillingPreviewRunResponse
     */
	public function getBillingPreviewRun(
        \OpenAPI\OpenAPI\Models\Operations\GETBillingPreviewRunRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GETBillingPreviewRunResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/billing-preview-runs/{billingPreviewRunId}', \OpenAPI\OpenAPI\Models\Operations\GETBillingPreviewRunRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GETBillingPreviewRunResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getBillingPreviewRunResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetBillingPreviewRunResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a billing preview run
     * 
     * Creates a billing preview run for multiple customer accounts.
     * 
     * You can run up to 20 billing preview runs in batches concurrently. A single batch of customer accounts can only have one billing preview run at a time. So you can have up to 20 batches running at the same time. If you create a billing preview run for all customer batches, you cannot create another billing preview run until this preview run is completed.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\POSTBillingPreviewRunRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\POSTBillingPreviewRunResponse
     */
	public function postBillingPreviewRun(
        \OpenAPI\OpenAPI\Models\Operations\POSTBillingPreviewRunRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\POSTBillingPreviewRunResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/billing-preview-runs');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "postBillingPreviewRunParam", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\POSTBillingPreviewRunResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json; charset=utf-8')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postBillingPreviewRun200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\POSTBillingPreviewRun200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}