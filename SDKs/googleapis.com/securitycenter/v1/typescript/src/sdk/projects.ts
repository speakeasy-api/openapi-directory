/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Filters an organization's assets and groups them by their specified properties.
   */
  securitycenterProjectsAssetsGroup(
    req: operations.SecuritycenterProjectsAssetsGroupRequest,
    security: operations.SecuritycenterProjectsAssetsGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsAssetsGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsAssetsGroupRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/assets:group",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "groupAssetsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SecuritycenterProjectsAssetsGroupSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsAssetsGroupResponse =
        new operations.SecuritycenterProjectsAssetsGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupAssetsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GroupAssetsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists an organization's assets.
   */
  securitycenterProjectsAssetsList(
    req: operations.SecuritycenterProjectsAssetsListRequest,
    security: operations.SecuritycenterProjectsAssetsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsAssetsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsAssetsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/assets", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SecuritycenterProjectsAssetsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsAssetsListResponse =
        new operations.SecuritycenterProjectsAssetsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAssetsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAssetsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a BigQuery export.
   */
  securitycenterProjectsBigQueryExportsCreate(
    req: operations.SecuritycenterProjectsBigQueryExportsCreateRequest,
    security: operations.SecuritycenterProjectsBigQueryExportsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsBigQueryExportsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsBigQueryExportsCreateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/bigQueryExports",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleCloudSecuritycenterV1BigQueryExportInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsBigQueryExportsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsBigQueryExportsCreateResponse =
        new operations.SecuritycenterProjectsBigQueryExportsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleCloudSecuritycenterV1BigQueryExport = utils.objectToClass(
              httpRes?.data,
              shared.GoogleCloudSecuritycenterV1BigQueryExport
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists BigQuery exports. Note that when requesting BigQuery exports at a given level all exports under that level are also returned e.g. if requesting BigQuery exports under a folder, then all BigQuery exports immediately under the folder plus the ones created under the projects within the folder are returned.
   */
  securitycenterProjectsBigQueryExportsList(
    req: operations.SecuritycenterProjectsBigQueryExportsListRequest,
    security: operations.SecuritycenterProjectsBigQueryExportsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsBigQueryExportsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsBigQueryExportsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/bigQueryExports",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsBigQueryExportsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsBigQueryExportsListResponse =
        new operations.SecuritycenterProjectsBigQueryExportsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBigQueryExportsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBigQueryExportsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Kicks off an LRO to bulk mute findings for a parent based on a filter. The parent can be either an organization, folder or project. The findings matched by the filter will be muted after the LRO is done.
   */
  securitycenterProjectsFindingsBulkMute(
    req: operations.SecuritycenterProjectsFindingsBulkMuteRequest,
    security: operations.SecuritycenterProjectsFindingsBulkMuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsFindingsBulkMuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsFindingsBulkMuteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/findings:bulkMute",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "bulkMuteFindingsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SecuritycenterProjectsFindingsBulkMuteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsFindingsBulkMuteResponse =
        new operations.SecuritycenterProjectsFindingsBulkMuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a mute config.
   */
  securitycenterProjectsMuteConfigsCreate(
    req: operations.SecuritycenterProjectsMuteConfigsCreateRequest,
    security: operations.SecuritycenterProjectsMuteConfigsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsMuteConfigsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsMuteConfigsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/muteConfigs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleCloudSecuritycenterV1MuteConfigInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SecuritycenterProjectsMuteConfigsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsMuteConfigsCreateResponse =
        new operations.SecuritycenterProjectsMuteConfigsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleCloudSecuritycenterV1MuteConfig = utils.objectToClass(
              httpRes?.data,
              shared.GoogleCloudSecuritycenterV1MuteConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists mute configs.
   */
  securitycenterProjectsMuteConfigsList(
    req: operations.SecuritycenterProjectsMuteConfigsListRequest,
    security: operations.SecuritycenterProjectsMuteConfigsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsMuteConfigsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsMuteConfigsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/muteConfigs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SecuritycenterProjectsMuteConfigsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsMuteConfigsListResponse =
        new operations.SecuritycenterProjectsMuteConfigsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMuteConfigsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListMuteConfigsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a notification config.
   */
  securitycenterProjectsNotificationConfigsCreate(
    req: operations.SecuritycenterProjectsNotificationConfigsCreateRequest,
    security: operations.SecuritycenterProjectsNotificationConfigsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsNotificationConfigsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.SecuritycenterProjectsNotificationConfigsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/notificationConfigs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "notificationConfigInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsNotificationConfigsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsNotificationConfigsCreateResponse =
        new operations.SecuritycenterProjectsNotificationConfigsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notificationConfig = utils.objectToClass(
              httpRes?.data,
              shared.NotificationConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a notification config.
   */
  securitycenterProjectsNotificationConfigsDelete(
    req: operations.SecuritycenterProjectsNotificationConfigsDeleteRequest,
    security: operations.SecuritycenterProjectsNotificationConfigsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsNotificationConfigsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.SecuritycenterProjectsNotificationConfigsDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsNotificationConfigsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsNotificationConfigsDeleteResponse =
        new operations.SecuritycenterProjectsNotificationConfigsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a notification config.
   */
  securitycenterProjectsNotificationConfigsGet(
    req: operations.SecuritycenterProjectsNotificationConfigsGetRequest,
    security: operations.SecuritycenterProjectsNotificationConfigsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsNotificationConfigsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsNotificationConfigsGetRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsNotificationConfigsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsNotificationConfigsGetResponse =
        new operations.SecuritycenterProjectsNotificationConfigsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.notificationConfig = utils.objectToClass(
              httpRes?.data,
              shared.NotificationConfig
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists notification configs.
   */
  securitycenterProjectsNotificationConfigsList(
    req: operations.SecuritycenterProjectsNotificationConfigsListRequest,
    security: operations.SecuritycenterProjectsNotificationConfigsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsNotificationConfigsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsNotificationConfigsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/notificationConfigs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsNotificationConfigsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsNotificationConfigsListResponse =
        new operations.SecuritycenterProjectsNotificationConfigsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listNotificationConfigsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListNotificationConfigsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates external system. This is for a given finding.
   */
  securitycenterProjectsSourcesFindingsExternalSystemsPatch(
    req: operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchRequest,
    security: operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "googleCloudSecuritycenterV1ExternalSystem",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchResponse =
        new operations.SecuritycenterProjectsSourcesFindingsExternalSystemsPatchResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.googleCloudSecuritycenterV1ExternalSystem = utils.objectToClass(
              httpRes?.data,
              shared.GoogleCloudSecuritycenterV1ExternalSystem
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Filters an organization or source's findings and groups them by their specified properties. To group across all sources provide a `-` as the source id. Example: /v1/organizations/{organization_id}/sources/-/findings, /v1/folders/{folder_id}/sources/-/findings, /v1/projects/{project_id}/sources/-/findings
   */
  securitycenterProjectsSourcesFindingsGroup(
    req: operations.SecuritycenterProjectsSourcesFindingsGroupRequest,
    security: operations.SecuritycenterProjectsSourcesFindingsGroupSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsSourcesFindingsGroupResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsSourcesFindingsGroupRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/findings:group",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "groupFindingsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsSourcesFindingsGroupSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsSourcesFindingsGroupResponse =
        new operations.SecuritycenterProjectsSourcesFindingsGroupResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupFindingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GroupFindingsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists an organization or source's findings. To list across all sources provide a `-` as the source id. Example: /v1/organizations/{organization_id}/sources/-/findings
   */
  securitycenterProjectsSourcesFindingsList(
    req: operations.SecuritycenterProjectsSourcesFindingsListRequest,
    security: operations.SecuritycenterProjectsSourcesFindingsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsSourcesFindingsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsSourcesFindingsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/findings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsSourcesFindingsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsSourcesFindingsListResponse =
        new operations.SecuritycenterProjectsSourcesFindingsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listFindingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListFindingsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the mute state of a finding.
   */
  securitycenterProjectsSourcesFindingsSetMute(
    req: operations.SecuritycenterProjectsSourcesFindingsSetMuteRequest,
    security: operations.SecuritycenterProjectsSourcesFindingsSetMuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsSourcesFindingsSetMuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsSourcesFindingsSetMuteRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:setMute", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setMuteRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsSourcesFindingsSetMuteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsSourcesFindingsSetMuteResponse =
        new operations.SecuritycenterProjectsSourcesFindingsSetMuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.finding = utils.objectToClass(httpRes?.data, shared.Finding);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the state of a finding.
   */
  securitycenterProjectsSourcesFindingsSetState(
    req: operations.SecuritycenterProjectsSourcesFindingsSetStateRequest,
    security: operations.SecuritycenterProjectsSourcesFindingsSetStateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsSourcesFindingsSetStateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsSourcesFindingsSetStateRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:setState", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setFindingStateRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.SecuritycenterProjectsSourcesFindingsSetStateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsSourcesFindingsSetStateResponse =
        new operations.SecuritycenterProjectsSourcesFindingsSetStateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.finding = utils.objectToClass(httpRes?.data, shared.Finding);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all sources belonging to an organization.
   */
  securitycenterProjectsSourcesList(
    req: operations.SecuritycenterProjectsSourcesListRequest,
    security: operations.SecuritycenterProjectsSourcesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SecuritycenterProjectsSourcesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SecuritycenterProjectsSourcesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/sources", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SecuritycenterProjectsSourcesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SecuritycenterProjectsSourcesListResponse =
        new operations.SecuritycenterProjectsSourcesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSourcesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSourcesResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
