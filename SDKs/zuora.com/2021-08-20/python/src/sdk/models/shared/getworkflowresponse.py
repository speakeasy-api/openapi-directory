"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional

class GetWorkflowResponseStatusEnum(str, Enum):
    r"""The status of the workflow:
      - Queued: The workflow is in queue for being processed.
      - Processing: The workflow is in process.
      - Stopping: The workflow is being stopped through Zuora UI.
      - Stopped: The workflow is stopped through Zuora UI.
      - Finished: The workflow is finished. When a workflow is finished, it might have tasks pending for retry or delay. Pending tasks do not block the onfinish branch of the workflow, but they block the oncomplete branch of the iterate.
    """
    QUEUED = 'Queued'
    PROCESSING = 'Processing'
    STOPPING = 'Stopping'
    STOPPED = 'Stopped'
    FINISHED = 'Finished'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetWorkflowResponseTasks:
    r"""An object containing task counts."""
    
    error: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('error'), 'exclude': lambda f: f is None }})
    r"""The number of tasks in **Error** state."""  
    pending: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pending'), 'exclude': lambda f: f is None }})
    r"""The number of tasks in **Pending** state."""  
    processing: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('processing'), 'exclude': lambda f: f is None }})
    r"""The number of tasks in **Processing** state."""  
    queued: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('queued'), 'exclude': lambda f: f is None }})
    r"""The number of tasks in **Queued** state."""  
    stopped: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('stopped'), 'exclude': lambda f: f is None }})
    r"""The number of tasks in **Stopped** state."""  
    success: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('success'), 'exclude': lambda f: f is None }})
    r"""The number of tasks in **Success** state."""  
    total: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total'), 'exclude': lambda f: f is None }})
    r"""The total number of tasks."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetWorkflowResponse:
    
    cpu_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cpuTime'), 'exclude': lambda f: f is None }})
    r"""The overall CPU time for the execution of the workflow."""  
    created_at: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('createdAt'), 'exclude': lambda f: f is None }})
    r"""The date and time when the workflow is created, in the `YYYY-MM-DD HH:MM:SS` format.."""  
    finished_at: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('finishedAt'), 'exclude': lambda f: f is None }})
    r"""The date and time when the execution of the workflow completes, in the `YYYY-MM-DD HH:MM:SS` format."""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The unique ID of the workflow."""  
    messages: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('messages'), 'exclude': lambda f: f is None }})
    r"""Messages from tasks."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The unique run number of the workflow."""  
    original_workflow_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('originalWorkflowId'), 'exclude': lambda f: f is None }})
    r"""The ID of the workflow setup."""  
    run_time: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runTime'), 'exclude': lambda f: f is None }})
    r"""The execution time of the workflow including the waiting time, in seconds."""  
    status: Optional[GetWorkflowResponseStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The status of the workflow:
      - Queued: The workflow is in queue for being processed.
      - Processing: The workflow is in process.
      - Stopping: The workflow is being stopped through Zuora UI.
      - Stopped: The workflow is stopped through Zuora UI.
      - Finished: The workflow is finished. When a workflow is finished, it might have tasks pending for retry or delay. Pending tasks do not block the onfinish branch of the workflow, but they block the oncomplete branch of the iterate.
    """  
    tasks: Optional[GetWorkflowResponseTasks] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tasks'), 'exclude': lambda f: f is None }})
    r"""An object containing task counts."""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the current workflow.
    Possible values:
        - `Workflow::Setup`: The workflow is a setup and is used for creating workflow instances.
        - `Workflow::Instance`: The workflow is an execution that has data.
    """  
    updated_at: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('updatedAt'), 'exclude': lambda f: f is None }})
    r"""The date and time when the workflow is updated the last time, in the `YYYY-MM-DD HH:MM:SS` format."""  
    