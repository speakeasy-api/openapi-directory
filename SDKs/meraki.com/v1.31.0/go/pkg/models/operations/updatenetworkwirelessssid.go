// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type UpdateNetworkWirelessSsidPathParams struct {
	NetworkID string `pathParam:"style=simple,explode=false,name=networkId"`
	Number    string `pathParam:"style=simple,explode=false,name=number"`
}

// UpdateNetworkWirelessSsidRequestBodyActiveDirectoryCredentials - (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
type UpdateNetworkWirelessSsidRequestBodyActiveDirectoryCredentials struct {
	// The logon name of the Active Directory account.
	LogonName *string `json:"logonName,omitempty"`
	// The password to the Active Directory user account.
	Password *string `json:"password,omitempty"`
}

type UpdateNetworkWirelessSsidRequestBodyActiveDirectoryServers struct {
	// IP address of your Active Directory server.
	Host string `json:"host"`
	// (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
	Port *int64 `json:"port,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyActiveDirectory - The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
type UpdateNetworkWirelessSsidRequestBodyActiveDirectory struct {
	// (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
	Credentials *UpdateNetworkWirelessSsidRequestBodyActiveDirectoryCredentials `json:"credentials,omitempty"`
	// The Active Directory servers to be used for authentication.
	Servers []UpdateNetworkWirelessSsidRequestBodyActiveDirectoryServers `json:"servers,omitempty"`
}

type UpdateNetworkWirelessSsidRequestBodyApTagsAndVlanIds struct {
	// Array of AP tags
	Tags []string `json:"tags,omitempty"`
	// Numerical identifier that is assigned to the VLAN
	VlanID *int64 `json:"vlanId,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyAuthModeEnum - The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
type UpdateNetworkWirelessSsidRequestBodyAuthModeEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumEightThousandAndTwentyOnexGoogle      UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "8021x-google"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumEightThousandAndTwentyOnexLocalradius UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "8021x-localradius"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumEightThousandAndTwentyOnexMeraki      UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "8021x-meraki"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumEightThousandAndTwentyOnexNac         UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "8021x-nac"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumEightThousandAndTwentyOnexRadius      UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "8021x-radius"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumIpskWithRadius                        UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "ipsk-with-radius"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumIpskWithoutRadius                     UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "ipsk-without-radius"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumOpen                                  UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "open"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumOpenEnhanced                          UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "open-enhanced"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumOpenWithNac                           UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "open-with-nac"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumOpenWithRadius                        UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "open-with-radius"
	UpdateNetworkWirelessSsidRequestBodyAuthModeEnumPsk                                   UpdateNetworkWirelessSsidRequestBodyAuthModeEnum = "psk"
)

func (e *UpdateNetworkWirelessSsidRequestBodyAuthModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "8021x-google":
		fallthrough
	case "8021x-localradius":
		fallthrough
	case "8021x-meraki":
		fallthrough
	case "8021x-nac":
		fallthrough
	case "8021x-radius":
		fallthrough
	case "ipsk-with-radius":
		fallthrough
	case "ipsk-without-radius":
		fallthrough
	case "open":
		fallthrough
	case "open-enhanced":
		fallthrough
	case "open-with-nac":
		fallthrough
	case "open-with-radius":
		fallthrough
	case "psk":
		*e = UpdateNetworkWirelessSsidRequestBodyAuthModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyAuthModeEnum: %s", s)
	}
}

// UpdateNetworkWirelessSsidRequestBodyDNSRewrite - DNS servers rewrite settings
type UpdateNetworkWirelessSsidRequestBodyDNSRewrite struct {
	// User specified DNS servers (up to two servers)
	DNSCustomNameservers []string `json:"dnsCustomNameservers,omitempty"`
	// Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
	Enabled *bool `json:"enabled,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyDot11r - The current setting for 802.11r
type UpdateNetworkWirelessSsidRequestBodyDot11r struct {
	// (Optional) Whether 802.11r is adaptive or not.
	Adaptive *bool `json:"adaptive,omitempty"`
	// Whether 802.11r is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyDot11w - The current setting for Protected Management Frames (802.11w).
type UpdateNetworkWirelessSsidRequestBodyDot11w struct {
	// Whether 802.11w is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`
	// (Optional) Whether 802.11w is required or not.
	Required *bool `json:"required,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum - The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
type UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnumWep UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum = "wep"
	UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnumWpa UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum = "wpa"
)

func (e *UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "wep":
		fallthrough
	case "wpa":
		*e = UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum: %s", s)
	}
}

// UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum - Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
type UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnumAccessDisabled UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum = "access disabled"
	UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnumAccessEnabled  UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum = "access enabled"
)

func (e *UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "access disabled":
		fallthrough
	case "access enabled":
		*e = UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum: %s", s)
	}
}

// UpdateNetworkWirelessSsidRequestBodyGreConcentrator - The EoGRE concentrator's settings
type UpdateNetworkWirelessSsidRequestBodyGreConcentrator struct {
	// The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
	Host string `json:"host"`
}

// UpdateNetworkWirelessSsidRequestBodyGre - Ethernet over GRE settings
type UpdateNetworkWirelessSsidRequestBodyGre struct {
	// The EoGRE concentrator's settings
	Concentrator *UpdateNetworkWirelessSsidRequestBodyGreConcentrator `json:"concentrator,omitempty"`
	// Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
	Key *int64 `json:"key,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyLdapCredentials - (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
type UpdateNetworkWirelessSsidRequestBodyLdapCredentials struct {
	// The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
	DistinguishedName *string `json:"distinguishedName,omitempty"`
	// The password of the LDAP user account.
	Password *string `json:"password,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyLdapServerCaCertificate - The CA certificate used to sign the LDAP server's key.
type UpdateNetworkWirelessSsidRequestBodyLdapServerCaCertificate struct {
	// The contents of the CA certificate. Must be in PEM or DER format.
	Contents *string `json:"contents,omitempty"`
}

type UpdateNetworkWirelessSsidRequestBodyLdapServers struct {
	// IP address of your LDAP server.
	Host string `json:"host"`
	// UDP port the LDAP server listens on.
	Port int64 `json:"port"`
}

// UpdateNetworkWirelessSsidRequestBodyLdap - The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
type UpdateNetworkWirelessSsidRequestBodyLdap struct {
	// The base distinguished name of users on the LDAP server.
	BaseDistinguishedName *string `json:"baseDistinguishedName,omitempty"`
	// (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
	Credentials *UpdateNetworkWirelessSsidRequestBodyLdapCredentials `json:"credentials,omitempty"`
	// The CA certificate used to sign the LDAP server's key.
	ServerCaCertificate *UpdateNetworkWirelessSsidRequestBodyLdapServerCaCertificate `json:"serverCaCertificate,omitempty"`
	// The LDAP servers to be used for authentication.
	Servers []UpdateNetworkWirelessSsidRequestBodyLdapServers `json:"servers,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate - The Client CA Certificate used to sign the client certificate.
type UpdateNetworkWirelessSsidRequestBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate struct {
	// The contents of the Client CA Certificate. Must be in PEM or DER format.
	Contents *string `json:"contents,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyLocalRadiusCertificateAuthentication - The current setting for certificate verification.
type UpdateNetworkWirelessSsidRequestBodyLocalRadiusCertificateAuthentication struct {
	// The Client CA Certificate used to sign the client certificate.
	ClientRootCaCertificate *UpdateNetworkWirelessSsidRequestBodyLocalRadiusCertificateAuthenticationClientRootCaCertificate `json:"clientRootCaCertificate,omitempty"`
	// Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
	Enabled *bool `json:"enabled,omitempty"`
	// (Optional) The URL of the OCSP responder to verify client certificate status.
	OcspResponderURL *string `json:"ocspResponderUrl,omitempty"`
	// Whether or not to verify the certificate with LDAP.
	UseLdap *bool `json:"useLdap,omitempty"`
	// Whether or not to verify the certificate with OCSP.
	UseOcsp *bool `json:"useOcsp,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyLocalRadiusPasswordAuthentication - The current setting for password-based authentication.
type UpdateNetworkWirelessSsidRequestBodyLocalRadiusPasswordAuthentication struct {
	// Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
	Enabled *bool `json:"enabled,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyLocalRadius - The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'.
type UpdateNetworkWirelessSsidRequestBodyLocalRadius struct {
	// The duration (in seconds) for which LDAP and OCSP lookups are cached.
	CacheTimeout *int64 `json:"cacheTimeout,omitempty"`
	// The current setting for certificate verification.
	CertificateAuthentication *UpdateNetworkWirelessSsidRequestBodyLocalRadiusCertificateAuthentication `json:"certificateAuthentication,omitempty"`
	// The current setting for password-based authentication.
	PasswordAuthentication *UpdateNetworkWirelessSsidRequestBodyLocalRadiusPasswordAuthentication `json:"passwordAuthentication,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyOauth - The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'.
type UpdateNetworkWirelessSsidRequestBodyOauth struct {
	// (Optional) The list of domains allowed access to the network.
	AllowedDomains []string `json:"allowedDomains,omitempty"`
}

type UpdateNetworkWirelessSsidRequestBodyRadiusAccountingServers struct {
	// Certificate used for authorization for the RADSEC Server
	CaCertificate *string `json:"caCertificate,omitempty"`
	// IP address to which the APs will send RADIUS accounting messages
	Host string `json:"host"`
	// Port on the RADIUS server that is listening for accounting messages
	Port *int64 `json:"port,omitempty"`
	// Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
	RadsecEnabled *bool `json:"radsecEnabled,omitempty"`
	// Shared key used to authenticate messages between the APs and RADIUS server
	Secret *string `json:"secret,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum - Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
type UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnumAirespaceACLName UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum = "Airespace-ACL-Name"
	UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnumArubaUserRole    UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum = "Aruba-User-Role"
	UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnumFilterID         UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum = "Filter-Id"
	UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnumReplyMessage     UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum = "Reply-Message"
)

func (e *UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Airespace-ACL-Name":
		fallthrough
	case "Aruba-User-Role":
		fallthrough
	case "Filter-Id":
		fallthrough
	case "Reply-Message":
		*e = UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum: %s", s)
	}
}

// UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum - This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
type UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnumAllowAccess UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum = "Allow access"
	UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnumDenyAccess  UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum = "Deny access"
)

func (e *UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Allow access":
		fallthrough
	case "Deny access":
		*e = UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum: %s", s)
	}
}

// UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum - This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
type UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnumRoundRobin          UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum = "Round robin"
	UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnumStrictPriorityOrder UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum = "Strict priority order"
)

func (e *UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Round robin":
		fallthrough
	case "Strict priority order":
		*e = UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum: %s", s)
	}
}

type UpdateNetworkWirelessSsidRequestBodyRadiusServers struct {
	// Certificate used for authorization for the RADSEC Server
	CaCertificate *string `json:"caCertificate,omitempty"`
	// IP address of your RADIUS server
	Host string `json:"host"`
	// The ID of the Openroaming Certificate attached to radius server.
	OpenRoamingCertificateID *int64 `json:"openRoamingCertificateId,omitempty"`
	// UDP port the RADIUS server listens on for Access-requests
	Port *int64 `json:"port,omitempty"`
	// Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
	RadsecEnabled *bool `json:"radsecEnabled,omitempty"`
	// RADIUS client shared secret
	Secret *string `json:"secret,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodySpeedBurst - The SpeedBurst setting for this SSID'
type UpdateNetworkWirelessSsidRequestBodySpeedBurst struct {
	// Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
	Enabled *bool `json:"enabled,omitempty"`
}

// UpdateNetworkWirelessSsidRequestBodySplashPageEnum - The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
type UpdateNetworkWirelessSsidRequestBodySplashPageEnum string

const (
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumBilling                              UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Billing"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumCiscoIse                             UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Cisco ISE"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumClickThroughSplashPage               UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Click-through splash page"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumFacebookWiFi                         UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Facebook Wi-Fi"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumGoogleAppsDomain                     UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Google Apps domain"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumGoogleOAuth                          UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Google OAuth"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumNone                                 UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "None"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumPasswordProtectedWithActiveDirectory UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Password-protected with Active Directory"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumPasswordProtectedWithLdap            UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Password-protected with LDAP"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumPasswordProtectedWithMerakiRadius    UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Password-protected with Meraki RADIUS"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumPasswordProtectedWithCustomRadius    UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Password-protected with custom RADIUS"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumSmsAuthentication                    UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "SMS authentication"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumSponsoredGuest                       UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Sponsored guest"
	UpdateNetworkWirelessSsidRequestBodySplashPageEnumSystemsManagerSentry                 UpdateNetworkWirelessSsidRequestBodySplashPageEnum = "Systems Manager Sentry"
)

func (e *UpdateNetworkWirelessSsidRequestBodySplashPageEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "Billing":
		fallthrough
	case "Cisco ISE":
		fallthrough
	case "Click-through splash page":
		fallthrough
	case "Facebook Wi-Fi":
		fallthrough
	case "Google Apps domain":
		fallthrough
	case "Google OAuth":
		fallthrough
	case "None":
		fallthrough
	case "Password-protected with Active Directory":
		fallthrough
	case "Password-protected with LDAP":
		fallthrough
	case "Password-protected with Meraki RADIUS":
		fallthrough
	case "Password-protected with custom RADIUS":
		fallthrough
	case "SMS authentication":
		fallthrough
	case "Sponsored guest":
		fallthrough
	case "Systems Manager Sentry":
		*e = UpdateNetworkWirelessSsidRequestBodySplashPageEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodySplashPageEnum: %s", s)
	}
}

// UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum - The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
type UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum string

const (
	UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnumWpa1AndWpa2        UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum = "WPA1 and WPA2"
	UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnumWpa1Only           UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum = "WPA1 only"
	UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnumWpa2Only           UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum = "WPA2 only"
	UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnumWpa3TransitionMode UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum = "WPA3 Transition Mode"
	UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnumWpa3Only           UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum = "WPA3 only"
)

func (e *UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "WPA1 and WPA2":
		fallthrough
	case "WPA1 only":
		fallthrough
	case "WPA2 only":
		fallthrough
	case "WPA3 Transition Mode":
		fallthrough
	case "WPA3 only":
		*e = UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum: %s", s)
	}
}

type UpdateNetworkWirelessSsidRequestBody struct {
	// The current setting for Active Directory. Only valid if splashPage is 'Password-protected with Active Directory'
	ActiveDirectory *UpdateNetworkWirelessSsidRequestBodyActiveDirectory `json:"activeDirectory,omitempty"`
	// Boolean indicating whether or not adult content will be blocked
	AdultContentFilteringEnabled *bool `json:"adultContentFilteringEnabled,omitempty"`
	// The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	ApTagsAndVlanIds []UpdateNetworkWirelessSsidRequestBodyApTagsAndVlanIds `json:"apTagsAndVlanIds,omitempty"`
	// The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
	AuthMode *UpdateNetworkWirelessSsidRequestBodyAuthModeEnum `json:"authMode,omitempty"`
	// Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
	AvailabilityTags []string `json:"availabilityTags,omitempty"`
	// Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
	AvailableOnAllAps *bool `json:"availableOnAllAps,omitempty"`
	// The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
	BandSelection *string `json:"bandSelection,omitempty"`
	// The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
	ConcentratorNetworkID *string `json:"concentratorNetworkId,omitempty"`
	// The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	DefaultVlanID *int64 `json:"defaultVlanId,omitempty"`
	// Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.
	DisassociateClientsOnVpnFailover *bool `json:"disassociateClientsOnVpnFailover,omitempty"`
	// DNS servers rewrite settings
	DNSRewrite *UpdateNetworkWirelessSsidRequestBodyDNSRewrite `json:"dnsRewrite,omitempty"`
	// The current setting for 802.11r
	Dot11r *UpdateNetworkWirelessSsidRequestBodyDot11r `json:"dot11r,omitempty"`
	// The current setting for Protected Management Frames (802.11w).
	Dot11w *UpdateNetworkWirelessSsidRequestBodyDot11w `json:"dot11w,omitempty"`
	// Whether or not the SSID is enabled
	Enabled *bool `json:"enabled,omitempty"`
	// The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
	EncryptionMode *UpdateNetworkWirelessSsidRequestBodyEncryptionModeEnum `json:"encryptionMode,omitempty"`
	// Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
	EnterpriseAdminAccess *UpdateNetworkWirelessSsidRequestBodyEnterpriseAdminAccessEnum `json:"enterpriseAdminAccess,omitempty"`
	// Ethernet over GRE settings
	Gre *UpdateNetworkWirelessSsidRequestBodyGre `json:"gre,omitempty"`
	// The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')
	IPAssignmentMode *string `json:"ipAssignmentMode,omitempty"`
	// Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
	LanIsolationEnabled *bool `json:"lanIsolationEnabled,omitempty"`
	// The current setting for LDAP. Only valid if splashPage is 'Password-protected with LDAP'.
	Ldap *UpdateNetworkWirelessSsidRequestBodyLdap `json:"ldap,omitempty"`
	// The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is '8021x-localradius'.
	LocalRadius *UpdateNetworkWirelessSsidRequestBodyLocalRadius `json:"localRadius,omitempty"`
	// If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
	MandatoryDhcpEnabled *bool `json:"mandatoryDhcpEnabled,omitempty"`
	// The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
	MinBitrate *float32 `json:"minBitrate,omitempty"`
	// The name of the SSID
	Name *string `json:"name,omitempty"`
	// The OAuth settings of this SSID. Only valid if splashPage is 'Google OAuth'.
	Oauth *UpdateNetworkWirelessSsidRequestBodyOauth `json:"oauth,omitempty"`
	// The download bandwidth limit in Kbps. (0 represents no limit.)
	PerClientBandwidthLimitDown *int64 `json:"perClientBandwidthLimitDown,omitempty"`
	// The upload bandwidth limit in Kbps. (0 represents no limit.)
	PerClientBandwidthLimitUp *int64 `json:"perClientBandwidthLimitUp,omitempty"`
	// The total download bandwidth limit in Kbps. (0 represents no limit.)
	PerSsidBandwidthLimitDown *int64 `json:"perSsidBandwidthLimitDown,omitempty"`
	// The total upload bandwidth limit in Kbps. (0 represents no limit.)
	PerSsidBandwidthLimitUp *int64 `json:"perSsidBandwidthLimitUp,omitempty"`
	// The passkey for the SSID. This param is only valid if the authMode is 'psk'
	Psk *string `json:"psk,omitempty"`
	// Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
	RadiusAccountingEnabled *bool `json:"radiusAccountingEnabled,omitempty"`
	// The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
	RadiusAccountingInterimInterval *int64 `json:"radiusAccountingInterimInterval,omitempty"`
	// The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
	RadiusAccountingServers []UpdateNetworkWirelessSsidRequestBodyRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
	RadiusAttributeForGroupPolicies *UpdateNetworkWirelessSsidRequestBodyRadiusAttributeForGroupPoliciesEnum `json:"radiusAttributeForGroupPolicies,omitempty"`
	// The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
	RadiusAuthenticationNasID *string `json:"radiusAuthenticationNasId,omitempty"`
	// The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
	RadiusCalledStationID *string `json:"radiusCalledStationId,omitempty"`
	// If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
	RadiusCoaEnabled *bool `json:"radiusCoaEnabled,omitempty"`
	// This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
	RadiusFailoverPolicy *UpdateNetworkWirelessSsidRequestBodyRadiusFailoverPolicyEnum `json:"radiusFailoverPolicy,omitempty"`
	// Whether or not higher priority RADIUS servers should be retried after 60 seconds.
	RadiusFallbackEnabled *bool `json:"radiusFallbackEnabled,omitempty"`
	// Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
	RadiusGuestVlanEnabled *bool `json:"radiusGuestVlanEnabled,omitempty"`
	// VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
	RadiusGuestVlanID *int64 `json:"radiusGuestVlanId,omitempty"`
	// This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
	RadiusLoadBalancingPolicy *UpdateNetworkWirelessSsidRequestBodyRadiusLoadBalancingPolicyEnum `json:"radiusLoadBalancingPolicy,omitempty"`
	// If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
	RadiusOverride *bool `json:"radiusOverride,omitempty"`
	// If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
	RadiusProxyEnabled *bool `json:"radiusProxyEnabled,omitempty"`
	// The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
	RadiusServerAttemptsLimit *int64 `json:"radiusServerAttemptsLimit,omitempty"`
	// The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
	RadiusServerTimeout *int64 `json:"radiusServerTimeout,omitempty"`
	// The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
	RadiusServers []UpdateNetworkWirelessSsidRequestBodyRadiusServers `json:"radiusServers,omitempty"`
	// If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
	RadiusTestingEnabled *bool `json:"radiusTestingEnabled,omitempty"`
	// The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)
	SecondaryConcentratorNetworkID *string `json:"secondaryConcentratorNetworkId,omitempty"`
	// The SpeedBurst setting for this SSID'
	SpeedBurst *UpdateNetworkWirelessSsidRequestBodySpeedBurst `json:"speedBurst,omitempty"`
	// Array of valid sponsor email domains for sponsored guest splash type.
	SplashGuestSponsorDomains []string `json:"splashGuestSponsorDomains,omitempty"`
	// The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
	SplashPage *UpdateNetworkWirelessSsidRequestBodySplashPageEnum `json:"splashPage,omitempty"`
	// Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
	UseVlanTagging *bool `json:"useVlanTagging,omitempty"`
	// Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
	Visible *bool `json:"visible,omitempty"`
	// The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
	VlanID *int64 `json:"vlanId,omitempty"`
	// Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
	WalledGardenEnabled *bool `json:"walledGardenEnabled,omitempty"`
	// Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
	WalledGardenRanges []string `json:"walledGardenRanges,omitempty"`
	// The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
	WpaEncryptionMode *UpdateNetworkWirelessSsidRequestBodyWpaEncryptionModeEnum `json:"wpaEncryptionMode,omitempty"`
}

type UpdateNetworkWirelessSsidRequest struct {
	PathParams UpdateNetworkWirelessSsidPathParams
	Request    *UpdateNetworkWirelessSsidRequestBody `request:"mediaType=application/json"`
}

type UpdateNetworkWirelessSsidResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	UpdateNetworkWirelessSsid200ApplicationJSONObject map[string]interface{}
}
