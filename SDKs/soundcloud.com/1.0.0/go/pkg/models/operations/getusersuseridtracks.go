// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"bytes"
	"encoding/json"
	"errors"
	"net/http"
	"openapi/pkg/models/shared"
)

type GetUsersUserIDTracksSecurity struct {
	AuthHeader shared.SchemeAuthHeader `security:"scheme,type=apiKey,subtype=header"`
	ClientID   shared.SchemeClientID   `security:"scheme,type=apiKey,subtype=query"`
}

type GetUsersUserIDTracksPathParams struct {
	// SoundCloud User id
	UserID int64 `pathParam:"style=simple,explode=false,name=user_id"`
}

type GetUsersUserIDTracksQueryParams struct {
	// Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	//
	Access []shared.AccessEnum `queryParam:"style=form,explode=false,name=access"`
	// Number of results to return in the collection.
	Limit *int64 `queryParam:"style=form,explode=true,name=limit"`
	// Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *bool `queryParam:"style=form,explode=true,name=linked_partitioning"`
}

type GetUsersUserIDTracksRequest struct {
	PathParams  GetUsersUserIDTracksPathParams
	QueryParams GetUsersUserIDTracksQueryParams
	Security    GetUsersUserIDTracksSecurity
}

type GetUsersUserIDTracks200ApplicationJSONType string

const (
	GetUsersUserIDTracks200ApplicationJSONTypeTracks       GetUsersUserIDTracks200ApplicationJSONType = "Tracks"
	GetUsersUserIDTracks200ApplicationJSONTypeArrayOfTrack GetUsersUserIDTracks200ApplicationJSONType = "arrayOfTrack"
)

type GetUsersUserIDTracks200ApplicationJSON struct {
	Tracks       *shared.Tracks
	ArrayOfTrack []shared.Track

	Type GetUsersUserIDTracks200ApplicationJSONType
}

func CreateGetUsersUserIDTracks200ApplicationJSONTracks(tracks shared.Tracks) GetUsersUserIDTracks200ApplicationJSON {
	typ := GetUsersUserIDTracks200ApplicationJSONTypeTracks

	return GetUsersUserIDTracks200ApplicationJSON{
		Tracks: &tracks,
		Type:   typ,
	}
}

func CreateGetUsersUserIDTracks200ApplicationJSONArrayOfTrack(arrayOfTrack []shared.Track) GetUsersUserIDTracks200ApplicationJSON {
	typ := GetUsersUserIDTracks200ApplicationJSONTypeArrayOfTrack

	return GetUsersUserIDTracks200ApplicationJSON{
		ArrayOfTrack: arrayOfTrack,
		Type:         typ,
	}
}

func (u *GetUsersUserIDTracks200ApplicationJSON) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	tracks := new(shared.Tracks)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&tracks); err == nil {
		u.Tracks = tracks
		u.Type = GetUsersUserIDTracks200ApplicationJSONTypeTracks
		return nil
	}

	arrayOfTrack := []shared.Track{}
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&arrayOfTrack); err == nil {
		u.ArrayOfTrack = arrayOfTrack
		u.Type = GetUsersUserIDTracks200ApplicationJSONTypeArrayOfTrack
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u GetUsersUserIDTracks200ApplicationJSON) MarshalJSON() ([]byte, error) {
	if u.Tracks != nil {
		return json.Marshal(u.Tracks)
	}

	if u.ArrayOfTrack != nil {
		return json.Marshal(u.ArrayOfTrack)
	}

	return nil, nil
}

type GetUsersUserIDTracksResponse struct {
	ContentType string
	// Unauthorized
	Error       *shared.Error
	StatusCode  int
	RawResponse *http.Response
	// Success
	GetUsersUserIDTracks200ApplicationJSONOneOf *GetUsersUserIDTracks200ApplicationJSON
}
