/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SpeakeasyBase, SpeakeasyMetadata } from "../../../internal/utils";
import { AdminDimension } from "./admindimension";
import { AdminFilterAttribute } from "./adminfilterattribute";
import { Expose, Type } from "class-transformer";

export class AdminCorpus extends SpeakeasyBase {
  @SpeakeasyMetadata({ elemType: AdminDimension })
  @Expose({ name: "customDimensions" })
  @Type(() => AdminDimension)
  customDimensions?: AdminDimension[];

  /**
   * A description for the corpus.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "description" })
  description?: string;

  /**
   * The time at which the corpus was provisioned.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "dtProvision" })
  dtProvision?: string;

  /**
   * Whether the corpus is enabled for use or not.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "enabled" })
  enabled?: boolean;

  /**
   * This is an advanced setting for changing the underlying model type.  The
   *
   * @remarks
   * default value is "1", which is Vectara's high-performing global model.
   * Underlying models may be swapped for some paying customers by contacting
   * our support team.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "encoderId" })
  encoderId?: string;

  /**
   * Encryption is on by default and cannot be turned off.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "encrypted" })
  encrypted?: boolean;

  @SpeakeasyMetadata({ elemType: AdminFilterAttribute })
  @Expose({ name: "filterAttributes" })
  @Type(() => AdminFilterAttribute)
  filterAttributes?: AdminFilterAttribute[];

  /**
   * The Corpus ID.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "id" })
  id?: number;

  /**
   * An optional maximum size of the metadata that each document can contain.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "metadataMaxBytes" })
  metadataMaxBytes?: number;

  /**
   * The name of the corpus.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "name" })
  name?: string;

  /**
   * The default query encoder is designed for normal question-answering types
   *
   * @remarks
   * of queries when the text contains the answer.  Swapping the index encoder
   * is generally rare, but can be used to help directly match questions to
   * questions.  This can be useful if you have a FAQ dataset and you want to
   * directly match the user question to the question in the FAQ.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "swapIenc" })
  swapIenc?: boolean;

  @SpeakeasyMetadata()
  @Expose({ name: "swapQenc" })
  swapQenc?: boolean;

  /**
   * When a corpus is "textless", Vectara does not store the original text.
   *
   * @remarks
   * Instead, Vectara converts the text to vectors and only retains metadata.
   */
  @SpeakeasyMetadata()
  @Expose({ name: "textless" })
  textless?: boolean;
}
