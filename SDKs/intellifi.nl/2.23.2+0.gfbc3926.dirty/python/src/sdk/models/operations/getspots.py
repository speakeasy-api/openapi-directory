"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import geocoords as shared_geocoords
from ..shared import location as shared_location
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from sdk import utils
from typing import Any, Optional


@dataclasses.dataclass
class GetSpotsRequest:
    
    after: Optional[datetime] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'after', 'style': 'form', 'explode': True }})
    r"""Limits on `time_created`, Marks the start of a range, optionally use `before` to set the end. Result output excludes the given timestamp."""  
    after_id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'after_id', 'style': 'form', 'explode': True }})
    r"""Limits directly on `id`. Marks the start of a range, optionally use `before_id` to set the end. Result output excludes the given `id` value. Please note that `id` is in chronological order."""  
    before: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'before', 'style': 'form', 'explode': True }})
    r"""Limits on `time_created`. Marks the end of a range, optionally use `after` to set the start. Result output excludes the given timestamp."""  
    before_id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'before_id', 'style': 'form', 'explode': True }})
    r"""Limits directly on `id`. Marks the end of a range, optionally use `after_id` to set the start. Result output excludes the given `id` value. Please note that `id` is in chronological order."""  
    from_: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'from', 'style': 'form', 'explode': True }})
    r"""Limits on `time_created`. Marks the start of a range, optionally use `until` to set the end. Result output includes the given timestamp."""  
    from_id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'from_id', 'style': 'form', 'explode': True }})
    r"""Limits on `id`. Marks the start of a range, optionally use `until_id` to set the end. Result output includes the given `id` value. Please note that `id` is in chronological order."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'id', 'style': 'form', 'explode': True }})
    r"""Unique identifier"""  
    id_only: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'id_only', 'style': 'form', 'explode': True }})
    r"""Removes `url` fields from output and shows `_id` instead of `_url` in references."""  
    is_online: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'is_online', 'style': 'form', 'explode': True }})
    r"""Filter based on the online status."""  
    limit: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'limit', 'style': 'form', 'explode': True }})
    r"""Sets the maximum number of returned resources. You may increase this number to large values, keep in mind that query times could become large. We advise you to use the pagination feature whenever you can."""  
    populate: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'populate', 'style': 'form', 'explode': True }})
    r"""Expand a reference into the actual resource (lookup). You may add multiple fields by giving a comma separated value."""  
    request_counter: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'request_counter', 'style': 'form', 'explode': True }})
    r"""Filter based on the amount of request made"""  
    results_only: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'results_only', 'style': 'form', 'explode': True }})
    r"""Removes response envelope with information about query, only sends back a JSON array with the applicable resources."""  
    select: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'select', 'style': 'form', 'explode': True }})
    r"""Select which properties should be returned. You may add multiple fields by giving a comma separated value. Select can also be used together with populate: Specify the resource first, then a period(.) followed by the field."""  
    serial_number: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'serial_number', 'style': 'form', 'explode': True }})
    r"""Filter based on the serial number."""  
    sort: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'sort', 'style': 'form', 'explode': True }})
    r"""Allows you to sort on on or more fields in the resource. You may append a minus sign (`-`) to request reverse order (new to old)."""  
    time_created: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'time_created', 'style': 'form', 'explode': True }})
    r"""Filter on the time the resource was created."""  
    time_updated: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'time_updated', 'style': 'form', 'explode': True }})
    r"""Filter on the time the resource was last updated"""  
    timeout_s: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'timeout_s', 'style': 'form', 'explode': True }})
    r"""Overrides the default query timeout (in seconds). A value of 0 means unlimited. IMPORTANT: using high timeouts in production code is strongly discouraged as it may lead to stability issues."""  
    until: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'until', 'style': 'form', 'explode': True }})
    r"""Limits on `time_created`. Marks the end of a range, optionally use `from` to set the start. Result output includes the given timestamp."""  
    until_id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'until_id', 'style': 'form', 'explode': True }})
    r"""Limits on `id`. Marks the end of a range, optionally use `from_id` to set the start. Result output includes the given `id` value. Please note that `id` is in chronological order."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSONResults3AntennaReportLocations:
    
    antenna_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('antenna_number'), 'exclude': lambda f: f is None }})
    r"""Antenna number"""  
    report_location: Optional[shared_location.Location] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location'), 'exclude': lambda f: f is None }})  
    report_location_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    report_location_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSONResults3:
    
    antenna_report_locations: Optional[list[GetSpots200ApplicationJSONResults3AntennaReportLocations]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('antenna_report_locations'), 'exclude': lambda f: f is None }})
    r"""You may configure this field to an object which couples individual antenna ports to locations."""  
    config: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config'), 'exclude': lambda f: f is None }})
    r"""JSON object with possible settings. Refer to individual service documentation for a good overview."""  
    config_request: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config_request'), 'exclude': lambda f: f is None }})
    r"""Object containing the new configuration. This will be applied automatically when the values are valid."""  
    geo_coords: Optional[shared_geocoords.GeoCoords] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('geo_coords'), 'exclude': lambda f: f is None }})
    r"""Last known geolocation estimate of this object. Not guaranteed to be included in response."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    is_online: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_online'), 'exclude': lambda f: f is None }})
    r"""Whether or not this resource is actively connected to the Brain."""  
    report_location_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    request_counter: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_counter'), 'exclude': lambda f: f is None }})
    r"""The total number of HTTP requests that this resource has done."""  
    senses: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('senses'), 'exclude': lambda f: f is None }})
    r"""Senses are values that in most cases are generated inside the spot (number of presences, spot booted etc.). We also have a few senses that can be controlled by the brain. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information."""  
    senses_request: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('senses_request'), 'exclude': lambda f: f is None }})
    r"""Object containing the new senses configuration. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information."""  
    serial_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serial_number'), 'exclude': lambda f: f is None }})
    r"""This is the fixed and unique spot number. It's assigned during the production process and used to identify an individual device during its lifetime."""  
    status: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""An object with specific information about the spot, directly send by the spot itself when the connection is created."""  
    time_created: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_created'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created."""  
    time_updated: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_updated'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated."""  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSONResults2AntennaReportLocations:
    
    antenna_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('antenna_number'), 'exclude': lambda f: f is None }})
    r"""Antenna number"""  
    report_location: Optional[shared_location.Location] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location'), 'exclude': lambda f: f is None }})  
    report_location_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    report_location_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSONResults2:
    
    antenna_report_locations: Optional[list[GetSpots200ApplicationJSONResults2AntennaReportLocations]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('antenna_report_locations'), 'exclude': lambda f: f is None }})
    r"""You may configure this field to an object which couples individual antenna ports to locations."""  
    config: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config'), 'exclude': lambda f: f is None }})
    r"""JSON object with possible settings. Refer to individual service documentation for a good overview."""  
    config_request: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config_request'), 'exclude': lambda f: f is None }})
    r"""Object containing the new configuration. This will be applied automatically when the values are valid."""  
    geo_coords: Optional[shared_geocoords.GeoCoords] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('geo_coords'), 'exclude': lambda f: f is None }})
    r"""Last known geolocation estimate of this object. Not guaranteed to be included in response."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    is_online: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_online'), 'exclude': lambda f: f is None }})
    r"""Whether or not this resource is actively connected to the Brain."""  
    report_location_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    request_counter: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_counter'), 'exclude': lambda f: f is None }})
    r"""The total number of HTTP requests that this resource has done."""  
    senses: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('senses'), 'exclude': lambda f: f is None }})
    r"""Senses are values that in most cases are generated inside the spot (number of presences, spot booted etc.). We also have a few senses that can be controlled by the brain. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information."""  
    senses_request: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('senses_request'), 'exclude': lambda f: f is None }})
    r"""Object containing the new senses configuration. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information."""  
    serial_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serial_number'), 'exclude': lambda f: f is None }})
    r"""This is the fixed and unique spot number. It's assigned during the production process and used to identify an individual device during its lifetime."""  
    status: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""An object with specific information about the spot, directly send by the spot itself when the connection is created."""  
    time_created: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_created'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created."""  
    time_updated: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_updated'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated."""  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSONResults1AntennaReportLocations:
    
    antenna_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('antenna_number'), 'exclude': lambda f: f is None }})
    r"""Antenna number"""  
    report_location: Optional[shared_location.Location] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location'), 'exclude': lambda f: f is None }})  
    report_location_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    report_location_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location_url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSONResults1:
    
    antenna_report_locations: Optional[list[GetSpots200ApplicationJSONResults1AntennaReportLocations]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('antenna_report_locations'), 'exclude': lambda f: f is None }})
    r"""You may configure this field to an object which couples individual antenna ports to locations."""  
    config: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config'), 'exclude': lambda f: f is None }})
    r"""JSON object with possible settings. Refer to individual service documentation for a good overview."""  
    config_request: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('config_request'), 'exclude': lambda f: f is None }})
    r"""Object containing the new configuration. This will be applied automatically when the values are valid."""  
    geo_coords: Optional[shared_geocoords.GeoCoords] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('geo_coords'), 'exclude': lambda f: f is None }})
    r"""Last known geolocation estimate of this object. Not guaranteed to be included in response."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier for resource."""  
    is_online: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_online'), 'exclude': lambda f: f is None }})
    r"""Whether or not this resource is actively connected to the Brain."""  
    report_location: Optional[shared_location.Location] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('report_location'), 'exclude': lambda f: f is None }})  
    request_counter: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_counter'), 'exclude': lambda f: f is None }})
    r"""The total number of HTTP requests that this resource has done."""  
    senses: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('senses'), 'exclude': lambda f: f is None }})
    r"""Senses are values that in most cases are generated inside the spot (number of presences, spot booted etc.). We also have a few senses that can be controlled by the brain. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information."""  
    senses_request: Optional[dict[str, Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('senses_request'), 'exclude': lambda f: f is None }})
    r"""Object containing the new senses configuration. See [Sense & Control](https://intellifi.zendesk.com/hc/en-us/sections/360001568254) documentation for more information."""  
    serial_number: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('serial_number'), 'exclude': lambda f: f is None }})
    r"""This is the fixed and unique spot number. It's assigned during the production process and used to identify an individual device during its lifetime."""  
    status: Optional[Any] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""An object with specific information about the spot, directly send by the spot itself when the connection is created."""  
    time_created: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_created'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was created."""  
    time_updated: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_updated'), 'exclude': lambda f: f is None }})
    r"""[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) formatted string for when this resource was updated."""  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetSpots200ApplicationJSON:
    r"""A JSON object containing a list of spots"""
    
    count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('count'), 'exclude': lambda f: f is None }})
    r"""The maximum number of items in the response (as set in the query or by default)."""  
    count_current: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('count_current'), 'exclude': lambda f: f is None }})
    r"""The maximum number of items available to return."""  
    is_limited: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_limited'), 'exclude': lambda f: f is None }})
    r"""Becomes false when the number of results is smaller than limit."""  
    next_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('next_url'), 'exclude': lambda f: f is None }})
    r"""URL to the next page of items. ( null if none)"""  
    query_duration_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('query_duration_ms'), 'exclude': lambda f: f is None }})
    r"""Amount of time, in milliseconds, the request needed to complete."""  
    results: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('results'), 'exclude': lambda f: f is None }})  
    url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('url'), 'exclude': lambda f: f is None }})
    r"""Url to the individual resource."""  
    

@dataclasses.dataclass
class GetSpotsResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    get_spots_200_application_json_object: Optional[GetSpots200ApplicationJSON] = dataclasses.field(default=None)
    r"""A JSON object containing a list of spots"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    