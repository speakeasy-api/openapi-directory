<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class BranchingModel 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Get the branching model for a repository
     * 
     * Return the branching model as applied to the repository. This view is
     * read-only. The branching model settings can be changed using the
     * [settings](#api-repositories-workspace-repo-slug-branching-model-settings-get) API.
     * 
     * The returned object:
     * 
     * 1. Always has a `development` property. `development.branch` contains
     *    the actual repository branch object that is considered to be the
     *    `development` branch. `development.branch` will not be present
     *    if it does not exist.
     * 2. Might have a `production` property. `production` will not
     *    be present when `production` is disabled.
     *    `production.branch` contains the actual branch object that is
     *    considered to be the `production` branch. `production.branch` will
     *    not be present if it does not exist.
     * 3. Always has a `branch_types` array which contains all enabled branch
     *    types.
     * 
     * Example body:
     * 
     * ```
     * {
     *   "development": {
     *     "name": "master",
     *     "branch": {
     *       "type": "branch",
     *       "name": "master",
     *       "target": {
     *         "hash": "16dffcb0de1b22e249db6799532074cf32efe80f"
     *       }
     *     },
     *     "use_mainbranch": true
     *   },
     *   "production": {
     *     "name": "production",
     *     "branch": {
     *       "type": "branch",
     *       "name": "production",
     *       "target": {
     *         "hash": "16dffcb0de1b22e249db6799532074cf32efe80f"
     *       }
     *     },
     *     "use_mainbranch": false
     *   },
     *   "branch_types": [
     *     {
     *       "kind": "release",
     *       "prefix": "release/"
     *     },
     *     {
     *       "kind": "hotfix",
     *       "prefix": "hotfix/"
     *     },
     *     {
     *       "kind": "feature",
     *       "prefix": "feature/"
     *     },
     *     {
     *       "kind": "bugfix",
     *       "prefix": "bugfix/"
     *     }
     *   ],
     *   "type": "branching_model",
     *   "links": {
     *     "self": {
     *       "href": "https://api.bitbucket.org/.../branching-model"
     *     }
     *   }
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelResponse
     */
	public function getRepositoriesWorkspaceRepoSlugBranchingModel(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branching-model', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchingModel = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the branching model config for a repository
     * 
     * Return the branching model configuration for a repository. The returned
     * object:
     * 
     * 1. Always has a `development` property for the development branch.
     * 2. Always a `production` property for the production branch. The
     *    production branch can be disabled.
     * 3. The `branch_types` contains all the branch types.
     * 
     * This is the raw configuration for the branching model. A client
     * wishing to see the branching model with its actual current branches may
     * find the [active model API](/cloud/bitbucket/rest/api-group-branching-model/#api-repositories-workspace-repo-slug-branching-model-get) more useful.
     * 
     * Example body:
     * 
     * ```
     * {
     *   "development": {
     *     "is_valid": true,
     *     "name": null,
     *     "use_mainbranch": true
     *   },
     *   "production": {
     *     "is_valid": true,
     *     "name": "production",
     *     "use_mainbranch": false,
     *     "enabled": false
     *   },
     *   "branch_types": [
     *     {
     *       "kind": "release",
     *       "enabled": true,
     *       "prefix": "release/"
     *     },
     *     {
     *       "kind": "hotfix",
     *       "enabled": true,
     *       "prefix": "hotfix/"
     *     },
     *     {
     *       "kind": "feature",
     *       "enabled": true,
     *       "prefix": "feature/"
     *     },
     *     {
     *       "kind": "bugfix",
     *       "enabled": false,
     *       "prefix": "bugfix/"
     *     }
     *   ],
     *   "type": "branching_model_settings",
     *   "links": {
     *     "self": {
     *       "href": "https://api.bitbucket.org/.../branching-model/settings"
     *     }
     *   }
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugBranchingModelSettings(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branching-model/settings', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugBranchingModelSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchingModelSettings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the effective, or currently applied, branching model for a repository
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelResponse
     */
	public function getRepositoriesWorkspaceRepoSlugEffectiveBranchingModel(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/effective-branching-model', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveBranchingModelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->effectiveRepoBranchingModel = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the branching model for a project
     * 
     * Return the branching model set at the project level. This view is
     * read-only. The branching model settings can be changed using the
     * [settings](#api-workspaces-workspace-projects-project-key-branching-model-settings-get)
     * API.
     * 
     * The returned object:
     * 
     * 1. Always has a `development` property. `development.name` is
     *    the user-specified branch that can be inherited by an individual repository's
     *    branching model.
     * 2. Might have a `production` property. `production` will not
     *    be present when `production` is disabled.
     *    `production.name` is the user-specified branch that can be
     *    inherited by an individual repository's branching model.
     * 3. Always has a `branch_types` array which contains all enabled branch
     *    types.
     * 
     * Example body:
     * 
     * ```
     * {
     *   "development": {
     *     "name": "master",
     *     "use_mainbranch": true
     *   },
     *   "production": {
     *     "name": "production",
     *     "use_mainbranch": false
     *   },
     *   "branch_types": [
     *     {
     *       "kind": "release",
     *       "prefix": "release/"
     *     },
     *     {
     *       "kind": "hotfix",
     *       "prefix": "hotfix/"
     *     },
     *     {
     *       "kind": "feature",
     *       "prefix": "feature/"
     *     },
     *     {
     *       "kind": "bugfix",
     *       "prefix": "bugfix/"
     *     }
     *   ],
     *   "type": "project_branching_model",
     *   "links": {
     *     "self": {
     *       "href": "https://api.bitbucket.org/.../branching-model"
     *     }
     *   }
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelResponse
     */
	public function getWorkspacesWorkspaceProjectsProjectKeyBranchingModel(
        \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/projects/{project_key}/branching-model', \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->projectBranchingModel = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the branching model config for a project
     * 
     * Return the branching model configuration for a project. The returned
     * object:
     * 
     * 1. Always has a `development` property for the development branch.
     * 2. Always a `production` property for the production branch. The
     *    production branch can be disabled.
     * 3. The `branch_types` contains all the branch types.
     * 
     * 
     * This is the raw configuration for the branching model. A client
     * wishing to see the branching model with its actual current branches may find the
     * [active model API](#api-workspaces-workspace-projects-project-key-branching-model-get)
     * more useful.
     * 
     * Example body:
     * 
     * ```
     * {
     *   "development": {
     *     "name": null,
     *     "use_mainbranch": true
     *   },
     *   "production": {
     *     "name": "production",
     *     "use_mainbranch": false,
     *     "enabled": false
     *   },
     *   "branch_types": [
     *     {
     *       "kind": "release",
     *       "enabled": true,
     *       "prefix": "release/"
     *     },
     *     {
     *       "kind": "hotfix",
     *       "enabled": true,
     *       "prefix": "hotfix/"
     *     },
     *     {
     *       "kind": "feature",
     *       "enabled": true,
     *       "prefix": "feature/"
     *     },
     *     {
     *       "kind": "bugfix",
     *       "enabled": false,
     *       "prefix": "bugfix/"
     *     }
     *   ],
     *   "type": "branching_model_settings",
     *   "links": {
     *     "self": {
     *       "href": "https://api.bitbucket.org/.../branching-model/settings"
     *     }
     *   }
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsResponse
     */
	public function getWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettings(
        \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/projects/{project_key}/branching-model/settings', \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchingModelSettings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the branching model config for a repository
     * 
     * Update the branching model configuration for a repository.
     * 
     * The `development` branch can be configured to a specific branch or to
     * track the main branch. When set to a specific branch it must
     * currently exist. Only the passed properties will be updated. The
     * properties not passed will be left unchanged. A request without a
     * `development` property will leave the development branch unchanged.
     * 
     * It is possible for the `development` branch to be invalid. This
     * happens when it points at a specific branch that has been
     * deleted. This is indicated in the `is_valid` field for the branch. It is
     * not possible to update the settings for `development` if that
     * would leave the branch in an invalid state. Such a request will be
     * rejected.
     * 
     * The `production` branch can be a specific branch, the main
     * branch or disabled. When set to a specific branch it must currently
     * exist. The `enabled` property can be used to enable (`true`) or
     * disable (`false`) it. Only the passed properties will be updated. The
     * properties not passed will be left unchanged. A request without a
     * `production` property will leave the production branch unchanged.
     * 
     * It is possible for the `production` branch to be invalid. This
     * happens when it points at a specific branch that has been
     * deleted. This is indicated in the `is_valid` field for the branch. A
     * request that would leave `production` enabled and invalid will be
     * rejected. It is possible to update `production` and make it invalid if
     * it would also be left disabled.
     * 
     * The `branch_types` property contains the branch types to be updated.
     * Only the branch types passed will be updated. All updates will be
     * rejected if it would leave the branching model in an invalid state.
     * For branch types this means that:
     * 
     * 1. The prefixes for all enabled branch types are valid. For example,
     *    it is not possible to use '*' inside a Git prefix.
     * 2. A prefix of an enabled branch type must not be a prefix of another
     *    enabled branch type. This is to ensure that a branch can be easily
     *    classified by its prefix unambiguously.
     * 
     * It is possible to store an invalid prefix if that branch type would be
     * left disabled. Only the passed properties will be updated. The
     * properties not passed will be left unchanged. Each branch type must
     * have a `kind` property to identify it.
     * 
     * Example Body:
     * 
     * ```
     *     {
     *       "development": {
     *         "use_mainbranch": true
     *       },
     *       "production": {
     *         "enabled": true,
     *         "use_mainbranch": false,
     *         "name": "production"
     *       },
     *       "branch_types": [
     *         {
     *           "kind": "bugfix",
     *           "enabled": true,
     *           "prefix": "bugfix/"
     *         },
     *         {
     *           "kind": "feature",
     *           "enabled": true,
     *           "prefix": "feature/"
     *         },
     *         {
     *           "kind": "hotfix",
     *           "prefix": "hotfix/"
     *         },
     *         {
     *           "kind": "release",
     *           "enabled": false,
     *         }
     *       ]
     *     }
     * ```
     * 
     * There is currently a side effect when using this API endpoint. If the
     * repository is inheriting branching model settings from its project,
     * updating the branching model for this repository will disable the
     * project setting inheritance.
     * 
     * 
     * We have deprecated this side effect and will remove it on 1 August 2022.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsResponse
     */
	public function putRepositoriesWorkspaceRepoSlugBranchingModelSettings(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/branching-model/settings', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugBranchingModelSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchingModelSettings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the branching model config for a project
     * 
     * Update the branching model configuration for a project.
     * 
     * The `development` branch can be configured to a specific branch or to
     * track the main branch. Any branch name can be supplied, but will only
     * successfully be applied to a repository via inheritance if that branch
     * exists for that repository. Only the passed properties will be updated. The
     * properties not passed will be left unchanged. A request without a
     * `development` property will leave the development branch unchanged.
     * 
     * The `production` branch can be a specific branch, the main
     * branch or disabled. Any branch name can be supplied, but will only
     * successfully be applied to a repository via inheritance if that branch
     * exists for that repository. The `enabled` property can be used to enable (`true`)
     * or disable (`false`) it. Only the passed properties will be updated. The
     * properties not passed will be left unchanged. A request without a
     * `production` property will leave the production branch unchanged.
     * 
     * The `branch_types` property contains the branch types to be updated.
     * Only the branch types passed will be updated. All updates will be
     * rejected if it would leave the branching model in an invalid state.
     * For branch types this means that:
     * 
     * 1. The prefixes for all enabled branch types are valid. For example,
     *    it is not possible to use '*' inside a Git prefix.
     * 2. A prefix of an enabled branch type must not be a prefix of another
     *    enabled branch type. This is to ensure that a branch can be easily
     *    classified by its prefix unambiguously.
     * 
     * It is possible to store an invalid prefix if that branch type would be
     * left disabled. Only the passed properties will be updated. The
     * properties not passed will be left unchanged. Each branch type must
     * have a `kind` property to identify it.
     * 
     * Example Body:
     * 
     * ```
     *     {
     *       "development": {
     *         "use_mainbranch": true
     *       },
     *       "production": {
     *         "enabled": true,
     *         "use_mainbranch": false,
     *         "name": "production"
     *       },
     *       "branch_types": [
     *         {
     *           "kind": "bugfix",
     *           "enabled": true,
     *           "prefix": "bugfix/"
     *         },
     *         {
     *           "kind": "feature",
     *           "enabled": true,
     *           "prefix": "feature/"
     *         },
     *         {
     *           "kind": "hotfix",
     *           "prefix": "hotfix/"
     *         },
     *         {
     *           "kind": "release",
     *           "enabled": false,
     *         }
     *       ]
     *     }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsResponse
     */
	public function putWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettings(
        \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/workspaces/{workspace}/projects/{project_key}/branching-model/settings', \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutWorkspacesWorkspaceProjectsProjectKeyBranchingModelSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->branchingModelSettings = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}