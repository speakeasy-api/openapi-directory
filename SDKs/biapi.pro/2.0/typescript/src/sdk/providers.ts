/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Providers {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Disable a connection source
   *
   * @remarks
   * This will make it so the specified source will not be synchronized anymore.<br><br>
   */
  deleteConnectionsIdConnectionSourcesIdSource(
    req: operations.DeleteConnectionsIdConnectionSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConnectionsIdConnectionSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConnectionsIdConnectionSourcesIdSourceRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connections/{id_connection}/sources/{id_source}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConnectionsIdConnectionSourcesIdSourceResponse =
        new operations.DeleteConnectionsIdConnectionSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectionSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectionSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a single Logo object.
   */
  deleteConnectorsIdConnectorLogosIdLogo(
    req: operations.DeleteConnectorsIdConnectorLogosIdLogoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConnectorsIdConnectorLogosIdLogoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConnectorsIdConnectorLogosIdLogoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos/{id_logo}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConnectorsIdConnectorLogosIdLogoResponse =
        new operations.DeleteConnectorsIdConnectorLogosIdLogoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorLogo = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorLogo
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete all connections
   */
  deleteUsersIdUserConnections(
    req: operations.DeleteUsersIdUserConnectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUsersIdUserConnectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUsersIdUserConnectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUsersIdUserConnectionsResponse =
        new operations.DeleteUsersIdUserConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connection = utils.objectToClass(
              httpRes?.data,
              shared.Connection
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a connection.
   *
   * @remarks
   * This endpoint deletes a connection and all related accounts and transactions.<br><br>
   */
  deleteUsersIdUserConnectionsIdConnection(
    req: operations.DeleteUsersIdUserConnectionsIdConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUsersIdUserConnectionsIdConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUsersIdUserConnectionsIdConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUsersIdUserConnectionsIdConnectionResponse =
        new operations.DeleteUsersIdUserConnectionsIdConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connection = utils.objectToClass(
              httpRes?.data,
              shared.Connection
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disable a connection source
   *
   * @remarks
   * This will make it so the specified source will not be synchronized anymore.<br><br>
   */
  deleteUsersIdUserConnectionsIdConnectionSourcesIdSource(
    req: operations.DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}/sources/{id_source}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse =
        new operations.DeleteUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectionSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectionSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of connectors
   */
  getBanks(
    req: operations.GetBanksRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/banks";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksResponse = new operations.GetBanksResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBanks200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetBanks200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a connector
   */
  getBanksIdBank(
    req: operations.GetBanksIdBankRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksIdBankResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksIdBankRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/banks/{id_bank}", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksIdBankResponse =
        new operations.GetBanksIdBankResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connector = utils.objectToClass(
              httpRes?.data,
              shared.Connector
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getBanksIdConnectorLogos(
    req: operations.GetBanksIdConnectorLogosRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksIdConnectorLogosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksIdConnectorLogosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/banks/{id_connector}/logos",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksIdConnectorLogosResponse =
        new operations.GetBanksIdConnectorLogosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBanksIdConnectorLogos200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetBanksIdConnectorLogos200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getBanksIdConnectorLogosMain(
    req: operations.GetBanksIdConnectorLogosMainRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksIdConnectorLogosMainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksIdConnectorLogosMainRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/banks/{id_connector}/logos/main",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksIdConnectorLogosMainResponse =
        new operations.GetBanksIdConnectorLogosMainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBanksIdConnectorLogosMain200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetBanksIdConnectorLogosMain200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getBanksIdConnectorLogosThumbnail(
    req: operations.GetBanksIdConnectorLogosThumbnailRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksIdConnectorLogosThumbnailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksIdConnectorLogosThumbnailRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/banks/{id_connector}/logos/thumbnail",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksIdConnectorLogosThumbnailResponse =
        new operations.GetBanksIdConnectorLogosThumbnailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBanksIdConnectorLogosThumbnail200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetBanksIdConnectorLogosThumbnail200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of connector sources
   */
  getBanksIdConnectorSources(
    req: operations.GetBanksIdConnectorSourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksIdConnectorSourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksIdConnectorSourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/banks/{id_connector}/sources",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksIdConnectorSourcesResponse =
        new operations.GetBanksIdConnectorSourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBanksIdConnectorSources200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetBanksIdConnectorSources200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the connector source
   */
  getBanksIdConnectorSourcesIdSource(
    req: operations.GetBanksIdConnectorSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBanksIdConnectorSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBanksIdConnectorSourcesIdSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/banks/{id_connector}/sources/{id_source}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBanksIdConnectorSourcesIdSourceResponse =
        new operations.GetBanksIdConnectorSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connections without a user
   */
  getConnections(
    req: operations.GetConnectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/connections";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectionsResponse =
        new operations.GetConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnections200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetConnections200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection logs
   *
   * @remarks
   * Get logs about connections.<br><br>
   */
  getConnectionsIdConnectionLogs(
    req: operations.GetConnectionsIdConnectionLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectionsIdConnectionLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectionsIdConnectionLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connections/{id_connection}/logs",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectionsIdConnectionLogsResponse =
        new operations.GetConnectionsIdConnectionLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectionsIdConnectionLogs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetConnectionsIdConnectionLogs200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection sources
   */
  getConnectionsIdConnectionSources(
    req: operations.GetConnectionsIdConnectionSourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectionsIdConnectionSourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectionsIdConnectionSourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connections/{id_connection}/sources",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectionsIdConnectionSourcesResponse =
        new operations.GetConnectionsIdConnectionSourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectionsIdConnectionSources200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetConnectionsIdConnectionSources200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of connectors
   */
  getConnectors(
    req: operations.GetConnectorsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/connectors";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsResponse =
        new operations.GetConnectorsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectors200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetConnectors200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a connector
   */
  getConnectorsIdConnector(
    req: operations.GetConnectorsIdConnectorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsIdConnectorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsIdConnectorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsIdConnectorResponse =
        new operations.GetConnectorsIdConnectorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connector = utils.objectToClass(
              httpRes?.data,
              shared.Connector
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getConnectorsIdConnectorLogos(
    req: operations.GetConnectorsIdConnectorLogosRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsIdConnectorLogosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsIdConnectorLogosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsIdConnectorLogosResponse =
        new operations.GetConnectorsIdConnectorLogosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectorsIdConnectorLogos200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetConnectorsIdConnectorLogos200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getConnectorsIdConnectorLogosMain(
    req: operations.GetConnectorsIdConnectorLogosMainRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsIdConnectorLogosMainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsIdConnectorLogosMainRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos/main",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsIdConnectorLogosMainResponse =
        new operations.GetConnectorsIdConnectorLogosMainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectorsIdConnectorLogosMain200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetConnectorsIdConnectorLogosMain200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getConnectorsIdConnectorLogosThumbnail(
    req: operations.GetConnectorsIdConnectorLogosThumbnailRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsIdConnectorLogosThumbnailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsIdConnectorLogosThumbnailRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos/thumbnail",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsIdConnectorLogosThumbnailResponse =
        new operations.GetConnectorsIdConnectorLogosThumbnailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectorsIdConnectorLogosThumbnail200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetConnectorsIdConnectorLogosThumbnail200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of connector sources
   */
  getConnectorsIdConnectorSources(
    req: operations.GetConnectorsIdConnectorSourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsIdConnectorSourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsIdConnectorSourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/sources",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsIdConnectorSourcesResponse =
        new operations.GetConnectorsIdConnectorSourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectorsIdConnectorSources200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetConnectorsIdConnectorSources200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the connector source
   */
  getConnectorsIdConnectorSourcesIdSource(
    req: operations.GetConnectorsIdConnectorSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectorsIdConnectorSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectorsIdConnectorSourcesIdSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/sources/{id_source}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectorsIdConnectorSourcesIdSourceResponse =
        new operations.GetConnectorsIdConnectorSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection logs
   *
   * @remarks
   * Get logs about connections.<br><br>
   */
  getLogs(
    req: operations.GetLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/logs";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetLogsResponse = new operations.GetLogsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getLogs200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetLogs200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of connectors
   */
  getProviders(
    req: operations.GetProvidersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/providers";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersResponse =
        new operations.GetProvidersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProviders200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.GetProviders200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getProvidersIdConnectorLogos(
    req: operations.GetProvidersIdConnectorLogosRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersIdConnectorLogosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersIdConnectorLogosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{id_connector}/logos",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersIdConnectorLogosResponse =
        new operations.GetProvidersIdConnectorLogosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProvidersIdConnectorLogos200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetProvidersIdConnectorLogos200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getProvidersIdConnectorLogosMain(
    req: operations.GetProvidersIdConnectorLogosMainRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersIdConnectorLogosMainResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersIdConnectorLogosMainRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{id_connector}/logos/main",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersIdConnectorLogosMainResponse =
        new operations.GetProvidersIdConnectorLogosMainResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProvidersIdConnectorLogosMain200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetProvidersIdConnectorLogosMain200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all links to the files associated with this connector.
   *
   * @remarks
   * This endpoint returns all links to files associated with this connector.<br><br>
   */
  getProvidersIdConnectorLogosThumbnail(
    req: operations.GetProvidersIdConnectorLogosThumbnailRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersIdConnectorLogosThumbnailResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersIdConnectorLogosThumbnailRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{id_connector}/logos/thumbnail",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersIdConnectorLogosThumbnailResponse =
        new operations.GetProvidersIdConnectorLogosThumbnailResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProvidersIdConnectorLogosThumbnail200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetProvidersIdConnectorLogosThumbnail200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get list of connector sources
   */
  getProvidersIdConnectorSources(
    req: operations.GetProvidersIdConnectorSourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersIdConnectorSourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersIdConnectorSourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{id_connector}/sources",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersIdConnectorSourcesResponse =
        new operations.GetProvidersIdConnectorSourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getProvidersIdConnectorSources200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetProvidersIdConnectorSources200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the connector source
   */
  getProvidersIdConnectorSourcesIdSource(
    req: operations.GetProvidersIdConnectorSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersIdConnectorSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersIdConnectorSourcesIdSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{id_connector}/sources/{id_source}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersIdConnectorSourcesIdSourceResponse =
        new operations.GetProvidersIdConnectorSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a connector
   */
  getProvidersIdProvider(
    req: operations.GetProvidersIdProviderRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetProvidersIdProviderResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetProvidersIdProviderRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/providers/{id_provider}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetProvidersIdProviderResponse =
        new operations.GetProvidersIdProviderResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connector = utils.objectToClass(
              httpRes?.data,
              shared.Connector
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connections
   */
  getUsersIdUserConnections(
    req: operations.GetUsersIdUserConnectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUsersIdUserConnectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUsersIdUserConnectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUsersIdUserConnectionsResponse =
        new operations.GetUsersIdUserConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUsersIdUserConnections200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetUsersIdUserConnections200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection additionnal informations
   *
   * @remarks
   * <br><br>
   */
  getUsersIdUserConnectionsIdConnectionInformations(
    req: operations.GetUsersIdUserConnectionsIdConnectionInformationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUsersIdUserConnectionsIdConnectionInformationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetUsersIdUserConnectionsIdConnectionInformationsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}/informations",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUsersIdUserConnectionsIdConnectionInformationsResponse =
        new operations.GetUsersIdUserConnectionsIdConnectionInformationsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUsersIdUserConnectionsIdConnectionInformations200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetUsersIdUserConnectionsIdConnectionInformations200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection logs
   *
   * @remarks
   * Get logs about connections.<br><br>
   */
  getUsersIdUserConnectionsIdConnectionLogs(
    req: operations.GetUsersIdUserConnectionsIdConnectionLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUsersIdUserConnectionsIdConnectionLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUsersIdUserConnectionsIdConnectionLogsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}/logs",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUsersIdUserConnectionsIdConnectionLogsResponse =
        new operations.GetUsersIdUserConnectionsIdConnectionLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUsersIdUserConnectionsIdConnectionLogs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetUsersIdUserConnectionsIdConnectionLogs200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection sources
   */
  getUsersIdUserConnectionsIdConnectionSources(
    req: operations.GetUsersIdUserConnectionsIdConnectionSourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUsersIdUserConnectionsIdConnectionSourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUsersIdUserConnectionsIdConnectionSourcesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}/sources",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUsersIdUserConnectionsIdConnectionSourcesResponse =
        new operations.GetUsersIdUserConnectionsIdConnectionSourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUsersIdUserConnectionsIdConnectionSources200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetUsersIdUserConnectionsIdConnectionSources200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get connection logs
   *
   * @remarks
   * Get logs about connections.<br><br>
   */
  getUsersIdUserLogs(
    req: operations.GetUsersIdUserLogsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUsersIdUserLogsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUsersIdUserLogsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/logs",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUsersIdUserLogsResponse =
        new operations.GetUsersIdUserLogsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUsersIdUserLogs200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.GetUsersIdUserLogs200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * "
   *
   * @remarks
   * This endpoint is used to enable a source or force a synchronization on it.<br><br>
   */
  postConnectionsIdConnectionSourcesIdSource(
    req: operations.PostConnectionsIdConnectionSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostConnectionsIdConnectionSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostConnectionsIdConnectionSourcesIdSourceRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connections/{id_connection}/sources/{id_source}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostConnectionsIdConnectionSourcesIdSourceResponse =
        new operations.PostConnectionsIdConnectionSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectionSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectionSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Request a new connector
   *
   * @remarks
   * Send a request to add a new connector<br><br>
   */
  postConnectors(
    req: operations.PostConnectorsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostConnectorsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostConnectorsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/connectors";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostConnectorsResponse =
        new operations.PostConnectorsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connector = utils.objectToClass(
              httpRes?.data,
              shared.Connector
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a connector Logo
   *
   * @remarks
   * This endpoint creates a connector logo. You can either pass a file to as a parameter to insert and link it with the connector or pass an id_file to link a connector with an existing file. Will fail if the file is already linked with that connector.<br><br>Form params: - id_file (integer): The id of the file to link with that connector. - img (string): Path to the image to link with that connector.<br><br>
   */
  postConnectorsIdConnectorLogos(
    req: operations.PostConnectorsIdConnectorLogosRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostConnectorsIdConnectorLogosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostConnectorsIdConnectorLogosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostConnectorsIdConnectorLogosResponse =
        new operations.PostConnectorsIdConnectorLogosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorLogo = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorLogo
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add a new connection.
   *
   * @remarks
   * Create a new connection to a given bank or provider. You have to give all needed parameters (use /banks/ID/fields or /providers/ID/fields to get them).<br><br>
   */
  postUsersIdUserConnections(
    req: operations.PostUsersIdUserConnectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostUsersIdUserConnectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostUsersIdUserConnectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostUsersIdUserConnectionsResponse =
        new operations.PostUsersIdUserConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connection = utils.objectToClass(
              httpRes?.data,
              shared.Connection
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a connection.
   *
   * @remarks
   * Give new parameters to change on the configuration of this connection (for example "password").<br><br>It tests connection to website, and if it fails, a 400 response is given with the error code "wrongpass" or "websiteUnavailable".<br><br>You can also supply meta-parameters on connection, like 'active' or 'expire'.<br><br>It's possible to execute the update/synchronization in the background with a query parameter. If done in background this endpoint will respond with data that is not yet updated. To obtain updated data, polling is required as the the data will be filled in the background.<br><br>
   */
  postUsersIdUserConnectionsIdConnection(
    req: operations.PostUsersIdUserConnectionsIdConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostUsersIdUserConnectionsIdConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostUsersIdUserConnectionsIdConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostUsersIdUserConnectionsIdConnectionResponse =
        new operations.PostUsersIdUserConnectionsIdConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connection = utils.objectToClass(
              httpRes?.data,
              shared.Connection
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * "
   *
   * @remarks
   * This endpoint is used to enable a source or force a synchronization on it.<br><br>
   */
  postUsersIdUserConnectionsIdConnectionSourcesIdSource(
    req: operations.PostUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PostUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}/sources/{id_source}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse =
        new operations.PostUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectionSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectionSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update connection source
   *
   * @remarks
   * This endpoint is used to enable a source or force a synchronization on it.<br><br>
   */
  putConnectionsIdConnectionSourcesIdSource(
    req: operations.PutConnectionsIdConnectionSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutConnectionsIdConnectionSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutConnectionsIdConnectionSourcesIdSourceRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connections/{id_connection}/sources/{id_source}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutConnectionsIdConnectionSourcesIdSourceResponse =
        new operations.PutConnectionsIdConnectionSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectionSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectionSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create or Update a connector Logo
   *
   * @remarks
   * This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
   */
  putConnectorsIdConnectorLogos(
    req: operations.PutConnectorsIdConnectorLogosRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutConnectorsIdConnectorLogosResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutConnectorsIdConnectorLogosRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutConnectorsIdConnectorLogosResponse =
        new operations.PutConnectorsIdConnectorLogosResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorLogo = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorLogo
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create or Update a connector Logo.
   *
   * @remarks
   * This endpoint creates or update a connector logo. This logo is a mapping between a file (/file route) and a connector (/connectors route) or a provider (/providers route).<br><br>Form params: - id_file (integer): The id of the file to link with that connector.<br><br>
   */
  putConnectorsIdConnectorLogosIdLogo(
    req: operations.PutConnectorsIdConnectorLogosIdLogoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutConnectorsIdConnectorLogosIdLogoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutConnectorsIdConnectorLogosIdLogoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/logos/{id_logo}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutConnectorsIdConnectorLogosIdLogoResponse =
        new operations.PutConnectorsIdConnectorLogosIdLogoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorLogo = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorLogo
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Edit several connector sources
   */
  putConnectorsIdConnectorSources(
    req: operations.PutConnectorsIdConnectorSourcesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutConnectorsIdConnectorSourcesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutConnectorsIdConnectorSourcesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/sources",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutConnectorsIdConnectorSourcesResponse =
        new operations.PutConnectorsIdConnectorSourcesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Edit the provided connector source
   */
  putConnectorsIdConnectorSourcesIdSource(
    req: operations.PutConnectorsIdConnectorSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutConnectorsIdConnectorSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutConnectorsIdConnectorSourcesIdSourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/connectors/{id_connector}/sources/{id_source}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutConnectorsIdConnectorSourcesIdSourceResponse =
        new operations.PutConnectorsIdConnectorSourcesIdSourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectorSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectorSource
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Force synchronisation of a connection.
   *
   * @remarks
   * We suggest to pass parameter expand=accounts[transactions] to get all *new* and *updated* transactions.<br><br>
   */
  putUsersIdUserConnectionsIdConnection(
    req: operations.PutUsersIdUserConnectionsIdConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutUsersIdUserConnectionsIdConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutUsersIdUserConnectionsIdConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutUsersIdUserConnectionsIdConnectionResponse =
        new operations.PutUsersIdUserConnectionsIdConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connection = utils.objectToClass(
              httpRes?.data,
              shared.Connection
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update connection source
   *
   * @remarks
   * This endpoint is used to enable a source or force a synchronization on it.<br><br>
   */
  putUsersIdUserConnectionsIdConnectionSourcesIdSource(
    req: operations.PutUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PutUsersIdUserConnectionsIdConnectionSourcesIdSourceRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/users/{id_user}/connections/{id_connection}/sources/{id_source}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse =
        new operations.PutUsersIdUserConnectionsIdConnectionSourcesIdSourceResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.connectionSource = utils.objectToClass(
              httpRes?.data,
              shared.ConnectionSource
            );
          }
          break;
      }

      return res;
    });
  }
}
