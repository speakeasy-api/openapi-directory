/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  /**
   * The AWS Glue multi-region endpoint
   */
  "http://glue.{region}.amazonaws.com",
  /**
   * The AWS Glue multi-region endpoint
   */
  "https://glue.{region}.amazonaws.com",
  /**
   * The AWS Glue endpoint for China (Beijing) and China (Ningxia)
   */
  "http://glue.{region}.amazonaws.com.cn",
  /**
   * The AWS Glue endpoint for China (Beijing) and China (Ningxia)
   */
  "https://glue.{region}.amazonaws.com.cn",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * <fullname>Glue</fullname> <p>Defines the public endpoint for the Glue service.</p>
 *
 * @see {@link https://docs.aws.amazon.com/glue/} - Amazon Web Services documentation
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * Creates one or more partitions in a batch operation.
   */
  batchCreatePartition(
    req: operations.BatchCreatePartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchCreatePartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchCreatePartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchCreatePartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchCreatePartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchCreatePartitionResponse =
        new operations.BatchCreatePartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchCreatePartitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchCreatePartitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a list of connection definitions from the Data Catalog.
   */
  batchDeleteConnection(
    req: operations.BatchDeleteConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchDeleteConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchDeleteConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchDeleteConnection";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchDeleteConnectionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchDeleteConnectionResponse =
        new operations.BatchDeleteConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchDeleteConnectionResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchDeleteConnectionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes one or more partitions in a batch operation.
   */
  batchDeletePartition(
    req: operations.BatchDeletePartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchDeletePartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchDeletePartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchDeletePartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchDeletePartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchDeletePartitionResponse =
        new operations.BatchDeletePartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchDeletePartitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchDeletePartitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Deletes multiple tables at once.</p> <note> <p>After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service.</p> <p>To ensure the immediate deletion of all related resources, before calling <code>BatchDeleteTable</code>, use <code>DeleteTableVersion</code> or <code>BatchDeleteTableVersion</code>, and <code>DeletePartition</code> or <code>BatchDeletePartition</code>, to delete any resources that belong to the table.</p> </note>
   */
  batchDeleteTable(
    req: operations.BatchDeleteTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchDeleteTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchDeleteTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchDeleteTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchDeleteTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchDeleteTableResponse =
        new operations.BatchDeleteTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchDeleteTableResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchDeleteTableResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified batch of versions of a table.
   */
  batchDeleteTableVersion(
    req: operations.BatchDeleteTableVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchDeleteTableVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchDeleteTableVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchDeleteTableVersion";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchDeleteTableVersionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchDeleteTableVersionResponse =
        new operations.BatchDeleteTableVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchDeleteTableVersionResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchDeleteTableVersionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves information about a list of blueprints.
   */
  batchGetBlueprints(
    req: operations.BatchGetBlueprintsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetBlueprintsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetBlueprintsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchGetBlueprints";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetBlueprintsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetBlueprintsResponse =
        new operations.BatchGetBlueprintsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetBlueprintsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetBlueprintsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of resource metadata for a given list of crawler names. After calling the <code>ListCrawlers</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
   */
  batchGetCrawlers(
    req: operations.BatchGetCrawlersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetCrawlersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetCrawlersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchGetCrawlers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetCrawlersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetCrawlersResponse =
        new operations.BatchGetCrawlersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetCrawlersResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetCrawlersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the details for the custom patterns specified by a list of names.
   */
  batchGetCustomEntityTypes(
    req: operations.BatchGetCustomEntityTypesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetCustomEntityTypesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetCustomEntityTypesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchGetCustomEntityTypes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetCustomEntityTypesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetCustomEntityTypesResponse =
        new operations.BatchGetCustomEntityTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetCustomEntityTypesResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetCustomEntityTypesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of data quality results for the specified result IDs.
   */
  batchGetDataQualityResult(
    req: operations.BatchGetDataQualityResultRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetDataQualityResultResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetDataQualityResultRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchGetDataQualityResult";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetDataQualityResultRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetDataQualityResultResponse =
        new operations.BatchGetDataQualityResultResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetDataQualityResultResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetDataQualityResultResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of resource metadata for a given list of development endpoint names. After calling the <code>ListDevEndpoints</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
   */
  batchGetDevEndpoints(
    req: operations.BatchGetDevEndpointsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetDevEndpointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetDevEndpointsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchGetDevEndpoints";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetDevEndpointsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetDevEndpointsResponse =
        new operations.BatchGetDevEndpointsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetDevEndpointsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetDevEndpointsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of resource metadata for a given list of job names. After calling the <code>ListJobs</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
   */
  batchGetJobs(
    req: operations.BatchGetJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchGetJobs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetJobsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetJobsResponse =
        new operations.BatchGetJobsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetJobsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetJobsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves partitions in a batch request.
   */
  batchGetPartition(
    req: operations.BatchGetPartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetPartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetPartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchGetPartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetPartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetPartitionResponse =
        new operations.BatchGetPartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetPartitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetPartitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of resource metadata for a given list of trigger names. After calling the <code>ListTriggers</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
   */
  batchGetTriggers(
    req: operations.BatchGetTriggersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetTriggersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetTriggersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchGetTriggers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetTriggersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetTriggersResponse =
        new operations.BatchGetTriggersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetTriggersResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetTriggersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of resource metadata for a given list of workflow names. After calling the <code>ListWorkflows</code> operation, you can call this operation to access the data to which you have been granted permissions. This operation supports all IAM permissions, including permission conditions that uses tags.
   */
  batchGetWorkflows(
    req: operations.BatchGetWorkflowsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchGetWorkflowsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchGetWorkflowsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchGetWorkflows";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchGetWorkflowsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchGetWorkflowsResponse =
        new operations.BatchGetWorkflowsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchGetWorkflowsResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchGetWorkflowsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stops one or more job runs for a specified job definition.
   */
  batchStopJobRun(
    req: operations.BatchStopJobRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchStopJobRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchStopJobRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.BatchStopJobRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchStopJobRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchStopJobRunResponse =
        new operations.BatchStopJobRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchStopJobRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchStopJobRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates one or more partitions in a batch operation.
   */
  batchUpdatePartition(
    req: operations.BatchUpdatePartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchUpdatePartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchUpdatePartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.BatchUpdatePartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "batchUpdatePartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchUpdatePartitionResponse =
        new operations.BatchUpdatePartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchUpdatePartitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchUpdatePartitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels the specified recommendation run that was being used to generate rules.
   */
  cancelDataQualityRuleRecommendationRun(
    req: operations.CancelDataQualityRuleRecommendationRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelDataQualityRuleRecommendationRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelDataQualityRuleRecommendationRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CancelDataQualityRuleRecommendationRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cancelDataQualityRuleRecommendationRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelDataQualityRuleRecommendationRunResponse =
        new operations.CancelDataQualityRuleRecommendationRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelDataQualityRuleRecommendationRunResponse =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels a run where a ruleset is being evaluated against a data source.
   */
  cancelDataQualityRulesetEvaluationRun(
    req: operations.CancelDataQualityRulesetEvaluationRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelDataQualityRulesetEvaluationRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelDataQualityRulesetEvaluationRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CancelDataQualityRulesetEvaluationRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cancelDataQualityRulesetEvaluationRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelDataQualityRulesetEvaluationRunResponse =
        new operations.CancelDataQualityRulesetEvaluationRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelDataQualityRulesetEvaluationRunResponse =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels (stops) a task run. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can cancel a machine learning task run at any time by calling <code>CancelMLTaskRun</code> with a task run's parent transform's <code>TransformID</code> and the task run's <code>TaskRunId</code>.
   */
  cancelMLTaskRun(
    req: operations.CancelMLTaskRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelMLTaskRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelMLTaskRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CancelMLTaskRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cancelMLTaskRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelMLTaskRunResponse =
        new operations.CancelMLTaskRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelMLTaskRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.CancelMLTaskRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels the statement.
   */
  cancelStatement(
    req: operations.CancelStatementRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelStatementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelStatementRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CancelStatement";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "cancelStatementRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CancelStatementResponse =
        new operations.CancelStatementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.cancelStatementResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalSessionStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validates the supplied schema. This call has no side effects, it simply validates using the supplied schema using <code>DataFormat</code> as the format. Since it does not take a schema set name, no compatibility checks are performed.
   */
  checkSchemaVersionValidity(
    req: operations.CheckSchemaVersionValidityRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CheckSchemaVersionValidityResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CheckSchemaVersionValidityRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CheckSchemaVersionValidity";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "checkSchemaVersionValidityInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CheckSchemaVersionValidityResponse =
        new operations.CheckSchemaVersionValidityResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.checkSchemaVersionValidityResponse = utils.objectToClass(
              httpRes?.data,
              shared.CheckSchemaVersionValidityResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Registers a blueprint with Glue.
   */
  createBlueprint(
    req: operations.CreateBlueprintRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateBlueprintResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateBlueprintRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateBlueprint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createBlueprintRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateBlueprintResponse =
        new operations.CreateBlueprintResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createBlueprintResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateBlueprintResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a classifier in the user's account. This can be a <code>GrokClassifier</code>, an <code>XMLClassifier</code>, a <code>JsonClassifier</code>, or a <code>CsvClassifier</code>, depending on which field of the request is present.
   */
  createClassifier(
    req: operations.CreateClassifierRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateClassifierResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateClassifierRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateClassifier";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createClassifierRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateClassifierResponse =
        new operations.CreateClassifierResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createClassifierResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a connection definition in the Data Catalog.
   */
  createConnection(
    req: operations.CreateConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateConnection";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createConnectionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateConnectionResponse =
        new operations.CreateConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createConnectionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new crawler with specified targets, role, configuration, and optional schedule. At least one crawl target must be specified, in the <code>s3Targets</code> field, the <code>jdbcTargets</code> field, or the <code>DynamoDBTargets</code> field.
   */
  createCrawler(
    req: operations.CreateCrawlerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCrawlerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCrawlerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateCrawler";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createCrawlerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCrawlerResponse =
        new operations.CreateCrawlerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createCrawlerResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a custom pattern that is used to detect sensitive data across the columns and rows of your structured data.</p> <p>Each custom pattern you create specifies a regular expression and an optional list of context words. If no context words are passed only a regular expression is checked.</p>
   */
  createCustomEntityType(
    req: operations.CreateCustomEntityTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCustomEntityTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateCustomEntityTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CreateCustomEntityType";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createCustomEntityTypeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateCustomEntityTypeResponse =
        new operations.CreateCustomEntityTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createCustomEntityTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateCustomEntityTypeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a data quality ruleset with DQDL rules applied to a specified Glue table.</p> <p>You create the ruleset using the Data Quality Definition Language (DQDL). For more information, see the Glue developer guide.</p>
   */
  createDataQualityRuleset(
    req: operations.CreateDataQualityRulesetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDataQualityRulesetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDataQualityRulesetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CreateDataQualityRuleset";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createDataQualityRulesetRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDataQualityRulesetResponse =
        new operations.CreateDataQualityRulesetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createDataQualityRulesetResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateDataQualityRulesetResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new database in a Data Catalog.
   */
  createDatabase(
    req: operations.CreateDatabaseRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDatabaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDatabaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateDatabase";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createDatabaseRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDatabaseResponse =
        new operations.CreateDatabaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createDatabaseResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new development endpoint.
   */
  createDevEndpoint(
    req: operations.CreateDevEndpointRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateDevEndpointResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateDevEndpointRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateDevEndpoint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createDevEndpointRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateDevEndpointResponse =
        new operations.CreateDevEndpointResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createDevEndpointResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateDevEndpointResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new job definition.
   */
  createJob(
    req: operations.CreateJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateJob";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateJobResponse =
        new operations.CreateJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateJobResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates an Glue machine learning transform. This operation creates the transform and all the necessary parameters to train it.</p> <p>Call this operation as the first step in the process of using a machine learning transform (such as the <code>FindMatches</code> transform) for deduplicating data. You can provide an optional <code>Description</code>, in addition to the parameters that you want to use for your algorithm.</p> <p>You must also specify certain parameters for the tasks that Glue runs on your behalf as part of learning from your data and creating a high-quality machine learning transform. These parameters include <code>Role</code>, and optionally, <code>AllocatedCapacity</code>, <code>Timeout</code>, and <code>MaxRetries</code>. For more information, see <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html">Jobs</a>.</p>
   */
  createMLTransform(
    req: operations.CreateMLTransformRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateMLTransformResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateMLTransformRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateMLTransform";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createMLTransformRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateMLTransformResponse =
        new operations.CreateMLTransformResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createMLTransformResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateMLTransformResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new partition.
   */
  createPartition(
    req: operations.CreatePartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreatePartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createPartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePartitionResponse =
        new operations.CreatePartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createPartitionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a specified partition index in an existing table.
   */
  createPartitionIndex(
    req: operations.CreatePartitionIndexRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreatePartitionIndexResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreatePartitionIndexRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CreatePartitionIndex";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createPartitionIndexRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreatePartitionIndexResponse =
        new operations.CreatePartitionIndexResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createPartitionIndexResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new registry which may be used to hold a collection of schemas.
   */
  createRegistry(
    req: operations.CreateRegistryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateRegistryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateRegistryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateRegistry";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createRegistryInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateRegistryResponse =
        new operations.CreateRegistryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createRegistryResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateRegistryResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates a new schema set and registers the schema definition. Returns an error if the schema set already exists without actually registering the version.</p> <p>When the schema set is created, a version checkpoint will be set to the first version. Compatibility mode "DISABLED" restricts any additional schema versions from being added after the first schema version. For all other compatibility modes, validation of compatibility settings will be applied only from the second version onwards when the <code>RegisterSchemaVersion</code> API is used.</p> <p>When this API is called without a <code>RegistryId</code>, this will create an entry for a "default-registry" in the registry database tables, if it is not already present.</p>
   */
  createSchema(
    req: operations.CreateSchemaRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSchemaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSchemaRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateSchema";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createSchemaInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSchemaResponse =
        new operations.CreateSchemaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createSchemaResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateSchemaResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transforms a directed acyclic graph (DAG) into code.
   */
  createScript(
    req: operations.CreateScriptRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateScriptResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateScriptRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateScript";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createScriptRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateScriptResponse =
        new operations.CreateScriptResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createScriptResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateScriptResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new security configuration. A security configuration is a set of security properties that can be used by Glue. You can use a security configuration to encrypt data at rest. For information about using security configurations in Glue, see <a href="https://docs.aws.amazon.com/glue/latest/dg/encryption-security-configuration.html">Encrypting Data Written by Crawlers, Jobs, and Development Endpoints</a>.
   */
  createSecurityConfiguration(
    req: operations.CreateSecurityConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSecurityConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSecurityConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CreateSecurityConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createSecurityConfigurationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSecurityConfigurationResponse =
        new operations.CreateSecurityConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createSecurityConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateSecurityConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new session.
   */
  createSession(
    req: operations.CreateSessionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSessionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSessionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateSession";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createSessionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateSessionResponse =
        new operations.CreateSessionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createSessionResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateSessionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new table definition in the Data Catalog.
   */
  createTable(
    req: operations.CreateTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTableResponse =
        new operations.CreateTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createTableResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 488:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new trigger.
   */
  createTrigger(
    req: operations.CreateTriggerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateTriggerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateTrigger";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createTriggerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateTriggerResponse =
        new operations.CreateTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createTriggerResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateTriggerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new function definition in the Data Catalog.
   */
  createUserDefinedFunction(
    req: operations.CreateUserDefinedFunctionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateUserDefinedFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateUserDefinedFunctionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.CreateUserDefinedFunction";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createUserDefinedFunctionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateUserDefinedFunctionResponse =
        new operations.CreateUserDefinedFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createUserDefinedFunctionResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new workflow.
   */
  createWorkflow(
    req: operations.CreateWorkflowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateWorkflowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.CreateWorkflow";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createWorkflowRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CreateWorkflowResponse =
        new operations.CreateWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.createWorkflowResponse = utils.objectToClass(
              httpRes?.data,
              shared.CreateWorkflowResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an existing blueprint.
   */
  deleteBlueprint(
    req: operations.DeleteBlueprintRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteBlueprintResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteBlueprintRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteBlueprint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteBlueprintRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteBlueprintResponse =
        new operations.DeleteBlueprintResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteBlueprintResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteBlueprintResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a classifier from the Data Catalog.
   */
  deleteClassifier(
    req: operations.DeleteClassifierRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteClassifierResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteClassifierRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteClassifier";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteClassifierRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteClassifierResponse =
        new operations.DeleteClassifierResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteClassifierResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Delete the partition column statistics of a column.</p> <p>The Identity and Access Management (IAM) permission required for this operation is <code>DeletePartition</code>.</p>
   */
  deleteColumnStatisticsForPartition(
    req: operations.DeleteColumnStatisticsForPartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteColumnStatisticsForPartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteColumnStatisticsForPartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteColumnStatisticsForPartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteColumnStatisticsForPartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteColumnStatisticsForPartitionResponse =
        new operations.DeleteColumnStatisticsForPartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteColumnStatisticsForPartitionResponse =
              utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves table statistics of columns.</p> <p>The Identity and Access Management (IAM) permission required for this operation is <code>DeleteTable</code>.</p>
   */
  deleteColumnStatisticsForTable(
    req: operations.DeleteColumnStatisticsForTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteColumnStatisticsForTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteColumnStatisticsForTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteColumnStatisticsForTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteColumnStatisticsForTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteColumnStatisticsForTableResponse =
        new operations.DeleteColumnStatisticsForTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteColumnStatisticsForTableResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a connection from the Data Catalog.
   */
  deleteConnection(
    req: operations.DeleteConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteConnection";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteConnectionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteConnectionResponse =
        new operations.DeleteConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteConnectionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a specified crawler from the Glue Data Catalog, unless the crawler state is <code>RUNNING</code>.
   */
  deleteCrawler(
    req: operations.DeleteCrawlerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCrawlerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCrawlerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteCrawler";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteCrawlerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCrawlerResponse =
        new operations.DeleteCrawlerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteCrawlerResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlerRunningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulerTransitioningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a custom pattern by specifying its name.
   */
  deleteCustomEntityType(
    req: operations.DeleteCustomEntityTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteCustomEntityTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteCustomEntityTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteCustomEntityType";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteCustomEntityTypeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteCustomEntityTypeResponse =
        new operations.DeleteCustomEntityTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteCustomEntityTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteCustomEntityTypeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a data quality ruleset.
   */
  deleteDataQualityRuleset(
    req: operations.DeleteDataQualityRulesetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDataQualityRulesetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDataQualityRulesetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteDataQualityRuleset";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteDataQualityRulesetRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDataQualityRulesetResponse =
        new operations.DeleteDataQualityRulesetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteDataQualityRulesetResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Removes a specified database from a Data Catalog.</p> <note> <p>After completing this operation, you no longer have access to the tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted database. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service.</p> <p>To ensure the immediate deletion of all related resources, before calling <code>DeleteDatabase</code>, use <code>DeleteTableVersion</code> or <code>BatchDeleteTableVersion</code>, <code>DeletePartition</code> or <code>BatchDeletePartition</code>, <code>DeleteUserDefinedFunction</code>, and <code>DeleteTable</code> or <code>BatchDeleteTable</code>, to delete any resources that belong to the database.</p> </note>
   */
  deleteDatabase(
    req: operations.DeleteDatabaseRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDatabaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDatabaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteDatabase";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteDatabaseRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDatabaseResponse =
        new operations.DeleteDatabaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteDatabaseResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified development endpoint.
   */
  deleteDevEndpoint(
    req: operations.DeleteDevEndpointRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteDevEndpointResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteDevEndpointRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteDevEndpoint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteDevEndpointRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteDevEndpointResponse =
        new operations.DeleteDevEndpointResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteDevEndpointResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified job definition. If the job definition is not found, no exception is thrown.
   */
  deleteJob(
    req: operations.DeleteJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteJob";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteJobResponse =
        new operations.DeleteJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteJobResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an Glue machine learning transform. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. If you no longer need a transform, you can delete it by calling <code>DeleteMLTransforms</code>. However, any Glue jobs that still reference the deleted transform will no longer succeed.
   */
  deleteMLTransform(
    req: operations.DeleteMLTransformRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteMLTransformResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteMLTransformRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteMLTransform";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteMLTransformRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteMLTransformResponse =
        new operations.DeleteMLTransformResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteMLTransformResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteMLTransformResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified partition.
   */
  deletePartition(
    req: operations.DeletePartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeletePartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deletePartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePartitionResponse =
        new operations.DeletePartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deletePartitionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified partition index from an existing table.
   */
  deletePartitionIndex(
    req: operations.DeletePartitionIndexRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletePartitionIndexResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletePartitionIndexRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeletePartitionIndex";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deletePartitionIndexRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletePartitionIndexResponse =
        new operations.DeletePartitionIndexResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deletePartitionIndexResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete the entire registry including schema and all of its versions. To get the status of the delete operation, you can call the <code>GetRegistry</code> API after the asynchronous call. Deleting a registry will deactivate all online operations for the registry such as the <code>UpdateRegistry</code>, <code>CreateSchema</code>, <code>UpdateSchema</code>, and <code>RegisterSchemaVersion</code> APIs.
   */
  deleteRegistry(
    req: operations.DeleteRegistryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRegistryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRegistryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteRegistry";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteRegistryInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRegistryResponse =
        new operations.DeleteRegistryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteRegistryResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteRegistryResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified policy.
   */
  deleteResourcePolicy(
    req: operations.DeleteResourcePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteResourcePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteResourcePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteResourcePolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteResourcePolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteResourcePolicyResponse =
        new operations.DeleteResourcePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteResourcePolicyResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conditionCheckFailureException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the entire schema set, including the schema set and all of its versions. To get the status of the delete operation, you can call <code>GetSchema</code> API after the asynchronous call. Deleting a registry will deactivate all online operations for the schema, such as the <code>GetSchemaByDefinition</code>, and <code>RegisterSchemaVersion</code> APIs.
   */
  deleteSchema(
    req: operations.DeleteSchemaRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSchemaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSchemaRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteSchema";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteSchemaInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSchemaResponse =
        new operations.DeleteSchemaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteSchemaResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteSchemaResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Remove versions from the specified schema. A version number or range may be supplied. If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned. Calling the <code>GetSchemaVersions</code> API after this call will list the status of the deleted versions.</p> <p>When the range of version numbers contain check pointed version, the API will return a 409 conflict and will not proceed with the deletion. You have to remove the checkpoint first using the <code>DeleteSchemaCheckpoint</code> API before using this API.</p> <p>You cannot use the <code>DeleteSchemaVersions</code> API to delete the first schema version in the schema set. The first schema version can only be deleted by the <code>DeleteSchema</code> API. This operation will also delete the attached <code>SchemaVersionMetadata</code> under the schema versions. Hard deletes will be enforced on the database.</p> <p>If the compatibility mode forbids deleting of a version that is necessary, such as BACKWARDS_FULL, an error is returned.</p>
   */
  deleteSchemaVersions(
    req: operations.DeleteSchemaVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSchemaVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSchemaVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteSchemaVersions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteSchemaVersionsInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSchemaVersionsResponse =
        new operations.DeleteSchemaVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteSchemaVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteSchemaVersionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified security configuration.
   */
  deleteSecurityConfiguration(
    req: operations.DeleteSecurityConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSecurityConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSecurityConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteSecurityConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteSecurityConfigurationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSecurityConfigurationResponse =
        new operations.DeleteSecurityConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteSecurityConfigurationResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the session.
   */
  deleteSession(
    req: operations.DeleteSessionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteSessionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteSessionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteSession";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteSessionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteSessionResponse =
        new operations.DeleteSessionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteSessionResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteSessionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalSessionStateException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Removes a table definition from the Data Catalog.</p> <note> <p>After completing this operation, you no longer have access to the table versions and partitions that belong to the deleted table. Glue deletes these "orphaned" resources asynchronously in a timely manner, at the discretion of the service.</p> <p>To ensure the immediate deletion of all related resources, before calling <code>DeleteTable</code>, use <code>DeleteTableVersion</code> or <code>BatchDeleteTableVersion</code>, and <code>DeletePartition</code> or <code>BatchDeletePartition</code>, to delete any resources that belong to the table.</p> </note>
   */
  deleteTable(
    req: operations.DeleteTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTableResponse =
        new operations.DeleteTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteTableResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified version of a table.
   */
  deleteTableVersion(
    req: operations.DeleteTableVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTableVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTableVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteTableVersion";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteTableVersionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTableVersionResponse =
        new operations.DeleteTableVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteTableVersionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a specified trigger. If the trigger is not found, no exception is thrown.
   */
  deleteTrigger(
    req: operations.DeleteTriggerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTriggerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteTrigger";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteTriggerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTriggerResponse =
        new operations.DeleteTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteTriggerResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteTriggerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes an existing function definition from the Data Catalog.
   */
  deleteUserDefinedFunction(
    req: operations.DeleteUserDefinedFunctionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteUserDefinedFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteUserDefinedFunctionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.DeleteUserDefinedFunction";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteUserDefinedFunctionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteUserDefinedFunctionResponse =
        new operations.DeleteUserDefinedFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteUserDefinedFunctionResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes a workflow.
   */
  deleteWorkflow(
    req: operations.DeleteWorkflowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWorkflowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.DeleteWorkflow";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "deleteWorkflowRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWorkflowResponse =
        new operations.DeleteWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.deleteWorkflowResponse = utils.objectToClass(
              httpRes?.data,
              shared.DeleteWorkflowResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the details of a blueprint.
   */
  getBlueprint(
    req: operations.GetBlueprintRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBlueprintResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBlueprintRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetBlueprint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getBlueprintRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBlueprintResponse =
        new operations.GetBlueprintResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBlueprintResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetBlueprintResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the details of a blueprint run.
   */
  getBlueprintRun(
    req: operations.GetBlueprintRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBlueprintRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBlueprintRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetBlueprintRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getBlueprintRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBlueprintRunResponse =
        new operations.GetBlueprintRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBlueprintRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetBlueprintRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the details of blueprint runs for a specified blueprint.
   */
  getBlueprintRuns(
    req: operations.GetBlueprintRunsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetBlueprintRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetBlueprintRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetBlueprintRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getBlueprintRunsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetBlueprintRunsResponse =
        new operations.GetBlueprintRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getBlueprintRunsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetBlueprintRunsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the status of a migration operation.
   */
  getCatalogImportStatus(
    req: operations.GetCatalogImportStatusRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCatalogImportStatusResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCatalogImportStatusRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetCatalogImportStatus";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getCatalogImportStatusRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCatalogImportStatusResponse =
        new operations.GetCatalogImportStatusResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCatalogImportStatusResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetCatalogImportStatusResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a classifier by name.
   */
  getClassifier(
    req: operations.GetClassifierRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetClassifierResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetClassifierRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetClassifier";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getClassifierRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetClassifierResponse =
        new operations.GetClassifierResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getClassifierResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetClassifierResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all classifier objects in the Data Catalog.
   */
  getClassifiers(
    req: operations.GetClassifiersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetClassifiersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetClassifiersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetClassifiers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getClassifiersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetClassifiersResponse =
        new operations.GetClassifiersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getClassifiersResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetClassifiersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves partition statistics of columns.</p> <p>The Identity and Access Management (IAM) permission required for this operation is <code>GetPartition</code>.</p>
   */
  getColumnStatisticsForPartition(
    req: operations.GetColumnStatisticsForPartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetColumnStatisticsForPartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetColumnStatisticsForPartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetColumnStatisticsForPartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getColumnStatisticsForPartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetColumnStatisticsForPartitionResponse =
        new operations.GetColumnStatisticsForPartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getColumnStatisticsForPartitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetColumnStatisticsForPartitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves table statistics of columns.</p> <p>The Identity and Access Management (IAM) permission required for this operation is <code>GetTable</code>.</p>
   */
  getColumnStatisticsForTable(
    req: operations.GetColumnStatisticsForTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetColumnStatisticsForTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetColumnStatisticsForTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetColumnStatisticsForTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getColumnStatisticsForTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetColumnStatisticsForTableResponse =
        new operations.GetColumnStatisticsForTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getColumnStatisticsForTableResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetColumnStatisticsForTableResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a connection definition from the Data Catalog.
   */
  getConnection(
    req: operations.GetConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetConnection";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getConnectionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectionResponse =
        new operations.GetConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetConnectionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of connection definitions from the Data Catalog.
   */
  getConnections(
    req: operations.GetConnectionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetConnectionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetConnectionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetConnections";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getConnectionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetConnectionsResponse =
        new operations.GetConnectionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getConnectionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetConnectionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves metadata for a specified crawler.
   */
  getCrawler(
    req: operations.GetCrawlerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCrawlerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCrawlerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetCrawler";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getCrawlerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCrawlerResponse =
        new operations.GetCrawlerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCrawlerResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetCrawlerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves metrics about specified crawlers.
   */
  getCrawlerMetrics(
    req: operations.GetCrawlerMetricsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCrawlerMetricsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCrawlerMetricsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetCrawlerMetrics";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getCrawlerMetricsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCrawlerMetricsResponse =
        new operations.GetCrawlerMetricsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCrawlerMetricsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetCrawlerMetricsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves metadata for all crawlers defined in the customer account.
   */
  getCrawlers(
    req: operations.GetCrawlersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCrawlersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCrawlersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetCrawlers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getCrawlersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCrawlersResponse =
        new operations.GetCrawlersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCrawlersResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetCrawlersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the details of a custom pattern by specifying its name.
   */
  getCustomEntityType(
    req: operations.GetCustomEntityTypeRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetCustomEntityTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetCustomEntityTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetCustomEntityType";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getCustomEntityTypeRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetCustomEntityTypeResponse =
        new operations.GetCustomEntityTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getCustomEntityTypeResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetCustomEntityTypeResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the security configuration for a specified catalog.
   */
  getDataCatalogEncryptionSettings(
    req: operations.GetDataCatalogEncryptionSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDataCatalogEncryptionSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDataCatalogEncryptionSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetDataCatalogEncryptionSettings";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDataCatalogEncryptionSettingsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDataCatalogEncryptionSettingsResponse =
        new operations.GetDataCatalogEncryptionSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDataCatalogEncryptionSettingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDataCatalogEncryptionSettingsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the result of a data quality rule evaluation.
   */
  getDataQualityResult(
    req: operations.GetDataQualityResultRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDataQualityResultResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDataQualityResultRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetDataQualityResult";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDataQualityResultRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDataQualityResultResponse =
        new operations.GetDataQualityResultResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDataQualityResultResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDataQualityResultResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the specified recommendation run that was used to generate rules.
   */
  getDataQualityRuleRecommendationRun(
    req: operations.GetDataQualityRuleRecommendationRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDataQualityRuleRecommendationRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDataQualityRuleRecommendationRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetDataQualityRuleRecommendationRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDataQualityRuleRecommendationRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDataQualityRuleRecommendationRunResponse =
        new operations.GetDataQualityRuleRecommendationRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDataQualityRuleRecommendationRunResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GetDataQualityRuleRecommendationRunResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns an existing ruleset by identifier or name.
   */
  getDataQualityRuleset(
    req: operations.GetDataQualityRulesetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDataQualityRulesetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDataQualityRulesetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetDataQualityRuleset";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDataQualityRulesetRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDataQualityRulesetResponse =
        new operations.GetDataQualityRulesetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDataQualityRulesetResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDataQualityRulesetResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a specific run where a ruleset is evaluated against a data source.
   */
  getDataQualityRulesetEvaluationRun(
    req: operations.GetDataQualityRulesetEvaluationRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDataQualityRulesetEvaluationRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDataQualityRulesetEvaluationRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetDataQualityRulesetEvaluationRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDataQualityRulesetEvaluationRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDataQualityRulesetEvaluationRunResponse =
        new operations.GetDataQualityRulesetEvaluationRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDataQualityRulesetEvaluationRunResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.GetDataQualityRulesetEvaluationRunResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the definition of a specified database.
   */
  getDatabase(
    req: operations.GetDatabaseRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDatabaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDatabaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetDatabase";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDatabaseRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDatabaseResponse =
        new operations.GetDatabaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDatabaseResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDatabaseResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves all databases defined in a given Data Catalog.
   */
  getDatabases(
    req: operations.GetDatabasesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDatabasesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDatabasesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetDatabases";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDatabasesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDatabasesResponse =
        new operations.GetDatabasesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDatabasesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDatabasesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Transforms a Python script into a directed acyclic graph (DAG).
   */
  getDataflowGraph(
    req: operations.GetDataflowGraphRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDataflowGraphResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDataflowGraphRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetDataflowGraph";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDataflowGraphRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDataflowGraphResponse =
        new operations.GetDataflowGraphResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDataflowGraphResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDataflowGraphResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves information about a specified development endpoint.</p> <note> <p>When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address, and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.</p> </note>
   */
  getDevEndpoint(
    req: operations.GetDevEndpointRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDevEndpointResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDevEndpointRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetDevEndpoint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDevEndpointRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDevEndpointResponse =
        new operations.GetDevEndpointResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDevEndpointResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDevEndpointResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves all the development endpoints in this Amazon Web Services account.</p> <note> <p>When you create a development endpoint in a virtual private cloud (VPC), Glue returns only a private IP address and the public IP address field is not populated. When you create a non-VPC development endpoint, Glue returns only a public IP address.</p> </note>
   */
  getDevEndpoints(
    req: operations.GetDevEndpointsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetDevEndpointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetDevEndpointsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetDevEndpoints";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getDevEndpointsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetDevEndpointsResponse =
        new operations.GetDevEndpointsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getDevEndpointsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetDevEndpointsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves an existing job definition.
   */
  getJob(
    req: operations.GetJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetJob";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJobResponse = new operations.GetJobResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetJobResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Returns information on a job bookmark entry.</p> <p>For more information about enabling and using job bookmarks, see:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html">Tracking processed data using job bookmarks</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Job parameters used by Glue</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html#aws-glue-api-jobs-job-Job">Job structure</a> </p> </li> </ul>
   */
  getJobBookmark(
    req: operations.GetJobBookmarkRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJobBookmarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJobBookmarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetJobBookmark";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getJobBookmarkRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJobBookmarkResponse =
        new operations.GetJobBookmarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getJobBookmarkResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetJobBookmarkResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the metadata for a given job run.
   */
  getJobRun(
    req: operations.GetJobRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJobRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJobRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetJobRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getJobRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJobRunResponse =
        new operations.GetJobRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getJobRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetJobRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves metadata for all runs of a given job definition.
   */
  getJobRuns(
    req: operations.GetJobRunsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJobRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJobRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetJobRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getJobRunsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJobRunsResponse =
        new operations.GetJobRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getJobRunsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetJobRunsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves all current job definitions.
   */
  getJobs(
    req: operations.GetJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetJobs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getJobsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetJobsResponse = new operations.GetJobsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getJobsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetJobsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets details for a specific task run on a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can check the stats of any task run by calling <code>GetMLTaskRun</code> with the <code>TaskRunID</code> and its parent transform's <code>TransformID</code>.
   */
  getMLTaskRun(
    req: operations.GetMLTaskRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetMLTaskRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetMLTaskRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetMLTaskRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getMLTaskRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMLTaskRunResponse =
        new operations.GetMLTaskRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getMLTaskRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetMLTaskRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Gets a list of runs for a machine learning transform. Machine learning task runs are asynchronous tasks that Glue runs on your behalf as part of various machine learning workflows. You can get a sortable, filterable list of machine learning task runs by calling <code>GetMLTaskRuns</code> with their parent transform's <code>TransformID</code> and other optional parameters as documented in this section.</p> <p>This operation returns a list of historic runs and must be paginated.</p>
   */
  getMLTaskRuns(
    req: operations.GetMLTaskRunsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetMLTaskRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetMLTaskRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetMLTaskRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getMLTaskRunsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMLTaskRunsResponse =
        new operations.GetMLTaskRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getMLTaskRunsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetMLTaskRunsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets an Glue machine learning transform artifact and all its corresponding metadata. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue. You can retrieve their metadata by calling <code>GetMLTransform</code>.
   */
  getMLTransform(
    req: operations.GetMLTransformRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetMLTransformResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetMLTransformRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetMLTransform";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getMLTransformRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMLTransformResponse =
        new operations.GetMLTransformResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getMLTransformResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetMLTransformResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a sortable, filterable list of existing Glue machine learning transforms. Machine learning transforms are a special type of transform that use machine learning to learn the details of the transformation to be performed by learning from examples provided by humans. These transformations are then saved by Glue, and you can retrieve their metadata by calling <code>GetMLTransforms</code>.
   */
  getMLTransforms(
    req: operations.GetMLTransformsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetMLTransformsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetMLTransformsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetMLTransforms";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getMLTransformsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMLTransformsResponse =
        new operations.GetMLTransformsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getMLTransformsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetMLTransformsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates mappings.
   */
  getMapping(
    req: operations.GetMappingRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetMappingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetMappingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetMapping";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getMappingRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetMappingResponse =
        new operations.GetMappingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getMappingResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetMappingResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves information about a specified partition.
   */
  getPartition(
    req: operations.GetPartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetPartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getPartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPartitionResponse =
        new operations.GetPartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getPartitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetPartitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the partition indexes associated with a table.
   */
  getPartitionIndexes(
    req: operations.GetPartitionIndexesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPartitionIndexesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPartitionIndexesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetPartitionIndexes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getPartitionIndexesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPartitionIndexesResponse =
        new operations.GetPartitionIndexesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getPartitionIndexesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetPartitionIndexesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves information about the partitions in a table.
   */
  getPartitions(
    req: operations.GetPartitionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPartitionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPartitionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetPartitions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getPartitionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPartitionsResponse =
        new operations.GetPartitionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getPartitionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetPartitionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidStateException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets code to perform a specified mapping.
   */
  getPlan(
    req: operations.GetPlanRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetPlanResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetPlanRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetPlan";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getPlanRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetPlanResponse = new operations.GetPlanResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getPlanResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetPlanResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Describes the specified registry in detail.
   */
  getRegistry(
    req: operations.GetRegistryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRegistryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRegistryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetRegistry";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getRegistryInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRegistryResponse =
        new operations.GetRegistryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRegistryResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetRegistryResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves the resource policies set on individual resources by Resource Access Manager during cross-account permission grants. Also retrieves the Data Catalog resource policy.</p> <p>If you enabled metadata encryption in Data Catalog settings, and you do not have permission on the KMS key, the operation can't return the Data Catalog resource policy.</p>
   */
  getResourcePolicies(
    req: operations.GetResourcePoliciesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResourcePoliciesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetResourcePoliciesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetResourcePolicies";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getResourcePoliciesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResourcePoliciesResponse =
        new operations.GetResourcePoliciesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getResourcePoliciesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetResourcePoliciesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a specified resource policy.
   */
  getResourcePolicy(
    req: operations.GetResourcePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetResourcePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetResourcePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetResourcePolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getResourcePolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetResourcePolicyResponse =
        new operations.GetResourcePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getResourcePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetResourcePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Describes the specified schema in detail.
   */
  getSchema(
    req: operations.GetSchemaRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSchemaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSchemaRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetSchema";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSchemaInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSchemaResponse =
        new operations.GetSchemaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSchemaResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSchemaResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a schema by the <code>SchemaDefinition</code>. The schema definition is sent to the Schema Registry, canonicalized, and hashed. If the hash is matched within the scope of the <code>SchemaName</code> or ARN (or the default registry, if none is supplied), that schema’s metadata is returned. Otherwise, a 404 or NotFound error is returned. Schema versions in <code>Deleted</code> statuses will not be included in the results.
   */
  getSchemaByDefinition(
    req: operations.GetSchemaByDefinitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSchemaByDefinitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSchemaByDefinitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetSchemaByDefinition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSchemaByDefinitionInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSchemaByDefinitionResponse =
        new operations.GetSchemaByDefinitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSchemaByDefinitionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSchemaByDefinitionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the specified schema by its unique ID assigned when a version of the schema is created or registered. Schema versions in Deleted status will not be included in the results.
   */
  getSchemaVersion(
    req: operations.GetSchemaVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSchemaVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSchemaVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetSchemaVersion";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSchemaVersionInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSchemaVersionResponse =
        new operations.GetSchemaVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSchemaVersionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSchemaVersionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Fetches the schema version difference in the specified difference type between two stored schema versions in the Schema Registry.</p> <p>This API allows you to compare two schema versions between two schema definitions under the same schema.</p>
   */
  getSchemaVersionsDiff(
    req: operations.GetSchemaVersionsDiffRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSchemaVersionsDiffResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSchemaVersionsDiffRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetSchemaVersionsDiff";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSchemaVersionsDiffInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSchemaVersionsDiffResponse =
        new operations.GetSchemaVersionsDiffResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSchemaVersionsDiffResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSchemaVersionsDiffResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a specified security configuration.
   */
  getSecurityConfiguration(
    req: operations.GetSecurityConfigurationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSecurityConfigurationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSecurityConfigurationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetSecurityConfiguration";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSecurityConfigurationRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSecurityConfigurationResponse =
        new operations.GetSecurityConfigurationResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSecurityConfigurationResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSecurityConfigurationResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of all security configurations.
   */
  getSecurityConfigurations(
    req: operations.GetSecurityConfigurationsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSecurityConfigurationsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSecurityConfigurationsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetSecurityConfigurations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSecurityConfigurationsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSecurityConfigurationsResponse =
        new operations.GetSecurityConfigurationsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSecurityConfigurationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSecurityConfigurationsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the session.
   */
  getSession(
    req: operations.GetSessionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetSessionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetSessionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetSession";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getSessionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetSessionResponse =
        new operations.GetSessionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getSessionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetSessionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the statement.
   */
  getStatement(
    req: operations.GetStatementRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetStatementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetStatementRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetStatement";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getStatementRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetStatementResponse =
        new operations.GetStatementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getStatementResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetStatementResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalSessionStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the <code>Table</code> definition in a Data Catalog for a specified table.
   */
  getTable(
    req: operations.GetTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTableResponse = new operations.GetTableResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTableResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTableResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a specified version of a table.
   */
  getTableVersion(
    req: operations.GetTableVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTableVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTableVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTableVersion";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTableVersionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTableVersionResponse =
        new operations.GetTableVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTableVersionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTableVersionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of strings that identify available versions of a specified table.
   */
  getTableVersions(
    req: operations.GetTableVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTableVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTableVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTableVersions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTableVersionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTableVersionsResponse =
        new operations.GetTableVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTableVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTableVersionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the definitions of some or all of the tables in a given <code>Database</code>.
   */
  getTables(
    req: operations.GetTablesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTablesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTablesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTables";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTablesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTablesResponse =
        new operations.GetTablesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTablesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTablesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a list of tags associated with a resource.
   */
  getTags(
    req: operations.GetTagsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTags";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTagsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTagsResponse = new operations.GetTagsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTagsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTagsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the definition of a trigger.
   */
  getTrigger(
    req: operations.GetTriggerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTriggerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTrigger";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTriggerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTriggerResponse =
        new operations.GetTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTriggerResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTriggerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets all the triggers associated with a job.
   */
  getTriggers(
    req: operations.GetTriggersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTriggersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTriggersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetTriggers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getTriggersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTriggersResponse =
        new operations.GetTriggersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getTriggersResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetTriggersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves partition metadata from the Data Catalog that contains unfiltered metadata.</p> <p>For IAM authorization, the public IAM action associated with this API is <code>glue:GetPartition</code>.</p>
   */
  getUnfilteredPartitionMetadata(
    req: operations.GetUnfilteredPartitionMetadataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUnfilteredPartitionMetadataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUnfilteredPartitionMetadataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetUnfilteredPartitionMetadata";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getUnfilteredPartitionMetadataRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUnfilteredPartitionMetadataResponse =
        new operations.GetUnfilteredPartitionMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUnfilteredPartitionMetadataResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetUnfilteredPartitionMetadataResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.permissionTypeMismatchException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves partition metadata from the Data Catalog that contains unfiltered metadata.</p> <p>For IAM authorization, the public IAM action associated with this API is <code>glue:GetPartitions</code>.</p>
   */
  getUnfilteredPartitionsMetadata(
    req: operations.GetUnfilteredPartitionsMetadataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUnfilteredPartitionsMetadataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUnfilteredPartitionsMetadataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetUnfilteredPartitionsMetadata";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getUnfilteredPartitionsMetadataRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUnfilteredPartitionsMetadataResponse =
        new operations.GetUnfilteredPartitionsMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUnfilteredPartitionsMetadataResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetUnfilteredPartitionsMetadataResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.permissionTypeMismatchException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves table metadata from the Data Catalog that contains unfiltered metadata.</p> <p>For IAM authorization, the public IAM action associated with this API is <code>glue:GetTable</code>.</p>
   */
  getUnfilteredTableMetadata(
    req: operations.GetUnfilteredTableMetadataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUnfilteredTableMetadataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUnfilteredTableMetadataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetUnfilteredTableMetadata";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getUnfilteredTableMetadataRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUnfilteredTableMetadataResponse =
        new operations.GetUnfilteredTableMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUnfilteredTableMetadataResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetUnfilteredTableMetadataResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.permissionTypeMismatchException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves a specified function definition from the Data Catalog.
   */
  getUserDefinedFunction(
    req: operations.GetUserDefinedFunctionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserDefinedFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserDefinedFunctionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetUserDefinedFunction";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getUserDefinedFunctionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserDefinedFunctionResponse =
        new operations.GetUserDefinedFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUserDefinedFunctionResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetUserDefinedFunctionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves multiple function definitions from the Data Catalog.
   */
  getUserDefinedFunctions(
    req: operations.GetUserDefinedFunctionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetUserDefinedFunctionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetUserDefinedFunctionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetUserDefinedFunctions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getUserDefinedFunctionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetUserDefinedFunctionsResponse =
        new operations.GetUserDefinedFunctionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getUserDefinedFunctionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetUserDefinedFunctionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves resource metadata for a workflow.
   */
  getWorkflow(
    req: operations.GetWorkflowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkflowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetWorkflow";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getWorkflowRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkflowResponse =
        new operations.GetWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWorkflowResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetWorkflowResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the metadata for a given workflow run.
   */
  getWorkflowRun(
    req: operations.GetWorkflowRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkflowRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkflowRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetWorkflowRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getWorkflowRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkflowRunResponse =
        new operations.GetWorkflowRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWorkflowRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetWorkflowRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves the workflow run properties which were set during the run.
   */
  getWorkflowRunProperties(
    req: operations.GetWorkflowRunPropertiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkflowRunPropertiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkflowRunPropertiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.GetWorkflowRunProperties";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getWorkflowRunPropertiesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkflowRunPropertiesResponse =
        new operations.GetWorkflowRunPropertiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWorkflowRunPropertiesResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetWorkflowRunPropertiesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves metadata for all runs of a given workflow.
   */
  getWorkflowRuns(
    req: operations.GetWorkflowRunsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkflowRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkflowRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.GetWorkflowRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "getWorkflowRunsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkflowRunsResponse =
        new operations.GetWorkflowRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getWorkflowRunsResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetWorkflowRunsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Imports an existing Amazon Athena Data Catalog to Glue.
   */
  importCatalogToGlue(
    req: operations.ImportCatalogToGlueRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ImportCatalogToGlueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ImportCatalogToGlueRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ImportCatalogToGlue";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "importCatalogToGlueRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ImportCatalogToGlueResponse =
        new operations.ImportCatalogToGlueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.importCatalogToGlueResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the blueprint names in an account.
   */
  listBlueprints(
    req: operations.ListBlueprintsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListBlueprintsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListBlueprintsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListBlueprints";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listBlueprintsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListBlueprintsResponse =
        new operations.ListBlueprintsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBlueprintsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBlueprintsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves the names of all crawler resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names.</p> <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.</p>
   */
  listCrawlers(
    req: operations.ListCrawlersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCrawlersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCrawlersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListCrawlers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listCrawlersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCrawlersResponse =
        new operations.ListCrawlersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCrawlersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListCrawlersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Returns all the crawls of a specified crawler. Returns only the crawls that have occurred since the launch date of the crawler history feature, and only retains up to 12 months of crawls. Older crawls will not be returned.</p> <p>You may use this API to:</p> <ul> <li> <p>Retrive all the crawls of a specified crawler.</p> </li> <li> <p>Retrieve all the crawls of a specified crawler within a limited count.</p> </li> <li> <p>Retrieve all the crawls of a specified crawler in a specific time range.</p> </li> <li> <p>Retrieve all the crawls of a specified crawler with a particular state, crawl ID, or DPU hour value.</p> </li> </ul>
   */
  listCrawls(
    req: operations.ListCrawlsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCrawlsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCrawlsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListCrawls";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listCrawlsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCrawlsResponse =
        new operations.ListCrawlsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCrawlsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListCrawlsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the custom patterns that have been created.
   */
  listCustomEntityTypes(
    req: operations.ListCustomEntityTypesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListCustomEntityTypesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListCustomEntityTypesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.ListCustomEntityTypes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listCustomEntityTypesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListCustomEntityTypesResponse =
        new operations.ListCustomEntityTypesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCustomEntityTypesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListCustomEntityTypesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns all data quality execution results for your account.
   */
  listDataQualityResults(
    req: operations.ListDataQualityResultsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDataQualityResultsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDataQualityResultsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.ListDataQualityResults";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listDataQualityResultsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDataQualityResultsResponse =
        new operations.ListDataQualityResultsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDataQualityResultsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDataQualityResultsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the recommendation runs meeting the filter criteria.
   */
  listDataQualityRuleRecommendationRuns(
    req: operations.ListDataQualityRuleRecommendationRunsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDataQualityRuleRecommendationRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDataQualityRuleRecommendationRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.ListDataQualityRuleRecommendationRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listDataQualityRuleRecommendationRunsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDataQualityRuleRecommendationRunsResponse =
        new operations.ListDataQualityRuleRecommendationRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDataQualityRuleRecommendationRunsResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.ListDataQualityRuleRecommendationRunsResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all the runs meeting the filter criteria, where a ruleset is evaluated against a data source.
   */
  listDataQualityRulesetEvaluationRuns(
    req: operations.ListDataQualityRulesetEvaluationRunsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDataQualityRulesetEvaluationRunsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDataQualityRulesetEvaluationRunsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.ListDataQualityRulesetEvaluationRuns";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listDataQualityRulesetEvaluationRunsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDataQualityRulesetEvaluationRunsResponse =
        new operations.ListDataQualityRulesetEvaluationRunsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDataQualityRulesetEvaluationRunsResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.ListDataQualityRulesetEvaluationRunsResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a paginated list of rulesets for the specified list of Glue tables.
   */
  listDataQualityRulesets(
    req: operations.ListDataQualityRulesetsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDataQualityRulesetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDataQualityRulesetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.ListDataQualityRulesets";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listDataQualityRulesetsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDataQualityRulesetsResponse =
        new operations.ListDataQualityRulesetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDataQualityRulesetsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDataQualityRulesetsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves the names of all <code>DevEndpoint</code> resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names.</p> <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.</p>
   */
  listDevEndpoints(
    req: operations.ListDevEndpointsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDevEndpointsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDevEndpointsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListDevEndpoints";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listDevEndpointsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDevEndpointsResponse =
        new operations.ListDevEndpointsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDevEndpointsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDevEndpointsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves the names of all job resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names.</p> <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.</p>
   */
  listJobs(
    req: operations.ListJobsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListJobsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListJobsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListJobs";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listJobsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListJobsResponse = new operations.ListJobsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listJobsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListJobsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   *  Retrieves a sortable, filterable list of existing Glue machine learning transforms in this Amazon Web Services account, or the resources with the specified tag. This operation takes the optional <code>Tags</code> field, which you can use as a filter of the responses so that tagged resources can be retrieved as a group. If you choose to use tag filtering, only resources with the tags are retrieved.
   */
  listMLTransforms(
    req: operations.ListMLTransformsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListMLTransformsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListMLTransformsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListMLTransforms";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listMLTransformsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListMLTransformsResponse =
        new operations.ListMLTransformsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listMLTransformsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListMLTransformsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of registries that you have created, with minimal registry information. Registries in the <code>Deleting</code> status will not be included in the results. Empty results will be returned if there are no registries available.
   */
  listRegistries(
    req: operations.ListRegistriesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListRegistriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListRegistriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListRegistries";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listRegistriesInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListRegistriesResponse =
        new operations.ListRegistriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRegistriesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRegistriesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns a list of schema versions that you have created, with minimal information. Schema versions in Deleted status will not be included in the results. Empty results will be returned if there are no schema versions available.
   */
  listSchemaVersions(
    req: operations.ListSchemaVersionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSchemaVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSchemaVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListSchemaVersions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listSchemaVersionsInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSchemaVersionsResponse =
        new operations.ListSchemaVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSchemaVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSchemaVersionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Returns a list of schemas with minimal details. Schemas in Deleting status will not be included in the results. Empty results will be returned if there are no schemas available.</p> <p>When the <code>RegistryId</code> is not provided, all the schemas across registries will be part of the API response.</p>
   */
  listSchemas(
    req: operations.ListSchemasRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSchemasResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSchemasRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListSchemas";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listSchemasInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSchemasResponse =
        new operations.ListSchemasResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSchemasResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSchemasResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieve a list of sessions.
   */
  listSessions(
    req: operations.ListSessionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSessionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSessionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListSessions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listSessionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSessionsResponse =
        new operations.ListSessionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSessionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSessionsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists statements for the session.
   */
  listStatements(
    req: operations.ListStatementsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListStatementsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListStatementsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListStatements";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listStatementsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListStatementsResponse =
        new operations.ListStatementsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listStatementsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListStatementsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalSessionStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Retrieves the names of all trigger resources in this Amazon Web Services account, or the resources with the specified tag. This operation allows you to see which resources are available in your account, and their names.</p> <p>This operation takes the optional <code>Tags</code> field, which you can use as a filter on the response so that tagged resources can be retrieved as a group. If you choose to use tags filtering, only resources with the tag are retrieved.</p>
   */
  listTriggers(
    req: operations.ListTriggersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListTriggersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListTriggersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListTriggers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listTriggersRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListTriggersResponse =
        new operations.ListTriggersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTriggersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTriggersResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists names of workflows created in the account.
   */
  listWorkflows(
    req: operations.ListWorkflowsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListWorkflowsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListWorkflowsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ListWorkflows";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "listWorkflowsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListWorkflowsResponse =
        new operations.ListWorkflowsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listWorkflowsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListWorkflowsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the security configuration for a specified catalog. After the configuration has been set, the specified encryption is applied to every catalog write thereafter.
   */
  putDataCatalogEncryptionSettings(
    req: operations.PutDataCatalogEncryptionSettingsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutDataCatalogEncryptionSettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutDataCatalogEncryptionSettingsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.PutDataCatalogEncryptionSettings";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "putDataCatalogEncryptionSettingsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutDataCatalogEncryptionSettingsResponse =
        new operations.PutDataCatalogEncryptionSettingsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putDataCatalogEncryptionSettingsResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the Data Catalog resource policy for access control.
   */
  putResourcePolicy(
    req: operations.PutResourcePolicyRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutResourcePolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutResourcePolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.PutResourcePolicy";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "putResourcePolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutResourcePolicyResponse =
        new operations.PutResourcePolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putResourcePolicyResponse = utils.objectToClass(
              httpRes?.data,
              shared.PutResourcePolicyResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conditionCheckFailureException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Puts the metadata key value pair for a specified schema version ID. A maximum of 10 key value pairs will be allowed per schema version. They can be added over one or more calls.
   */
  putSchemaVersionMetadata(
    req: operations.PutSchemaVersionMetadataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutSchemaVersionMetadataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutSchemaVersionMetadataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.PutSchemaVersionMetadata";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "putSchemaVersionMetadataInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutSchemaVersionMetadataResponse =
        new operations.PutSchemaVersionMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putSchemaVersionMetadataResponse = utils.objectToClass(
              httpRes?.data,
              shared.PutSchemaVersionMetadataResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Puts the specified workflow run properties for the given workflow run. If a property already exists for the specified run, then it overrides the value otherwise adds the property to existing properties.
   */
  putWorkflowRunProperties(
    req: operations.PutWorkflowRunPropertiesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutWorkflowRunPropertiesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutWorkflowRunPropertiesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.PutWorkflowRunProperties";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "putWorkflowRunPropertiesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutWorkflowRunPropertiesResponse =
        new operations.PutWorkflowRunPropertiesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.putWorkflowRunPropertiesResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Queries for the schema version metadata information.
   */
  querySchemaVersionMetadata(
    req: operations.QuerySchemaVersionMetadataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.QuerySchemaVersionMetadataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.QuerySchemaVersionMetadataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.QuerySchemaVersionMetadata";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "querySchemaVersionMetadataInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.QuerySchemaVersionMetadataResponse =
        new operations.QuerySchemaVersionMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.querySchemaVersionMetadataResponse = utils.objectToClass(
              httpRes?.data,
              shared.QuerySchemaVersionMetadataResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Adds a new version to the existing schema. Returns an error if new version of schema does not meet the compatibility requirements of the schema set. This API will not create a new schema set and will return a 404 error if the schema set is not already present in the Schema Registry.</p> <p>If this is the first schema definition to be registered in the Schema Registry, this API will store the schema version and return immediately. Otherwise, this call has the potential to run longer than other operations due to compatibility modes. You can call the <code>GetSchemaVersion</code> API with the <code>SchemaVersionId</code> to check compatibility modes.</p> <p>If the same schema definition is already stored in Schema Registry as a version, the schema ID of the existing schema is returned to the caller.</p>
   */
  registerSchemaVersion(
    req: operations.RegisterSchemaVersionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RegisterSchemaVersionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RegisterSchemaVersionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.RegisterSchemaVersion";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "registerSchemaVersionInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RegisterSchemaVersionResponse =
        new operations.RegisterSchemaVersionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.registerSchemaVersionResponse = utils.objectToClass(
              httpRes?.data,
              shared.RegisterSchemaVersionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes a key value pair from the schema version metadata for the specified schema version ID.
   */
  removeSchemaVersionMetadata(
    req: operations.RemoveSchemaVersionMetadataRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RemoveSchemaVersionMetadataResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RemoveSchemaVersionMetadataRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.RemoveSchemaVersionMetadata";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "removeSchemaVersionMetadataInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RemoveSchemaVersionMetadataResponse =
        new operations.RemoveSchemaVersionMetadataResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.removeSchemaVersionMetadataResponse = utils.objectToClass(
              httpRes?.data,
              shared.RemoveSchemaVersionMetadataResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Resets a bookmark entry.</p> <p>For more information about enabling and using job bookmarks, see:</p> <ul> <li> <p> <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html">Tracking processed data using job bookmarks</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html">Job parameters used by Glue</a> </p> </li> <li> <p> <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html#aws-glue-api-jobs-job-Job">Job structure</a> </p> </li> </ul>
   */
  resetJobBookmark(
    req: operations.ResetJobBookmarkRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ResetJobBookmarkResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ResetJobBookmarkRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ResetJobBookmark";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resetJobBookmarkRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ResetJobBookmarkResponse =
        new operations.ResetJobBookmarkResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resetJobBookmarkResponse = utils.objectToClass(
              httpRes?.data,
              shared.ResetJobBookmarkResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Restarts selected nodes of a previous partially completed workflow run and resumes the workflow run. The selected nodes and all nodes that are downstream from the selected nodes are run.
   */
  resumeWorkflowRun(
    req: operations.ResumeWorkflowRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ResumeWorkflowRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ResumeWorkflowRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.ResumeWorkflowRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "resumeWorkflowRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ResumeWorkflowRunResponse =
        new operations.ResumeWorkflowRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resumeWorkflowRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.ResumeWorkflowRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentRunsExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalWorkflowStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Executes the statement.
   */
  runStatement(
    req: operations.RunStatementRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RunStatementResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunStatementRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.RunStatement";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "runStatementRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunStatementResponse =
        new operations.RunStatementResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.runStatementResponse = utils.objectToClass(
              httpRes?.data,
              shared.RunStatementResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalSessionStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Searches a set of tables based on properties in the table metadata as well as on the parent database. You can search against text or filter conditions. </p> <p>You can only get tables that you have access to based on the security policies defined in Lake Formation. You need at least a read-only access to the table for it to be returned. If you do not have access to all the columns in the table, these columns will not be searched against when returning the list of tables back to you. If you have access to the columns but not the data in the columns, those columns and the associated metadata for those columns will be included in the search. </p>
   */
  searchTables(
    req: operations.SearchTablesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.SearchTablesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SearchTablesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.SearchTables";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "searchTablesRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    const queryParams: string = utils.serializeQueryParams(req);
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SearchTablesResponse =
        new operations.SearchTablesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.searchTablesResponse = utils.objectToClass(
              httpRes?.data,
              shared.SearchTablesResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a new run of the specified blueprint.
   */
  startBlueprintRun(
    req: operations.StartBlueprintRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartBlueprintRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartBlueprintRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StartBlueprintRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startBlueprintRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartBlueprintRunResponse =
        new operations.StartBlueprintRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startBlueprintRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartBlueprintRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalBlueprintStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a crawl using the specified crawler, regardless of what is scheduled. If the crawler is already running, returns a <a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-exceptions.html#aws-glue-api-exceptions-CrawlerRunningException">CrawlerRunningException</a>.
   */
  startCrawler(
    req: operations.StartCrawlerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartCrawlerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartCrawlerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StartCrawler";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startCrawlerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartCrawlerResponse =
        new operations.StartCrawlerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startCrawlerResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlerRunningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes the schedule state of the specified crawler to <code>SCHEDULED</code>, unless the crawler is already running or the schedule state is already <code>SCHEDULED</code>.
   */
  startCrawlerSchedule(
    req: operations.StartCrawlerScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartCrawlerScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartCrawlerScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartCrawlerSchedule";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startCrawlerScheduleRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartCrawlerScheduleResponse =
        new operations.StartCrawlerScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startCrawlerScheduleResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulerRunningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulerTransitioningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.noScheduleException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a recommendation run that is used to generate rules when you don't know what rules to write. Glue Data Quality analyzes the data and comes up with recommendations for a potential ruleset. You can then triage the ruleset and modify the generated ruleset to your liking.
   */
  startDataQualityRuleRecommendationRun(
    req: operations.StartDataQualityRuleRecommendationRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartDataQualityRuleRecommendationRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartDataQualityRuleRecommendationRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartDataQualityRuleRecommendationRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startDataQualityRuleRecommendationRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartDataQualityRuleRecommendationRunResponse =
        new operations.StartDataQualityRuleRecommendationRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startDataQualityRuleRecommendationRunResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.StartDataQualityRuleRecommendationRunResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Once you have a ruleset definition (either recommended or your own), you call this operation to evaluate the ruleset against a data source (Glue table). The evaluation computes results which you can retrieve with the <code>GetDataQualityResult</code> API.
   */
  startDataQualityRulesetEvaluationRun(
    req: operations.StartDataQualityRulesetEvaluationRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartDataQualityRulesetEvaluationRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartDataQualityRulesetEvaluationRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartDataQualityRulesetEvaluationRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startDataQualityRulesetEvaluationRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartDataQualityRulesetEvaluationRunResponse =
        new operations.StartDataQualityRulesetEvaluationRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startDataQualityRulesetEvaluationRunResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.StartDataQualityRulesetEvaluationRunResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.conflictException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Begins an asynchronous task to export all labeled data for a particular transform. This task is the only label-related API call that is not part of the typical active learning workflow. You typically use <code>StartExportLabelsTaskRun</code> when you want to work with all of your existing labels at the same time, such as when you want to remove or change labels that were previously submitted as truth. This API operation accepts the <code>TransformId</code> whose labels you want to export and an Amazon Simple Storage Service (Amazon S3) path to export the labels to. The operation returns a <code>TaskRunId</code>. You can check on the status of your task run by calling the <code>GetMLTaskRun</code> API.
   */
  startExportLabelsTaskRun(
    req: operations.StartExportLabelsTaskRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartExportLabelsTaskRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartExportLabelsTaskRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartExportLabelsTaskRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startExportLabelsTaskRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartExportLabelsTaskRunResponse =
        new operations.StartExportLabelsTaskRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startExportLabelsTaskRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartExportLabelsTaskRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Enables you to provide additional labels (examples of truth) to be used to teach the machine learning transform and improve its quality. This API operation is generally used as part of the active learning workflow that starts with the <code>StartMLLabelingSetGenerationTaskRun</code> call and that ultimately results in improving the quality of your machine learning transform. </p> <p>After the <code>StartMLLabelingSetGenerationTaskRun</code> finishes, Glue machine learning will have generated a series of questions for humans to answer. (Answering these questions is often called 'labeling' in the machine learning workflows). In the case of the <code>FindMatches</code> transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?” After the labeling process is finished, users upload their answers/labels with a call to <code>StartImportLabelsTaskRun</code>. After <code>StartImportLabelsTaskRun</code> finishes, all future runs of the machine learning transform use the new and improved labels and perform a higher-quality transformation.</p> <p>By default, <code>StartMLLabelingSetGenerationTaskRun</code> continually learns from and combines all labels that you upload unless you set <code>Replace</code> to true. If you set <code>Replace</code> to true, <code>StartImportLabelsTaskRun</code> deletes and forgets all previously uploaded labels and learns only from the exact set that you upload. Replacing labels can be helpful if you realize that you previously uploaded incorrect labels, and you believe that they are having a negative effect on your transform quality.</p> <p>You can check on the status of your task run by calling the <code>GetMLTaskRun</code> operation. </p>
   */
  startImportLabelsTaskRun(
    req: operations.StartImportLabelsTaskRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartImportLabelsTaskRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartImportLabelsTaskRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartImportLabelsTaskRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startImportLabelsTaskRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartImportLabelsTaskRunResponse =
        new operations.StartImportLabelsTaskRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startImportLabelsTaskRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartImportLabelsTaskRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a job run using a job definition.
   */
  startJobRun(
    req: operations.StartJobRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartJobRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartJobRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StartJobRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startJobRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartJobRunResponse =
        new operations.StartJobRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startJobRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartJobRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentRunsExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Starts a task to estimate the quality of the transform. </p> <p>When you provide label sets as examples of truth, Glue machine learning uses some of those examples to learn from them. The rest of the labels are used as a test to estimate quality.</p> <p>Returns a unique identifier for the run. You can call <code>GetMLTaskRun</code> to get more information about the stats of the <code>EvaluationTaskRun</code>.</p>
   */
  startMLEvaluationTaskRun(
    req: operations.StartMLEvaluationTaskRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartMLEvaluationTaskRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartMLEvaluationTaskRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartMLEvaluationTaskRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startMLEvaluationTaskRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartMLEvaluationTaskRunResponse =
        new operations.StartMLEvaluationTaskRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startMLEvaluationTaskRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartMLEvaluationTaskRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentRunsExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.mlTransformNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Starts the active learning workflow for your machine learning transform to improve the transform's quality by generating label sets and adding labels.</p> <p>When the <code>StartMLLabelingSetGenerationTaskRun</code> finishes, Glue will have generated a "labeling set" or a set of questions for humans to answer.</p> <p>In the case of the <code>FindMatches</code> transform, these questions are of the form, “What is the correct way to group these rows together into groups composed entirely of matching records?” </p> <p>After the labeling process is finished, you can upload your labels with a call to <code>StartImportLabelsTaskRun</code>. After <code>StartImportLabelsTaskRun</code> finishes, all future runs of the machine learning transform will use the new and improved labels and perform a higher-quality transformation.</p>
   */
  startMLLabelingSetGenerationTaskRun(
    req: operations.StartMLLabelingSetGenerationTaskRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartMLLabelingSetGenerationTaskRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartMLLabelingSetGenerationTaskRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.StartMLLabelingSetGenerationTaskRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startMLLabelingSetGenerationTaskRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartMLLabelingSetGenerationTaskRunResponse =
        new operations.StartMLLabelingSetGenerationTaskRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startMLLabelingSetGenerationTaskRunResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.StartMLLabelingSetGenerationTaskRunResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentRunsExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts an existing trigger. See <a href="https://docs.aws.amazon.com/glue/latest/dg/trigger-job.html">Triggering Jobs</a> for information about how different types of trigger are started.
   */
  startTrigger(
    req: operations.StartTriggerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartTriggerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StartTrigger";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startTriggerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartTriggerResponse =
        new operations.StartTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startTriggerResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartTriggerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentRunsExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts a new run of the specified workflow.
   */
  startWorkflowRun(
    req: operations.StartWorkflowRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StartWorkflowRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StartWorkflowRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StartWorkflowRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "startWorkflowRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StartWorkflowRunResponse =
        new operations.StartWorkflowRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.startWorkflowRunResponse = utils.objectToClass(
              httpRes?.data,
              shared.StartWorkflowRunResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentRunsExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * If the specified crawler is running, stops the crawl.
   */
  stopCrawler(
    req: operations.StopCrawlerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StopCrawlerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopCrawlerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StopCrawler";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stopCrawlerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopCrawlerResponse =
        new operations.StopCrawlerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stopCrawlerResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlerNotRunningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlerStoppingException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the schedule state of the specified crawler to <code>NOT_SCHEDULED</code>, but does not stop the crawler if it is already running.
   */
  stopCrawlerSchedule(
    req: operations.StopCrawlerScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StopCrawlerScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopCrawlerScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StopCrawlerSchedule";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stopCrawlerScheduleRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopCrawlerScheduleResponse =
        new operations.StopCrawlerScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stopCrawlerScheduleResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulerNotRunningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulerTransitioningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stops the session.
   */
  stopSession(
    req: operations.StopSessionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StopSessionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopSessionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StopSession";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stopSessionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopSessionResponse =
        new operations.StopSessionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stopSessionResponse = utils.objectToClass(
              httpRes?.data,
              shared.StopSessionResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalSessionStateException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stops a specified trigger.
   */
  stopTrigger(
    req: operations.StopTriggerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StopTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopTriggerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StopTrigger";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stopTriggerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopTriggerResponse =
        new operations.StopTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stopTriggerResponse = utils.objectToClass(
              httpRes?.data,
              shared.StopTriggerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Stops the execution of the specified workflow run.
   */
  stopWorkflowRun(
    req: operations.StopWorkflowRunRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.StopWorkflowRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StopWorkflowRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.StopWorkflowRun";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "stopWorkflowRunRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StopWorkflowRunResponse =
        new operations.StopWorkflowRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.stopWorkflowRunResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalWorkflowStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Adds tags to a resource. A tag is a label you can assign to an Amazon Web Services resource. In Glue, you can tag only certain resources. For information about what resources you can tag, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html">Amazon Web Services Tags in Glue</a>.
   */
  tagResource(
    req: operations.TagResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.TagResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.TagResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.TagResource";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "tagResourceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.TagResourceResponse =
        new operations.TagResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.tagResourceResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes tags from a resource.
   */
  untagResource(
    req: operations.UntagResourceRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UntagResourceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UntagResourceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UntagResource";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "untagResourceRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UntagResourceResponse =
        new operations.UntagResourceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.untagResourceResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a registered blueprint.
   */
  updateBlueprint(
    req: operations.UpdateBlueprintRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateBlueprintResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateBlueprintRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateBlueprint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateBlueprintRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateBlueprintResponse =
        new operations.UpdateBlueprintResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateBlueprintResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateBlueprintResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.illegalBlueprintStateException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Modifies an existing classifier (a <code>GrokClassifier</code>, an <code>XMLClassifier</code>, a <code>JsonClassifier</code>, or a <code>CsvClassifier</code>, depending on which field is present).
   */
  updateClassifier(
    req: operations.UpdateClassifierRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateClassifierResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateClassifierRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateClassifier";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateClassifierRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateClassifierResponse =
        new operations.UpdateClassifierResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateClassifierResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.versionMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates or updates partition statistics of columns.</p> <p>The Identity and Access Management (IAM) permission required for this operation is <code>UpdatePartition</code>.</p>
   */
  updateColumnStatisticsForPartition(
    req: operations.UpdateColumnStatisticsForPartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateColumnStatisticsForPartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateColumnStatisticsForPartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateColumnStatisticsForPartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateColumnStatisticsForPartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateColumnStatisticsForPartitionResponse =
        new operations.UpdateColumnStatisticsForPartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateColumnStatisticsForPartitionResponse =
              utils.objectToClass(
                httpRes?.data,
                shared.UpdateColumnStatisticsForPartitionResponse
              );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Creates or updates table statistics of columns.</p> <p>The Identity and Access Management (IAM) permission required for this operation is <code>UpdateTable</code>.</p>
   */
  updateColumnStatisticsForTable(
    req: operations.UpdateColumnStatisticsForTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateColumnStatisticsForTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateColumnStatisticsForTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateColumnStatisticsForTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateColumnStatisticsForTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateColumnStatisticsForTableResponse =
        new operations.UpdateColumnStatisticsForTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateColumnStatisticsForTableResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateColumnStatisticsForTableResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a connection definition in the Data Catalog.
   */
  updateConnection(
    req: operations.UpdateConnectionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateConnectionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateConnectionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateConnection";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateConnectionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateConnectionResponse =
        new operations.UpdateConnectionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateConnectionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case [480, 483].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a crawler. If a crawler is running, you must stop it using <code>StopCrawler</code> before updating it.
   */
  updateCrawler(
    req: operations.UpdateCrawlerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCrawlerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCrawlerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateCrawler";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateCrawlerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCrawlerResponse =
        new operations.UpdateCrawlerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateCrawlerResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.versionMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.crawlerRunningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the schedule of a crawler using a <code>cron</code> expression.
   */
  updateCrawlerSchedule(
    req: operations.UpdateCrawlerScheduleRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateCrawlerScheduleResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateCrawlerScheduleRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateCrawlerSchedule";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateCrawlerScheduleRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateCrawlerScheduleResponse =
        new operations.UpdateCrawlerScheduleResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateCrawlerScheduleResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.versionMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.schedulerTransitioningException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the specified data quality ruleset.
   */
  updateDataQualityRuleset(
    req: operations.UpdateDataQualityRulesetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDataQualityRulesetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDataQualityRulesetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateDataQualityRuleset";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateDataQualityRulesetRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDataQualityRulesetResponse =
        new operations.UpdateDataQualityRulesetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateDataQualityRulesetResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateDataQualityRulesetResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.idempotentParameterMismatchException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing database definition in a Data Catalog.
   */
  updateDatabase(
    req: operations.UpdateDatabaseRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDatabaseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDatabaseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateDatabase";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateDatabaseRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDatabaseResponse =
        new operations.UpdateDatabaseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateDatabaseResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a specified development endpoint.
   */
  updateDevEndpoint(
    req: operations.UpdateDevEndpointRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateDevEndpointResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateDevEndpointRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateDevEndpoint";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateDevEndpointRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateDevEndpointResponse =
        new operations.UpdateDevEndpointResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateDevEndpointResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing job definition. The previous job definition is completely overwritten by this information.
   */
  updateJob(
    req: operations.UpdateJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateJob";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateJobResponse =
        new operations.UpdateJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateJobResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Synchronizes a job from the source control repository. This operation takes the job artifacts that are located in the remote repository and updates the Glue internal stores with these artifacts.</p> <p>This API supports optional parameters which take in the repository information.</p>
   */
  updateJobFromSourceControl(
    req: operations.UpdateJobFromSourceControlRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateJobFromSourceControlResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateJobFromSourceControlRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateJobFromSourceControl";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateJobFromSourceControlRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateJobFromSourceControlResponse =
        new operations.UpdateJobFromSourceControlResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateJobFromSourceControlResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateJobFromSourceControlResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Updates an existing machine learning transform. Call this operation to tune the algorithm parameters to achieve better results.</p> <p>After calling this operation, you can call the <code>StartMLEvaluationTaskRun</code> operation to assess how well your new parameters achieved your goals (such as improving the quality of your machine learning transform, or making it more cost-effective).</p>
   */
  updateMLTransform(
    req: operations.UpdateMLTransformRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateMLTransformResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateMLTransformRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateMLTransform";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateMLTransformRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateMLTransformResponse =
        new operations.UpdateMLTransformResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateMLTransformResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateMLTransformResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a partition.
   */
  updatePartition(
    req: operations.UpdatePartitionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdatePartitionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdatePartitionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdatePartition";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updatePartitionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdatePartitionResponse =
        new operations.UpdatePartitionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updatePartitionResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing registry which is used to hold a collection of schemas. The updated properties relate to the registry, and do not modify any of the schemas within the registry.
   */
  updateRegistry(
    req: operations.UpdateRegistryRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateRegistryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateRegistryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateRegistry";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateRegistryInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateRegistryResponse =
        new operations.UpdateRegistryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateRegistryResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateRegistryResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Updates the description, compatibility setting, or version checkpoint for a schema set.</p> <p>For updating the compatibility setting, the call will not validate compatibility for the entire set of schema versions with the new compatibility setting. If the value for <code>Compatibility</code> is provided, the <code>VersionNumber</code> (a checkpoint) is also required. The API will validate the checkpoint version number for consistency.</p> <p>If the value for the <code>VersionNumber</code> (checkpoint) is provided, <code>Compatibility</code> is optional and this can be used to set/reset a checkpoint for the schema.</p> <p>This update will happen only if the schema is in the AVAILABLE state.</p>
   */
  updateSchema(
    req: operations.UpdateSchemaRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSchemaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSchemaRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateSchema";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateSchemaInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSchemaResponse =
        new operations.UpdateSchemaResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateSchemaResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateSchemaResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * <p>Synchronizes a job to the source control repository. This operation takes the job artifacts from the Glue internal stores and makes a commit to the remote repository that is configured on the job.</p> <p>This API supports optional parameters which take in the repository information.</p>
   */
  updateSourceControlFromJob(
    req: operations.UpdateSourceControlFromJobRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateSourceControlFromJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateSourceControlFromJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateSourceControlFromJob";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateSourceControlFromJobRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateSourceControlFromJobResponse =
        new operations.UpdateSourceControlFromJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateSourceControlFromJobResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateSourceControlFromJobResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accessDeniedException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.alreadyExistsException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a metadata table in the Data Catalog.
   */
  updateTable(
    req: operations.UpdateTableRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTableResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTableRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateTable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateTableRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTableResponse =
        new operations.UpdateTableResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateTableResponse = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
        case httpRes?.status == 485:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNumberLimitExceededException = httpRes?.data;
          }
          break;
        case httpRes?.status == 486:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
        case httpRes?.status == 487:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotReadyException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a trigger definition.
   */
  updateTrigger(
    req: operations.UpdateTriggerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateTriggerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateTriggerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateTrigger";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateTriggerRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateTriggerResponse =
        new operations.UpdateTriggerResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateTriggerResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateTriggerResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing function definition in the Data Catalog.
   */
  updateUserDefinedFunction(
    req: operations.UpdateUserDefinedFunctionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateUserDefinedFunctionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateUserDefinedFunctionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") +
      "/#X-Amz-Target=AWSGlue.UpdateUserDefinedFunction";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateUserDefinedFunctionRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateUserDefinedFunctionResponse =
        new operations.UpdateUserDefinedFunctionResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateUserDefinedFunctionResponse = utils.objectToClass(
              httpRes?.data
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.glueEncryptionException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates an existing workflow.
   */
  updateWorkflow(
    req: operations.UpdateWorkflowRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.UpdateWorkflowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.UpdateWorkflowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/#X-Amz-Target=AWSGlue.UpdateWorkflow";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "updateWorkflowRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.UpdateWorkflowResponse =
        new operations.UpdateWorkflowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.updateWorkflowResponse = utils.objectToClass(
              httpRes?.data,
              shared.UpdateWorkflowResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidInputException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.entityNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalServiceException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operationTimeoutException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.concurrentModificationException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
