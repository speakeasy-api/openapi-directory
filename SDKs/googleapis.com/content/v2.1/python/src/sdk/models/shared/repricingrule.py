"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import repricingrulecostofgoodssalerule as shared_repricingrulecostofgoodssalerule
from ..shared import repricingruleeffectivetime as shared_repricingruleeffectivetime
from ..shared import repricingruleeligibleoffermatcher as shared_repricingruleeligibleoffermatcher
from ..shared import repricingrulerestriction as shared_repricingrulerestriction
from ..shared import repricingrulestatsbasedrule as shared_repricingrulestatsbasedrule
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class RepricingRuleTypeEnum(str, Enum):
    r"""Required. Immutable. The type of the rule."""
    REPRICING_RULE_TYPE_UNSPECIFIED = 'REPRICING_RULE_TYPE_UNSPECIFIED'
    TYPE_STATS_BASED = 'TYPE_STATS_BASED'
    TYPE_COGS_BASED = 'TYPE_COGS_BASED'
    TYPE_SALES_VOLUME_BASED = 'TYPE_SALES_VOLUME_BASED'
    TYPE_COMPETITIVE_PRICE = 'TYPE_COMPETITIVE_PRICE'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RepricingRuleInput:
    r"""Represents a repricing rule. A repricing rule is used by shopping serving to adjust transactable offer prices if conditions are met."""
    
    cogs_based_rule: Optional[shared_repricingrulecostofgoodssalerule.RepricingRuleCostOfGoodsSaleRule] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cogsBasedRule'), 'exclude': lambda f: f is None }})
    r"""A repricing rule that changes the sale price based on cost of goods sale."""  
    country_code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('countryCode'), 'exclude': lambda f: f is None }})
    r"""Required. Immutable. [CLDR country code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml) (e.g. \\"US\\")."""  
    effective_time_period: Optional[shared_repricingruleeffectivetime.RepricingRuleEffectiveTime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('effectiveTimePeriod'), 'exclude': lambda f: f is None }})  
    eligible_offer_matcher: Optional[shared_repricingruleeligibleoffermatcher.RepricingRuleEligibleOfferMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eligibleOfferMatcher'), 'exclude': lambda f: f is None }})
    r"""Matcher that specifies eligible offers. When the USE_FEED_ATTRIBUTE option is selected, only the repricing_rule_id attribute on the product feed is used to specify offer-rule mapping. When the CUSTOM_FILTER option is selected, only the *_matcher fields are used to filter the offers for offer-rule mapping. If the CUSTOM_FILTER option is selected, an offer needs to satisfy each custom filter matcher to be eligible for a rule. Size limit: the sum of the number of entries in all the matchers should not exceed 20. For example, there can be 15 product ids and 5 brands, but not 10 product ids and 11 brands."""  
    language_code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('languageCode'), 'exclude': lambda f: f is None }})
    r"""Required. Immutable. The two-letter ISO 639-1 language code associated with the repricing rule."""  
    paused: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('paused'), 'exclude': lambda f: f is None }})
    r"""Represents whether a rule is paused. A paused rule will behave like a non-paused rule within CRUD operations, with the major difference that a paused rule will not be evaluated and will have no effect on offers."""  
    restriction: Optional[shared_repricingrulerestriction.RepricingRuleRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('restriction'), 'exclude': lambda f: f is None }})
    r"""Definition of a rule restriction. At least one of the following needs to be true: (1) use_auto_pricing_min_price is true (2) floor.price_delta exists (3) floor.percentage_delta exists If floor.price_delta and floor.percentage_delta are both set on a rule, the highest value will be chosen by the Repricer. In other words, for a product with a price of $50, if the `floor.percentage_delta` is \\"-10\\" and the floor.price_delta is \\"-12\\", the offer price will only be lowered $5 (10% lower than the original offer price)."""  
    stats_based_rule: Optional[shared_repricingrulestatsbasedrule.RepricingRuleStatsBasedRule] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('statsBasedRule'), 'exclude': lambda f: f is None }})
    r"""Definition of stats based rule."""  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})
    r"""The title for the rule."""  
    type: Optional[RepricingRuleTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Required. Immutable. The type of the rule."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RepricingRule:
    r"""Represents a repricing rule. A repricing rule is used by shopping serving to adjust transactable offer prices if conditions are met."""
    
    cogs_based_rule: Optional[shared_repricingrulecostofgoodssalerule.RepricingRuleCostOfGoodsSaleRule] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cogsBasedRule'), 'exclude': lambda f: f is None }})
    r"""A repricing rule that changes the sale price based on cost of goods sale."""  
    country_code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('countryCode'), 'exclude': lambda f: f is None }})
    r"""Required. Immutable. [CLDR country code](http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml) (e.g. \\"US\\")."""  
    effective_time_period: Optional[shared_repricingruleeffectivetime.RepricingRuleEffectiveTime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('effectiveTimePeriod'), 'exclude': lambda f: f is None }})  
    eligible_offer_matcher: Optional[shared_repricingruleeligibleoffermatcher.RepricingRuleEligibleOfferMatcher] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('eligibleOfferMatcher'), 'exclude': lambda f: f is None }})
    r"""Matcher that specifies eligible offers. When the USE_FEED_ATTRIBUTE option is selected, only the repricing_rule_id attribute on the product feed is used to specify offer-rule mapping. When the CUSTOM_FILTER option is selected, only the *_matcher fields are used to filter the offers for offer-rule mapping. If the CUSTOM_FILTER option is selected, an offer needs to satisfy each custom filter matcher to be eligible for a rule. Size limit: the sum of the number of entries in all the matchers should not exceed 20. For example, there can be 15 product ids and 5 brands, but not 10 product ids and 11 brands."""  
    language_code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('languageCode'), 'exclude': lambda f: f is None }})
    r"""Required. Immutable. The two-letter ISO 639-1 language code associated with the repricing rule."""  
    merchant_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('merchantId'), 'exclude': lambda f: f is None }})
    r"""Output only. Immutable. Merchant that owns the repricing rule."""  
    paused: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('paused'), 'exclude': lambda f: f is None }})
    r"""Represents whether a rule is paused. A paused rule will behave like a non-paused rule within CRUD operations, with the major difference that a paused rule will not be evaluated and will have no effect on offers."""  
    restriction: Optional[shared_repricingrulerestriction.RepricingRuleRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('restriction'), 'exclude': lambda f: f is None }})
    r"""Definition of a rule restriction. At least one of the following needs to be true: (1) use_auto_pricing_min_price is true (2) floor.price_delta exists (3) floor.percentage_delta exists If floor.price_delta and floor.percentage_delta are both set on a rule, the highest value will be chosen by the Repricer. In other words, for a product with a price of $50, if the `floor.percentage_delta` is \\"-10\\" and the floor.price_delta is \\"-12\\", the offer price will only be lowered $5 (10% lower than the original offer price)."""  
    rule_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ruleId'), 'exclude': lambda f: f is None }})
    r"""Output only. Immutable. The ID to uniquely identify each repricing rule."""  
    stats_based_rule: Optional[shared_repricingrulestatsbasedrule.RepricingRuleStatsBasedRule] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('statsBasedRule'), 'exclude': lambda f: f is None }})
    r"""Definition of stats based rule."""  
    title: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title'), 'exclude': lambda f: f is None }})
    r"""The title for the rule."""  
    type: Optional[RepricingRuleTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Required. Immutable. The type of the rule."""  
    