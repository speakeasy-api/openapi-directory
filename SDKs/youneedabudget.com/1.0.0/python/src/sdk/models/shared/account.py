"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from ..shared import accounttype_enum as shared_accounttype_enum
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Account:
    
    balance: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('balance') }})
    r"""The current balance of the account in milliunits format"""  
    cleared_balance: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cleared_balance') }})
    r"""The current cleared balance of the account in milliunits format"""  
    closed: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('closed') }})
    r"""Whether this account is closed or not"""  
    deleted: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deleted') }})
    r"""Whether or not the account has been deleted.  Deleted accounts will only be included in delta requests."""  
    id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})  
    name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name') }})  
    on_budget: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('on_budget') }})
    r"""Whether this account is on budget or not"""  
    transfer_payee_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('transfer_payee_id') }})
    r"""The payee id which should be used when transferring to this account"""  
    type: shared_accounttype_enum.AccountTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type') }})
    r"""The type of account"""  
    uncleared_balance: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uncleared_balance') }})
    r"""The current uncleared balance of the account in milliunits format"""  
    debt_escrow_amounts: Optional[dict[str, int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('debt_escrow_amounts'), 'exclude': lambda f: f is None }})  
    debt_interest_rates: Optional[dict[str, int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('debt_interest_rates'), 'exclude': lambda f: f is None }})  
    debt_minimum_payments: Optional[dict[str, int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('debt_minimum_payments'), 'exclude': lambda f: f is None }})  
    debt_original_balance: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('debt_original_balance'), 'exclude': lambda f: f is None }})
    r"""The original debt/loan account balance, specified in milliunits format."""  
    direct_import_in_error: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direct_import_in_error'), 'exclude': lambda f: f is None }})
    r"""If an account linked to a financial institution (direct_import_linked=true) and the linked connection is not in a healthy state, this will be true."""  
    direct_import_linked: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('direct_import_linked'), 'exclude': lambda f: f is None }})
    r"""Whether or not the account is linked to a financial institution for automatic transaction import."""  
    last_reconciled_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_reconciled_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""A date/time specifying when the account was last reconciled."""  
    note: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('note'), 'exclude': lambda f: f is None }})  
    