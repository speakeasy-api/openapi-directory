"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Any, Optional

class IssueTracker:
    r"""The issue resources provide functionality for getting information on
    issues in an issue tracker, creating new issues, updating them and deleting
    them.
    
    You can access public issues without authentication, but you can't gain access
    to private repositories' issues. By authenticating, you will get the ability
    to create issues, as well as access to updating data or deleting issues you
    have access to.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_repositories_workspace_repo_slug_issues_issue_id_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse:
        r"""Delete an issue
        Deletes the specified issue. This requires write access to the
        repository.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_issues_issue_id_attachments_path_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse:
        r"""Delete an attachment for an issue
        Deletes an attachment.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 401]:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse:
        r"""Delete a comment on an issue
        Deletes the specified comment.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_repositories_workspace_repo_slug_issues_issue_id_vote(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse:
        r"""Remove vote for an issue
        Retract your vote.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if True:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_repositories_workspace_repo_slug_issues_issue_id_watch(self, request: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest, security: operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchSecurity) -> operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse:
        r"""Stop watching an issue
        Stop watching this issue.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_components(self, request: operations.GetRepositoriesWorkspaceRepoSlugComponentsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugComponentsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse:
        r"""List components
        Returns the components that have been defined in the issue tracker.
        
        This resource is only available on repositories that have the issue
        tracker enabled.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugComponentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/components', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugComponentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedComponents])
                res.paginated_components = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_components_component_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDResponse:
        r"""Get a component for issues
        Returns the specified issue tracker component object.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/components/{component_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugComponentsComponentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.component = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse:
        r"""List issues
        Returns the issues in the issue tracker.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedIssues])
                res.paginated_issues = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_export_repo_name_issues_task_id_zip(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipResponse:
        r"""Check issue export status
        This endpoint is used to poll for the progress of an issue export
        job and return the zip file after the job is complete.
        As long as the job is running, this will return a 200 response
        with in the response body a description of the current status.
        
        After the job has been scheduled, but before it starts executing, this
        endpoint's response is:
        
        {
         \"type\": \"issue_job_status\",
         \"status\": \"ACCEPTED\",
         \"phase\": \"Initializing\",
         \"total\": 0,
         \"count\": 0,
         \"pct\": 0
        }
        
        
        Then once it starts running, it becomes:
        
        {
         \"type\": \"issue_job_status\",
         \"status\": \"STARTED\",
         \"phase\": \"Attachments\",
         \"total\": 15,
         \"count\": 11,
         \"pct\": 73
        }
        
        Once the job has successfully completed, it returns a stream of the zip file.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/export/{repo_name}-issues-{task_id}.zip', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesExportRepoNameIssuesTaskIDZipResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueJobStatus])
                res.issue_job_status = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_import(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesImportRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesImportSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse:
        r"""Check issue import status
        When using GET, this endpoint reports the status of the current import task. Request example:
        
        ```
        $ curl -u <username> -X GET https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
        ```
        
        After the job has been scheduled, but before it starts executing, this endpoint's response is:
        
        ```
        < HTTP/1.1 202 Accepted
        {
            \"type\": \"issue_job_status\",
            \"status\": \"PENDING\",
            \"phase\": \"Attachments\",
            \"total\": 15,
            \"count\": 0,
            \"percent\": 0
        }
        ```
        
        Once it starts running, it is a 202 response with status STARTED and progress filled.
        
        After it is finished, it becomes a 200 response with status SUCCESS or FAILURE.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesImportRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/import', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesImportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [200, 202]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueJobStatus])
                res.issue_job_status = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse:
        r"""Get an issue
        Returns the specified issue.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue = out
        elif http_res.status_code in [403, 404, 410]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_attachments(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse:
        r"""List attachments for an issue
        Returns all attachments for this issue.
        
        This returns the files' meta data. This does not return the files'
        actual contents.
        
        The files are always ordered by their upload date.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedIssueAttachments])
                res.paginated_issue_attachments = out
        elif http_res.status_code == 401:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_attachments_path_(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse:
        r"""Get attachment for an issue
        Returns the contents of the specified file attachment.
        
        Note that this endpoint does not return a JSON response, but instead
        returns a redirect pointing to the actual file that in turn will return
        the raw contents.
        
        The redirect URL contains a one-time token that has a limited lifetime.
        As a result, the link should not be persisted, stored, or shared.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments/{path}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsPathResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 302:
            res.headers = http_res.headers
            
        elif http_res.status_code == 401:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_changes(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse:
        r"""List changes on an issue
        Returns the list of all changes that have been made to the specified
        issue. Changes are returned in chronological order with the oldest
        change first.
        
        Each time an issue is edited in the UI or through the API, an immutable
        change record is created under the `/issues/123/changes` endpoint. It
        also has a comment associated with the change.
        
        Note that this operation is changing significantly, due to privacy changes.
        See the [announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-changes-gdpr/#changes-to-the-issue-changes-api)
        for details.
        
        ```
        $ curl -s https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes - | jq .
        
        {
          \"pagelen\": 20,
          \"values\": [
            {
              \"changes\": {
                \"priority\": {
                  \"new\": \"trivial\",
                  \"old\": \"major\"
                },
                \"assignee\": {
                  \"new\": \"\",
                  \"old\": \"evzijst\"
                },
                \"assignee_account_id\": {
                  \"new\": \"\",
                  \"old\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"
                },
                \"kind\": {
                  \"new\": \"enhancement\",
                  \"old\": \"bug\"
                }
              },
              \"links\": {
                \"self\": {
                  \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1/changes/2\"
                },
                \"html\": {
                  \"href\": \"https://bitbucket.org/evzijst/dogslow/issues/1#comment-2\"
                }
              },
              \"issue\": {
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow/issues/1\"
                  }
                },
                \"type\": \"issue\",
                \"id\": 1,
                \"repository\": {
                  \"links\": {
                    \"self\": {
                      \"href\": \"https://api.bitbucket.org/2.0/repositories/evzijst/dogslow\"
                    },
                    \"html\": {
                      \"href\": \"https://bitbucket.org/evzijst/dogslow\"
                    },
                    \"avatar\": {
                      \"href\": \"https://bitbucket.org/evzijst/dogslow/avatar/32/\"
                    }
                  },
                  \"type\": \"repository\",
                  \"name\": \"dogslow\",
                  \"full_name\": \"evzijst/dogslow\",
                  \"uuid\": \"{988b17c6-1a47-4e70-84ee-854d5f012bf6}\"
                },
                \"title\": \"Updated title\"
              },
              \"created_on\": \"2018-03-03T00:35:28.353630+00:00\",
              \"user\": {
                \"username\": \"evzijst\",
                \"nickname\": \"evzijst\",
                \"display_name\": \"evzijst\",
                \"type\": \"user\",
                \"uuid\": \"{aaa7972b-38af-4fb1-802d-6e3854c95778}\",
                \"links\": {
                  \"self\": {
                    \"href\": \"https://api.bitbucket.org/2.0/users/evzijst\"
                  },
                  \"html\": {
                    \"href\": \"https://bitbucket.org/evzijst/\"
                  },
                  \"avatar\": {
                    \"href\": \"https://bitbucket.org/account/evzijst/avatar/32/\"
                  }
                }
              },
              \"message\": {
                \"raw\": \"Removed assignee, changed kind and priority.\",
                \"markup\": \"markdown\",
                \"html\": \"<p>Removed assignee, changed kind and priority.</p>\",
                \"type\": \"rendered\"
              },
              \"type\": \"issue_change\",
              \"id\": 2
            }
          ],
          \"page\": 1
        }
        ```
        
        Changes support [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) that
        can be used to search for specific changes. For instance, to see
        when an issue transitioned to \"resolved\":
        
        ```
        $ curl -s https://api.bitbucket.org/2.0/repositories/site/master/issues/1/changes \
           -G --data-urlencode='q=changes.state.new = \"resolved\"'
        ```
        
        This resource is only available on repositories that have the issue
        tracker enabled.
        
        N.B.
        
        The `changes.assignee` and `changes.assignee_account_id` fields are not
        a `user` object. Instead, they contain the raw `username` and
        `account_id` of the user. This is to protect the integrity of the audit
        log even after a user account gets deleted.
        
        The `changes.assignee` field is deprecated will disappear in the
        future. Use `changes.assignee_account_id` instead.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedLogEntries])
                res.paginated_log_entries = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_changes_change_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDResponse:
        r"""Get issue change object
        Returns the specified issue change object.
        
        This resource is only available on repositories that have the issue
        tracker enabled.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes/{change_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesChangeIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue_change = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_comments(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse:
        r"""List comments on an issue
        Returns a paginated list of all comments that were made on the
        specified issue.
        
        The default sorting is oldest to newest and can be overridden with
        the `sort` query parameter.
        
        This endpoint also supports filtering and sorting of the results. See
        [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments', request)
        
        query_params = utils.get_query_params(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedIssueComments])
                res.paginated_issue_comments = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse:
        r"""Get a comment on an issue
        Returns the specified issue comment object.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue_comment = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_vote(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse:
        r"""Check if current user voted for an issue
        Check whether the authenticated user has voted for this issue.
        A 204 status code indicates that the user has voted, while a 404
        implies they haven't.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_issues_issue_id_watch(self, request: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest, security: operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse:
        r"""Check if current user is watching a issue
        Indicated whether or not the authenticated user is watching this
        issue.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_milestones(self, request: operations.GetRepositoriesWorkspaceRepoSlugMilestonesRequest, security: operations.GetRepositoriesWorkspaceRepoSlugMilestonesSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse:
        r"""List milestones
        Returns the milestones that have been defined in the issue tracker.
        
        This resource is only available on repositories that have the issue
        tracker enabled.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugMilestonesRequest, base_url, '/repositories/{workspace}/{repo_slug}/milestones', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugMilestonesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedMilestones])
                res.paginated_milestones = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_milestones_milestone_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDResponse:
        r"""Get a milestone
        Returns the specified issue tracker milestone object.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/milestones/{milestone_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugMilestonesMilestoneIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.milestone = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_versions(self, request: operations.GetRepositoriesWorkspaceRepoSlugVersionsRequest, security: operations.GetRepositoriesWorkspaceRepoSlugVersionsSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse:
        r"""List defined versions for issues
        Returns the versions that have been defined in the issue tracker.
        
        This resource is only available on repositories that have the issue
        tracker enabled.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugVersionsRequest, base_url, '/repositories/{workspace}/{repo_slug}/versions', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugVersionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PaginatedVersions])
                res.paginated_versions = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_repositories_workspace_repo_slug_versions_version_id_(self, request: operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDRequest, security: operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDSecurity) -> operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDResponse:
        r"""Get a defined version for issues
        Returns the specified issue tracker version object.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/versions/{version_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetRepositoriesWorkspaceRepoSlugVersionsVersionIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.version = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_issues(self, request: operations.PostRepositoriesWorkspaceRepoSlugIssuesRequest, security: operations.PostRepositoriesWorkspaceRepoSlugIssuesSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse:
        r"""Create an issue
        Creates a new issue.
        
        This call requires authentication. Private repositories or private
        issue trackers require the caller to authenticate with an account that
        has appropriate authorization.
        
        The authenticated user is used for the issue's `reporter` field.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugIssuesRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugIssuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_issues_export(self, request: operations.PostRepositoriesWorkspaceRepoSlugIssuesExportRequest, security: operations.PostRepositoriesWorkspaceRepoSlugIssuesExportSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse:
        r"""Export issues
        A POST request to this endpoint initiates a new background celery task that archives the repo's issues.
        
        For example, you can run:
        
        curl -u <username> -X POST http://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/
        issues/export
        
        When the job has been accepted, it will return a 202 (Accepted) along with a unique url to this job in the
        'Location' response header. This url is the endpoint for where the user can obtain their zip files.\" 
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugIssuesExportRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/export', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugIssuesExportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            pass
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_issues_import(self, request: operations.PostRepositoriesWorkspaceRepoSlugIssuesImportRequest, security: operations.PostRepositoriesWorkspaceRepoSlugIssuesImportSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse:
        r"""Import issues
        A POST request to this endpoint will import the zip file given by the archive parameter into the repository. All
        existing issues will be deleted and replaced by the contents of the imported zip file.
        
        Imports are done through a multipart/form-data POST. There is one valid and required form field, with the name
        \"archive,\" which needs to be a file field:
        
        ```
        $ curl -u <username> -X POST -F archive=@/path/to/file.zip https://api.bitbucket.org/2.0/repositories/<owner_username>/<repo_slug>/issues/import
        ```
        
        When the import job is accepted, here is example output:
        
        ```
        < HTTP/1.1 202 Accepted
        
        {
            \"type\": \"issue_job_status\",
            \"status\": \"ACCEPTED\",
            \"phase\": \"Attachments\",
            \"total\": 15,
            \"count\": 0,
            \"percent\": 0
        }
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugIssuesImportRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/import', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugIssuesImportResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.IssueJobStatus])
                res.issue_job_status = out
        elif http_res.status_code in [401, 403, 404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_issues_issue_id_attachments(self, request: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsRequest, security: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse:
        r"""Upload an attachment to an issue
        Upload new issue attachments.
        
        To upload files, perform a `multipart/form-data` POST containing one
        or more file fields.
        
        When a file is uploaded with the same name as an existing attachment,
        then the existing file will be replaced.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/attachments', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDAttachmentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 401]:
            pass
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_issues_issue_id_changes(self, request: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest, security: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse:
        r"""Modify the state of an issue
        Makes a change to the specified issue.
        
        For example, to change an issue's state and assignee, create a new
        change object that modifies these fields:
        
        ```
        curl https://api.bitbucket.org/2.0/site/master/issues/1234/changes \
          -s -u evzijst -X POST -H \"Content-Type: application/json\" \
          -d '{
            \"changes\": {
              \"assignee_account_id\": {
                \"new\": \"557058:c0b72ad0-1cb5-4018-9cdc-0cde8492c443\"
              },
              \"state\": {
                \"new\": 'resolved\"
              }
            }
            \"message\": {
              \"raw\": \"This is now resolved.\"
            }
          }'
        ```
        
        The above example also includes a custom comment to go alongside the
        change. This comment will also be visible on the issue page in the UI.
        
        The fields of the `changes` object are strings, not objects. This
        allows for immutable change log records, even after user accounts,
        milestones, or other objects recorded in a change entry, get renamed or
        deleted.
        
        The `assignee_account_id` field stores the account id. When POSTing a
        new change and changing the assignee, the client should therefore use
        the user's account_id in the `changes.assignee_account_id.new` field.
        
        This call requires authentication. Private repositories or private
        issue trackers require the caller to authenticate with an account that
        has appropriate authorization.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/changes', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDChangesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue_change = out
        elif http_res.status_code in [401, 403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_repositories_workspace_repo_slug_issues_issue_id_comments(self, request: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest, security: operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsSecurity) -> operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse:
        r"""Create a comment on an issue
        Creates a new issue comment.
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/ \
          -X POST -u evzijst \
          -H 'Content-Type: application/json' \
          -d '{\"content\": {\"raw\": \"Lorem ipsum.\"}}'
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            res.headers = http_res.headers
            
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_issues_issue_id_(self, request: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest, security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse:
        r"""Update an issue
        Modifies the issue.
        
        ```
        $ curl https://api.bitbucket.org/2.0/repostories/evzijst/dogslow/issues/123 \
          -u evzijst -s -X PUT -H 'Content-Type: application/json' \
          -d '{
          \"title\": \"Updated title\",
          \"assignee\": {
            \"account_id\": \"5d5355e8c6b9320d9ea5b28d\"
          },
          \"priority\": \"minor\",
          \"version\": {
            \"name\": \"1.0\"
          },
          \"component\": null
        }'
        ```
        
        This example changes the `title`, `assignee`, `priority` and the
        `version`. It also removes the value of the `component` from the issue
        by setting the field to `null`. Any field not present keeps its existing
        value.
        
        Each time an issue is edited in the UI or through the API, an immutable
        change record is created under the `/issues/123/changes` endpoint. It
        also has a comment associated with the change.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue = out
        elif http_res.status_code in [403, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_issues_issue_id_comments_comment_id_(self, request: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest, security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse:
        r"""Update a comment on an issue
        Updates the content of the specified issue comment. Note that only
        the `content.raw` field can be modified.
        
        ```
        $ curl https://api.bitbucket.org/2.0/repositories/atlassian/prlinks/issues/42/comments/5728901 \
          -X PUT -u evzijst \
          -H 'Content-Type: application/json' \
          -d '{\"content\": {\"raw\": \"Lorem ipsum.\"}'
        ```
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/comments/{comment_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDCommentsCommentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.issue_comment = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_issues_issue_id_vote(self, request: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest, security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse:
        r"""Vote for an issue
        Vote for this issue.
        
        To cast your vote, do an empty PUT. The 204 status code indicates that
        the operation was successful.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/vote', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDVoteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_repositories_workspace_repo_slug_issues_issue_id_watch(self, request: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest, security: operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchSecurity) -> operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse:
        r"""Watch an issue
        Start watching this issue.
        
        To start watching this issue, do an empty PUT. The 204 status code
        indicates that the operation was successful.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchRequest, base_url, '/repositories/{workspace}/{repo_slug}/issues/{issue_id}/watch', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutRepositoriesWorkspaceRepoSlugIssuesIssueIDWatchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code in [204, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    