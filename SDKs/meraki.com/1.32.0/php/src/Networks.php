<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Networks 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Bind a network to a template.
     * 
     * Bind a network to a template.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BindNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BindNetworkResponse
     */
	public function bindNetwork(
        \OpenAPI\OpenAPI\Models\Operations\BindNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BindNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/bind', \OpenAPI\OpenAPI\Models\Operations\BindNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BindNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bindNetwork200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)
     * 
     * Claim devices into a network. (Note: for recently claimed devices, it may take a few minutes for API requsts against that device to succeed)
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ClaimNetworkDevicesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ClaimNetworkDevicesResponse
     */
	public function claimNetworkDevices(
        \OpenAPI\OpenAPI\Models\Operations\ClaimNetworkDevicesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ClaimNetworkDevicesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/devices/claim', \OpenAPI\OpenAPI\Models\Operations\ClaimNetworkDevicesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ClaimNetworkDevicesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Combine multiple networks into a single network
     * 
     * Combine multiple networks into a single network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworksResponse
     */
	public function combineOrganizationNetworks(
        \OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/organizations/{organizationId}/networks/combine', \OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworksRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->combineOrganizationNetworks200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CombineOrganizationNetworks200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Rollback a Firmware Upgrade For A Network
     * 
     * Rollback a Firmware Upgrade For A Network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollbackRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollbackResponse
     */
	public function createNetworkFirmwareUpgradesRollback(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollbackRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollbackResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/rollbacks', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollbackRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollbackResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkFirmwareUpgradesRollback200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesRollback200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Staged Upgrade Event for a network
     * 
     * Create a Staged Upgrade Event for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEventRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEventResponse
     */
	public function createNetworkFirmwareUpgradesStagedEvent(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEventRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEventResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/events', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEventRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEventResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkFirmwareUpgradesStagedEvent200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedEvent200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a Staged Upgrade Group for a network
     * 
     * Create a Staged Upgrade Group for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedGroupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedGroupResponse
     */
	public function createNetworkFirmwareUpgradesStagedGroup(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedGroupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedGroupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/groups', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedGroupRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFirmwareUpgradesStagedGroupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkFirmwareUpgradesStagedGroup200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Upload a floor plan
     * 
     * Upload a floor plan
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFloorPlanRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFloorPlanResponse
     */
	public function createNetworkFloorPlan(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFloorPlanRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFloorPlanResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/floorPlans', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFloorPlanRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkFloorPlanResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkFloorPlan201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a group policy
     * 
     * Create a group policy
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkGroupPolicyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkGroupPolicyResponse
     */
	public function createNetworkGroupPolicy(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkGroupPolicyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkGroupPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/groupPolicies', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkGroupPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkGroupPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkGroupPolicy201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     * 
     * Authorize a user configured with Meraki Authentication for a network (currently supports 802.1X, splash guest, and client VPN users, and currently, organizations have a 50,000 user cap)
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUserResponse
     */
	public function createNetworkMerakiAuthUser(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/merakiAuthUsers', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkMerakiAuthUser201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateNetworkMerakiAuthUser201ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add an MQTT broker
     * 
     * Add an MQTT broker
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMqttBrokerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMqttBrokerResponse
     */
	public function createNetworkMqttBroker(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMqttBrokerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMqttBrokerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/mqttBrokers', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMqttBrokerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkMqttBrokerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkMqttBroker201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Submit a new delete or restrict processing PII request
     * 
     * Submit a new delete or restrict processing PII request
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/requests
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkPiiRequestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkPiiRequestResponse
     */
	public function createNetworkPiiRequest(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkPiiRequestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkPiiRequestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/requests', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkPiiRequestRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkPiiRequestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkPiiRequest201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add an HTTP server to a network
     * 
     * Add an HTTP server to a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServerResponse
     */
	public function createNetworkWebhooksHttpServer(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/httpServers', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkWebhooksHttpServer201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksHttpServer201ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a webhook payload template for a network
     * 
     * Create a webhook payload template for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplateResponse
     */
	public function createNetworkWebhooksPayloadTemplate(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/payloadTemplates', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkWebhooksPayloadTemplate201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksPayloadTemplate201ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Send a test webhook for a network
     * 
     * Send a test webhook for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTestResponse
     */
	public function createNetworkWebhooksWebhookTest(
        \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/webhookTests', \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTestRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createNetworkWebhooksWebhookTest201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateNetworkWebhooksWebhookTest201ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a network
     * 
     * Create a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetworkResponse
     */
	public function createOrganizationNetwork(
        \OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/organizations/{organizationId}/networks', \OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createOrganizationNetwork201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\CreateOrganizationNetwork201ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Postpone by 1 week all pending staged upgrade stages for a network
     * 
     * Postpone by 1 week all pending staged upgrade stages for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEventsResponse
     */
	public function deferNetworkFirmwareUpgradesStagedEvents(
        \OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/events/defer', \OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEventsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deferNetworkFirmwareUpgradesStagedEvents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\DeferNetworkFirmwareUpgradesStagedEvents200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a network
     * 
     * Delete a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkResponse
     */
	public function deleteNetwork(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete a Staged Upgrade Group
     * 
     * Delete a Staged Upgrade Group
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFirmwareUpgradesStagedGroupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFirmwareUpgradesStagedGroupResponse
     */
	public function deleteNetworkFirmwareUpgradesStagedGroup(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFirmwareUpgradesStagedGroupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFirmwareUpgradesStagedGroupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFirmwareUpgradesStagedGroupRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFirmwareUpgradesStagedGroupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Destroy a floor plan
     * 
     * Destroy a floor plan
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFloorPlanRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFloorPlanResponse
     */
	public function deleteNetworkFloorPlan(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFloorPlanRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFloorPlanResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/floorPlans/{floorPlanId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFloorPlanRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkFloorPlanResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete a group policy
     * 
     * Delete a group policy
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkGroupPolicyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkGroupPolicyResponse
     */
	public function deleteNetworkGroupPolicy(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkGroupPolicyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkGroupPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/groupPolicies/{groupPolicyId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkGroupPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkGroupPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Deauthorize a user
     * 
     * Deauthorize a user. To reauthorize a user after deauthorizing them, POST to this endpoint. (Currently, 802.1X RADIUS, splash guest, and client VPN users can be deauthorized.)
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMerakiAuthUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMerakiAuthUserResponse
     */
	public function deleteNetworkMerakiAuthUser(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMerakiAuthUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMerakiAuthUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMerakiAuthUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMerakiAuthUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete an MQTT broker
     * 
     * Delete an MQTT broker
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMqttBrokerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMqttBrokerResponse
     */
	public function deleteNetworkMqttBroker(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMqttBrokerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMqttBrokerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/mqttBrokers/{mqttBrokerId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMqttBrokerRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkMqttBrokerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete a restrict processing PII request
     * 
     * Delete a restrict processing PII request
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/requests/{requestId}
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkPiiRequestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkPiiRequestResponse
     */
	public function deleteNetworkPiiRequest(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkPiiRequestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkPiiRequestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/requests/{requestId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkPiiRequestRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkPiiRequestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete an HTTP server from a network
     * 
     * Delete an HTTP server from a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksHttpServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksHttpServerResponse
     */
	public function deleteNetworkWebhooksHttpServer(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksHttpServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksHttpServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/httpServers/{httpServerId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksHttpServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksHttpServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Destroy a webhook payload template for a network
     * 
     * Destroy a webhook payload template for a network. Does not work for included templates ('wpt_00001', 'wpt_00002', 'wpt_00003', 'wpt_00004', 'wpt_00005' or 'wpt_00006')
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksPayloadTemplateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksPayloadTemplateResponse
     */
	public function deleteNetworkWebhooksPayloadTemplate(
        \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksPayloadTemplateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksPayloadTemplateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}', \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksPayloadTemplateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteNetworkWebhooksPayloadTemplateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Return a network
     * 
     * Return a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkResponse
     */
	public function getNetwork(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetwork200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetwork200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the alert history for this network
     * 
     * Return the alert history for this network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryResponse
     */
	public function getNetworkAlertsHistory(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/alerts/history', \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkAlertsHistory200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsHistory200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the alert configuration for this network
     * 
     * Return the alert configuration for this network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsSettingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsSettingsResponse
     */
	public function getNetworkAlertsSettings(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsSettingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/alerts/settings', \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkAlertsSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkAlertsSettings200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return a Bluetooth client
     * 
     * Return a Bluetooth client. Bluetooth clients can be identified by their ID or their MAC.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientResponse
     */
	public function getNetworkBluetoothClient(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/bluetoothClients/{bluetoothClientId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkBluetoothClient200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the Bluetooth clients seen by APs in this network
     * 
     * List the Bluetooth clients seen by APs in this network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsResponse
     */
	public function getNetworkBluetoothClients(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/bluetoothClients', \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkBluetoothClientsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkBluetoothClients200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the client associated with the given identifier
     * 
     * Return the client associated with the given identifier. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientResponse
     */
	public function getNetworkClient(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClient200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkClient200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the policy assigned to a client on the network
     * 
     * Return the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientPolicyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientPolicyResponse
     */
	public function getNetworkClientPolicy(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientPolicyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}/policy', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientPolicy200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the splash authorization for a client, for each SSID they've associated with through splash
     * 
     * Return the splash authorization for a client, for each SSID they've associated with through splash. Only enabled SSIDs with Click-through splash enabled will be included. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientSplashAuthorizationStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientSplashAuthorizationStatusResponse
     */
	public function getNetworkClientSplashAuthorizationStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientSplashAuthorizationStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientSplashAuthorizationStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientSplashAuthorizationStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientSplashAuthorizationStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientSplashAuthorizationStatus200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the client's network traffic data over time
     * 
     * Return the client's network traffic data over time. Usage data is in kilobytes. This endpoint requires detailed traffic analysis to be enabled on the Network-wide > General page. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryResponse
     */
	public function getNetworkClientTrafficHistory(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}/trafficHistory', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientTrafficHistoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientTrafficHistory200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the client's daily usage history
     * 
     * Return the client's daily usage history. Usage data is in kilobytes. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientUsageHistoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientUsageHistoryResponse
     */
	public function getNetworkClientUsageHistory(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientUsageHistoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientUsageHistoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}/usageHistory', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientUsageHistoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientUsageHistoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientUsageHistory200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the clients that have used this network in the timespan
     * 
     * List the clients that have used this network in the timespan
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsResponse
     */
	public function getNetworkClients(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClients200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkClients200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the application usage data for clients
     * 
     * Return the application usage data for clients. Usage data is in kilobytes. Clients can be identified by client keys or either the MACs or IPs depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageResponse
     */
	public function getNetworkClientsApplicationUsage(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/applicationUsage', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsApplicationUsageResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientsApplicationUsage200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     * 
     * Returns a timeseries of total traffic consumption rates for all clients on a network within a given timespan, in megabits per second.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryResponse
     */
	public function getNetworkClientsBandwidthUsageHistory(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/bandwidthUsageHistory', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsBandwidthUsageHistoryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientsBandwidthUsageHistory200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return overview statistics for network clients
     * 
     * Return overview statistics for network clients
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewResponse
     */
	public function getNetworkClientsOverview(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/overview', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsOverviewResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientsOverview200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the usage histories for clients
     * 
     * Return the usage histories for clients. Usage data is in kilobytes. Clients can be identified by client keys or either the MACs or IPs depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesResponse
     */
	public function getNetworkClientsUsageHistories(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/usageHistories', \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkClientsUsageHistoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkClientsUsageHistories200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the devices in a network
     * 
     * List the devices in a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkDevicesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkDevicesResponse
     */
	public function getNetworkDevices(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkDevicesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkDevicesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/devices', \OpenAPI\OpenAPI\Models\Operations\GetNetworkDevicesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkDevicesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkDevices200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the events for the network
     * 
     * List the events for the network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsResponse
     */
	public function getNetworkEvents(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/events', \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkEvents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkEvents200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the event type to human-readable description
     * 
     * List the event type to human-readable description
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypesResponse
     */
	public function getNetworkEventsEventTypes(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/events/eventTypes', \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkEventsEventTypes200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkEventsEventTypes200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get firmware upgrade information for a network
     * 
     * Get firmware upgrade information for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesResponse
     */
	public function getNetworkFirmwareUpgrades(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFirmwareUpgrades200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgrades200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the Staged Upgrade Event from a network
     * 
     * Get the Staged Upgrade Event from a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEventsResponse
     */
	public function getNetworkFirmwareUpgradesStagedEvents(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/events', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEventsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFirmwareUpgradesStagedEvents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedEvents200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a Staged Upgrade Group from a network
     * 
     * Get a Staged Upgrade Group from a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupResponse
     */
	public function getNetworkFirmwareUpgradesStagedGroup(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFirmwareUpgradesStagedGroup200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroup200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List of Staged Upgrade Groups in a network
     * 
     * List of Staged Upgrade Groups in a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupsResponse
     */
	public function getNetworkFirmwareUpgradesStagedGroups(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/groups', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroupsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFirmwareUpgradesStagedGroups200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedGroups200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Order of Staged Upgrade Groups in a network
     * 
     * Order of Staged Upgrade Groups in a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStagesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStagesResponse
     */
	public function getNetworkFirmwareUpgradesStagedStages(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStagesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStagesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/stages', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStagesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStagesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFirmwareUpgradesStagedStages200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkFirmwareUpgradesStagedStages200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Find a floor plan by ID
     * 
     * Find a floor plan by ID
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlanRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlanResponse
     */
	public function getNetworkFloorPlan(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlanRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlanResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/floorPlans/{floorPlanId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlanRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlanResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFloorPlan200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the floor plans that belong to your network
     * 
     * List the floor plans that belong to your network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlansRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlansResponse
     */
	public function getNetworkFloorPlans(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlansRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlansResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/floorPlans', \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlansRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkFloorPlansResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkFloorPlans200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the group policies in a network
     * 
     * List the group policies in a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPoliciesResponse
     */
	public function getNetworkGroupPolicies(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/groupPolicies', \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPoliciesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkGroupPolicies200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Display a group policy
     * 
     * Display a group policy
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPolicyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPolicyResponse
     */
	public function getNetworkGroupPolicy(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPolicyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/groupPolicies/{groupPolicyId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkGroupPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkGroupPolicy200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return all global alerts on this network
     * 
     * Return all global alerts on this network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlertsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlertsResponse
     */
	public function getNetworkHealthAlerts(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlertsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlertsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/health/alerts', \OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlertsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlertsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkHealthAlerts200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkHealthAlerts200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     * 
     * Return the Meraki Auth splash guest, RADIUS, or client VPN user
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUserResponse
     */
	public function getNetworkMerakiAuthUser(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkMerakiAuthUser200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUser200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)
     * 
     * List the users configured under Meraki Authentication for a network (splash guest or RADIUS users for a wireless network, or client VPN users for a wired network)
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsersResponse
     */
	public function getNetworkMerakiAuthUsers(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/merakiAuthUsers', \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkMerakiAuthUsers200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkMerakiAuthUsers200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return an MQTT broker
     * 
     * Return an MQTT broker
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokerResponse
     */
	public function getNetworkMqttBroker(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/mqttBrokers/{mqttBrokerId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokerRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkMqttBroker200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the MQTT brokers for this network
     * 
     * List the MQTT brokers for this network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokersResponse
     */
	public function getNetworkMqttBrokers(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/mqttBrokers', \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokersRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkMqttBrokersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkMqttBrokers200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the NetFlow traffic reporting settings for a network
     * 
     * Return the NetFlow traffic reporting settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetflowRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetflowResponse
     */
	public function getNetworkNetflow(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetflowRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetflowResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/netflow', \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetflowRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetflowResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkNetflow200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the channel utilization over each radio for all APs in a network.
     * 
     * Get the channel utilization over each radio for all APs in a network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationResponse
     */
	public function getNetworkNetworkHealthChannelUtilization(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/networkHealth/channelUtilization', \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkNetworkHealthChannelUtilizationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkNetworkHealthChannelUtilization200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the keys required to access Personally Identifiable Information (PII) for a given identifier
     * 
     * List the keys required to access Personally Identifiable Information (PII) for a given identifier. Exactly one identifier will be accepted. If the organization contains org-wide Systems Manager users matching the key provided then there will be an entry with the key "0" containing the applicable keys.
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/piiKeys
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysResponse
     */
	public function getNetworkPiiPiiKeys(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/piiKeys', \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiPiiKeysResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkPiiPiiKeys200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return a PII request
     * 
     * Return a PII request
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/requests/{requestId}
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestResponse
     */
	public function getNetworkPiiRequest(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/requests/{requestId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkPiiRequest200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the PII requests for this network or organization
     * 
     * List the PII requests for this network or organization
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/requests
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestsResponse
     */
	public function getNetworkPiiRequests(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/requests', \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiRequestsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkPiiRequests200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier
     * 
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager device ID(s) associated with that identifier. These device IDs can be used with the Systems Manager API endpoints to retrieve device details. Exactly one identifier will be accepted.
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/smDevicesForKey
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyResponse
     */
	public function getNetworkPiiSmDevicesForKey(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/smDevicesForKey', \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmDevicesForKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkPiiSmDevicesForKey200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier
     * 
     * Given a piece of Personally Identifiable Information (PII), return the Systems Manager owner ID(s) associated with that identifier. These owner IDs can be used with the Systems Manager API endpoints to retrieve owner details. Exactly one identifier will be accepted.
     * 
     * ## ALTERNATE PATH
     * 
     * ```
     * /organizations/{organizationId}/pii/smOwnersForKey
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyResponse
     */
	public function getNetworkPiiSmOwnersForKey(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/pii/smOwnersForKey', \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkPiiSmOwnersForKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkPiiSmOwnersForKey200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get policies for all clients with policies
     * 
     * Get policies for all clients with policies
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientResponse
     */
	public function getNetworkPoliciesByClient(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/policies/byClient', \OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClientResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkPoliciesByClient200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkPoliciesByClient200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the settings for a network
     * 
     * Return the settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkSettingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkSettingsResponse
     */
	public function getNetworkSettings(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkSettingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/settings', \OpenAPI\OpenAPI\Models\Operations\GetNetworkSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkSettings200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkSettings200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the SNMP settings for a network
     * 
     * Return the SNMP settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkSnmpRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkSnmpResponse
     */
	public function getNetworkSnmp(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkSnmpRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkSnmpResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/snmp', \OpenAPI\OpenAPI\Models\Operations\GetNetworkSnmpRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkSnmpResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkSnmp200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the splash login attempts for a network
     * 
     * List the splash login attempts for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsResponse
     */
	public function getNetworkSplashLoginAttempts(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/splashLoginAttempts', \OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkSplashLoginAttemptsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkSplashLoginAttempts200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the syslog servers for a network
     * 
     * List the syslog servers for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServersResponse
     */
	public function getNetworkSyslogServers(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/syslogServers', \OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServersRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkSyslogServers200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkSyslogServers200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the LLDP and CDP information for all discovered devices and connections in a network.
     * 
     * List the LLDP and CDP information for all discovered devices and connections in a network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkTopologyLinkLayerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkTopologyLinkLayerResponse
     */
	public function getNetworkTopologyLinkLayer(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkTopologyLinkLayerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkTopologyLinkLayerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/topology/linkLayer', \OpenAPI\OpenAPI\Models\Operations\GetNetworkTopologyLinkLayerRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkTopologyLinkLayerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkTopologyLinkLayer200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the traffic analysis data for this network
     * 
     * Return the traffic analysis data for this network. Traffic analysis with hostname visibility must be enabled on the network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficResponse
     */
	public function getNetworkTraffic(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/traffic', \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkTraffic200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the traffic analysis settings for a network
     * 
     * Return the traffic analysis settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficAnalysisRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficAnalysisResponse
     */
	public function getNetworkTrafficAnalysis(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficAnalysisRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficAnalysisResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/trafficAnalysis', \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficAnalysisRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficAnalysisResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkTrafficAnalysis200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the application categories for traffic shaping rules.
     * 
     * Returns the application categories for traffic shaping rules.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingApplicationCategoriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingApplicationCategoriesResponse
     */
	public function getNetworkTrafficShapingApplicationCategories(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingApplicationCategoriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingApplicationCategoriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/trafficShaping/applicationCategories', \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingApplicationCategoriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingApplicationCategoriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkTrafficShapingApplicationCategories200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the available DSCP tagging options for your traffic shaping rules.
     * 
     * Returns the available DSCP tagging options for your traffic shaping rules.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingDscpTaggingOptionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingDscpTaggingOptionsResponse
     */
	public function getNetworkTrafficShapingDscpTaggingOptions(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingDscpTaggingOptionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingDscpTaggingOptionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/trafficShaping/dscpTaggingOptions', \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingDscpTaggingOptionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkTrafficShapingDscpTaggingOptionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkTrafficShapingDscpTaggingOptions200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<array<string, mixed>>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return an HTTP server for a network
     * 
     * Return an HTTP server for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServerResponse
     */
	public function getNetworkWebhooksHttpServer(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/httpServers/{httpServerId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkWebhooksHttpServer200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServer200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the HTTP servers for a network
     * 
     * List the HTTP servers for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServersResponse
     */
	public function getNetworkWebhooksHttpServers(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/httpServers', \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServersRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkWebhooksHttpServers200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksHttpServers200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the webhook payload template for a network
     * 
     * Get the webhook payload template for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplateResponse
     */
	public function getNetworkWebhooksPayloadTemplate(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplateRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkWebhooksPayloadTemplate200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplate200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the webhook payload templates for a network
     * 
     * List the webhook payload templates for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplatesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplatesResponse
     */
	public function getNetworkWebhooksPayloadTemplates(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplatesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplatesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/payloadTemplates', \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplatesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplatesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkWebhooksPayloadTemplates200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksPayloadTemplates200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Return the status of a webhook test for a network
     * 
     * Return the status of a webhook test for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTestRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTestResponse
     */
	public function getNetworkWebhooksWebhookTest(
        \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTestRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTestResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/webhookTests/{webhookTestId}', \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTestRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTestResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getNetworkWebhooksWebhookTest200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetNetworkWebhooksWebhookTest200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns list of networks eligible for adding cloud monitored device
     * 
     * Returns list of networks eligible for adding cloud monitored device
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksResponse
     */
	public function getOrganizationInventoryOnboardingCloudMonitoringNetworks(
        \OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/organizations/{organizationId}/inventory/onboarding/cloudMonitoring/networks', \OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getOrganizationInventoryOnboardingCloudMonitoringNetworks202ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetOrganizationInventoryOnboardingCloudMonitoringNetworks202ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List the networks that the user has privileges on in an organization
     * 
     * List the networks that the user has privileges on in an organization
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksResponse
     */
	public function getOrganizationNetworks(
        \OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/organizations/{organizationId}/networks', \OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworksResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getOrganizationNetworks200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\GetOrganizationNetworks200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Provisions a client with a name and policy
     * 
     * Provisions a client with a name and policy. Clients can be provisioned before they associate to the network.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ProvisionNetworkClientsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ProvisionNetworkClientsResponse
     */
	public function provisionNetworkClients(
        \OpenAPI\OpenAPI\Models\Operations\ProvisionNetworkClientsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ProvisionNetworkClientsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/provision', \OpenAPI\OpenAPI\Models\Operations\ProvisionNetworkClientsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ProvisionNetworkClientsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->provisionNetworkClients201ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove a single device
     * 
     * Remove a single device
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveNetworkDevicesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveNetworkDevicesResponse
     */
	public function removeNetworkDevices(
        \OpenAPI\OpenAPI\Models\Operations\RemoveNetworkDevicesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveNetworkDevicesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/devices/remove', \OpenAPI\OpenAPI\Models\Operations\RemoveNetworkDevicesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveNetworkDevicesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Rollback a Staged Upgrade Event for a network
     * 
     * Rollback a Staged Upgrade Event for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEventsResponse
     */
	public function rollbacksNetworkFirmwareUpgradesStagedEvents(
        \OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/events/rollbacks', \OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEventsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->rollbacksNetworkFirmwareUpgradesStagedEvents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\RollbacksNetworkFirmwareUpgradesStagedEvents200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Split a combined network into individual networks for each type of device
     * 
     * Split a combined network into individual networks for each type of device
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SplitNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SplitNetworkResponse
     */
	public function splitNetwork(
        \OpenAPI\OpenAPI\Models\Operations\SplitNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SplitNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/split', \OpenAPI\OpenAPI\Models\Operations\SplitNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SplitNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->splitNetwork200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\SplitNetwork200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unbind a network from a template.
     * 
     * Unbind a network from a template.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UnbindNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UnbindNetworkResponse
     */
	public function unbindNetwork(
        \OpenAPI\OpenAPI\Models\Operations\UnbindNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UnbindNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/unbind', \OpenAPI\OpenAPI\Models\Operations\UnbindNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UnbindNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->unbindNetwork200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UnbindNetwork200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a network
     * 
     * Update a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkResponse
     */
	public function updateNetwork(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetwork200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetwork200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the alert configuration for this network
     * 
     * Update the alert configuration for this network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkAlertsSettingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkAlertsSettingsResponse
     */
	public function updateNetworkAlertsSettings(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkAlertsSettingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkAlertsSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/alerts/settings', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkAlertsSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkAlertsSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkAlertsSettings200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the policy assigned to a client on the network
     * 
     * Update the policy assigned to a client on the network. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientPolicyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientPolicyResponse
     */
	public function updateNetworkClientPolicy(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientPolicyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}/policy', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkClientPolicy200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a client's splash authorization
     * 
     * Update a client's splash authorization. Clients can be identified by a client key or either the MAC or IP depending on whether the network uses Track-by-IP.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientSplashAuthorizationStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientSplashAuthorizationStatusResponse
     */
	public function updateNetworkClientSplashAuthorizationStatus(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientSplashAuthorizationStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientSplashAuthorizationStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/clients/{clientId}/splashAuthorizationStatus', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientSplashAuthorizationStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkClientSplashAuthorizationStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkClientSplashAuthorizationStatus200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update firmware upgrade information for a network
     * 
     * Update firmware upgrade information for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesResponse
     */
	public function updateNetworkFirmwareUpgrades(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkFirmwareUpgrades200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgrades200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the Staged Upgrade Event for a network
     * 
     * Update the Staged Upgrade Event for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEventsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEventsResponse
     */
	public function updateNetworkFirmwareUpgradesStagedEvents(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEventsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEventsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/events', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEventsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEventsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkFirmwareUpgradesStagedEvents200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedEvents200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Staged Upgrade Group for a network
     * 
     * Update a Staged Upgrade Group for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedGroupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedGroupResponse
     */
	public function updateNetworkFirmwareUpgradesStagedGroup(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedGroupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedGroupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/groups/{groupId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedGroupRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedGroupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkFirmwareUpgradesStagedGroup200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Assign Staged Upgrade Group order in the sequence.
     * 
     * Assign Staged Upgrade Group order in the sequence.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStagesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStagesResponse
     */
	public function updateNetworkFirmwareUpgradesStagedStages(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStagesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStagesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/firmwareUpgrades/staged/stages', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStagesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStagesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkFirmwareUpgradesStagedStages200ApplicationJSONObjects = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFirmwareUpgradesStagedStages200ApplicationJSON>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a floor plan's geolocation and other meta data
     * 
     * Update a floor plan's geolocation and other meta data
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFloorPlanRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFloorPlanResponse
     */
	public function updateNetworkFloorPlan(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFloorPlanRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFloorPlanResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/floorPlans/{floorPlanId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFloorPlanRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkFloorPlanResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkFloorPlan200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a group policy
     * 
     * Update a group policy
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkGroupPolicyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkGroupPolicyResponse
     */
	public function updateNetworkGroupPolicy(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkGroupPolicyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkGroupPolicyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/groupPolicies/{groupPolicyId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkGroupPolicyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkGroupPolicyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkGroupPolicy200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     * 
     * Update a user configured with Meraki Authentication (currently, 802.1X RADIUS, splash guest, and client VPN users can be updated)
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUserRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUserResponse
     */
	public function updateNetworkMerakiAuthUser(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUserRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/merakiAuthUsers/{merakiAuthUserId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkMerakiAuthUser200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMerakiAuthUser200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an MQTT broker
     * 
     * Update an MQTT broker
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMqttBrokerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMqttBrokerResponse
     */
	public function updateNetworkMqttBroker(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMqttBrokerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMqttBrokerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/mqttBrokers/{mqttBrokerId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMqttBrokerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkMqttBrokerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkMqttBroker200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the NetFlow traffic reporting settings for a network
     * 
     * Update the NetFlow traffic reporting settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkNetflowRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkNetflowResponse
     */
	public function updateNetworkNetflow(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkNetflowRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkNetflowResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/netflow', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkNetflowRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkNetflowResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkNetflow200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the settings for a network
     * 
     * Update the settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettingsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettingsResponse
     */
	public function updateNetworkSettings(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettingsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettingsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/settings', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettingsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettingsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkSettings200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSettings200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the SNMP settings for a network
     * 
     * Update the SNMP settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSnmpRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSnmpResponse
     */
	public function updateNetworkSnmp(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSnmpRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSnmpResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/snmp', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSnmpRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSnmpResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkSnmp200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the syslog servers for a network
     * 
     * Update the syslog servers for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServersResponse
     */
	public function updateNetworkSyslogServers(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/syslogServers', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkSyslogServers200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkSyslogServers200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the traffic analysis settings for a network
     * 
     * Update the traffic analysis settings for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkTrafficAnalysisRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkTrafficAnalysisResponse
     */
	public function updateNetworkTrafficAnalysis(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkTrafficAnalysisRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkTrafficAnalysisResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/trafficAnalysis', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkTrafficAnalysisRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkTrafficAnalysisResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkTrafficAnalysis200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update an HTTP server
     * 
     * Update an HTTP server. To change a URL, create a new HTTP server.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServerRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServerResponse
     */
	public function updateNetworkWebhooksHttpServer(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServerRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServerResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/httpServers/{httpServerId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServerRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServerResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkWebhooksHttpServer200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksHttpServer200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a webhook payload template for a network
     * 
     * Update a webhook payload template for a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplateResponse
     */
	public function updateNetworkWebhooksPayloadTemplate(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/webhooks/payloadTemplates/{payloadTemplateId}', \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->updateNetworkWebhooksPayloadTemplate200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\UpdateNetworkWebhooksPayloadTemplate200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Claim a vMX into a network
     * 
     * Claim a vMX into a network
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\VmxNetworkDevicesClaimRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\VmxNetworkDevicesClaimResponse
     */
	public function vmxNetworkDevicesClaim(
        \OpenAPI\OpenAPI\Models\Operations\VmxNetworkDevicesClaimRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\VmxNetworkDevicesClaimResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/networks/{networkId}/devices/claim/vmx', \OpenAPI\OpenAPI\Models\Operations\VmxNetworkDevicesClaimRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\VmxNetworkDevicesClaimResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->vmxNetworkDevicesClaim200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}