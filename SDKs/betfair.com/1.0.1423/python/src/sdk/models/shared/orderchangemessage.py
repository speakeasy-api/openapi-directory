"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import ordermarketchange as shared_ordermarketchange
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class OrderChangeMessageCtEnum(str, Enum):
    r"""Change Type - set to indicate the type of change - if null this is a delta)"""
    SUB_IMAGE = 'SUB_IMAGE'
    RESUB_DELTA = 'RESUB_DELTA'
    HEARTBEAT = 'HEARTBEAT'

class OrderChangeMessageSegmentTypeEnum(str, Enum):
    r"""Segment Type - if the change is split into multiple segments, this denotes the beginning and end of a change, and segments in between. Will be null if data is not segmented"""
    SEG_START = 'SEG_START'
    SEG = 'SEG'
    SEG_END = 'SEG_END'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class OrderChangeMessage:
    
    clk: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clk'), 'exclude': lambda f: f is None }})
    r"""Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)"""  
    conflate_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conflateMs'), 'exclude': lambda f: f is None }})
    r"""Conflate Milliseconds - the conflation rate (may differ from that requested if subscription is delayed)"""  
    ct: Optional[OrderChangeMessageCtEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ct'), 'exclude': lambda f: f is None }})
    r"""Change Type - set to indicate the type of change - if null this is a delta)"""  
    heartbeat_ms: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('heartbeatMs'), 'exclude': lambda f: f is None }})
    r"""Heartbeat Milliseconds - the heartbeat rate (may differ from requested: bounds are 500 to 30000)"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Client generated unique id to link request with response (like json rpc)"""  
    initial_clk: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('initialClk'), 'exclude': lambda f: f is None }})
    r"""Token value (non-null) should be stored and passed in a MarketSubscriptionMessage to resume subscription (in case of disconnect)"""  
    oc: Optional[list[shared_ordermarketchange.OrderMarketChange]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oc'), 'exclude': lambda f: f is None }})
    r"""OrderMarketChanges - the modifications to account's orders (will be null on a heartbeat"""  
    op: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('op'), 'exclude': lambda f: f is None }})
    r"""The operation type"""  
    pt: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pt'), 'exclude': lambda f: f is None }})
    r"""Publish Time (in millis since epoch) that the changes were generated"""  
    segment_type: Optional[OrderChangeMessageSegmentTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('segmentType'), 'exclude': lambda f: f is None }})
    r"""Segment Type - if the change is split into multiple segments, this denotes the beginning and end of a change, and segments in between. Will be null if data is not segmented"""  
    status: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""Stream status: set to null if the exchange stream data is up to date and 503 if the downstream services are experiencing latencies"""  
    