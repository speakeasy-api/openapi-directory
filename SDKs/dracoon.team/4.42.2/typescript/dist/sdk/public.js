"use strict";
/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Public = void 0;
var utils = __importStar(require("../internal/utils"));
var operations = __importStar(require("./models/operations"));
var shared = __importStar(require("./models/shared"));
/**
 * Public API (upload / download shares, software information)
 */
var Public = /** @class */ (function () {
    function Public(defaultClient, securityClient, serverURL, language, sdkVersion, genVersion) {
        this._defaultClient = defaultClient;
        this._securityClient = securityClient;
        this._serverURL = serverURL;
        this._language = language;
        this._sdkVersion = sdkVersion;
        this._genVersion = genVersion;
    }
    /**
     * Cancel file upload
     *
     * @remarks
     * ### Description:
     * Abort (chunked) upload via Upload Share.
     *
     * ### Precondition:
     * Valid Upload ID.
     *
     * ### Postcondition:
     * Aborts upload and invalidates upload ID / token.
     *
     * ### Further Information:
     * None.
     */
    Public.prototype.cancelFileUploadViaShare = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CancelFileUploadViaShareRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}/{upload_id}", req);
        var client = this._securityClient || this._defaultClient;
        var r = client.request(__assign({ url: url, method: "delete" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CancelFileUploadViaShareResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 204:
                    break;
                case [400, 404, 406, 504, 507].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Check public Download Share password
     *
     * @remarks
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.36.0</h3>
     *
     * ### Description:
     * Check password for a public Download Share
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * None.
     *
     * ### Further Information:
     * None.
     */
    Public.prototype.checkPublicDownloadSharePassword = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CheckPublicDownloadSharePasswordRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/downloads/{access_key}", req);
        var client = this._securityClient || this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "head" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CheckPublicDownloadSharePasswordResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [200, 400, 401, 403, 404, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
            }
            return res;
        });
    };
    /**
     * Complete file upload
     *
     * @remarks
     * ### Description:
     * Finalize (chunked) upload via Upload Share.
     *
     * ### Precondition:
     * Valid upload ID.
     * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
     *
     * ### Postcondition:
     * Finalizes upload.
     *
     * ### Further Information:
     * Chunked uploads (range requests) are supported.
     *
     * Please ensure that all chunks have been transferred correctly before finishing the upload.
     * If file hash has been created in time a `201 Created` will be responded and hash will be part of response, otherwise it will be a `202 Accepted` without it.
     *
     *
     * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
     */
    Public.prototype.completeFileUploadViaShare = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CompleteFileUploadViaShareRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}/{upload_id}", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "userFileKeyList", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign(__assign({}, utils.getHeadersFromRequest(req)), reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "put", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CompleteFileUploadViaShareResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [201, 202].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.publicUploadedFileData = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.PublicUploadedFileData);
                    }
                    break;
                case [400, 403, 404, 406, 412, 504, 507].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Complete S3 file upload
     *
     * @remarks
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     *
     * ### Description:
     * Finishes a S3 file upload and closes the corresponding upload channel.
     *
     * ### Precondition:
     * Valid upload ID.
     * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
     *
     * ### Postcondition:
     * Upload channel is closed. S3 multipart upload request is completed.
     *
     * ### Further Information:
     * None.
     *
     */
    Public.prototype.completeS3FileUploadViaShare = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CompleteS3FileUploadViaShareRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}/{upload_id}/s3", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "completeS3ShareUploadRequest", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "put", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CompleteS3FileUploadViaShareResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 202:
                    break;
                case [400, 404, 406, 412].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Create new file upload channel
     *
     * @remarks
     * ### Description:
     * Create a new upload channel.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * Upload channel is created and corresponding upload URL, token & upload ID are returned.
     *
     * ### Further Information:
     * Use `uploadUrl` the upload `token` is deprecated.
     *
     * Please provide the size of the intended upload so that the quota can be checked in advanced and no data is transferred unnecessarily.
     *
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     *
     */
    Public.prototype.createShareUploadChannel = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.CreateShareUploadChannelRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "createShareUploadChannelRequest", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.CreateShareUploadChannelResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.createShareUploadChannelResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.CreateShareUploadChannelResponse);
                    }
                    break;
                case [400, 401, 403, 404, 406, 412, 504, 507].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Download file with token
     *
     * @remarks
     * ### Description:
     * Download a file (or zip archive if target is a folder or room).
     *
     * ### Precondition:
     * Valid download token.
     *
     * ### Postcondition:
     * Stream is returned.
     *
     * ### Further Information:
     * Range requests are supported.
     * Range requests are illegal for zip archive download.
     *
     * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
     */
    Public.prototype.downloadFileViaTokenPublic = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.DownloadFileViaTokenPublicRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/downloads/{access_key}/{token}", req);
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.DownloadFileViaTokenPublicResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [200, 206].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [400, 404, 406, 416].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/octet-stream")) {
                        var resBody = JSON.stringify(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, null, 0);
                        var out = new Uint8Array(resBody.length);
                        for (var i = 0; i < resBody.length; i++)
                            out[i] = resBody.charCodeAt(i);
                        res.body = out;
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Download file with token
     *
     * @remarks
     * ### Description:
     * Download a file (or zip archive if target is a folder or room).
     *
     * ### Precondition:
     * Valid download token.
     *
     * ### Postcondition:
     * Stream is returned.
     *
     * ### Further Information:
     * Range requests are supported.
     * Range requests are illegal for zip archive download.
     *
     * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
     */
    Public.prototype.downloadFileViaTokenPublic1 = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.DownloadFileViaTokenPublic1Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/downloads/{access_key}/{token}", req);
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "head", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.DownloadFileViaTokenPublic1Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [200, 206].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    break;
                case [400, 404, 406, 416].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/octet-stream")) {
                        var resBody = JSON.stringify(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, null, 0);
                        var out = new Uint8Array(resBody.length);
                        for (var i = 0; i < resBody.length; i++)
                            out[i] = resBody.charCodeAt(i);
                        res.body = out;
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Generate download URL
     *
     * @remarks
     * ### Description:
     * Generate a download URL to retrieve a shared file.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * Download URL and token are generated and returned.
     *
     * ### Further Information:
     * Use `downloadUrl` the download `token` is deprecated.
     */
    Public.prototype.generateDownloadUrlPublic = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GenerateDownloadUrlPublicRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/downloads/{access_key}", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "publicDownloadTokenGenerateRequest", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GenerateDownloadUrlPublicResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.publicDownloadTokenGenerateResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.PublicDownloadTokenGenerateResponse);
                    }
                    break;
                case [400, 401, 403, 404, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Generate presigned URLs for S3 file upload
     *
     * @remarks
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     *
     * ### Description:
     * Generate presigned URLs for S3 file upload.
     *
     * ### Precondition:
     * Valid upload ID
     *
     * ### Postcondition:
     * List of presigned URLs is returned.
     *
     * ### Further Information:
     * The size for each part must be >= 5 MB, except for the last part.
     * The part number of the first part in S3 is 1 (not 0).
     * Use HTTP method `PUT` for uploading bytes via presigned URL.
     */
    Public.prototype.generatePresignedUrlsPublic = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GeneratePresignedUrlsPublicRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}/{upload_id}/s3_urls", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "generatePresignedUrlsRequest", "json"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign(__assign({}, utils.getHeadersFromRequest(req)), reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        if (reqBody == null || Object.keys(reqBody).length === 0)
            throw new Error("request body is required");
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.GeneratePresignedUrlsPublicResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 201:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.presignedUrlList = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.PresignedUrlList);
                    }
                    break;
                case [400, 403, 404, 406, 412, 504, 507].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request Active Directory authentication information
     *
     * @remarks
     * ### Description:
     * Provides information about Active Directory authentication options.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * Active Directory authentication options information is returned.
     *
     * ### Further Information:
     * None.
     */
    Public.prototype.requestActiveDirectoryAuthInfo = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestActiveDirectoryAuthInfoRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v4/public/system/info/auth/ad";
        var client = this._securityClient || this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestActiveDirectoryAuthInfoResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.activeDirectoryAuthInfo = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ActiveDirectoryAuthInfo);
                    }
                    break;
                case [400, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request OpenID Connect provider authentication information
     *
     * @remarks
     * ### Description:
     * Provides information about OpenID Connect authentication options.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * OpenID Connect authentication options information is returned.
     *
     * ### Further Information:
     * None.
     */
    Public.prototype.requestOpenIdAuthInfo = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestOpenIdAuthInfoRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v4/public/system/info/auth/openid";
        var client = this._securityClient || this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestOpenIdAuthInfoResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.openIdAuthInfo = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.OpenIdAuthInfo);
                    }
                    break;
                case [400, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request public Download Share information
     *
     * @remarks
     * ### Description:
     * Retrieve the public information of a Download Share.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * Download Share information is returned.
     *
     * ### Further Information:
     * None.
     */
    Public.prototype.requestPublicDownloadShareInfo = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestPublicDownloadShareInfoRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/downloads/{access_key}", req);
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestPublicDownloadShareInfoResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.publicDownloadShare = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.PublicDownloadShare);
                    }
                    break;
                case [400, 404, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request public Upload Share information
     *
     * @remarks
     * ### Description:
     * Provides information about the desired Upload Share.
     *
     * ### Precondition:
     * Only `userUserPublicKeyList` is returned to the users who owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage upload share</span>
     *
     * ### Postcondition:
     * None.
     *
     * ### Further Information:
     * If no password is set, the returned information is reduced to the following attributes (if available):
     *
     * * `name`
     * * `createdAt`
     * * `isProtected`
     * * `isEncrypted`
     * * `showUploadedFiles`
     * * `userUserPublicKeyList` (if parent is end-to-end encrypted)
     *
     * Only if the password is transmitted as `X-Sds-Share-Password` header, all values are returned.
     *
     */
    Public.prototype.requestPublicUploadShareInfo = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestPublicUploadShareInfoRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}", req);
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestPublicUploadShareInfoResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.publicUploadShare = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.PublicUploadShare);
                    }
                    break;
                case [400, 401, 404, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request software version information
     *
     * @remarks
     * ### Description:
     * Public software version information.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * Sofware version information is returned.
     *
     * ### Further Information:
     * The version of DRACOON Server consists of two components:
     * * **API**
     * * **Core** (referred to as _"Server"_)
     *
     * which are versioned individually.
     */
    Public.prototype.requestSoftwareVersion = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestSoftwareVersionRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v4/public/software/version";
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestSoftwareVersionResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.softwareVersionData = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SoftwareVersionData);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 406:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request system information
     *
     * @remarks
     * ### Description:
     * Provides information about system.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * System information is returned.
     *
     * ### Further Information:
     * Authentication methods are sorted by **priority** attribute.
     * Smaller values have higher priority.
     * Authentication method with highest priority is considered as default.
     *
     * ### System information:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     *
     * | Setting | Description | Value |
     * | :--- | :--- | :--- |
     * | `languageDefault` | Defines which language should be default. | `ISO 639-1 code` |
     * | `hideLoginInputFields` | Defines if login fields should be hidden. | `true or false` |
     * | `s3Hosts` | List of available S3 hosts. | `String array` |
     * | `s3EnforceDirectUpload` | Determines whether S3 direct upload is enforced or not. | `true or false` |
     * | `useS3Storage` | Determines whether S3 Storage enabled and used. | `true or false` |
     *
     * </details>
     *
     * ### Authentication methods:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     *
     * | Authentication Method | Description |
     * | :--- | :--- |
     * | `basic` | **Basic** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their credentials stored in the database.<br>Formerly known as `sql`. |
     * | `active_directory` | **Active Directory** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their Active Directory credentials. |
     * | `radius` | **RADIUS** authentication globally allowed.<br>This option **MUST** be activated to allow users to log in with their RADIUS username, their PIN and a token password. |
     * | `openid` | **OpenID Connect** authentication globally allowed.This option **MUST** be activated to allow users to log in with their OpenID Connect identity. |
     * | `hideLoginInputFields` | Determines whether input fields for login should be enabled | `true or false` |
     *
     * </details>
     *
     * @see {@link https://tools.ietf.org/html/rfc5646} - Tags for Identifying Languages
     */
    Public.prototype.requestSystemInfo = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestSystemInfoRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v4/public/system/info";
        var client = this._securityClient || this._defaultClient;
        var queryParams = utils.serializeQueryParams(req);
        var r = client.request(__assign({ url: url + queryParams, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestSystemInfoResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.systemInfo = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SystemInfo);
                    }
                    break;
                case [400, 406].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request system time
     *
     * @remarks
     * ### Description:
     * Retrieve the actual server time.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * Server time is returned.
     *
     * ### Further Information:
     * None.
     */
    Public.prototype.requestSystemTime = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestSystemTimeRequest(req);
        }
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") + "/v4/public/time";
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign({}, utils.getHeadersFromRequest(req)), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "get", headers: headers }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestSystemTimeResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.sdsServerTime = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.SdsServerTime);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 406:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request third-party software dependencies
     *
     * @remarks
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.9.0</h3>
     *
     * ### Description:
     * Provides information about used third-party software dependencies.
     *
     * ### Precondition:
     * None.
     *
     * ### Postcondition:
     * List of the third-party software dependencies used by **DRACOON Core** (referred to as _"Server"_) is returned.
     *
     * ### Further Information:
     * None.
     *
     *
     */
    Public.prototype.requestThirdPartyDependencies = function (config) {
        var baseURL = this._serverURL;
        var url = baseURL.replace(/\/$/, "") +
            "/v4/public/software/third_party_dependencies";
        var client = this._securityClient || this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestThirdPartyDependenciesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.thirdPartyDependenciesData = [];
                        var resFieldDepth = utils.getResFieldDepth(res);
                        res.thirdPartyDependenciesData = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ThirdPartyDependenciesData, resFieldDepth);
                    }
                    break;
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 406:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Request status of S3 file upload
     *
     * @remarks
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     *
     * ### Description:
     * Request status of a S3 file upload.
     *
     * ### Precondition:
     * An upload channel has been created and the user has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the parent container (room or folder).
     *
     * ### Postcondition:
     * Status of S3 multipart upload request is returned.
     *
     * ### Further Information:
     * None.
     *
     * ### Possible errors:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     *
     * | Http Status | Error Code | Description |
     * | :--- | :--- | :--- |
     * | `400 Bad Request` | `-80000` | Mandatory fields cannot be empty |
     * | `400 Bad Request` | `-80001` | Invalid positive number |
     * | `400 Bad Request` | `-80002` | Invalid number |
     * | `400 Bad Request` | `-40001` | (Target) room is not encrypted |
     * | `400 Bad Request` | `-40755` | Bad file name |
     * | `400 Bad Request` | `-40763` | File key must be set for an upload into encrypted room |
     * | `400 Bad Request` | `-50506` | Exceeds the number of files for this Upload Share |
     * | `403 Forbidden` |  | Access denied |
     * | `404 Not Found` | `-20501` | Upload not found |
     * | `404 Not Found` | `-40000` | Container not found |
     * | `404 Not Found` | `-41000` | Node not found |
     * | `404 Not Found` | `-70501` | User not found |
     * | `409 Conflict` | `-40010` | Container cannot be overwritten |
     * | `409 Conflict` |  | File cannot be overwritten |
     * | `500 Internal Server Error` |  | System Error |
     * | `502 Bad Gateway` |  | S3 Error |
     * | `502 Insufficient Storage` | `-50504` | Exceeds the quota for this Upload Share |
     * | `502 Insufficient Storage` | `-40200` | Exceeds the free node quota in room |
     * | `502 Insufficient Storage` | `-90200` | Exceeds the free customer quota |
     * | `502 Insufficient Storage` | `-90201` | Exceeds the free customer physical disk space |
     *
     * </details>
     */
    Public.prototype.requestUploadStatusPublic = function (req, config) {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.RequestUploadStatusPublicRequest(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}/{upload_id}", req);
        var client = this._securityClient || this._defaultClient;
        var r = client.request(__assign({ url: url, method: "get" }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.RequestUploadStatusPublicResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case (httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == 200:
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.s3ShareUploadStatus = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.S3ShareUploadStatus);
                    }
                    break;
                case [400, 404, 406, 412].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    /**
     * Upload file
     *
     * @remarks
     * ### Description:
     * Chunked upload of files via Upload Share.
     *
     * ### Precondition:
     * Valid upload ID.
     *
     * ### Postcondition:
     * Chunk of file is uploaded.
     *
     * ### Further Information:
     * Chunked uploads (range requests) are supported.
     *
     * Following `Content-Types` are supported by this API:
     * * `multipart/form-data`
     * * provided `Content-Type`
     *
     * For both file upload types set the correct `Content-Type` header and body.
     *
     * ### Examples:
     *
     * * `multipart/form-data`
     * ```
     * POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1
     *
     * Header:
     * ...
     * Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
     * ...
     *
     * Body:
     * ------WebKitFormBoundary7MA4YWxkTrZu0gW
     * Content-Disposition: form-data; name="file"; filename="file.txt"
     * Content-Type: text/plain
     *
     * Content of file.txt
     * ------WebKitFormBoundary7MA4YWxkTrZu0gW--
     * ```
     *
     * * any other `Content-Type`
     * ```
     * POST /api/v4/public/shares/uploads/{access_key}{upload_id} HTTP/1.1
     *
     * Header:
     * ...
     * Content-Type: { ... }
     * ...
     *
     * Body:
     * raw content
     * ```
     *
     * @see {@link https://tools.ietf.org/html/rfc7233} - Range Requests
     */
    Public.prototype.uploadFileAsMultipartPublic1 = function (req, config) {
        var _a;
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.UploadFileAsMultipartPublic1Request(req);
        }
        var baseURL = this._serverURL;
        var url = utils.generateURL(baseURL, "/v4/public/shares/uploads/{access_key}/{upload_id}", req);
        var _b = [{}, {}], reqBodyHeaders = _b[0], reqBody = _b[1];
        try {
            _a = utils.serializeRequestBody(req, "requestBody", "multipart"), reqBodyHeaders = _a[0], reqBody = _a[1];
        }
        catch (e) {
            if (e instanceof Error) {
                throw new Error("Error serializing request body, cause: ".concat(e.message));
            }
        }
        var client = this._securityClient || this._defaultClient;
        var headers = __assign(__assign(__assign({}, utils.getHeadersFromRequest(req)), reqBodyHeaders), config === null || config === void 0 ? void 0 : config.headers);
        var r = client.request(__assign({ url: url, method: "post", headers: headers, data: reqBody }, config));
        return r.then(function (httpRes) {
            var _a, _b;
            var contentType = (_b = (_a = httpRes === null || httpRes === void 0 ? void 0 : httpRes.headers) === null || _a === void 0 ? void 0 : _a["content-type"]) !== null && _b !== void 0 ? _b : "";
            if ((httpRes === null || httpRes === void 0 ? void 0 : httpRes.status) == null)
                throw new Error("status code not found in response: ".concat(httpRes));
            var res = new operations.UploadFileAsMultipartPublic1Response({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
            switch (true) {
                case [200, 201].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.chunkUploadResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ChunkUploadResponse);
                    }
                    break;
                case [400, 404, 406, 412, 507].includes(httpRes === null || httpRes === void 0 ? void 0 : httpRes.status):
                    if (utils.matchContentType(contentType, "application/json")) {
                        res.errorResponse = utils.objectToClass(httpRes === null || httpRes === void 0 ? void 0 : httpRes.data, shared.ErrorResponse);
                    }
                    break;
            }
            return res;
        });
    };
    return Public;
}());
exports.Public = Public;
