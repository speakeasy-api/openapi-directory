/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Buyers {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Creates a creative.
   */
  realtimebiddingBuyersCreativesCreate(
    req: operations.RealtimebiddingBuyersCreativesCreateRequest,
    security: operations.RealtimebiddingBuyersCreativesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersCreativesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersCreativesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/creatives",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "creativeInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersCreativesCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersCreativesCreateResponse =
        new operations.RealtimebiddingBuyersCreativesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.creative = utils.objectToClass(httpRes?.data, shared.Creative);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists creatives as they are at the time of the initial request. This call may take multiple hours to complete. For large, paginated requests, this method returns a snapshot of creatives at the time of request for the first page. `lastStatusUpdate` and `creativeServingDecision` may be outdated for creatives on sequential pages. We recommend [Google Cloud Pub/Sub](//cloud.google.com/pubsub/docs/overview) to view the latest status.
   */
  realtimebiddingBuyersCreativesList(
    req: operations.RealtimebiddingBuyersCreativesListRequest,
    security: operations.RealtimebiddingBuyersCreativesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersCreativesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersCreativesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/creatives",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersCreativesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersCreativesListResponse =
        new operations.RealtimebiddingBuyersCreativesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listCreativesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListCreativesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates a creative.
   */
  realtimebiddingBuyersCreativesPatch(
    req: operations.RealtimebiddingBuyersCreativesPatchRequest,
    security: operations.RealtimebiddingBuyersCreativesPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersCreativesPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersCreativesPatchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "creativeInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersCreativesPatchSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersCreativesPatchResponse =
        new operations.RealtimebiddingBuyersCreativesPatchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.creative = utils.objectToClass(httpRes?.data, shared.Creative);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists all buyer account information the calling buyer user or service account is permissioned to manage.
   */
  realtimebiddingBuyersList(
    req: operations.RealtimebiddingBuyersListRequest,
    security: operations.RealtimebiddingBuyersListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v1/buyers";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersListResponse =
        new operations.RealtimebiddingBuyersListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBuyersResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBuyersResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change the status of a user list to CLOSED. This prevents new users from being added to the user list.
   */
  realtimebiddingBuyersUserListsClose(
    req: operations.RealtimebiddingBuyersUserListsCloseRequest,
    security: operations.RealtimebiddingBuyersUserListsCloseSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsCloseResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersUserListsCloseRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:close", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersUserListsCloseSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsCloseResponse =
        new operations.RealtimebiddingBuyersUserListsCloseResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userList = utils.objectToClass(httpRes?.data, shared.UserList);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new user list.
   */
  realtimebiddingBuyersUserListsCreate(
    req: operations.RealtimebiddingBuyersUserListsCreateRequest,
    security: operations.RealtimebiddingBuyersUserListsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersUserListsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/userLists",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userListInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersUserListsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsCreateResponse =
        new operations.RealtimebiddingBuyersUserListsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userList = utils.objectToClass(httpRes?.data, shared.UserList);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets a user list by its name.
   */
  realtimebiddingBuyersUserListsGet(
    req: operations.RealtimebiddingBuyersUserListsGetRequest,
    security: operations.RealtimebiddingBuyersUserListsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersUserListsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersUserListsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsGetResponse =
        new operations.RealtimebiddingBuyersUserListsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userList = utils.objectToClass(httpRes?.data, shared.UserList);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets remarketing tag for a buyer. A remarketing tag is a piece of JavaScript code that can be placed on a web page. When a user visits a page containing a remarketing tag, Google adds the user to a user list.
   */
  realtimebiddingBuyersUserListsGetRemarketingTag(
    req: operations.RealtimebiddingBuyersUserListsGetRemarketingTagRequest,
    security: operations.RealtimebiddingBuyersUserListsGetRemarketingTagSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsGetRemarketingTagResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RealtimebiddingBuyersUserListsGetRemarketingTagRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:getRemarketingTag",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RealtimebiddingBuyersUserListsGetRemarketingTagSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsGetRemarketingTagResponse =
        new operations.RealtimebiddingBuyersUserListsGetRemarketingTagResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.getRemarketingTagResponse = utils.objectToClass(
              httpRes?.data,
              shared.GetRemarketingTagResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists the user lists visible to the current user.
   */
  realtimebiddingBuyersUserListsList(
    req: operations.RealtimebiddingBuyersUserListsListRequest,
    security: operations.RealtimebiddingBuyersUserListsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersUserListsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/userLists",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersUserListsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsListResponse =
        new operations.RealtimebiddingBuyersUserListsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listUserListsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListUserListsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Change the status of a user list to OPEN. This allows new users to be added to the user list.
   */
  realtimebiddingBuyersUserListsOpen(
    req: operations.RealtimebiddingBuyersUserListsOpenRequest,
    security: operations.RealtimebiddingBuyersUserListsOpenSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsOpenResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersUserListsOpenRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:open", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersUserListsOpenSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsOpenResponse =
        new operations.RealtimebiddingBuyersUserListsOpenResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userList = utils.objectToClass(httpRes?.data, shared.UserList);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update the given user list. Only user lists with URLRestrictions can be updated.
   */
  realtimebiddingBuyersUserListsUpdate(
    req: operations.RealtimebiddingBuyersUserListsUpdateRequest,
    security: operations.RealtimebiddingBuyersUserListsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RealtimebiddingBuyersUserListsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RealtimebiddingBuyersUserListsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "userListInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RealtimebiddingBuyersUserListsUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RealtimebiddingBuyersUserListsUpdateResponse =
        new operations.RealtimebiddingBuyersUserListsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userList = utils.objectToClass(httpRes?.data, shared.UserList);
          }
          break;
      }

      return res;
    });
  }
}
