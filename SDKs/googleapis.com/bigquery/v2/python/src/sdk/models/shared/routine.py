"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import argument as shared_argument
from ..shared import remotefunctionoptions as shared_remotefunctionoptions
from ..shared import routinereference as shared_routinereference
from ..shared import sparkoptions as shared_sparkoptions
from ..shared import standardsqldatatype as shared_standardsqldatatype
from ..shared import standardsqltabletype as shared_standardsqltabletype
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class RoutineDeterminismLevelEnum(str, Enum):
    r"""Optional. The determinism level of the JavaScript UDF, if defined."""
    DETERMINISM_LEVEL_UNSPECIFIED = 'DETERMINISM_LEVEL_UNSPECIFIED'
    DETERMINISTIC = 'DETERMINISTIC'
    NOT_DETERMINISTIC = 'NOT_DETERMINISTIC'

class RoutineLanguageEnum(str, Enum):
    r"""Optional. Defaults to \\"SQL\\" if remote_function_options field is absent, not set otherwise."""
    LANGUAGE_UNSPECIFIED = 'LANGUAGE_UNSPECIFIED'
    SQL = 'SQL'
    JAVASCRIPT = 'JAVASCRIPT'
    PYTHON = 'PYTHON'
    JAVA = 'JAVA'
    SCALA = 'SCALA'

class RoutineRoutineTypeEnum(str, Enum):
    r"""Required. The type of routine."""
    ROUTINE_TYPE_UNSPECIFIED = 'ROUTINE_TYPE_UNSPECIFIED'
    SCALAR_FUNCTION = 'SCALAR_FUNCTION'
    PROCEDURE = 'PROCEDURE'
    TABLE_VALUED_FUNCTION = 'TABLE_VALUED_FUNCTION'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RoutineInput:
    r"""A user-defined function or a stored procedure."""
    
    arguments: Optional[list[shared_argument.Argument]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('arguments'), 'exclude': lambda f: f is None }})
    r"""Optional."""  
    definition_body: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('definitionBody'), 'exclude': lambda f: f is None }})
    r"""Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, \\"\n\\", y))` The definition_body is `concat(x, \\"\n\\", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return \\"\n\\";\n'` The definition_body is `return \\"\n\\";\n` Note that both \n are replaced with linebreaks."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Optional. The description of the routine, if defined."""  
    determinism_level: Optional[RoutineDeterminismLevelEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('determinismLevel'), 'exclude': lambda f: f is None }})
    r"""Optional. The determinism level of the JavaScript UDF, if defined."""  
    imported_libraries: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('importedLibraries'), 'exclude': lambda f: f is None }})
    r"""Optional. If language = \\"JAVASCRIPT\\", this field stores the path of the imported JAVASCRIPT libraries."""  
    language: Optional[RoutineLanguageEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('language'), 'exclude': lambda f: f is None }})
    r"""Optional. Defaults to \\"SQL\\" if remote_function_options field is absent, not set otherwise."""  
    remote_function_options: Optional[shared_remotefunctionoptions.RemoteFunctionOptions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('remoteFunctionOptions'), 'exclude': lambda f: f is None }})
    r"""Options for a remote user-defined function."""  
    return_table_type: Optional[shared_standardsqltabletype.StandardSQLTableType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('returnTableType'), 'exclude': lambda f: f is None }})
    r"""A table type"""  
    return_type: Optional[shared_standardsqldatatype.StandardSQLDataType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('returnType'), 'exclude': lambda f: f is None }})
    r"""The data type of a variable such as a function argument. Examples include: * INT64: `{\\"typeKind\\": \\"INT64\\"}` * ARRAY: { \\"typeKind\\": \\"ARRAY\\", \\"arrayElementType\\": {\\"typeKind\\": \\"STRING\\"} } * STRUCT>: { \\"typeKind\\": \\"STRUCT\\", \\"structType\\": { \\"fields\\": [ { \\"name\\": \\"x\\", \\"type\\": {\\"typeKind\\": \\"STRING\\"} }, { \\"name\\": \\"y\\", \\"type\\": { \\"typeKind\\": \\"ARRAY\\", \\"arrayElementType\\": {\\"typeKind\\": \\"DATE\\"} } } ] } }"""  
    routine_reference: Optional[shared_routinereference.RoutineReference] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('routineReference'), 'exclude': lambda f: f is None }})  
    routine_type: Optional[RoutineRoutineTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('routineType'), 'exclude': lambda f: f is None }})
    r"""Required. The type of routine."""  
    spark_options: Optional[shared_sparkoptions.SparkOptions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sparkOptions'), 'exclude': lambda f: f is None }})
    r"""Options for a user-defined Spark routine."""  
    strict_mode: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('strictMode'), 'exclude': lambda f: f is None }})
    r"""Optional. Can be set for procedures only. If true (default), the definition body will be validated in the creation and the updates of the procedure. For procedures with an argument of ANY TYPE, the definition body validtion is not supported at creation/update time, and thus this field must be set to false explicitly."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Routine:
    r"""A user-defined function or a stored procedure."""
    
    arguments: Optional[list[shared_argument.Argument]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('arguments'), 'exclude': lambda f: f is None }})
    r"""Optional."""  
    creation_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('creationTime'), 'exclude': lambda f: f is None }})
    r"""Output only. The time when this routine was created, in milliseconds since the epoch."""  
    definition_body: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('definitionBody'), 'exclude': lambda f: f is None }})
    r"""Required. The body of the routine. For functions, this is the expression in the AS clause. If language=SQL, it is the substring inside (but excluding) the parentheses. For example, for the function created with the following statement: `CREATE FUNCTION JoinLines(x string, y string) as (concat(x, \\"\n\\", y))` The definition_body is `concat(x, \\"\n\\", y)` (\n is not replaced with linebreak). If language=JAVASCRIPT, it is the evaluated string in the AS clause. For example, for the function created with the following statement: `CREATE FUNCTION f() RETURNS STRING LANGUAGE js AS 'return \\"\n\\";\n'` The definition_body is `return \\"\n\\";\n` Note that both \n are replaced with linebreaks."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Optional. The description of the routine, if defined."""  
    determinism_level: Optional[RoutineDeterminismLevelEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('determinismLevel'), 'exclude': lambda f: f is None }})
    r"""Optional. The determinism level of the JavaScript UDF, if defined."""  
    etag: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('etag'), 'exclude': lambda f: f is None }})
    r"""Output only. A hash of this resource."""  
    imported_libraries: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('importedLibraries'), 'exclude': lambda f: f is None }})
    r"""Optional. If language = \\"JAVASCRIPT\\", this field stores the path of the imported JAVASCRIPT libraries."""  
    language: Optional[RoutineLanguageEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('language'), 'exclude': lambda f: f is None }})
    r"""Optional. Defaults to \\"SQL\\" if remote_function_options field is absent, not set otherwise."""  
    last_modified_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModifiedTime'), 'exclude': lambda f: f is None }})
    r"""Output only. The time when this routine was last modified, in milliseconds since the epoch."""  
    remote_function_options: Optional[shared_remotefunctionoptions.RemoteFunctionOptions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('remoteFunctionOptions'), 'exclude': lambda f: f is None }})
    r"""Options for a remote user-defined function."""  
    return_table_type: Optional[shared_standardsqltabletype.StandardSQLTableType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('returnTableType'), 'exclude': lambda f: f is None }})
    r"""A table type"""  
    return_type: Optional[shared_standardsqldatatype.StandardSQLDataType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('returnType'), 'exclude': lambda f: f is None }})
    r"""The data type of a variable such as a function argument. Examples include: * INT64: `{\\"typeKind\\": \\"INT64\\"}` * ARRAY: { \\"typeKind\\": \\"ARRAY\\", \\"arrayElementType\\": {\\"typeKind\\": \\"STRING\\"} } * STRUCT>: { \\"typeKind\\": \\"STRUCT\\", \\"structType\\": { \\"fields\\": [ { \\"name\\": \\"x\\", \\"type\\": {\\"typeKind\\": \\"STRING\\"} }, { \\"name\\": \\"y\\", \\"type\\": { \\"typeKind\\": \\"ARRAY\\", \\"arrayElementType\\": {\\"typeKind\\": \\"DATE\\"} } } ] } }"""  
    routine_reference: Optional[shared_routinereference.RoutineReference] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('routineReference'), 'exclude': lambda f: f is None }})  
    routine_type: Optional[RoutineRoutineTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('routineType'), 'exclude': lambda f: f is None }})
    r"""Required. The type of routine."""  
    spark_options: Optional[shared_sparkoptions.SparkOptions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sparkOptions'), 'exclude': lambda f: f is None }})
    r"""Options for a user-defined Spark routine."""  
    strict_mode: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('strictMode'), 'exclude': lambda f: f is None }})
    r"""Optional. Can be set for procedures only. If true (default), the definition body will be validated in the creation and the updates of the procedure. For procedures with an argument of ANY TYPE, the definition body validtion is not supported at creation/update time, and thus this field must be set to false explicitly."""  
    