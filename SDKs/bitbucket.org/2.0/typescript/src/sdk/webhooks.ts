/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Webhooks provide a way to configure Bitbucket Cloud to make requests to
 *
 * @remarks
 * your server (or another external service) whenever certain events occur in
 * Bitbucket Cloud.
 *
 * A webhook consists of:
 *
 * * A subject -- The resource that generates the events. Currently, this resource
 * is the repository, user account, or team where you create the webhook.
 * * One or more event -- The default event is a repository push, but you can
 * select multiple events that can trigger the webhook.
 * * A URL -- The endpoint where you want Bitbucket to send the event payloads
 * when a matching event happens.
 *
 * There are two parts to getting a webhook to work: creating the webhook and
 * triggering the webhook. After you create a webhook for an event, every time
 * that event occurs, Bitbucket sends a payload request that describes the event
 * to the specified URL. Thus, you can think of webhooks as a kind of
 * notification system.
 *
 * Use webhooks to integrate applications with Bitbucket Cloud. The following
 * use cases provides examples of when you would want to use webhooks:
 *
 * * Every time a user pushes commits in a repository, you may want to notify
 * your CI server to start a build.
 * * Every time a user pushes commits or creates a pull request, you may want to
 * display a notification in your application.
 *
 */
export class Webhooks {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a webhook for a repository
   *
   * @remarks
   * Deletes the specified webhook subscription from the given
   * repository.
   */
  deleteRepositoriesWorkspaceRepoSlugHooksUid(
    req: operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidRequest,
    security: operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidResponse =
        new operations.DeleteRepositoriesWorkspaceRepoSlugHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a webhook for a workspace
   *
   * @remarks
   * Deletes the specified webhook subscription from the given workspace.
   */
  deleteWorkspacesWorkspaceHooksUid(
    req: operations.DeleteWorkspacesWorkspaceHooksUidRequest,
    security: operations.DeleteWorkspacesWorkspaceHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteWorkspacesWorkspaceHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteWorkspacesWorkspaceHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteWorkspacesWorkspaceHooksUidSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteWorkspacesWorkspaceHooksUidResponse =
        new operations.DeleteWorkspacesWorkspaceHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a webhook resource
   *
   * @remarks
   * Returns the webhook resource or subject types on which webhooks can
   * be registered.
   *
   * Each resource/subject type contains an `events` link that returns the
   * paginated list of specific events each individual subject type can
   * emit.
   *
   * This endpoint is publicly accessible and does not require
   * authentication or scopes.
   *
   * Example:
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/hook_events
   *
   * {
   *     "repository": {
   *         "links": {
   *             "events": {
   *                 "href": "https://api.bitbucket.org/2.0/hook_events/repository"
   *             }
   *         }
   *     },
   *     "workspace": {
   *         "links": {
   *             "events": {
   *                 "href": "https://api.bitbucket.org/2.0/hook_events/workspace"
   *             }
   *         }
   *     }
   * }
   * ```
   */
  getHookEvents(
    config?: AxiosRequestConfig
  ): Promise<operations.GetHookEventsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/hook_events";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHookEventsResponse =
        new operations.GetHookEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.subjectTypes = utils.objectToClass(
              httpRes?.data,
              shared.SubjectTypes
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List subscribable webhook types
   *
   * @remarks
   * Returns a paginated list of all valid webhook events for the
   * specified entity.
   * **The team and user webhooks are deprecated, and you should use workspace instead.
   * For more information, see [the announcement](https://developer.atlassian.com/cloud/bitbucket/bitbucket-api-teams-deprecation/).**
   *
   * This is public data that does not require any scopes or authentication.
   *
   * Example:
   *
   * NOTE: The following example is a truncated response object for the `workspace` `subject_type`.
   * We return the same structure for the other `subject_type` objects.
   *
   * ```
   * $ curl https://api.bitbucket.org/2.0/hook_events/workspace
   * {
   *     "page": 1,
   *     "pagelen": 30,
   *     "size": 21,
   *     "values": [
   *         {
   *             "category": "Repository",
   *             "description": "Whenever a repository push occurs",
   *             "event": "repo:push",
   *             "label": "Push"
   *         },
   *         {
   *             "category": "Repository",
   *             "description": "Whenever a repository fork occurs",
   *             "event": "repo:fork",
   *             "label": "Fork"
   *         },
   *         {
   *             "category": "Repository",
   *             "description": "Whenever a repository import occurs",
   *             "event": "repo:imported",
   *             "label": "Import"
   *         },
   *         ...
   *         {
   *             "category":"Pull Request",
   *             "label":"Approved",
   *             "description":"When someone has approved a pull request",
   *             "event":"pullrequest:approved"
   *         },
   *     ]
   * }
   * ```
   */
  getHookEventsSubjectType(
    req: operations.GetHookEventsSubjectTypeRequest,
    security: operations.GetHookEventsSubjectTypeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetHookEventsSubjectTypeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetHookEventsSubjectTypeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/hook_events/{subject_type}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetHookEventsSubjectTypeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetHookEventsSubjectTypeResponse =
        new operations.GetHookEventsSubjectTypeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedHookEvents = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedHookEvents
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List webhooks for a repository
   *
   * @remarks
   * Returns a paginated list of webhooks installed on this repository.
   */
  getRepositoriesWorkspaceRepoSlugHooks(
    req: operations.GetRepositoriesWorkspaceRepoSlugHooksRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugHooksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugHooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugHooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/hooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetRepositoriesWorkspaceRepoSlugHooksSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugHooksResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugHooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWebhookSubscriptions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWebhookSubscriptions
            );
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a webhook for a repository
   *
   * @remarks
   * Returns the webhook with the specified id installed on the specified
   * repository.
   */
  getRepositoriesWorkspaceRepoSlugHooksUid(
    req: operations.GetRepositoriesWorkspaceRepoSlugHooksUidRequest,
    security: operations.GetRepositoriesWorkspaceRepoSlugHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRepositoriesWorkspaceRepoSlugHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRepositoriesWorkspaceRepoSlugHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.GetRepositoriesWorkspaceRepoSlugHooksUidSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRepositoriesWorkspaceRepoSlugHooksUidResponse =
        new operations.GetRepositoriesWorkspaceRepoSlugHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List webhooks for a workspace
   *
   * @remarks
   * Returns a paginated list of webhooks installed on this workspace.
   */
  getWorkspacesWorkspaceHooks(
    req: operations.GetWorkspacesWorkspaceHooksRequest,
    security: operations.GetWorkspacesWorkspaceHooksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceHooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceHooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceHooksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceHooksResponse =
        new operations.GetWorkspacesWorkspaceHooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.paginatedWebhookSubscriptions = utils.objectToClass(
              httpRes?.data,
              shared.PaginatedWebhookSubscriptions
            );
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a webhook for a workspace
   *
   * @remarks
   * Returns the webhook with the specified id installed on the given
   * workspace.
   */
  getWorkspacesWorkspaceHooksUid(
    req: operations.GetWorkspacesWorkspaceHooksUidRequest,
    security: operations.GetWorkspacesWorkspaceHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetWorkspacesWorkspaceHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetWorkspacesWorkspaceHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetWorkspacesWorkspaceHooksUidSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetWorkspacesWorkspaceHooksUidResponse =
        new operations.GetWorkspacesWorkspaceHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a webhook for a repository
   *
   * @remarks
   * Creates a new webhook on the specified repository.
   *
   * Example:
   *
   * ```
   * $ curl -X POST -u credentials -H 'Content-Type: application/json'
   *   https://api.bitbucket.org/2.0/repositories/my-workspace/my-repo-slug/hooks
   *   -d '
   *     {
   *       "description": "Webhook Description",
   *       "url": "https://example.com/",
   *       "active": true,
   *       "events": [
   *         "repo:push",
   *         "issue:created",
   *         "issue:updated"
   *       ]
   *     }'
   * ```
   *
   * Note that this call requires the webhook scope, as well as any scope
   * that applies to the events that the webhook subscribes to. In the
   * example above that means: `webhook`, `repository` and `issue`.
   *
   * Also note that the `url` must properly resolve and cannot be an
   * internal, non-routed address.
   */
  postRepositoriesWorkspaceRepoSlugHooks(
    req: operations.PostRepositoriesWorkspaceRepoSlugHooksRequest,
    security: operations.PostRepositoriesWorkspaceRepoSlugHooksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRepositoriesWorkspaceRepoSlugHooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRepositoriesWorkspaceRepoSlugHooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/hooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostRepositoriesWorkspaceRepoSlugHooksSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRepositoriesWorkspaceRepoSlugHooksResponse =
        new operations.PostRepositoriesWorkspaceRepoSlugHooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a webhook for a workspace
   *
   * @remarks
   * Creates a new webhook on the specified workspace.
   *
   * Workspace webhooks are fired for events from all repositories contained
   * by that workspace.
   *
   * Example:
   *
   * ```
   * $ curl -X POST -u credentials -H 'Content-Type: application/json'
   *   https://api.bitbucket.org/2.0/workspaces/my-workspace/hooks
   *   -d '
   *     {
   *       "description": "Webhook Description",
   *       "url": "https://example.com/",
   *       "active": true,
   *       "events": [
   *         "repo:push",
   *         "issue:created",
   *         "issue:updated"
   *       ]
   *     }'
   * ```
   *
   * This call requires the webhook scope, as well as any scope
   * that applies to the events that the webhook subscribes to. In the
   * example above that means: `webhook`, `repository` and `issue`.
   *
   * The `url` must properly resolve and cannot be an internal, non-routed address.
   *
   * Only workspace owners can install webhooks on workspaces.
   */
  postWorkspacesWorkspaceHooks(
    req: operations.PostWorkspacesWorkspaceHooksRequest,
    security: operations.PostWorkspacesWorkspaceHooksSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostWorkspacesWorkspaceHooksResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostWorkspacesWorkspaceHooksRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostWorkspacesWorkspaceHooksSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostWorkspacesWorkspaceHooksResponse =
        new operations.PostWorkspacesWorkspaceHooksResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a webhook for a repository
   *
   * @remarks
   * Updates the specified webhook subscription.
   *
   * The following properties can be mutated:
   *
   * * `description`
   * * `url`
   * * `active`
   * * `events`
   */
  putRepositoriesWorkspaceRepoSlugHooksUid(
    req: operations.PutRepositoriesWorkspaceRepoSlugHooksUidRequest,
    security: operations.PutRepositoriesWorkspaceRepoSlugHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRepositoriesWorkspaceRepoSlugHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRepositoriesWorkspaceRepoSlugHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repositories/{workspace}/{repo_slug}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.PutRepositoriesWorkspaceRepoSlugHooksUidSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRepositoriesWorkspaceRepoSlugHooksUidResponse =
        new operations.PutRepositoriesWorkspaceRepoSlugHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a webhook for a workspace
   *
   * @remarks
   * Updates the specified webhook subscription.
   *
   * The following properties can be mutated:
   *
   * * `description`
   * * `url`
   * * `active`
   * * `events`
   */
  putWorkspacesWorkspaceHooksUid(
    req: operations.PutWorkspacesWorkspaceHooksUidRequest,
    security: operations.PutWorkspacesWorkspaceHooksUidSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PutWorkspacesWorkspaceHooksUidResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutWorkspacesWorkspaceHooksUidRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/workspaces/{workspace}/hooks/{uid}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PutWorkspacesWorkspaceHooksUidSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "put",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutWorkspacesWorkspaceHooksUidResponse =
        new operations.PutWorkspacesWorkspaceHooksUidResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.webhookSubscription = utils.objectToClass(httpRes?.data);
          }
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }
}
