"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import connectordoc as shared_connectordoc
from ..shared import connectorevent as shared_connectorevent
from ..shared import connectorsetting as shared_connectorsetting
from ..shared import connectorstatus_enum as shared_connectorstatus_enum
from ..shared import linkedconnectorresource as shared_linkedconnectorresource
from ..shared import unifiedapiid_enum as shared_unifiedapiid_enum
from ..shared import webhooksupport as shared_webhooksupport
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class ConnectorAuthTypeEnum(str, Enum):
    r"""Type of authorization used by the connector"""
    OAUTH2 = 'oauth2'
    API_KEY = 'apiKey'
    BASIC = 'basic'
    CUSTOM = 'custom'
    NONE = 'none'

class ConnectorOauthCredentialsSourceEnum(str, Enum):
    r"""Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault."""
    INTEGRATION = 'integration'
    CONNECTION = 'connection'

class ConnectorOauthGrantTypeEnum(str, Enum):
    r"""OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types"""
    AUTHORIZATION_CODE = 'authorization_code'
    CLIENT_CREDENTIALS = 'client_credentials'
    PASSWORD = 'password'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ConnectorOauthScopes:
    
    default_apis: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('default_apis'), 'exclude': lambda f: f is None }})
    r"""List of Unified APIs that request this OAuth Scope by default. Application owners can customize the requested scopes."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of the OAuth scope."""  
    label: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label'), 'exclude': lambda f: f is None }})
    r"""Label of the OAuth scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ConnectorTLSSupport:
    
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""Description of the TLS support"""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ConnectorUnifiedApisOauthScopes:
    r"""OAuth scopes required for the connector. Add these scopes to your OAuth app."""
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of the OAuth scope."""  
    label: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('label'), 'exclude': lambda f: f is None }})
    r"""Label of the OAuth scope."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ConnectorUnifiedApis:
    
    downstream_unsupported_resources: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('downstream_unsupported_resources'), 'exclude': lambda f: f is None }})
    r"""List of resources that are not supported on the downstream."""  
    id: Optional[shared_unifiedapiid_enum.UnifiedAPIIDEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Name of Apideck Unified API"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Name of the API."""  
    oauth_scopes: Optional[list[ConnectorUnifiedApisOauthScopes]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oauth_scopes'), 'exclude': lambda f: f is None }})  
    supported_events: Optional[list[shared_connectorevent.ConnectorEvent]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('supported_events'), 'exclude': lambda f: f is None }})
    r"""List of events that are supported on the connector for this Unified API."""  
    supported_resources: Optional[list[shared_linkedconnectorresource.LinkedConnectorResource]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('supported_resources'), 'exclude': lambda f: f is None }})
    r"""List of resources that are supported on the connector."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Connector:
    
    auth_only: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auth_only'), 'exclude': lambda f: f is None }})
    r"""Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API"""  
    auth_type: Optional[ConnectorAuthTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auth_type'), 'exclude': lambda f: f is None }})
    r"""Type of authorization used by the connector"""  
    blind_mapped: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('blind_mapped'), 'exclude': lambda f: f is None }})
    r"""Set to `true` when connector was implemented from downstream docs only and without API access. This state indicates that integration will require Apideck support, and access to downstream API to validate mapping quality."""  
    configurable_resources: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('configurable_resources'), 'exclude': lambda f: f is None }})
    r"""List of resources that have settings that can be configured."""  
    custom_scopes: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom_scopes'), 'exclude': lambda f: f is None }})
    r"""Set to `true` when connector allows the definition of custom scopes."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""A description of the object."""  
    docs: Optional[list[shared_connectordoc.ConnectorDoc]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('docs'), 'exclude': lambda f: f is None }})  
    free_trial_available: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('free_trial_available'), 'exclude': lambda f: f is None }})
    r"""Set to `true` when the connector offers a free trial. Use `signup_url` to sign up for a free trial"""  
    has_sandbox_credentials: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('has_sandbox_credentials'), 'exclude': lambda f: f is None }})
    r"""Indicates whether Apideck Sandbox OAuth credentials are available."""  
    icon_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('icon_url'), 'exclude': lambda f: f is None }})
    r"""Link to a small square icon for the connector."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""ID of the connector."""  
    logo_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('logo_url'), 'exclude': lambda f: f is None }})
    r"""Link to the full logo for the connector."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Name of the connector."""  
    oauth_credentials_source: Optional[ConnectorOauthCredentialsSourceEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oauth_credentials_source'), 'exclude': lambda f: f is None }})
    r"""Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault."""  
    oauth_grant_type: Optional[ConnectorOauthGrantTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oauth_grant_type'), 'exclude': lambda f: f is None }})
    r"""OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types"""  
    oauth_scopes: Optional[list[ConnectorOauthScopes]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('oauth_scopes'), 'exclude': lambda f: f is None }})
    r"""List of OAuth Scopes available for this connector."""  
    service_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('service_id'), 'exclude': lambda f: f is None }})
    r"""Service provider identifier"""  
    settings: Optional[list[shared_connectorsetting.ConnectorSetting]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('settings'), 'exclude': lambda f: f is None }})  
    signup_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('signup_url'), 'exclude': lambda f: f is None }})
    r"""Link to the connector's signup page."""  
    status: Optional[shared_connectorstatus_enum.ConnectorStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""Status of the connector. Connectors with status live or beta are callable."""  
    supported_events: Optional[list[shared_connectorevent.ConnectorEvent]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('supported_events'), 'exclude': lambda f: f is None }})
    r"""List of events that are supported on the connector across all Unified APIs."""  
    supported_resources: Optional[list[shared_linkedconnectorresource.LinkedConnectorResource]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('supported_resources'), 'exclude': lambda f: f is None }})
    r"""List of resources that are supported on the connector."""  
    tls_support: Optional[ConnectorTLSSupport] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tls_support'), 'exclude': lambda f: f is None }})  
    unified_apis: Optional[list[ConnectorUnifiedApis]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('unified_apis'), 'exclude': lambda f: f is None }})
    r"""List of Unified APIs that feature this connector."""  
    webhook_support: Optional[shared_webhooksupport.WebhookSupport] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('webhook_support'), 'exclude': lambda f: f is None }})
    r"""How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling."""  
    website_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('website_url'), 'exclude': lambda f: f is None }})
    r"""Link to the connector's website."""  
    