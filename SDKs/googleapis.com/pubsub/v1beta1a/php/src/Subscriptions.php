<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Subscriptions 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Acknowledges a particular received message: the Pub/Sub system can remove the given message from the subscription. Acknowledging a message whose Ack deadline has expired may succeed, but the message could have been already redelivered. Acknowledging a message more than once will not result in an error. This is only used for messages received via pull.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeResponse
     */
	public function pubsubSubscriptionsAcknowledge(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/acknowledge');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "acknowledgeRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsAcknowledgeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Creates a subscription on a given topic for a given subscriber. If the subscription already exists, returns ALREADY_EXISTS. If the corresponding topic doesn't exist, returns NOT_FOUND. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateResponse
     */
	public function pubsubSubscriptionsCreate(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "subscription", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->subscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Subscription', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to Pull after deletion will return NOT_FOUND.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteResponse
     */
	public function pubsubSubscriptionsDelete(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/{subscription}', \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Gets the configuration details of a subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetResponse
     */
	public function pubsubSubscriptionsGet(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/{subscription}', \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsGetResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->subscription = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Subscription', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Lists matching subscriptions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListResponse
     */
	public function pubsubSubscriptionsList(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->listSubscriptionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ListSubscriptionsResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modifies the Ack deadline for a message received from a pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineResponse
     */
	public function pubsubSubscriptionsModifyAckDeadline(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/modifyAckDeadline');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "modifyAckDeadlineRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyAckDeadlineResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Modifies the PushConfig for a specified subscription. This method can be used to suspend the flow of messages to an endpoint by clearing the PushConfig field in the request. Messages will be accumulated for delivery even if no push configuration is defined or while the configuration is modified.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigResponse
     */
	public function pubsubSubscriptionsModifyPushConfig(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/modifyPushConfig');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "modifyPushConfigRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsModifyPushConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->empty = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Pulls a single message from the server. If return_immediately is true, and no messages are available in the subscription, this method returns FAILED_PRECONDITION. The system is free to return an UNAVAILABLE error if no messages are available in a reasonable amount of time (to reduce system load).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullResponse
     */
	public function pubsubSubscriptionsPull(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/pull');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "pullRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PullResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The system is free to return UNAVAILABLE if there are too many pull requests outstanding for the given subscription.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchResponse
     */
	public function pubsubSubscriptionsPullBatch(
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1beta1a/subscriptions/pullBatch');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "pullBatchRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PubsubSubscriptionsPullBatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullBatchResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PullBatchResponse', 'json');
            }
        }

        return $response;
    }
}