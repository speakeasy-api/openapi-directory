"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Admin:
    r"""Administrative, system management."""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def anonymize(self, request: operations.AnonymizeRequest) -> operations.AnonymizeResponse:
        r"""Activate/deactivate anonymization for a source."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.AnonymizeRequest, base_url, '/api2/json/anonymize/{source}/{anonymized}/{token}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AnonymizeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIKeyOut])
                res.api_key_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def api_key_info(self) -> operations.APIKeyInfoResponse:
        r"""Read API Key info."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/apiKeyInfo'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.APIKeyInfoResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIKeyOut])
                res.api_key_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def api_status(self) -> operations.APIStatusResponse:
        r"""Prints the current status of the classifiers. A classifier name in apiStatus corresponds to a service name in apiServices."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/apiStatus'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.APIStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIClassifiersStatusOut])
                res.api_classifiers_status_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def api_usage(self) -> operations.APIUsageResponse:
        r"""Print current API usage."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/apiUsage'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.APIUsageResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIPeriodUsageOut])
                res.api_period_usage_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def api_usage_history(self) -> operations.APIUsageHistoryResponse:
        r"""Print historical API usage."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/apiUsageHistory'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.APIUsageHistoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIUsageHistoryOut])
                res.api_usage_history_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def api_usage_history_aggregate(self) -> operations.APIUsageHistoryAggregateResponse:
        r"""Print historical API usage (in an aggregated view, by service, by day/hour/min)."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/apiUsageHistoryAggregate'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.APIUsageHistoryAggregateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIUsageAggregatedOut])
                res.api_usage_aggregated_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def available_services(self) -> operations.AvailableServicesResponse:
        r"""List of classification services and usage cost in Units per classification (default is 1=ONE Unit). Some API endpoints (ex. Corridor) combine multiple classifiers."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/apiServices'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AvailableServicesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIServicesOut])
                res.api_services_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def learnable(self, request: operations.LearnableRequest) -> operations.LearnableResponse:
        r"""Activate/deactivate learning from a source."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LearnableRequest, base_url, '/api2/json/learnable/{source}/{learnable}/{token}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LearnableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIKeyOut])
                res.api_key_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def regions(self) -> operations.RegionsResponse:
        r"""Print basic source statistics."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/regions'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.RegionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RegionOut])
                res.region_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def software_version(self) -> operations.SoftwareVersionResponse:
        r"""Get the current software version"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/api2/json/softwareVersion'
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SoftwareVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SoftwareVersionOut])
                res.software_version_out = out
        elif http_res.status_code == 401:
            pass

        return res

    def taxonomy_classes(self, request: operations.TaxonomyClassesRequest) -> operations.TaxonomyClassesResponse:
        r"""Print the taxonomy classes valid for the given classifier."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.TaxonomyClassesRequest, base_url, '/api2/json/taxonomyClasses/{classifierName}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.TaxonomyClassesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.APIClassifierTaxonomyOut])
                res.api_classifier_taxonomy_out = out
        elif http_res.status_code == 401:
            pass

        return res

    