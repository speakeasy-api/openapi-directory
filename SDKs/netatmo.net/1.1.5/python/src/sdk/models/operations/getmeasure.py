"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import nameasureresponse as shared_nameasureresponse
from enum import Enum
from typing import Optional


@dataclasses.dataclass
class GetmeasureSecurity:
    
    code_oauth: Optional[str] = dataclasses.field(default=None, metadata={'security': { 'scheme': True, 'type': 'oauth2', 'field_name': 'Authorization' }})  
    password_oauth: Optional[str] = dataclasses.field(default=None, metadata={'security': { 'scheme': True, 'type': 'oauth2', 'field_name': 'Authorization' }})  
    
class GetmeasureScaleEnum(str, Enum):
    r"""Defines the time interval between two measurements.
    Possible values :
    max -> every value stored will be returned
    30min -> 1 value every 30 minutes
    1hour -> 1 value every hour
    3hours -> 1 value every 3 hours
    1day -> 1 value per day
    1week -> 1 value per week
    1month -> 1 value per month
    """
    MAX = 'max'
    THIRTYMIN = '30min'
    ONEHOUR = '1hour'
    THREEHOURS = '3hours'
    ONEDAY = '1day'
    ONEWEEK = '1week'
    ONEMONTH = '1month'

class GetmeasureTypeEnum(str, Enum):
    TEMPERATURE = 'Temperature'
    CO2 = 'CO2'
    HUMIDITY = 'Humidity'
    PRESSURE = 'Pressure'
    NOISE = 'Noise'
    RAIN = 'Rain'
    WIND_STRENGTH = 'WindStrength'
    WIND_ANGLE = 'WindAngle'
    GUSTSTRENGTH = 'Guststrength'
    GUST_ANGLE = 'GustAngle'
    SP_TEMPERATURE = 'Sp_Temperature'
    BOILER_ON = 'BoilerOn'
    BOILER_OFF = 'BoilerOff'
    MIN_TEMP = 'min_temp'
    DATE_MIN_TEMP = 'date_min_temp'
    MAX_TEMP = 'max_temp'
    DATE_MAX_TEMP = 'date_max_temp'
    MIN_HUM = 'min_hum'
    DATE_MIN_HUM = 'date_min_hum'
    MAX_HUM = 'max_hum'
    DATE_MAX_HUM = 'date_max_hum'
    MIN_PRESSURE = 'min_pressure'
    DATE_MIN_PRESSURE = 'date_min_pressure'
    MAX_PRESSURE = 'max_pressure'
    DATE_MAX_PRESSURE = 'date_max_pressure'
    MIN_NOISE = 'min_noise'
    DATE_MIN_NOISE = 'date_min_noise'
    MAX_NOISE = 'max_noise'
    DATE_MAX_NOISE = 'date_max_noise'
    DATE_MIN_CO2 = 'date_min_co2'
    DATE_MAX_CO2 = 'date_max_co2'
    DATE_MAX_GUST = 'date_max_gust'
    SUM_RAIN = 'sum_rain'
    SUM_BOILER_ON = 'sum_boiler_on'
    SUM_BOILER_OFF = 'sum_boiler_off'


@dataclasses.dataclass
class GetmeasureRequest:
    
    device_id: str = dataclasses.field(metadata={'query_param': { 'field_name': 'device_id', 'style': 'form', 'explode': True }})
    r"""Id of the device whose module's measurements you want to retrieve. This _id can be found in the user's devices field."""  
    scale: GetmeasureScaleEnum = dataclasses.field(metadata={'query_param': { 'field_name': 'scale', 'style': 'form', 'explode': True }})
    r"""Defines the time interval between two measurements.
    Possible values :
    max -> every value stored will be returned
    30min -> 1 value every 30 minutes
    1hour -> 1 value every hour
    3hours -> 1 value every 3 hours
    1day -> 1 value per day
    1week -> 1 value per week
    1month -> 1 value per month
    """  
    type: list[GetmeasureTypeEnum] = dataclasses.field(metadata={'query_param': { 'field_name': 'type', 'style': 'form', 'explode': False }})
    r"""Measures you are interested in. Data you can request depends on the scale.
    **For Weather Station:**
      * max -> Temperature (°C), CO2 (ppm), Humidity (%), Pressure (mbar), Noise (db), Rain (mm), WindStrength (km/h), WindAngle (angles), Guststrength (km/h), GustAngle (angles)
      * 30min, 1hour, 3hours -> Same as above + min_temp, max_temp, min_hum, max_hum, min_pressure, max_pressure, min_noise, max_noise, sum_rain, date_max_gust
      * 1day, 1week, 1month -> Same as above + date_min_temp, date_max_temp, date_min_hum, date_max_hum, date_min_pressure, date_max_pressure, date_min_noise, date_max_noise, date_min_co2, date_max_co2
    
    **For Thermostat:**
      * max -> temperature (°C), sp_temperature (°C), boileron (sec), boileroff (sec)
      * 30min, 1hour, 3hours -> temperature, sp_temperature, min_temp,
    max_temp, sum_boiler_on, sum_boiler_off
      * 1day, 1week, 1month -> temperature, min_temp, date_min_temp,
    max_temp, sum_boiler_on, sum_boiler_off
    """  
    date_begin: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'date_begin', 'style': 'form', 'explode': True }})
    r"""Starting timestamp (utc) of the requested measurements.
    Please note measurement retrieving is limited to 1024 measurements.
    """  
    date_end: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'date_end', 'style': 'form', 'explode': True }})
    r"""Ending timestamp (utc) of the request measurements.
    If you want only the last measurement, do not provide date_begin, and set date_end to `last`.
    """  
    limit: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'limit', 'style': 'form', 'explode': True }})
    r"""Limits the number of measurements returned (default & max is 1024)"""  
    module_id: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'module_id', 'style': 'form', 'explode': True }})
    r"""If you don't specify any module_id you will retrieve the device's measurements. If you specify a module_id you will retrieve the module's measurements."""  
    optimize: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'optimize', 'style': 'form', 'explode': True }})
    r"""Allows you to choose the format of the answer.
    If you build a mobile app and bandwith usage is an issue, use `optimize = true`.
    Use `optimize = false`, for an easier parse. In this case, values are indexed by sorted timestamp.
    Example of un-optimized response :
    ```json
    {\"status\": \"ok\", 
      \"body\": {
        \"1347575400\": [18.3,39],
        \"1347586200\": [20.6,48]
      },
    \"time_exec\": 0.012136936187744}
    ```
    If optimize is set true, measurements are returned as an array of series of regularly spaced measurements. Each series is defined by a beginning time beg_time and a step between measurements, step_time:
    ```json
    {\"status\": \"ok\",
      \"body\": [
        {\"beg_time\": 1347575400,
         \"step_time\": 10800,
         \"value\": 
            [[18.3,39],
            [ 20.6,48]]
        }],
    \"time_exec\": 0.014238119125366}
    ```
    Default value is `true`.
    """  
    real_time: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'real_time', 'style': 'form', 'explode': True }})
    r"""In scales higher than max, since the data is aggregated, the timestamps returned are by default offset by +(scale/2).
    For instance, if you ask for measurements at a daily scale, you will receive data timestamped at 12:00 if real_time is set to `false` (default case), and timestamped at 00:00 if real_time is set to `true`.
    NB : The servers always store data with real_time set to `true` and data are offset by this parameter AFTER having being time-filtered, thus you could have data after date_end if real_time is set to `false`.
    """  
    

@dataclasses.dataclass
class GetmeasureResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    na_measure_response: Optional[shared_nameasureresponse.NAMeasureResponse] = dataclasses.field(default=None)
    r"""Successful response"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    