<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Pullrequests 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Remove a user from the default reviewers
     * 
     * Removes a default reviewer from the repository.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unapprove a pull request
     * 
     * Redact the authenticated user's approval of the specified pull
     * request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprove(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a comment on a pull request
     * 
     * Deletes a specific pull request comment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentId(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reopen a comment thread
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolve(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove change request for a pull request
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesResponse
     */
	public function deleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChanges(
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes', \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List pull requests that contain a commit
     * 
     * Returns a paginated list of all pull requests as part of which this commit was reviewed. Pull Request Commit Links app must be installed first before using this API; installation automatically occurs when 'Go to pull request' is clicked from the web interface for a commit's details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitResponse
     */
	public function getPullrequestsForCommit(
        \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/commit/{commit}/pullrequests', \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsForCommitResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPullrequests = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPullrequests', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List pull requests for a user
     * 
     * Returns all pull requests authored by the specified user.
     * 
     * By default only open pull requests are returned. This can be controlled
     * using the `state` query parameter. To retrieve pull requests that are
     * in one of multiple states, repeat the `state` parameter for each
     * individual state.
     * 
     * This endpoint also supports filtering and sorting of the results. See
     * [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserResponse
     */
	public function getPullrequestsSelectedUser(
        \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/pullrequests/{selected_user}', \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPullrequestsSelectedUserResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPullrequests = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPullrequests', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List default reviewers
     * 
     * Returns the repository's default reviewers.
     * 
     * These are the users that are automatically added as reviewers on every
     * new pull request that is created. To obtain the repository's default reviewers
     * as well as the default reviewers inherited from the project, use the
     * [effective-default-reveiwers](#api-repositories-workspace-repo-slug-effective-default-reviewers-get) endpoint.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersResponse
     */
	public function getRepositoriesWorkspaceRepoSlugDefaultReviewers(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/default-reviewers', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedAccounts = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedAccounts', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a default reviewer
     * 
     * Returns the specified reviewer.
     * 
     * This can be used to test whether a user is among the repository's
     * default reviewers list. A 404 indicates that that specified user is not
     * a default reviewer.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse
     */
	public function getRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List effective default reviewers
     * 
     * Returns the repository's effective default reviewers. This includes both default
     * reviewers defined at the repository level as well as those inherited from its project.
     * 
     * These are the users that are automatically added as reviewers on every
     * new pull request that is created.
     * 
     * ```
     * $ curl https://api.bitbucket.org/2.0/repositories/{workspace_slug}/{repo_slug}/effective-default-reviewers?page=1&pagelen=20
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "user": {
     *                 "display_name": "Patrick Wolf",
     *                 "uuid": "{9565301a-a3cf-4b5d-88f4-dd6af8078d7e}"
     *             },
     *             "reviewer_type": "project",
     *             "type": "default_reviewer",
     *         },
     *         {
     *             "user": {
     *                 "display_name": "Davis Lee",
     *                 "uuid": "{f0e0e8e9-66c1-4b85-a784-44a9eb9ef1a6}"
     *             },
     *             "reviewer_type": "repository",
     *             "type": "default_reviewer",
     *         }
     *     ],
     *     "page": 1,
     *     "size": 2
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersResponse
     */
	public function getRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewers(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/effective-default-reviewers', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugEffectiveDefaultReviewersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedDefaultReviewerAndType = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedDefaultReviewerAndType', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List pull requests
     * 
     * Returns all pull requests on the specified repository.
     * 
     * By default only open pull requests are returned. This can be controlled
     * using the `state` query parameter. To retrieve pull requests that are
     * in one of multiple states, repeat the `state` parameter for each
     * individual state.
     * 
     * This endpoint also supports filtering and sorting of the results. See
     * [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequests(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPullrequests = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPullrequests', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List a pull request activity log
     * 
     * Returns a paginated list of the pull request's activity log.
     * 
     * This handler serves both a v20 and internal endpoint. The v20 endpoint
     * returns reviewer comments, updates, approvals and request changes. The internal
     * endpoint includes those plus tasks and attachments.
     * 
     * Comments created on a file or a line of code have an inline property.
     * 
     * Comment example:
     * ```
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "comment": {
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
     *                     }
     *                 },
     *                 "deleted": false,
     *                 "pullrequest": {
     *                     "type": "pullrequest",
     *                     "id": 5695,
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                         }
     *                     },
     *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *                 },
     *                 "content": {
     *                     "raw": "inline with to a dn from lines",
     *                     "markup": "markdown",
     *                     "html": "<p>inline with to a dn from lines</p>",
     *                     "type": "rendered"
     *                 },
     *                 "created_on": "2019-09-27T00:33:46.039178+00:00",
     *                 "user": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 },
     *                 "created_on": "2019-09-27T00:33:46.039178+00:00",
     *                 "user": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 },
     *                 "updated_on": "2019-09-27T00:33:46.055384+00:00",
     *                 "inline": {
     *                     "context_lines": "",
     *                     "to": null,
     *                     "path": "",
     *                     "outdated": false,
     *                     "from": 211
     *                 },
     *                 "type": "pullrequest_comment",
     *                 "id": 118571088
     *             },
     *             "pull_request": {
     *                 "type": "pullrequest",
     *                 "id": 5695,
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                     }
     *                 },
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *             }
     *         }
     *     ]
     * }
     * ```
     * 
     * Updates include a state property of OPEN, MERGED, or DECLINED.
     * 
     * Update example:
     * ```
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "update": {
     *                 "description": "",
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
     *                 "destination": {
     *                     "commit": {
     *                         "type": "commit",
     *                         "hash": "6a2c16e4a152",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
     *                             }
     *                         }
     *                     },
     *                     "branch": {
     *                         "name": "master"
     *                     },
     *                     "repository": {
     *                         "name": "Atlaskit-MK-2",
     *                         "type": "repository",
     *                         "full_name": "atlassian/atlaskit-mk-2",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
     *                             },
     *                             "avatar": {
     *                                 "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
     *                             }
     *                         },
     *                         "uuid": "{}"
     *                     }
     *                 },
     *                 "reason": "",
     *                 "source": {
     *                     "commit": {
     *                         "type": "commit",
     *                         "hash": "728c8bad1813",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
     *                             }
     *                         }
     *                     },
     *                     "branch": {
     *                         "name": "username/NONE-add-onClick-prop-for-accessibility"
     *                     },
     *                     "repository": {
     *                         "name": "Atlaskit-MK-2",
     *                         "type": "repository",
     *                         "full_name": "atlassian/atlaskit-mk-2",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
     *                             },
     *                             "avatar": {
     *                                 "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
     *                             }
     *                         },
     *                         "uuid": "{}"
     *                     }
     *                 },
     *                 "state": "OPEN",
     *                 "author": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 },
     *                 "date": "2019-05-10T06:48:25.305565+00:00"
     *             },
     *             "pull_request": {
     *                 "type": "pullrequest",
     *                 "id": 5695,
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                     }
     *                 },
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *             }
     *         }
     *     ]
     * }
     * ```
     * 
     * Approval example:
     * ```
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "approval": {
     *                 "date": "2019-09-27T00:37:19.849534+00:00",
     *                 "pullrequest": {
     *                     "type": "pullrequest",
     *                     "id": 5695,
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                         }
     *                     },
     *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *                 },
     *                 "user": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 }
     *             },
     *             "pull_request": {
     *                 "type": "pullrequest",
     *                 "id": 5695,
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                     }
     *                 },
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *             }
     *         }
     *     ]
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivityRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivitySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivityResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsActivity(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivityRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivitySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/activity', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivityRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsActivityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a pull request
     * 
     * Returns the specified pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequest = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List a pull request activity log
     * 
     * Returns a paginated list of the pull request's activity log.
     * 
     * This handler serves both a v20 and internal endpoint. The v20 endpoint
     * returns reviewer comments, updates, approvals and request changes. The internal
     * endpoint includes those plus tasks and attachments.
     * 
     * Comments created on a file or a line of code have an inline property.
     * 
     * Comment example:
     * ```
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "comment": {
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695/comments/118571088"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695/_/diff#comment-118571088"
     *                     }
     *                 },
     *                 "deleted": false,
     *                 "pullrequest": {
     *                     "type": "pullrequest",
     *                     "id": 5695,
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                         }
     *                     },
     *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *                 },
     *                 "content": {
     *                     "raw": "inline with to a dn from lines",
     *                     "markup": "markdown",
     *                     "html": "<p>inline with to a dn from lines</p>",
     *                     "type": "rendered"
     *                 },
     *                 "created_on": "2019-09-27T00:33:46.039178+00:00",
     *                 "user": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 },
     *                 "created_on": "2019-09-27T00:33:46.039178+00:00",
     *                 "user": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 },
     *                 "updated_on": "2019-09-27T00:33:46.055384+00:00",
     *                 "inline": {
     *                     "context_lines": "",
     *                     "to": null,
     *                     "path": "",
     *                     "outdated": false,
     *                     "from": 211
     *                 },
     *                 "type": "pullrequest_comment",
     *                 "id": 118571088
     *             },
     *             "pull_request": {
     *                 "type": "pullrequest",
     *                 "id": 5695,
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                     }
     *                 },
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *             }
     *         }
     *     ]
     * }
     * ```
     * 
     * Updates include a state property of OPEN, MERGED, or DECLINED.
     * 
     * Update example:
     * ```
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "update": {
     *                 "description": "",
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it",
     *                 "destination": {
     *                     "commit": {
     *                         "type": "commit",
     *                         "hash": "6a2c16e4a152",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/6a2c16e4a152"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/6a2c16e4a152"
     *                             }
     *                         }
     *                     },
     *                     "branch": {
     *                         "name": "master"
     *                     },
     *                     "repository": {
     *                         "name": "Atlaskit-MK-2",
     *                         "type": "repository",
     *                         "full_name": "atlassian/atlaskit-mk-2",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
     *                             },
     *                             "avatar": {
     *                                 "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
     *                             }
     *                         },
     *                         "uuid": "{}"
     *                     }
     *                 },
     *                 "reason": "",
     *                 "source": {
     *                     "commit": {
     *                         "type": "commit",
     *                         "hash": "728c8bad1813",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/commit/728c8bad1813"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/commits/728c8bad1813"
     *                             }
     *                         }
     *                     },
     *                     "branch": {
     *                         "name": "username/NONE-add-onClick-prop-for-accessibility"
     *                     },
     *                     "repository": {
     *                         "name": "Atlaskit-MK-2",
     *                         "type": "repository",
     *                         "full_name": "atlassian/atlaskit-mk-2",
     *                         "links": {
     *                             "self": {
     *                                 "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2"
     *                             },
     *                             "html": {
     *                                 "href": "https://bitbucket.org/atlassian/atlaskit-mk-2"
     *                             },
     *                             "avatar": {
     *                                 "href": "https://bytebucket.org/ravatar/%7B%7D?ts=js"
     *                             }
     *                         },
     *                         "uuid": "{}"
     *                     }
     *                 },
     *                 "state": "OPEN",
     *                 "author": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 },
     *                 "date": "2019-05-10T06:48:25.305565+00:00"
     *             },
     *             "pull_request": {
     *                 "type": "pullrequest",
     *                 "id": 5695,
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                     }
     *                 },
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *             }
     *         }
     *     ]
     * }
     * ```
     * 
     * Approval example:
     * ```
     * {
     *     "pagelen": 20,
     *     "values": [
     *         {
     *             "approval": {
     *                 "date": "2019-09-27T00:37:19.849534+00:00",
     *                 "pullrequest": {
     *                     "type": "pullrequest",
     *                     "id": 5695,
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                         }
     *                     },
     *                     "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *                 },
     *                 "user": {
     *                     "display_name": "Name Lastname",
     *                     "uuid": "{}",
     *                     "links": {
     *                         "self": {
     *                             "href": "https://api.bitbucket.org/2.0/users/%7B%7D"
     *                         },
     *                         "html": {
     *                             "href": "https://bitbucket.org/%7B%7D/"
     *                         },
     *                         "avatar": {
     *                             "href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/:/128"
     *                         }
     *                     },
     *                     "type": "user",
     *                     "nickname": "Name",
     *                     "account_id": ""
     *                 }
     *             },
     *             "pull_request": {
     *                 "type": "pullrequest",
     *                 "id": 5695,
     *                 "links": {
     *                     "self": {
     *                         "href": "https://api.bitbucket.org/2.0/repositories/atlassian/atlaskit-mk-2/pullrequests/5695"
     *                     },
     *                     "html": {
     *                         "href": "https://bitbucket.org/atlassian/atlaskit-mk-2/pull-requests/5695"
     *                     }
     *                 },
     *                 "title": "username/NONE: small change from onFocus to onClick to handle tabbing through the page and not expand the editor unless a click event triggers it"
     *             }
     *         }
     *     ]
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivitySecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivity(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivitySecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/activity', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdActivityResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List comments on a pull request
     * 
     * Returns a paginated list of the pull request's comments.
     * 
     * This includes both global, inline comments and replies.
     * 
     * The default sorting is oldest to newest and can be overridden with
     * the `sort` query parameter.
     * 
     * This endpoint also supports filtering and sorting of the results. See
     * [filtering and sorting](/cloud/bitbucket/rest/intro/#filtering) for more
     * details.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdComments(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedPullrequestComments = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedPullrequestComments', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a comment on a pull request
     * 
     * Returns a specific pull request comment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequestComment = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List commits on a pull request
     * 
     * Returns a paginated list of the pull request's commits.
     * 
     * These are the commits that are being merged into the destination
     * branch when the pull requests gets accepted.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommits(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/commits', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommitsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * List changes in a pull request
     * 
     * Redirects to the [repository diff](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diff-spec-get)
     * with the revspec that corresponds to the pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiff(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diff', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 302) {
        }

        return $response;
    }
	
    /**
     * Get the diff stat for a pull request
     * 
     * Redirects to the [repository diffstat](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-diffstat-spec-get)
     * with the revspec that corresponds to the pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstat(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diffstat', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDiffstatResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 302) {
        }

        return $response;
    }
	
    /**
     * Get the merge task status for a pull request
     * 
     * When merging a pull request takes too long, the client receives a
     * task ID along with a 202 status code. The task ID can be used in a call
     * to this endpoint to check the status of a merge task.
     * 
     * ```
     * curl -X GET https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>
     * ```
     * 
     * If the merge task is not yet finished, a PENDING status will be returned.
     * 
     * ```
     * HTTP/2 200
     * {
     *     "task_status": "PENDING",
     *     "links": {
     *         "self": {
     *             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
     *         }
     *     }
     * }
     * ```
     * 
     * If the merge was successful, a SUCCESS status will be returned.
     * 
     * ```
     * HTTP/2 200
     * {
     *     "task_status": "SUCCESS",
     *     "links": {
     *         "self": {
     *             "href": "https://api.bitbucket.org/2.0/repositories/atlassian/bitbucket/pullrequests/2286/merge/task-status/<task_id>"
     *         }
     *     },
     *     "merge_result": <the merged pull request object>
     * }
     * ```
     * 
     * If the merge task failed, an error will be returned.
     * 
     * ```
     * {
     *     "type": "error",
     *     "error": {
     *         "message": "<error message>"
     *     }
     * }
     * ```
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskId(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge/task-status/{task_id}', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeTaskStatusTaskIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403) {
        }

        return $response;
    }
	
    /**
     * Get the patch for a pull request
     * 
     * Redirects to the [repository patch](/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-patch-spec-get)
     * with the revspec that corresponds to pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatch(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/patch', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdPatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 302) {
        }

        return $response;
    }
	
    /**
     * List commit statuses for a pull request
     * 
     * Returns all statuses (e.g. build results) for the given pull
     * request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesResponse
     */
	public function getRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatuses(
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/statuses', \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdStatusesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->paginatedCommitstatuses = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PaginatedCommitstatuses', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401) {
        }
        else if ($httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a pull request
     * 
     * Creates a new pull request where the destination repository is
     * this repository and the author is the authenticated user.
     * 
     * The minimum required fields to create a pull request are `title` and
     * `source`, specified by a branch name.
     * 
     * ```
     * curl https://api.bitbucket.org/2.0/repositories/my-workspace/my-repository/pullrequests \
     *     -u my-username:my-password \
     *     --request POST \
     *     --header 'Content-Type: application/json' \
     *     --data '{
     *         "title": "My Title",
     *         "source": {
     *             "branch": {
     *                 "name": "staging"
     *             }
     *         }
     *     }'
     * ```
     * 
     * If the pull request's `destination` is not specified, it will default
     * to the `repository.mainbranch`. To open a pull request to a
     * different branch, say from a feature branch to a staging branch,
     * specify a `destination` (same format as the `source`):
     * 
     * ```
     * {
     *     "title": "My Title",
     *     "source": {
     *         "branch": {
     *             "name": "my-feature-branch"
     *         }
     *     },
     *     "destination": {
     *         "branch": {
     *             "name": "staging"
     *         }
     *     }
     * }
     * ```
     * 
     * Reviewers can be specified by adding an array of user objects as the
     * `reviewers` property.
     * 
     * ```
     * {
     *     "title": "My Title",
     *     "source": {
     *         "branch": {
     *             "name": "my-feature-branch"
     *         }
     *     },
     *     "reviewers": [
     *         {
     *             "uuid": "{504c3b62-8120-4f0c-a7bc-87800b9d6f70}"
     *         }
     *     ]
     * }
     * ```
     * 
     * Other fields:
     * 
     * * `description` - a string
     * * `close_source_branch` - boolean that specifies if the source branch should be closed upon merging
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequests(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequest = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Approve a pull request
     * 
     * Approve the specified pull request as the authenticated user.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApprove(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/approve', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdApproveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->participant = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a comment on a pull request
     * 
     * Creates a new pull request comment.
     * 
     * Returns the newly created pull request comment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdComments(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequestComment = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Resolve a comment thread
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolve(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}/resolve', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResolveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->commentResolution = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 409) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Decline a pull request
     * 
     * Declines the pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDecline(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/decline', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdDeclineResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequest = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 555) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Merge a pull request
     * 
     * Merges the pull request.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMerge(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/merge', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdMergeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequest = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 202) {
        }
        else if ($httpResponse->getStatusCode() === 555) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request changes for a pull request
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesResponse
     */
	public function postRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChanges(
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/request-changes', \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequestChangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->participant = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add a user to the default reviewers
     * 
     * Adds the specified user to the repository's list of default
     * reviewers.
     * 
     * This method is idempotent. Adding a user a second time has no effect.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse
     */
	public function putRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsername(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/default-reviewers/{target_username}', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugDefaultReviewersTargetUsernameResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->account = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a pull request
     * 
     * Mutates the specified pull request.
     * 
     * This can be used to change the pull request's branches or description.
     * 
     * Only open pull requests can be mutated.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdResponse
     */
	public function putRepositoriesWorkspaceRepoSlugPullrequestsPullRequestId(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequest = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a comment on a pull request
     * 
     * Updates a specific pull request comment.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse
     */
	public function putRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentId(
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PutRepositoriesWorkspaceRepoSlugPullrequestsPullRequestIdCommentsCommentIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pullrequestComment = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->error = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
}