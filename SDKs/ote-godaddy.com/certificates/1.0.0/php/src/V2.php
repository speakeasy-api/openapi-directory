<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class V2 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Retrieves the external account binding for the specified customer
     * 
     * Use this endpoint to retrieve a key identifier and Hash-based Message Authentication Code (HMAC) key for Automated Certificate Management Environment (ACME) External Account Binding (EAB). These credentials can be used with an ACME client that supports EAB (ex. CertBot) to automate the issuance request and deployment of DV SSL certificates
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAcmeExternalAccountBindingRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAcmeExternalAccountBindingResponse
     */
	public function getAcmeExternalAccountBinding(
        \OpenAPI\OpenAPI\Models\Operations\GetAcmeExternalAccountBindingRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAcmeExternalAccountBindingResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/customers/{customerId}/certificates/acme/externalAccountBinding', \OpenAPI\OpenAPI\Models\Operations\GetAcmeExternalAccountBindingRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAcmeExternalAccountBindingResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->externalAccountBinding = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExternalAccountBinding', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Retrieve individual certificate details
     * 
     * Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate. <ul><li>**shopperId** is **not the same** as **customerId**. **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCertificateDetailByCertIdentifierRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCertificateDetailByCertIdentifierResponse
     */
	public function getCertificateDetailByCertIdentifier(
        \OpenAPI\OpenAPI\Models\Operations\GetCertificateDetailByCertIdentifierRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCertificateDetailByCertIdentifierResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/customers/{customerId}/certificates/{certificateId}', \OpenAPI\OpenAPI\Models\Operations\GetCertificateDetailByCertIdentifierRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCertificateDetailByCertIdentifierResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateDetailV2 = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateDetailV2', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Retrieve customer's certificates
     * 
     * This method can be used to retrieve a list of certificates for a specified customer. <ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdResponse
     */
	public function getCustomerCertificatesByCustomerId(
        \OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/customers/{customerId}/certificates', \OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCustomerCertificatesByCustomerIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->certificateSummariesV2 = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CertificateSummariesV2', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Retrieve detailed information for supplied domain
     * 
     * Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. <ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetDomainDetailsByDomainRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDomainDetailsByDomainResponse
     */
	public function getDomainDetailsByDomain(
        \OpenAPI\OpenAPI\Models\Operations\GetDomainDetailsByDomainRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetDomainDetailsByDomainResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/customers/{customerId}/certificates/{certificateId}/domainVerifications/{domain}', \OpenAPI\OpenAPI\Models\Operations\GetDomainDetailsByDomainRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDomainDetailsByDomainResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->domainVerificationDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DomainVerificationDetail', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Retrieve domain verification status
     * 
     * This method can be used to retrieve the domain verification status for a certificate request.<ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>"
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetDomainInformationByCertificateIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDomainInformationByCertificateIdResponse
     */
	public function getDomainInformationByCertificateId(
        \OpenAPI\OpenAPI\Models\Operations\GetDomainInformationByCertificateIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetDomainInformationByCertificateIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v2/customers/{customerId}/certificates/{certificateId}/domainVerifications', \OpenAPI\OpenAPI\Models\Operations\GetDomainInformationByCertificateIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDomainInformationByCertificateIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->domainVerificationSummaries = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\DomainVerificationSummary>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 422 or $httpResponse->getStatusCode() === 429 or $httpResponse->getStatusCode() === 500) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
}