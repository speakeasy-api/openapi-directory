"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from datetime import date, datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclasses.dataclass
class RecordingsListSecurity:
    
    o_auth: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'oauth2', 'field_name': 'Authorization' }})  
    

@dataclasses.dataclass
class RecordingsListRequest:
    
    user_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'userId', 'style': 'simple', 'explode': False }})
    r"""The user ID or email address of the user. For user-level apps, pass `me` as the value for userId."""  
    from_: Optional[date] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'from', 'style': 'form', 'explode': True }})
    r"""The start date in 'yyyy-mm-dd' UTC format for the date range for which you would like to retrieve recordings. The maximum range can be a month. If no value is provided for this field, the default will be current date. For example, if you make the API request on June 30, 2020, without providing the “from” and “to” parameters, by default the value of 'from' field will be “2020-06-30” and the value of the 'to' field will be “2020-07-01”.
    
    **Note**: The \"trash\" files cannot be filtered by date range and thus, the \"from\" and \"to\" fields should not be used for trash files.
    """  
    mc: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'mc', 'style': 'form', 'explode': True }})
    r"""Query Metadata of Recording if an On-Premise Meeting Connector was used for the meeting."""  
    next_page_token: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'next_page_token', 'style': 'form', 'explode': True }})
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_size: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'page_size', 'style': 'form', 'explode': True }})
    r"""The number of records returned within a single API call."""  
    to: Optional[date] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'to', 'style': 'form', 'explode': True }})
    r"""End date in 'yyyy-mm-dd' 'yyyy-mm-dd' UTC format."""  
    trash: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'trash', 'style': 'form', 'explode': True }})
    r"""Query trash.
    `true`: List recordings from trash.<br> `false`: Do not list recordings from the trash.<br> The default value is `false`. If you set it to `true`, you can use the `trash_type` property to indicate the type of Cloud recording that you need to retrieve.
    """  
    trash_type: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'trash_type', 'style': 'form', 'explode': True }})
    r"""The type of Cloud recording that you would like to retrieve from the trash. The value can be one of the following:<br>
        `meeting_recordings`: List all meeting recordings from the trash.<br>
        `recording_file`: List all individual recording files from the trash.
    """  
    
class RecordingsListRecordingListRecordingFileListRecordingFilesStatusEnum(str, Enum):
    r"""The recording status."""
    COMPLETED = 'completed'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RecordingsListRecordingListRecordingFileListRecordingFiles:
    r"""Recording file object."""
    
    deleted_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('deleted_time'), 'exclude': lambda f: f is None }})
    r"""The time at which recording was deleted. Returned in the response only for trash query."""  
    download_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('download_url'), 'exclude': lambda f: f is None }})
    r"""The URL using which the recording file can be downloaded. **To access a private or password protected cloud recording of a user in your account, you can use a [Zoom JWT App Type](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app). Use the generated JWT token as the value of the `access_token` query parameter and include this query parameter at the end of the URL as shown in the example.**
    <br>
    Example: `https://api.zoom.us/recording/download/{{ Download Path }}?access_token={{ JWT Token }}`
    
    **Similarly, if the user has installed your OAuth app that contains recording scope(s), you can also use the user's [OAuth access token](https://marketplace.zoom.us/docs/guides/auth/oauth) to download the Cloud Recording.**<br>
    
    Example: `https://api.zoom.us/recording/download/{{ Download Path }}?access_token={{ OAuth Access Token }}`
    """  
    file_size: Optional[float] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_size'), 'exclude': lambda f: f is None }})
    r"""The recording file size."""  
    file_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_type'), 'exclude': lambda f: f is None }})
    r"""The recording file type. The value of this field could be one of the following:<br>
    `MP4`: Video file of the recording.<br>`M4A` Audio-only file of the recording.<br>`TIMELINE`: Timestamp file of the recording in JSON file format. To get a timeline file, the \"Add a timestamp to the recording\" setting must be enabled in the [recording settings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-recording#h_3f14c3a4-d16b-4a3c-bbe5-ef7d24500048). The time will display in the host's timezone, set on their Zoom profile.
    <br> `TRANSCRIPT`: Transcription file of the recording in VTT format.<br> `CHAT`: A TXT file containing in-meeting chat messages that were sent during the meeting.<br>`CC`: File containing closed captions of the recording in VTT file format.<br>`CSV`: File containing polling data in csv format.
    
    <br>
    
    A recording file object with file type of either `CC` or `TIMELINE` **does not have** the following properties:<br>
    	`id`, `status`, `file_size`, `recording_type`, and `play_url`.
    """  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The recording file ID. Included in the response of general query."""  
    meeting_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_id'), 'exclude': lambda f: f is None }})
    r"""The meeting ID."""  
    play_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('play_url'), 'exclude': lambda f: f is None }})
    r"""The URL using which a recording file can be played."""  
    recording_end: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_end'), 'exclude': lambda f: f is None }})
    r"""The recording end time. Response in general query."""  
    recording_start: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_start'), 'exclude': lambda f: f is None }})
    r"""The recording start time."""  
    recording_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_type'), 'exclude': lambda f: f is None }})
    r"""The recording type. The value of this field can be one of the following:<br>`shared_screen_with_speaker_view(CC)`<br>`shared_screen_with_speaker_view`<br>`shared_screen_with_gallery_view`<br>`speaker_view`<br>`gallery_view`<br>`shared_screen`<br>`audio_only`<br>`audio_transcript`<br>`chat_file`<br>`active_speaker`<br>`poll`"""  
    status: Optional[RecordingsListRecordingListRecordingFileListRecordingFilesStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""The recording status."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RecordingsListRecordingListRecordingFileList:
    r"""List of recording file."""
    
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('account_id'), 'exclude': lambda f: f is None }})
    r"""Unique Identifier of the user account."""  
    duration: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('duration'), 'exclude': lambda f: f is None }})
    r"""Meeting duration."""  
    host_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host_id'), 'exclude': lambda f: f is None }})
    r"""ID of the user set as host of meeting."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Meeting ID - also known as the meeting number."""  
    recording_count: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_count'), 'exclude': lambda f: f is None }})
    r"""Number of recording files returned in the response of this API call."""  
    recording_files: Optional[list[RecordingsListRecordingListRecordingFileListRecordingFiles]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_files'), 'exclude': lambda f: f is None }})
    r"""List of recording file."""  
    start_time: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('start_time'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""The time at which the meeting started."""  
    topic: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('topic'), 'exclude': lambda f: f is None }})
    r"""Meeting topic."""  
    total_size: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total_size'), 'exclude': lambda f: f is None }})
    r"""Total size of the recording."""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Type of the meeting that was recorded.
    
    Meeting Types:<br>`1` - Instant meeting.<br>`2` - Scheduled meeting.<br>`3` - Recurring meeting with no fixed time.<br>`8` - Recurring meeting with fixed time.
    """  
    uuid: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uuid'), 'exclude': lambda f: f is None }})
    r"""Unique Meeting Identifier. Each instance of the meeting will have its own UUID."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class RecordingsListRecordingList:
    r"""Pagination object."""
    
    from_: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('from'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Start Date."""  
    meetings: Optional[list[RecordingsListRecordingListRecordingFileList]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meetings'), 'exclude': lambda f: f is None }})
    r"""List of recordings."""  
    next_page_token: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('next_page_token'), 'exclude': lambda f: f is None }})
    r"""The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes."""  
    page_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('page_count'), 'exclude': lambda f: f is None }})
    r"""The number of pages returned for the request made."""  
    page_size: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('page_size'), 'exclude': lambda f: f is None }})
    r"""The number of records returned within a single API call."""  
    to: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('to'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""End Date."""  
    total_records: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('total_records'), 'exclude': lambda f: f is None }})
    r"""The number of all records available across pages."""  
    

@dataclasses.dataclass
class RecordingsListResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    body: Optional[bytes] = dataclasses.field(default=None)  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    recording_list: Optional[RecordingsListRecordingList] = dataclasses.field(default=None)
    r"""**HTTP Status Code:** `200`<br>
    List of recording objects returned.
    """  
    