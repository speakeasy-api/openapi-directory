"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "http://azure-api.sportsdata.io/golf/v2",
    "https://azure-api.sportsdata.io/golf/v2",
]
"""Contains the list of servers available to the SDK"""

class SDK:

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 security: shared.Security = None,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param security: The security details required for authentication
        :type security: shared.Security
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = utils.configure_security_client(self._client, security)
        

        
    
    
    def current_season(self, request: operations.CurrentSeasonRequest) -> operations.CurrentSeasonResponse:
        r"""Current Season"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.CurrentSeasonRequest, base_url, '/{format}/CurrentSeason', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CurrentSeasonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Season])
                res.season = out

        return res

    def dfs_slates(self, request: operations.DfsSlatesRequest) -> operations.DfsSlatesResponse:
        r"""DFS Slates"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.DfsSlatesRequest, base_url, '/{format}/DfsSlatesByTournament/{tournamentid}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DfsSlatesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.DfsSlate]])
                res.dfs_slates = out

        return res

    def injuries(self, request: operations.InjuriesRequest) -> operations.InjuriesResponse:
        r"""Injuries"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.InjuriesRequest, base_url, '/{format}/Injuries', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InjuriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Injury]])
                res.injuries = out

        return res

    def injuries_historical(self, request: operations.InjuriesHistoricalRequest) -> operations.InjuriesHistoricalResponse:
        r"""Injuries (Historical)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.InjuriesHistoricalRequest, base_url, '/{format}/InjuriesByHistorical', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.InjuriesHistoricalResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Injury]])
                res.injuries = out

        return res

    def leaderboard(self, request: operations.LeaderboardRequest) -> operations.LeaderboardResponse:
        r"""Leaderboard"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LeaderboardRequest, base_url, '/{format}/Leaderboard/{tournamentid}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LeaderboardResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Leaderboard])
                res.leaderboard = out

        return res

    def news(self, request: operations.NewsRequest) -> operations.NewsResponse:
        r"""News"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.NewsRequest, base_url, '/{format}/News', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.NewsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.News]])
                res.news = out

        return res

    def news_by_date(self, request: operations.NewsByDateRequest) -> operations.NewsByDateResponse:
        r"""News by Date"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.NewsByDateRequest, base_url, '/{format}/NewsByDate/{date}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.NewsByDateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.News]])
                res.news = out

        return res

    def news_by_player(self, request: operations.NewsByPlayerRequest) -> operations.NewsByPlayerResponse:
        r"""News by Player"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.NewsByPlayerRequest, base_url, '/{format}/NewsByPlayerID/{playerid}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.NewsByPlayerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.News]])
                res.news = out

        return res

    def player(self, request: operations.PlayerRequest) -> operations.PlayerResponse:
        r"""Player"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlayerRequest, base_url, '/{format}/Player/{playerid}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlayerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Player])
                res.player = out

        return res

    def player_season_stats_w_world_golf_rankings(self, request: operations.PlayerSeasonStatsWWorldGolfRankingsRequest) -> operations.PlayerSeasonStatsWWorldGolfRankingsResponse:
        r"""Player Season Stats (w/ World Golf Rankings)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlayerSeasonStatsWWorldGolfRankingsRequest, base_url, '/{format}/PlayerSeasonStats/{season}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlayerSeasonStatsWWorldGolfRankingsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PlayerSeason]])
                res.player_seasons = out

        return res

    def player_tournament_projected_stats_w_draftkings_salaries(self, request: operations.PlayerTournamentProjectedStatsWDraftkingsSalariesRequest) -> operations.PlayerTournamentProjectedStatsWDraftkingsSalariesResponse:
        r"""Player Tournament Projected Stats (w/ DraftKings Salaries)"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlayerTournamentProjectedStatsWDraftkingsSalariesRequest, base_url, '/{format}/PlayerTournamentProjectionStats/{tournamentid}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlayerTournamentProjectedStatsWDraftkingsSalariesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.PlayerTournamentProjection]])
                res.player_tournament_projections = out

        return res

    def player_tournament_stats_by_player(self, request: operations.PlayerTournamentStatsByPlayerRequest) -> operations.PlayerTournamentStatsByPlayerResponse:
        r"""Player Tournament Stats By Player"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlayerTournamentStatsByPlayerRequest, base_url, '/{format}/PlayerTournamentStatsByPlayer/{tournamentid}/{playerid}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlayerTournamentStatsByPlayerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PlayerTournament])
                res.player_tournament = out

        return res

    def players(self, request: operations.PlayersRequest) -> operations.PlayersResponse:
        r"""Players"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.PlayersRequest, base_url, '/{format}/Players', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PlayersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Player]])
                res.players = out

        return res

    def schedule(self, request: operations.ScheduleRequest) -> operations.ScheduleResponse:
        r"""Schedule"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ScheduleRequest, base_url, '/{format}/Tournaments', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ScheduleResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Tournament]])
                res.tournaments = out

        return res

    def schedule_by_season(self, request: operations.ScheduleBySeasonRequest) -> operations.ScheduleBySeasonResponse:
        r"""Schedule by Season"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.ScheduleBySeasonRequest, base_url, '/{format}/Tournaments/{season}', request)
        
        
        client = self._security_client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ScheduleBySeasonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.Tournament]])
                res.tournaments = out

        return res

    