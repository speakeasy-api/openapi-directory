"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import googleidentityaccesscontextmanagerv1osconstraint as shared_googleidentityaccesscontextmanagerv1osconstraint
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class GoogleIdentityAccesscontextmanagerV1DevicePolicyAllowedDeviceManagementLevelsEnum(str, Enum):
    MANAGEMENT_UNSPECIFIED = 'MANAGEMENT_UNSPECIFIED'
    NONE = 'NONE'
    BASIC = 'BASIC'
    COMPLETE = 'COMPLETE'

class GoogleIdentityAccesscontextmanagerV1DevicePolicyAllowedEncryptionStatusesEnum(str, Enum):
    ENCRYPTION_UNSPECIFIED = 'ENCRYPTION_UNSPECIFIED'
    ENCRYPTION_UNSUPPORTED = 'ENCRYPTION_UNSUPPORTED'
    UNENCRYPTED = 'UNENCRYPTED'
    ENCRYPTED = 'ENCRYPTED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GoogleIdentityAccesscontextmanagerV1DevicePolicy:
    r"""`DevicePolicy` specifies device specific restrictions necessary to acquire a given access level. A `DevicePolicy` specifies requirements for requests from devices to be granted access levels, it does not do any enforcement on the device. `DevicePolicy` acts as an AND over all specified fields, and each repeated field is an OR over its elements. Any unset fields are ignored. For example, if the proto is { os_type : DESKTOP_WINDOWS, os_type : DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be true for requests originating from encrypted Linux desktops and encrypted Windows desktops."""
    
    allowed_device_management_levels: Optional[list[GoogleIdentityAccesscontextmanagerV1DevicePolicyAllowedDeviceManagementLevelsEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowedDeviceManagementLevels'), 'exclude': lambda f: f is None }})
    r"""Allowed device management levels, an empty list allows all management levels."""  
    allowed_encryption_statuses: Optional[list[GoogleIdentityAccesscontextmanagerV1DevicePolicyAllowedEncryptionStatusesEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowedEncryptionStatuses'), 'exclude': lambda f: f is None }})
    r"""Allowed encryptions statuses, an empty list allows all statuses."""  
    os_constraints: Optional[list[shared_googleidentityaccesscontextmanagerv1osconstraint.GoogleIdentityAccesscontextmanagerV1OsConstraint]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('osConstraints'), 'exclude': lambda f: f is None }})
    r"""Allowed OS versions, an empty list allows all types and all versions."""  
    require_admin_approval: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('requireAdminApproval'), 'exclude': lambda f: f is None }})
    r"""Whether the device needs to be approved by the customer admin."""  
    require_corp_owned: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('requireCorpOwned'), 'exclude': lambda f: f is None }})
    r"""Whether the device needs to be corp owned."""  
    require_screenlock: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('requireScreenlock'), 'exclude': lambda f: f is None }})
    r"""Whether or not screenlock is required for the DevicePolicy to be true. Defaults to `false`."""  
    