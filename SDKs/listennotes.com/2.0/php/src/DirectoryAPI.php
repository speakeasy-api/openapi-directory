<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class DirectoryAPI 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Fetch a list of best podcasts by genre
     * 
     * Get a list of curated best podcasts by genre,
     * which are curated by Listen Notes staffs based on various signals from the Internet, e.g.,
     * top charts on other podcast platforms, recommendations from mainstream media,
     * user activities on listennotes.com...
     * You can get the genre ids from `GET /genres` endpoint.
     * This endpoint returns same data as https://www.listennotes.com/best-podcasts/
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetBestPodcastsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetBestPodcastsResponse
     */
	public function getBestPodcasts(
        \OpenAPI\OpenAPI\Models\Operations\GetBestPodcastsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetBestPodcastsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/best_podcasts');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetBestPodcastsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetBestPodcastsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->bestPodcastsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\BestPodcastsResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch a curated list of podcasts by id
     * 
     * Get detailed meta data of all podcasts in a specific curated list.
     * This endpoint returns same data as https://www.listennotes.com/curated-podcasts/
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastByIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastByIdResponse
     */
	public function getCuratedPodcastById(
        \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastByIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastByIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/curated_podcasts/{id}', \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastByIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastByIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->curatedListFull = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CuratedListFull', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch curated lists of podcasts
     * 
     * A bunch of curated lists from online media. For each list, you'll get basic info of up to 5 podcasts. To get detailed meta data of all podcasts in a specific list, you need to use `GET /curated_podcasts/{id}`. We add new curated lists to the database on a daily basis.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastsResponse
     */
	public function getCuratedPodcasts(
        \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/curated_podcasts');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCuratedPodcastsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getCuratedPodcastsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetCuratedPodcastsResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch detailed meta data for an episode by id
     * 
     * Fetch detailed meta data for a specific episode.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdResponse
     */
	public function getEpisodeById(
        \OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/episodes/{id}', \OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEpisodeByIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->episodeFull = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EpisodeFull', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch recommendations for an episode
     * 
     * Fetch up to 8 episode recommendations based on the given episode id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsResponse
     */
	public function getEpisodeRecommendations(
        \OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/episodes/{id}/recommendations', \OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEpisodeRecommendationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getEpisodeRecommendationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetEpisodeRecommendationsResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Batch fetch basic meta data for episodes
     * 
     * Batch fetch basic meta data for up to 10 episodes. This endpoint could be used to implement custom playlists for individual episodes. For detailed meta data of an individual episode, you need to use `GET /episodes/{id}`. This endpoint is available only in the PRO/ENTERPRISE plan.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEpisodesInBatchRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEpisodesInBatchResponse
     */
	public function getEpisodesInBatch(
        \OpenAPI\OpenAPI\Models\Operations\GetEpisodesInBatchRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEpisodesInBatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/episodes');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "getEpisodesInBatchForm", "form");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEpisodesInBatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getEpisodesInBatchResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetEpisodesInBatchResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch a list of podcast genres
     * 
     * Get a list of podcast genres that are supported in Listen Notes.
     * The genre id can be passed to other endpoints as a parameter to get podcasts in a specific genre,
     * e.g., `GET /best_podcasts`, `GET /search`...
     * You may want to cache the list of genres on the client side.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetGenresRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetGenresResponse
     */
	public function getGenres(
        \OpenAPI\OpenAPI\Models\Operations\GetGenresRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetGenresResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/genres');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetGenresRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetGenresResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getGenresResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetGenresResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch a list of supported languages for podcasts
     * 
     * Get a list of languages that are supported in Listen Notes database. You can use the language string as query parameter in `GET /search`.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLanguagesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLanguagesResponse
     */
	public function getLanguages(
        \OpenAPI\OpenAPI\Models\Operations\GetLanguagesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetLanguagesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/languages');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLanguagesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getLanguagesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetLanguagesResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch detailed meta data and episodes for a podcast by id
     * 
     * Fetch detailed meta data and episodes for a specific podcast (up to 10 episodes each time).
     * You can use the **next_episode_pub_date** parameter to do pagination and fetch more episodes.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdResponse
     */
	public function getPodcastById(
        \OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/podcasts/{id}', \OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPodcastByIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->podcastFull = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PodcastFull', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch recommendations for a podcast
     * 
     * Fetch up to 8 podcast recommendations based on the given podcast id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsResponse
     */
	public function getPodcastRecommendations(
        \OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/podcasts/{id}/recommendations', \OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPodcastRecommendationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPodcastRecommendationsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetPodcastRecommendationsResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Batch fetch basic meta data for podcasts
     * 
     * Batch fetch basic meta data for up to 10 podcasts.
     * This endpoint could be used to build something like OPML import,
     * allowing users to import a bunch of podcasts via rss urls.
     * For detailed meta data (including episodes) of an individual podcast, you need to use `GET /podcasts/{id}`. This endpoint is available only in the PRO/ENTERPRISE plan.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPodcastsInBatchRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPodcastsInBatchResponse
     */
	public function getPodcastsInBatch(
        \OpenAPI\OpenAPI\Models\Operations\GetPodcastsInBatchRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPodcastsInBatchResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/podcasts');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "getPodcastsInBatchForm", "form");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPodcastsInBatchResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPodcastsInBatchResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetPodcastsInBatchResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch a list of supported countries/regions for best podcasts
     * 
     * It returns a dictionary of country codes (e.g., us, gb...) & country names (United States, United Kingdom...). The country code is used in the query parameter **region** of `GET /best_podcasts`.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetRegionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetRegionsResponse
     */
	public function getRegions(
        \OpenAPI\OpenAPI\Models\Operations\GetRegionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetRegionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/regions');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetRegionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getRegionsResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\GetRegionsResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
	
    /**
     * Fetch a random podcast episode
     * 
     * Recently published episodes are more likely to be fetched. Good luck!
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\JustListenRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\JustListenResponse
     */
	public function justListen(
        \OpenAPI\OpenAPI\Models\Operations\JustListenRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\JustListenResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/just_listen');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\JustListenResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->episodeSimple = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\EpisodeSimple', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 429 or ($httpResponse->getStatusCode() >= 500 && $httpResponse->getStatusCode() < 600)) {
        }

        return $response;
    }
}