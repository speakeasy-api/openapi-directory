<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Nodes 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Mark a node (room, folder or file) as favorite
     * 
     * ### Description:  
     * Marks a node (room, folder or file) as favorite.
     * 
     * ### Precondition:
     * Authenticated user is allowed to <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128065; see</span> the node (i.e. `isBrowsable = true`).
     * 
     * ### Postcondition:
     * A node gets marked as favorite.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AddFavoriteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddFavoriteResponse
     */
	public function addFavorite(
        \OpenAPI\OpenAPI\Models\Operations\AddFavoriteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddFavoriteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/favorite', \OpenAPI\OpenAPI\Models\Operations\AddFavoriteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddFavoriteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add guest users to a room
     * 
     * ### Description:
     * Add guest users to a room
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>. To add new members, the user needs the right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; non-members add</span>, which is included in any role.
     * <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Guest User Policy</span> needs to be enabled.
     * 
     * 
     * ### Postcondition:
     * New or existing Guest-Users now have guest-permissions for this room
     * 
     * ### Further Information:
     * Batch function.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AddRoomGuestUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AddRoomGuestUsersResponse
     */
	public function addRoomGuestUsers(
        \OpenAPI\OpenAPI\Models\Operations\AddRoomGuestUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AddRoomGuestUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/guest_users', \OpenAPI\OpenAPI\Models\Operations\AddRoomGuestUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roomGuestUserAddRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AddRoomGuestUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Cancel file upload
     * 
     * ### Description:
     * Cancel a (S3) file upload and destroy the upload channel.
     * 
     * ### Precondition:
     * An upload channel has been created and user has to be the creator of the upload channel.
     * 
     * ### Postcondition:
     * The upload channel is removed and all temporary uploaded data is purged.
     * 
     * ### Further Information:
     * It is recommended to notify the API about cancelled uploads if possible.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadResponse
     */
	public function cancelFileUpload(
        \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CancelFileUploadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Handle user-room assignments per group
     * 
     * ### Description:  
     * Handles a list of user-room assignments by groups that have **NOT** been approved yet  
     * **WAITING** or **DENIED** assignments can be **ACCEPTED**.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * User-room assignment is approved and the user gets access to the group.
     * 
     * ### Further Information:
     * Room administrators should **SHOULD** handle pending assignments to provide access to rooms for other users.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ChangePendingAssignmentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ChangePendingAssignmentsResponse
     */
	public function changePendingAssignments(
        \OpenAPI\OpenAPI\Models\Operations\ChangePendingAssignmentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ChangePendingAssignmentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/pending');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "pendingAssignmentsRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ChangePendingAssignmentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Complete file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.9.0</h3>
     * 
     * ### Use `uploads` API
     * 
     * ### Description:
     * Finishes an upload and closes the corresponding upload channel.
     * 
     * ### Precondition:
     * An upload channel has been created and data has been transmitted.
     * 
     * ### Postcondition:
     * The upload is finished and the temporary file is moved to the productive environment.
     * 
     * ### Further Information:
     * The provided file name might be changed in accordance with the resolution strategy:  
     * * **autorename**: changes the file name and adds a number to avoid conflicts.
     * * **overwrite**: deletes any old file with the same file name.
     * * **fail**: returns an error; in this case, another `PUT` request with a different file name may be sent.
     * 
     * Please ensure that all chunks have been transferred correctly before finishing the upload.  
     * Download share id (if exists) gets changed if:
     * - node with the same name exists in the target container
     * - `resolutionStrategy` is `overwrite`
     * - `keepShareLinks` is `true`
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadResponse
     */
	public function completeFileUpload(
        \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "completeUploadRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteFileUploadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201 or $httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Complete S3 file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     * 
     * ### Description:
     * Finishes a S3 file upload and closes the corresponding upload channel.
     * 
     * ### Precondition:
     * An upload channel has been created, data has been transmitted and user has to be the creator of the upload channel
     * 
     * ### Postcondition:
     * Upload channel is closed. S3 multipart upload request is completed.
     * 
     * ### Further Information:
     * Download share id (if exists) gets changed if:
     * - node with the same name exists in the target container
     * - `resolutionStrategy` is `overwrite`
     * - `keepShareLinks` is `true`
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadResponse
     */
	public function completeS3FileUpload(
        \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads/{upload_id}/s3', \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "completeS3FileUploadRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompleteS3FileUploadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Configure room
     * 
     * ### Description:
     * Configure a room.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Room's configuration is changed.
     * 
     * ### Further Information:
     * Provided (or default) classification is taken from room when file gets uploaded without any classification.  
     * 
     * To set `adminIds` or `adminGroupIds` the `inheritPermissions` value has to be `false`. Otherwise use:
     * * `PUT /nodes/rooms/{room_id}/groups`
     * * `PUT /nodes/rooms/{room_id}/users `  
     * 
     * APIs.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ConfigureRoomRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ConfigureRoomResponse
     */
	public function configureRoom(
        \OpenAPI\OpenAPI\Models\Operations\ConfigureRoomRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ConfigureRoomResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/config', \OpenAPI\OpenAPI\Models\Operations\ConfigureRoomRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "configRoomRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ConfigureRoomResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Copy node(s)
     * 
     * ### Description:
     * Copies nodes (folder, file) to another parent.
     * 
     * ### Precondition:
     * Authenticated user with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in the source parent and <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the target parent node.
     * 
     * ### Postcondition:
     * Nodes are copied to target parent.
     * 
     * ### Further Information:
     * Nodes **MUST** be in same source parent.  
     * **Rooms **CANNOT** be copied.**
     * 
     * Download share id (if exists) gets changed if:
     * - node with the same name exists in the target container
     * - `resolutionStrategy` is `overwrite`
     * - `keepShareLinks` is `true`
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CopyNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CopyNodesResponse
     */
	public function copyNodes(
        \OpenAPI\OpenAPI\Models\Operations\CopyNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CopyNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/copy_to', \OpenAPI\OpenAPI\Models\Operations\CopyNodesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "copyNodesRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CopyNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 204) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->copyNodes204ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create key pair and preserve copy of old private key
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.24.0</h3>
     * 
     * ### Description:  
     * Create room rescue key pair and preserve copy of old private key.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Room rescue key pair is created.  
     * Copy of old private key is preserved.
     * 
     * ### Further Information:
     * You can submit your old private key, encrypted with your current password.  
     * This allows migrating file keys encrypted with your old key pair to the new one.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateAndPreserveRoomRescueKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateAndPreserveRoomRescueKeyPairResponse
     */
	public function createAndPreserveRoomRescueKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\CreateAndPreserveRoomRescueKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateAndPreserveRoomRescueKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/keypairs', \OpenAPI\OpenAPI\Models\Operations\CreateAndPreserveRoomRescueKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createKeyPairRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateAndPreserveRoomRescueKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create new file upload channel
     * 
     * ### Description:
     * This endpoint creates a new upload channel which is the first step in any file upload workflow.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the parent container (room or folder).
     * 
     * ### Postcondition:
     * A new upload channel for a file is created.  
     * Its ID and an upload token are returned.
     * 
     * ### Further Information:
     * The upload ID is used for uploads with `X-Sds-Auth-Token` header, the upload token can be used for uploads without authentication header.
     * 
     * Please provide the size of the intended upload so that the quota can be checked in advanced and no data is transferred unnecessarily.
     * 
     * Notes are limited to **255** characters.
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFileUploadChannelRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFileUploadChannelResponse
     */
	public function createFileUploadChannel(
        \OpenAPI\OpenAPI\Models\Operations\CreateFileUploadChannelRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFileUploadChannelResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createFileUploadRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFileUploadChannelResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->createFileUploadResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CreateFileUploadResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create new folder
     * 
     * ### Description:
     * Create a new folder.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in current room.
     * 
     * ### Postcondition:
     * New folder is created.
     * 
     * ### Further Information:
     * Folders **CANNOT** be created on top level (without parent element).  
     * Notes are limited to **255** characters.
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateFolderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateFolderResponse
     */
	public function createFolder(
        \OpenAPI\OpenAPI\Models\Operations\CreateFolderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateFolderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/folders');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createFolderRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateFolderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create node comment
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.10.0</h3>
     * 
     * ### Description:
     * Create a comment for a specific node.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions on the node.
     * 
     * ### Postcondition:
     * Comment is created.
     * 
     * ### Further Information:
     * Maximum allowed text length: **65535** characters.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateNodeCommentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateNodeCommentResponse
     */
	public function createNodeComment(
        \OpenAPI\OpenAPI\Models\Operations\CreateNodeCommentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateNodeCommentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/comments', \OpenAPI\OpenAPI\Models\Operations\CreateNodeCommentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createNodeCommentRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateNodeCommentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->comment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Comment', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create new room
     * 
     * ### Description:
     * Creates a new room at the provided parent node.  
     * Creation of top level rooms provided.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span> permissions in the parent room.
     * 
     * ### Postcondition:
     * A new room is created.
     * 
     * ### Further Information:  
     * Rooms may only have other rooms as parent.  
     * Rooms on top level do **NOT** have any parent.  
     * Rooms may have rooms as children on n hierarchy levels.  
     * If permission inheritance is disabled, there **MUST** be at least one admin user / group (with neither the group nor the user having an expiration date).
     * 
     * Notes are limited to **255** characters.
     * 
     * Provided (or default) classification is taken from room when file gets uploaded without any classification.
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRoomRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRoomResponse
     */
	public function createRoom(
        \OpenAPI\OpenAPI\Models\Operations\CreateRoomRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRoomResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "createRoomRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRoomResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download files / folders as ZIP archive
     * 
     * ### Description:  
     * Download multiple files in a ZIP archive.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in auth parent room.
     * 
     * ### Postcondition:
     * Stream is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DownloadZipArchiveRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DownloadZipArchiveResponse
     */
	public function downloadZipArchive(
        \OpenAPI\OpenAPI\Models\Operations\DownloadZipArchiveRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DownloadZipArchiveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/zip/download');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "zipDownloadRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DownloadZipArchiveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/octet-stream')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Empty recycle bin
     * 
     * ### Description:  
     * Empty a recycle bin.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; delete recycle bin</span> permissions in parent room.
     * 
     * ### Postcondition:
     * All files in the recycle bin are permanently removed.
     * 
     * ### Further Information:
     * Actually removes the previously deleted files from the system.  
     * **This action is irreversible.**
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\EmptyDeletedNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\EmptyDeletedNodesResponse
     */
	public function emptyDeletedNodes(
        \OpenAPI\OpenAPI\Models\Operations\EmptyDeletedNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\EmptyDeletedNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/deleted_nodes', \OpenAPI\OpenAPI\Models\Operations\EmptyDeletedNodesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\EmptyDeletedNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Encrypt room
     * 
     * ### Description:  
     * Activates the client-side encryption for a room.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Encryption of room is activated.
     * 
     * ### Further Information:
     * Only empty rooms at the top level may be encrypted.  
     * This endpoint may also be used to disable encryption of an empty room.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\EncryptRoomRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\EncryptRoomResponse
     */
	public function encryptRoom(
        \OpenAPI\OpenAPI\Models\Operations\EncryptRoomRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\EncryptRoomResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/encrypt', \OpenAPI\OpenAPI\Models\Operations\EncryptRoomRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "encryptRoomRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\EncryptRoomResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate download URL
     * 
     * ### Description:
     * Create a download URL to retrieve a file without `X-Sds-Auth-Token` Header.
     * 
     * ### Precondition:
     * User with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in parent room.
     * 
     * ### Postcondition:
     * Download token is generated and returned.
     * 
     * ### Further Information:
     * The token is necessary to access `downloads` ressources.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlResponse
     */
	public function generateDownloadUrl(
        \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/{file_id}/downloads', \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->downloadTokenGenerateResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DownloadTokenGenerateResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate download URL for ZIP download
     * 
     * ### Description:  
     * Create a download URL to retrieve several files in one ZIP archive.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in parent room.
     * 
     * ### Postcondition:
     * Download URL is generated and returned.
     * 
     * ### Further Information:
     * The token is necessary to access `downloads` resources.  
     * ZIP download is only available for files and folders.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlForZipArchiveRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlForZipArchiveResponse
     */
	public function generateDownloadUrlForZipArchive(
        \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlForZipArchiveRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlForZipArchiveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/zip');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "zipDownloadRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GenerateDownloadUrlForZipArchiveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->downloadTokenGenerateResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DownloadTokenGenerateResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Generate presigned URLs for S3 file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     * 
     * ### Description:
     * Generate presigned URLs for S3 file upload.
     * 
     * ### Precondition:
     * An upload channel has been created and user has to be the creator of the upload channel.
     * 
     * ### Postcondition:
     * List of presigned URLs is returned.
     * 
     * ### Further Information:
     * The size for each part must be >= 5 MB, except for the last part.  
     * The part number of the first part in S3 is 1 (not 0).  
     * Use HTTP method `PUT` for uploading bytes via presigned URL.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsFilesResponse
     */
	public function generatePresignedUrlsFiles(
        \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads/{upload_id}/s3_urls', \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsFilesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "generatePresignedUrlsRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GeneratePresignedUrlsFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->presignedUrlList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PresignedUrlList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 504 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Assign or unassign webhooks to room
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.19.0</h3>
     * 
     * ### Description:  
     * Handle room webhook assignments.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * List of webhooks is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * ### Available event types:
     * 
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | Name | Description | Scope |
     * | :--- | :--- | :--- |
     * | **`downloadshare.created`** | Triggered when a new download share is created in affected room | Node Webhook |
     * | **`downloadshare.deleted`** | Triggered when a download share is deleted in affected room | Node Webhook |
     * | **`downloadshare.used`** | Triggered when a download share is utilized in affected room | Node Webhook |
     * | **`uploadshare.created`** | Triggered when a new upload share is created in affected room | Node Webhook |
     * | **`uploadshare.deleted`** | Triggered when a upload share is deleted in affected room | Node Webhook |
     * | **`uploadshare.used`** | Triggered when a new file is uploaded via the upload share in affected room | Node Webhook |
     * | **`file.created`** | Triggered when a new file is uploaded in affected room | Node Webhook |
     * | **`folder.created`** | Triggered when a new folder is created in affected room | Node Webhook |
     * | **`room.created`** | Triggered when a new room is created (in affected room) | Node Webhook |
     * | **`file.deleted`** | Triggered when a file is deleted in affected room | Node Webhook |
     * | **`folder.deleted`** | Triggered when a folder is deleted in affected room | Node Webhook |
     * | **`room.deleted`** | Triggered when a room is deleted in affected room | Node Webhook |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\HandleRoomWebhookAssignmentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\HandleRoomWebhookAssignmentsResponse
     */
	public function handleRoomWebhookAssignments(
        \OpenAPI\OpenAPI\Models\Operations\HandleRoomWebhookAssignmentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\HandleRoomWebhookAssignmentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/webhooks', \OpenAPI\OpenAPI\Models\Operations\HandleRoomWebhookAssignmentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateRoomWebhookRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\HandleRoomWebhookAssignmentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->roomWebhookList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RoomWebhookList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Move node(s)
     * 
     * ### Description:  
     * Moves nodes (folder, file) to another parent.
     * 
     * ### Precondition:
     * Authenticated user with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> and <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; delete</span> permissions in the source parent and <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in the target parent node.
     * 
     * ### Postcondition:
     * Nodes are moved to target parent.
     * 
     * ### Further Information:
     * Nodes **MUST** be in same source parent.  
     * **Rooms **CANNOT** be moved.**
     * 
     * Download share id (if exists) gets changed if:
     * - node with the same name exists in the target container
     * - `resolutionStrategy` is `overwrite`
     * - `keepShareLinks` is `true`
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MoveNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MoveNodesResponse
     */
	public function moveNodes(
        \OpenAPI\OpenAPI\Models\Operations\MoveNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MoveNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/move_to', \OpenAPI\OpenAPI\Models\Operations\MoveNodesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "moveNodesRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MoveNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 204) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $response->moveNodes204ApplicationJSONString = $httpResponse->getBody()->getContents();
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove nodes from recycle bin
     * 
     * ### Description:
     * Permanently remove a list of nodes from the recycle bin.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; delete recycle bin</span> permissions in parent room.
     * 
     * ### Postcondition:
     * All provided nodes are removed.
     * 
     * ### Further Information:
     * The removal of deleted nodes from the recycle bin is irreversible.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveDeletedNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveDeletedNodesResponse
     */
	public function removeDeletedNodes(
        \OpenAPI\OpenAPI\Models\Operations\RemoveDeletedNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveDeletedNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/deleted_nodes');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "deleteDeletedNodesRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveDeletedNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Unmark a node (room, folder or file) as favorite
     * 
     * ### Description:
     * Unmarks a node (room, folder or file) as favorite.
     * 
     * ### Precondition:
     * Authenticated user is allowed to <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128065; see</span> the node (i.e. `isBrowsable = true`).
     * 
     * ### Postcondition:
     * A node gets unmarked as favorite.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveFavoriteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveFavoriteResponse
     */
	public function removeFavorite(
        \OpenAPI\OpenAPI\Models\Operations\RemoveFavoriteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveFavoriteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/favorite', \OpenAPI\OpenAPI\Models\Operations\RemoveFavoriteRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveFavoriteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove node
     * 
     * ### Description:
     * Delete node (room, folder or file).
     * 
     * ### Precondition:
     * Authenticated user with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; delete</span> permissions on supplied nodes (for folders or files) or on superordinated node (for rooms).
     * 
     * ### Postcondition:
     * Node gets deleted.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveNodeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveNodeResponse
     */
	public function removeNode(
        \OpenAPI\OpenAPI\Models\Operations\RemoveNodeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveNodeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}', \OpenAPI\OpenAPI\Models\Operations\RemoveNodeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveNodeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove node comment
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.10.0</h3>
     * 
     * ### Description:
     * Delete an existing comment for a specific node.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions on the node and is the creator of the comment **OR** <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span> in auth parent room.
     * 
     * ### Postcondition:
     * Comment is deleted.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveNodeCommentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveNodeCommentResponse
     */
	public function removeNodeComment(
        \OpenAPI\OpenAPI\Models\Operations\RemoveNodeCommentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveNodeCommentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\RemoveNodeCommentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveNodeCommentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove nodes
     * 
     * ### Description:
     * Delete nodes (room, folder or file).
     * 
     * ### Precondition:
     * Authenticated user with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; delete</span> permissions on supplied nodes (for folders or files) or on superordinated node (for rooms).
     * 
     * ### Postcondition:
     * Nodes are deleted.
     * 
     * ### Further Information:
     * Nodes **MUST** be in same parent.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveNodesResponse
     */
	public function removeNodes(
        \OpenAPI\OpenAPI\Models\Operations\RemoveNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "deleteNodesRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Remove rooms's rescue key pair
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.24.0</h3>
     * 
     * ### Description:  
     * Delete room rescue key pair.
     * 
     * ### Precondition:
     * Authenticated user.
     * 
     * ### Postcondition:
     * Key pair is removed (cf. further information below).
     * 
     * ### Further Information:
     * Please set a new room rescue key pair first and re-encrypt file keys with it.  
     * If no version is set, deleted key pair with lowest preference value.  
     * Although, `version` **SHOULD** be set.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairResponse
     */
	public function removeRoomRescueKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/keypair', \OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RemoveRoomRescueKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request deleted node
     * 
     * ### Description:  
     * Get metadata of a deleted node.
     * 
     * ### Precondition:
     * User can access parent room and has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read recycle bin</span> permissions.
     * 
     * ### Postcondition:
     * Requested deleted node is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeResponse
     */
	public function requestDeletedNode(
        \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/deleted_nodes/{deleted_node_id}', \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deletedNode = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DeletedNode', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request deleted versions of nodes
     * 
     * ### Description:  
     * Retrieve all deleted versions of a node.
     * 
     * ### Precondition:
     * User can access parent room and has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read recycle bin</span> permissions.
     * 
     * ### Postcondition:
     * List of deleted versions of a node is returned.
     * 
     * ### Further Information:
     * The node is identified by three parameters:
     * * parent ID
     * * name
     * * type (file, folder).
     * 
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `expireAt:desc|size:asc`  
     * Sort by `expireAt` descending **AND** `size` ascending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `expireAt` | Expiration date |
     * | `accessedAt` | Last access date |
     * | `size` | Node size |
     * | `classification` | Classification ID:<ul><li>1 - public</li><li>2 - internal</li><li>3 - confidential</li><li>4 - strictly confidential</li></ul> |
     * | `createdAt` | Creation date |
     * | `createdBy` | Creator first name, last name |
     * | `updatedAt` | Last modification date |
     * | `updatedBy` | Last modifier first name, last name |
     * | `deletedAt` | Deleted date |
     * | `deletedBy` | Deleter first name, last name |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsResponse
     */
	public function requestDeletedNodeVersions(
        \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/deleted_nodes/versions', \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodeVersionsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deletedNodeVersionsList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DeletedNodeVersionsList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of deleted nodes
     * 
     * ### Description:  
     * Retrieve a list of deleted nodes in a recycle bin.
     * 
     * ### Precondition:
     * User can access parent room and has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read recycle bin</span> permissions.
     * 
     * ### Postcondition:
     * List of deleted nodes is returned.
     * 
     * ### Further Information:
     * Only room IDs are accepted as parent ID since only rooms may have a recycle bin.
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `type:eq:file:folder|name:cn:searchString_1|parentPath:cn:searchString_2`  
     * Get deleted nodes where type equals (`file` **OR** `folder`) **AND** deleted node name containing `searchString_1` **AND** deleted node parent path containing `searchString 2`.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | `type` | Node type filter | `eq` | Node type equals value(s).<br>Multiple values are allowed and will be connected via logical disjunction (**OR**).<br>e.g. `type:eq:folder:file` | <ul><li>`folder`</li><li>`file`</li></ul> |
     * | `name` | Node name filter | `cn` | Node name contains value. | `search String` |
     * | `parentPath` | Parent path filter | `cn` | Parent path contains value. | `search String` |
     * | `timestampCreation` | Creation timestamp filter | `ge, le` | Creation timestamp is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `timestampCreation:ge:2016-12-31`&#124;<br>`timestampCreation:le:2018-01-01` | `Date (yyyy-MM-dd)` |
     * | `timestampModification` | Modification timestamp filter | `ge, le` | Modification timestamp is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `timestampModification:ge:2016-12-31T23:00:00.123`&#124;<br>`timestampModification:le:2018-01-01T11:00:00.540` | `Date (yyyy-MM-dd)` |
     * 
     * </details>
     * 
     * ---
     * 
     * ### Sorting:
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.  
     * Nodes are sorted by type first, then by sent sort string.  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `name:desc|timestampCreation:asc`  
     * Sort by `name` descending **AND** `timestampCreation` ascending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `name` | Node name |
     * | `cntVersions` | Number of deleted versions of this file |
     * | `firstDeletedAt` | First deleted version |
     * | `lastDeletedAt` | Last deleted version |
     * | `parentPath` | Parent path of deleted node |
     * | `timestampCreation` | Creation timestamp |
     * | `timestampModification` | Modification timestamp |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryResponse
     */
	public function requestDeletedNodesSummary(
        \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/deleted_nodes', \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestDeletedNodesSummaryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->deletedNodeSummaryList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\DeletedNodeSummaryList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of file versions
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.37.0</h3>
     * 
     * ### Description:  
     * Request a list of file versions. Both nodes and deleted nodes are included, depending on the user's permissions.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read/read recycle bin</span> permissions in parent room.
     * 
     * ### Postcondition:
     * List of file versions is returned.
     * 
     * ### Further Information:
     * Maximum number of file versions is 500. The list is sorted by ID DESC.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListResponse
     */
	public function requestFileVersionList(
        \OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/versions/{reference_id}', \OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestFileVersionListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileVersionList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileVersionList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of webhooks that are assigned or can be assigned to this room
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.19.0</h3>
     * 
     * ### Description:  
     * Get a list of webhooks for the room scope with their assignment status.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * List of webhooks is returned.
     * 
     * ### Further Information:
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `isAssigned:eq:true`  
     * Get a list of assigned webhooks to the room.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | **`isAssigned`** | Assigned/unassigned webhooks filter | `eq` |  | `true or false` |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomResponse
     */
	public function requestListOfWebhooksForRoom(
        \OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/webhooks', \OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestListOfWebhooksForRoomResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->roomWebhookList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RoomWebhookList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request files without user's file key
     * 
     * ### Description:  
     * Requests a list of missing file keys that may be generated by the current user.  
     * 
     * ### Precondition:
     * User has a key pair.  
     * Only returns users that owns one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>
     * 
     * ### Postcondition:
     * None.
     * 
     * ### Further Information:
     * Clients **SHOULD** regularly request missing file keys to provide access to files for other users.  
     * The returned list is ordered by priority (emergency passwords / rescue keys are returned first).
     * There is an enforced limit of **100** items per request.
     * A total value greater than limit signals that there are more entries but does not necessarily reflect the precise
     * number of total items.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestMissingFileKeysRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestMissingFileKeysResponse
     */
	public function requestMissingFileKeys(
        \OpenAPI\OpenAPI\Models\Operations\RequestMissingFileKeysRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestMissingFileKeysResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/missingFileKeys');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestMissingFileKeysRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestMissingFileKeysResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->missingKeysResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MissingKeysResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request node
     * 
     * ### Description:  
     * Get node (room, folder or file).
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in auth parent room.
     * 
     * ### Postcondition:
     * Requested node is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestNodeRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestNodeResponse
     */
	public function requestNode(
        \OpenAPI\OpenAPI\Models\Operations\RequestNodeRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestNodeResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}', \OpenAPI\OpenAPI\Models\Operations\RequestNodeRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestNodeResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of node comments
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.10.0</h3>
     * 
     * ### Description:
     * Get comments for a specific node.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions on the node.
     * 
     * ### Postcondition:
     * List with comments (sorted by `createdAt` timestamp) is returned.
     * 
     * ### Further Information:
     * An empty list is returned if no comments were found.  
     * Output is limited to **500** entries.  
     * For more results please use filter criteria and paging (`offset` + `limit`). 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsResponse
     */
	public function requestNodeComments(
        \OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/comments', \OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestNodeCommentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->commentList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CommentList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of parent nodes
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.10.0</h3>
     * 
     * ### Description:  
     * Requests a list of node ancestors, sorted from root node to the node's direct parent node.
     * 
     * ### Precondition:
     * User is allowed to browse through the node tree until the requested node.
     * 
     * ### Postcondition:
     * List of parent nodes is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestNodeParentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestNodeParentsResponse
     */
	public function requestNodeParents(
        \OpenAPI\OpenAPI\Models\Operations\RequestNodeParentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestNodeParentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/{node_id}/parents', \OpenAPI\OpenAPI\Models\Operations\RequestNodeParentsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestNodeParentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nodeParentList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NodeParentList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of nodes
     * 
     * ### Description:  
     * Provides a hierarchical list of file system nodes (rooms, folders or files) of a given parent that are accessible by the current user.
     * 
     * ### Precondition:
     * Authenticated user.
     * 
     * ### Postcondition:
     * List of nodes is returned.
     * 
     * ### Further Information:
     * `EncryptionInfo` is **NOT** provided.
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `type:eq:room:folder|perm:eq:read`  
     * Get nodes where type equals (`room` **OR** `folder`) **AND** user has `read` permissions.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | `type` | Node type filter | `eq` | Node type equals value.<br>Multiple values are allowed and will be connected via logical disjunction (**OR**).<br>e.g. `type:eq:room:folder` | <ul><li>`room`</li><li>`folder`</li><li>`file`</li></ul> |
     * | `perm` | Permission filter | `eq` | Permission equals value.<br>Multiple values are allowed and will be connected via logical disjunction (**OR**).<br>e.g. `perm:eq:read:create:delete` | <ul><li>`manage`</li><li>`read`</li><li>`change`</li><li>`create`</li><li>`delete`</li><li>`manageDownloadShare`</li><li>`manageUploadShare`</li><li>`canReadRecycleBin`</li><li>`canRestoreRecycleBin`</li><li>`canDeleteRecycleBin`</li></ul> |
     * | `childPerm` | Same as `perm`, but less restrictive (applies to child nodes only).<br>Child nodes of the parent node which do not meet the filter condition<br>are **NOT** returned. | `eq` | cf. `perm` | cf. `perm` |
     * | `name` | Node name filter | `cn, eq` | Node name contains / equals value. | `search String` |
     * | `encrypted` | Node encryption status filter | `eq` |  | `true or false` |
     * | `branchVersion` | Node branch version filter | `ge, le` | Branch version is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `branchVersion:ge:1423280937404`&#124;`branchVersion:le:1523280937404` | `version number` |
     * | `timestampCreation` | Creation timestamp filter | `ge, le` | Creation timestamp is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `timestampCreation:ge:2016-12-31T23:00:00.123`&#124;<br>`timestampCreation:le:2018-01-01T11:00:00.540` | `Date (yyyy-MM-dd)` |
     * | `timestampModification` | Modification timestamp filter | `ge, le` | Modification timestamp is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `timestampModification:ge:2016-12-31T23:00:00.123`&#124;<br>`timestampModification:le:2018-01-01T11:00:00.540` | `Date (yyyy-MM-dd)` |
     * | `referenceId`           | Reference ID filter               | `eq` | Reference ID equals value.   | `Integer ` |
     * </details>
     * 
     * ---
     * 
     * ### Sorting:
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.  
     * Nodes are sorted by type first, then by sent sort string.  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `name:desc|fileType:asc`  
     * Sort by `name` descending **AND** `fileType` ascending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `name` | Node name |
     * | `createdAt` | Creation date |
     * | `createdBy` | Creator first name, last name |
     * | `updatedAt` | Last modification date |
     * | `updatedBy` | Last modifier first name, last name |
     * | `fileType` | File type (extension) |
     * | `classification` | Classification ID:<ul><li>1 - public</li><li>2 - internal</li><li>3 - confidential</li><li>4 - strictly confidential</li></ul> |
     * | `size` | Node size |
     * | `cntDeletedVersions` | Number of deleted versions of this file / folder (**NOT** recursive; for files and folders only) |
     * | `timestampCreation` | Creation timestamp |
     * | `timestampModification` | Modification timestamp |
     * 
     * </details>
     * 
     * ### Deprecated sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | <del>`cntChildren`</del> | Number of direct children (**NOT** recursive; for rooms and folders only) |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestNodesResponse
     */
	public function requestNodes(
        \OpenAPI\OpenAPI\Models\Operations\RequestNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestNodesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nodeList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NodeList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request user-room assignments per group
     * 
     * ### Description:  
     * Requests a list of user-room assignments by groups that have **NOT** been approved yet  
     * These can have the state:
     * * **WAITING**  
     * * **DENIED**  
     * * **ACCEPTED**  
     * 
     * **ACCEPTED** assignments are already removed from the list.
     * 
     * ### Precondition:
     * None.
     * 
     * ### Postcondition:
     * List of user-room assignments is returned.
     * 
     * ### Further Information:
     * Room administrators **SHOULD** regularly request pending assingments to provide access to rooms for other users.
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `state:eq:WAITING`  
     * Filter assignments by state `WAITING`.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | `userId` | User ID filter | `eq` | User ID equals value. | `positive Integer` |
     * | `groupId` | Group ID filter | `eq` | Group ID equals value. | `positive Integer` |
     * | `roomId` | Room ID filter | `eq` | Room ID equals value. | `positive Integer` |
     * | `state` | Assignment state | `eq` | Assignment state equals value. | `WAITING or DENIED` |
     * 
     * </details>
     * 
     * ---
     * 
     * ### Sorting:
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `userId:desc|state:asc`  
     * Sort by `userId` descending **AND** `state` ascending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `userId` | User ID |
     * | `groupId` | Group ID |
     * | `roomId` | Room ID |
     * | `state` | State |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestPendingAssignmentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestPendingAssignmentsResponse
     */
	public function requestPendingAssignments(
        \OpenAPI\OpenAPI\Models\Operations\RequestPendingAssignmentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestPendingAssignmentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/pending');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestPendingAssignmentsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestPendingAssignmentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->pendingAssignmentList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\PendingAssignmentList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request events of a room
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.3.0</h3>
     * 
     * ### Description:
     * Retrieve syslog (audit log) events related to a room.
     * 
     * ### Precondition:
     * Requires <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions on that room.
     * 
     * ### Postcondition:
     * List of events is returned.
     * 
     * ### Further Information:
     * Output may be limited to a certain number of entries.  
     * Please use filter criteria and paging.
     * 
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort fields are supported.  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `time:desc`  
     * Sort by `time` descending (default sort option).
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `time` | Event timestamp |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonResponse
     */
	public function requestRoomActivitiesLogAsJson(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/events', \OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomActivitiesLogAsJsonResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->logEventList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\LogEventList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request room granted group(s) or / and group(s) that can be granted
     * 
     * ### Description:  
     * Retrieve a list of groups that are and / or can be granted to the room.
     * 
     * ### Precondition:
     * Any permissions on target room.
     * 
     * ### Postcondition:
     * List of groups is returned.
     * 
     * ### Further Information:
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `isGranted:eq:false|name:cn:searchString`  
     * Get all groups that are **NOT** granted to this room **AND** whose name is like `searchString`.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | `name` | Group name filter | `cn` | Group name contains value. | `search String` |
     * | `groupId` | Group ID filter | `eq` | Group ID equals value. | `positive Integer` |
     * | `isGranted` | Filter the groups that have (no) access to this room.<br>**This filter is only available for room administrators.**<br>**Other users can only look for groups in their rooms, so this filter is `true` and **CANNOT** be overridden.** | `eq` |  | <ul><li>`true`</li><li>`false`</li><li>`any`</li></ul>default: `true` |
     * | `permissionsManage` | Filter the groups that do (not) have `manage` permissions in this room. | `eq` |  | `true or false` |
     * | `effectivePerm` | Filter groups with DIRECT or DIRECT **AND** EFFECTIVE permissions<ul><li>`false`: DIRECT permissions</li><li>`true`: DIRECT **AND** EFFECTIVE permissions</li></ul>DIRECT means: e.g. room administrator grants `read` permissions to group of users **directly** on desired room.<br>EFFECTIVE means: e.g. group of users gets `read` permissions on desired room through **inheritance**. | `eq` |  | `true or false`<br>default: `false` |
     * 
     * </details>
     * 
     * ---
     * 
     * ### Sorting:
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `name:desc`  
     * Sort by `name` descending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `name` | Group name |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsResponse
     */
	public function requestRoomGroups(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/groups', \OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomGroupsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->roomGroupList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RoomGroupList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request Room Policies
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.32.0</h3>
     * 
     * ### Description:  
     * Retrieve the room policies:
     * * `defaultExpirationPeriod`
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in that room.
     * 
     * ### Postcondition:
     * Room Policies returned.
     * 
     * ### Further Information:
     * `defaultExpirationPeriod`: Default policy room expiration period in seconds.
     * All existing and future files in a room will have their expiration date set to this period after their respective upload.
     * Existing files can be set to expire earlier afterwards.
     * `0` means no default expiration policy will be enforced. 
     * 
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomPoliciesResponse
     */
	public function requestRoomPolicies(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/policies', \OpenAPI\OpenAPI\Models\Operations\RequestRoomPoliciesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->roomPolicies = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RoomPolicies', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request room rescue key
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.24.0</h3>
     * 
     * ### Description:  
     * Returns the file key for the room emergency password / rescue key of a certain file (if available).
     * 
     * ### Precondition:
     * User with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in parent room.
     * 
     * ### Postcondition:
     * File key is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyResponse
     */
	public function requestRoomRescueKey(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/{file_id}/data_room_file_key', \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileKey = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileKey', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request room rescue key
     * 
     * ### Description:  
     * Retrieve the room rescue key pair.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in that room.
     * 
     * ### Postcondition:
     * Key pair is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairResponse
     */
	public function requestRoomRescueKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/keypair', \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userKeyPairContainer = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserKeyPairContainer', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request all room rescue key pairs
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.24.0</h3>
     * 
     * ### Description:  
     * Retrieve all room rescue key pairs to allow migrating room-rescue-key-encrypted file keys.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in that room.
     * 
     * ### Postcondition:
     * List of key pairs is returned.
     * 
     * ### Further Information:
     * In the case of an algorithm migration to a room rescue key pair, one should create the new key pair before deleting the old one. This allows re-encrypting file keys with the new key pair, using the old one.
     * 
     * This API allows to retrieve both key pairs, in contrast to `GET /nodes/rooms/{room_id}/keypair`, which only delivers the preferred one.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairsResponse
     */
	public function requestRoomRescueKeyPairs(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/keypairs', \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomRescueKeyPairsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200 or $httpResponse->getStatusCode() === 204) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userKeyPairContainers = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\UserKeyPairContainer>', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request list of all assigned S3 tags to the room
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.9.0</h3>
     * 
     * ### Description:  
     * Retrieve a list of S3 tags assigned to a room.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * List of assigned S3 tags is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomS3TagsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomS3TagsResponse
     */
	public function requestRoomS3Tags(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomS3TagsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomS3TagsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/s3_tags', \OpenAPI\OpenAPI\Models\Operations\RequestRoomS3TagsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomS3TagsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->s3TagList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\S3TagList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request room granted user(s) or / and user(s) that can be granted
     * 
     * ### Description:  
     * Retrieve a list of users that are and / or can be granted to the room.
     * 
     * ### Precondition:
     * Any permissions on target room.
     * 
     * ### Postcondition:
     * None.
     * 
     * ### Further Information:
     * List of users is returned.
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * > `permissionsManage:eq:true|user:cn:searchString`  
     * Get all users that have `manage` permissions to this room **AND** whose (`firstName` **OR** `lastName` **OR** `email` **OR** `username`) is like `searchString`.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | `user` | User filter | `cn` | User contains value (`firstName` **OR** `lastName` **OR** `email` **OR** `username`). | `search String` |
     * | `userId` | User ID filter | `eq` | User ID equals value. | `positive Integer` |
     * | `isGranted` | Filter the users that have (no) access to this room.<br>**This filter is only available for room administrators.**<br>**Other users can only look for users in their rooms, so this filter is `true` and **CANNOT** be overridden.** | `eq` |  | <ul><li>`true`</li><li>`false`</li><li>`any`</li></ul>default: `true` |
     * | `permissionsManage` | Filter the users that do (not) have `manage` permissions in this room. | `eq` |  | `true or false` |
     * | `effectivePerm` | Filter users with DIRECT or DIRECT **AND** EFFECTIVE permissions<ul><li>`false`: DIRECT permissions</li><li>`true`: DIRECT **AND** EFFECTIVE permissions</li><li>`any`: DIRECT **AND** EFFECTIVE **AND** OVER GROUP permissions</li></ul>DIRECT means: e.g. room administrator grants `read` permissions to group of users **directly** on desired room.<br>EFFECTIVE means: e.g. group of users gets `read` permissions on desired room through **inheritance**.<br>OVER GROUP means: e.g. user gets `read` permissions on desired room through **group membership**. | `eq` |  | <ul><li>`true`</li><li>`false`</li><li>`any`</li></ul>default: `false` |
     * | `hasRole` | User role filter<br>For more Roles information please call `GET /roles API` | `eq`, `neq` | User role  equals value. | <ul><li>`CONFIG_MANAGER` - Manage global configs</li><li>`USER_MANAGER` - Manage Users</li><li>`GROUP_MANAGER` - Manage User-Groups</li><li>`ROOM_MANAGER` - Manage top level Data Rooms</li><li>`LOG_AUDITOR` - Read logs</li><li>`NONMEMBER_VIEWER` - View users and groups when having room manage permission</li><li>`USER` - Regular User role</li><li>`GUEST_USER` - Guest User role</li></ul> |
     * 
     * </details>
     * 
     * ### Deprecated filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Filter Description | `OPERATOR` | Operator Description | `VALUE` |
     * | :--- | :--- | :--- | :--- | :--- |
     * | <del>`displayName`</del> | User display name filter (use `user` filter) | `cn` | User display name contains value (`firstName` **OR** `lastName` **OR** `email`). | `search String` |
     * 
     * </details>
     * 
     * ---
     * 
     * ### Sorting:
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `user:desc`  
     * Sort by `user` descending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | **`user`** | User - sort by `firstName`, `lastName`, `username`, `email` (in this order) |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersResponse
     */
	public function requestRoomUsers(
        \OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/users', \OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestRoomUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->roomUserList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\RoomUserList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request system rescue key
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.24.0</h3>
     * 
     * ### Description:  
     * Returns the file key for the system emergency password / rescue key of a certain file (if available).
     * 
     * ### Precondition:
     * User with <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions in parent room.
     * 
     * ### Postcondition:
     * File key is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyResponse
     */
	public function requestSystemRescueKey(
        \OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/{file_id}/data_space_file_key', \OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestSystemRescueKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileKey = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileKey', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request status of S3 file upload
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.15.0</h3>
     * 
     * ### Description:
     * Request status of a S3 file upload.
     * 
     * ### Precondition:
     * An upload channel has been created and user has to be the creator of the upload channel.
     * 
     * ### Postcondition:
     * Status of S3 multipart upload request is returned.
     * 
     * ### Further Information:
     * None.
     * 
     * ### Possible errors:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | Http Status | Error Code | Description |
     * | :--- | :--- | :--- |
     * | `400 Bad Request` | `-80000` | Mandatory fields cannot be empty |
     * | `400 Bad Request` | `-80001` | Invalid positive number |
     * | `400 Bad Request` | `-80002` | Invalid number |
     * | `400 Bad Request` | `-40001` | (Target) room is not encrypted |
     * | `400 Bad Request` | `-40755` | Bad file name |
     * | `400 Bad Request` | `-40763` | File key must be set for an upload into encrypted room |
     * | `400 Bad Request` | `-50506` | Exceeds the number of files for this Upload Share |
     * | `403 Forbidden` |  | Access denied |
     * | `404 Not Found` | `-20501` | Upload not found |
     * | `404 Not Found` | `-40000` | Container not found |
     * | `404 Not Found` | `-41000` | Node not found |
     * | `404 Not Found` | `-70501` | User not found |
     * | `409 Conflict` | `-40010` | Container cannot be overwritten |
     * | `409 Conflict` |  | File cannot be overwritten |
     * | `500 Internal Server Error` |  | System Error |
     * | `502 Bad Gateway` |  | S3 Error |
     * | `502 Insufficient Storage` | `-50504` | Exceeds the quota for this Upload Share |
     * | `502 Insufficient Storage` | `-40200` | Exceeds the free node quota in room |
     * | `502 Insufficient Storage` | `-90200` | Exceeds the free customer quota |
     * | `502 Insufficient Storage` | `-90201` | Exceeds the free customer physical disk space |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusFilesResponse
     */
	public function requestUploadStatusFiles(
        \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusFilesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestUploadStatusFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->s3FileUploadStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\S3FileUploadStatus', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Request user's file key
     * 
     * ### Description:  
     * Returns the file key for the current user (if available).
     * 
     * ### Precondition:
     * User with one of the following permissions in parent room: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>
     * 
     * ### Postcondition:
     * File key is returned.
     * 
     * ### Further Information:
     * The symmetric file key is encrypted with the user's public key.  
     * File keys are generated with the workflow _"Generate file keys"_ that starts at `GET /nodes/missingFileKeys`.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyResponse
     */
	public function requestUserFileKey(
        \OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/{file_id}/user_file_key', \OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RequestUserFileKeyResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->fileKey = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\FileKey', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Restore deleted nodes
     * 
     * ### Description:  
     * Restore a list of deleted nodes.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; create</span> permissions in parent room and <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; restore recycle bin</span> permissions.
     * 
     * ### Postcondition:
     * The selected files are moved from the recycle bin to the chosen productive container.
     * 
     * ### Further Information:
     * If no parent ID is provided, the node is restored to its previous location.  
     * The default resolution strategy is `autorename` that adds numbers to the file name until the conflict is solved.  
     * If an existing file is overwritten, it is moved to the recycle bin instead of the restored one.
     * 
     * Download share id (if exists) gets changed if:
     * - node with the same name exists in the target container
     * - `resolutionStrategy` is `overwrite`
     * - `keepShareLinks` is `true`
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RestoreNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RestoreNodesResponse
     */
	public function restoreNodes(
        \OpenAPI\OpenAPI\Models\Operations\RestoreNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RestoreNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/deleted_nodes/actions/restore');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "restoreDeletedNodesRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RestoreNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Revoke granted group(s) from room
     * 
     * ### Description:  
     * Revoke granted groups from room.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Group's permissions are revoked.
     * 
     * ### Further Information:
     * Batch function.  
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RevokeRoomGroupsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RevokeRoomGroupsResponse
     */
	public function revokeRoomGroups(
        \OpenAPI\OpenAPI\Models\Operations\RevokeRoomGroupsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RevokeRoomGroupsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/groups', \OpenAPI\OpenAPI\Models\Operations\RevokeRoomGroupsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roomGroupsDeleteBatchRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RevokeRoomGroupsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Revoke granted user(s) from room
     * 
     * ### Description:  
     * Revoke granted users from room.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * User's permissions are revoked.
     * 
     * ### Further Information:
     * Batch function.  
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\RevokeRoomUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\RevokeRoomUsersResponse
     */
	public function revokeRoomUsers(
        \OpenAPI\OpenAPI\Models\Operations\RevokeRoomUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\RevokeRoomUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/users', \OpenAPI\OpenAPI\Models\Operations\RevokeRoomUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roomUsersDeleteBatchRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\RevokeRoomUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Search nodes
     * 
     * ### Description:  
     * Provides a flat list of file system nodes (rooms, folders or files) of a given parent that are accessible by the current user.
     * 
     * ### Precondition:
     * Authenticated user is allowed to <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128065; see</span> nodes (i.e. `isBrowsable = true`).
     * 
     * ### Postcondition:
     * List of nodes is returned.
     * 
     * ### Further Information:  
     * Output is limited to **500** entries.  
     * For more results please use filter criteria and paging (`offset` + `limit`).  
     * `EncryptionInfo` is **NOT** provided.  
     * Wildcard character is the asterisk character: `*`
     * 
     * ### Filtering:
     * All filter fields are connected via logical conjunction (**AND**)  
     * Filter string syntax: `FIELD_NAME:OPERATOR:VALUE[:VALUE...]`  
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `type:eq:file|createdAt:ge:2015-01-01`  
     * Get nodes where type equals `file` **AND** file creation date is **>=** `2015-01-01`.
     * 
     * </details>
     * 
     * ### Filtering options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME`            | Filter Description                | `OPERATOR` | Operator Description                                                                                                                                                                                                                                                                | `VALUE` |
     * |:------------------------|:----------------------------------| :--- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| :--- |
     * | `type`                  | Node type filter                  | `eq` | Node type equals value.<br>Multiple values are allowed and will be connected via logical disjunction (**OR**).<br>e.g. `type:eq:room:folder`                                                                                                                                        | <ul><li>`room`</li><li>`folder`</li><li>`file`</li></ul> |
     * | `fileType`              | File type filter (file extension) | `cn, eq` | File type contains / equals value.                                                                                                                                                                                                                                                  | `search String` |
     * | `classification`        | Classification filter             | `eq` | Classification equals value.                                                                                                                                                                                                                                                        | <ul><li>`1` - public</li><li>`2` - internal</li><li>`3` - confidential</li><li>`4` - strictly confidential</li></ul> |
     * | `createdBy`             | Creator login filter              | `cn, eq` | Creator login contains / equals value (`firstName` **OR** `lastName` **OR** `email` **OR** `username`).                                                                                                                                                                             | `search String` |
     * | `createdById`           | Creator ID filter                 | `eq` | Creator ID equals value.                                                                                                                                                                                                                                                            | `positive Integer  or -1 for external user` |
     * | `createdAt`             | Creation date filter              | `ge, le` | Creation date is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `createdAt:ge:2016-12-31`&#124;`createdAt:le:2018-01-01`                                                                | `Date (yyyy-MM-dd)` |
     * | `updatedBy`             | Last modifier login filter        | `cn, eq` | Last modifier login contains / equals value (`firstName` **OR** `lastName` **OR** `email` **OR** `username`).                                                                                                                                                                       | `search String` |
     * | `updatedById`           | Last modifier ID filter           | `eq` | Modifier ID equals value.                                                                                                                                                                                                                                                           | `positive Integer or -1 for external user` |
     * | `updatedAt`             | Last modification date filter     | `ge, le` | Last modification date is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `updatedAt:ge:2016-12-31`&#124;`updatedAt:le:2018-01-01`                                                       | `Date (yyyy-MM-dd)` |
     * | `expireAt`              | Expiration date filter            | `ge, le` | Expiration date is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `expireAt:ge:2016-12-31`&#124;`expireAt:le:2018-01-01`                                                                | `Date (yyyy-MM-dd)` |
     * | `size`                  | Node size filter                  | `ge, le` | Node size is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `size:ge:5`&#124;`size:le:10`                                                                                               | `size in bytes` |
     * | `isFavorite`            | Favorite filter                   | `eq` |                                                                                                                                                                                                                                                                                     | `true or false` |
     * | `branchVersion`         | Node branch version filter        | `ge, le` | Branch version is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `branchVersion:ge:1423280937404`&#124;`branchVersion:le:1523280937404`                                                 | `version number` |
     * | `parentPath`            | Parent path                       | `cn, eq` | Parent path contains / equals  value.                                                                                                                                                                                                                                               | `search String` |
     * | `timestampCreation`     | Creation timestamp filter         | `ge, le` | Creation timestamp is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `timestampCreation:ge:2016-12-31T23:00:00.123`&#124;<br>`timestampCreation:le:2018-01-01T11:00:00.540`             | `Date (yyyy-MM-dd)` |
     * | `timestampModification` | Modification timestamp filter     | `ge, le` | Modification timestamp is greater / less equals than value.<br>Multiple operator values are allowed and will be connected via logical conjunction (**AND**).<br>e.g. `timestampModification:ge:2016-12-31T23:00:00.123`&#124;<br>`timestampModification:le:2018-01-01T11:00:00.540` | `Date (yyyy-MM-dd)` |
     * | `referenceId`           | Reference ID filter               | `eq` | Reference ID equals value.                                                                                                                                                                                                                                                          | `Integer ` |
     * </details>
     * 
     * ---
     * 
     * ### Sorting:
     * Sort string syntax: `FIELD_NAME:ORDER`  
     * `ORDER` can be `asc` or `desc`.  
     * Multiple sort criteria are possible.  
     * Fields are connected via logical conjunction **AND**.
     * 
     * <details style="padding-left: 10px">
     * <summary style="cursor: pointer; outline: none"><strong>Example</strong></summary>
     * 
     * `name:desc|size:asc`  
     * Sort by `name` descending **AND** `size` ascending.
     * 
     * </details>
     * 
     * ### Sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | `name` | Node name |
     * | `createdAt` | Creation date |
     * | `createdBy` | Creator first name, last name |
     * | `updatedAt` | Last modification date |
     * | `updatedBy` | Last modifier first name, last name |
     * | `fileType` | File type (extension) |
     * | `classification` | Classification ID:<ul><li>1 - public</li><li>2 - internal</li><li>3 - confidential</li><li>4 - strictly confidential</li></ul> |
     * | `size` | Node size |
     * | `cntDeletedVersions` | Number of deleted versions of this file / folder (**NOT** recursive; for files and folders only) |
     * | `type` | Node type (room, folder, file) |
     * | `parentPath` | Parent path |
     * | `timestampCreation` | Creation timestamp |
     * | `timestampModification` | Modification timestamp |
     * 
     * </details>
     * 
     * ### Deprecated sorting options:
     * <details style="padding: 10px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px;">
     * <summary style="cursor: pointer; outline: none"><strong>Expand</strong></summary>
     * 
     * | `FIELD_NAME` | Description |
     * | :--- | :--- |
     * | <del>`cntChildren`</del> | Number of direct children (**NOT** recursive; for rooms and folders only) |
     * 
     * </details>
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SearchNodesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SearchNodesResponse
     */
	public function searchNodes(
        \OpenAPI\OpenAPI\Models\Operations\SearchNodesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SearchNodesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/search');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\SearchNodesRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SearchNodesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->nodeList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\NodeList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set room policies
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.32.0</h3>
     * 
     * ### Description:  
     * Retrieve the room policies:
     * * `defaultExpirationPeriod`
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Room policy is set.
     * 
     * ### Further Information:
     * `defaultExpirationPeriod`: Default policy room expiration period in seconds.
     * All existing and future files in a room will have their expiration date set to this period after their respective upload.
     * Existing files can be set to expire earlier afterwards.
     * `0` means no default expiration policy will be enforced. This removes all expiration dates from existing files.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetRoomPoliciesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetRoomPoliciesResponse
     */
	public function setRoomPolicies(
        \OpenAPI\OpenAPI\Models\Operations\SetRoomPoliciesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetRoomPoliciesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/policies', \OpenAPI\OpenAPI\Models\Operations\SetRoomPoliciesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roomPoliciesRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetRoomPoliciesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set room's rescue key pair
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.24.0</h3>
     * 
     * ### Description:  
     * Set room rescue key pair.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Key pair is set.
     * 
     * ### Further Information:
     * Room rescue key pair can be used to upgrade algorithm.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetRoomRescueKeyPairRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetRoomRescueKeyPairResponse
     */
	public function setRoomRescueKeyPair(
        \OpenAPI\OpenAPI\Models\Operations\SetRoomRescueKeyPairRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetRoomRescueKeyPairResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/keypair', \OpenAPI\OpenAPI\Models\Operations\SetRoomRescueKeyPairRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "userKeyPairContainer", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetRoomRescueKeyPairResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set S3 tags for a room
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.9.0</h3>
     * 
     * ### Description:  
     * Set S3 tags to a room.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>.
     * 
     * ### Postcondition:
     * Provided S3 tags are assigned to a room.
     * 
     * ### Further Information:
     * Every request overrides current S3 tags.  
     * Mandatory S3 tag IDs **MUST** be sent.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetRoomS3TagsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetRoomS3TagsResponse
     */
	public function setRoomS3Tags(
        \OpenAPI\OpenAPI\Models\Operations\SetRoomS3TagsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetRoomS3TagsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/s3_tags', \OpenAPI\OpenAPI\Models\Operations\SetRoomS3TagsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "s3TagIds", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetRoomS3TagsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->s3TagList = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\S3TagList', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Set file keys for a list of users and files
     * 
     * ### Description:  
     * Sets symmetric file keys for several users and files.
     * 
     * ### Precondition:
     * User has file keys for the files.  
     * Only settable by users that own one of the following permissions: <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; manage download share</span>, <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change config</span>
     * 
     * ### Postcondition:
     * Stores new file keys for other users.
     * 
     * ### Further Information:
     * Only users with copies of the file key (encrypted with their public keys) can access a certain file.  
     * This endpoint is used for the distribution of file keys amongst an authorized user base.  
     * User can set file key for himself.  
     * The users who already have a file key are ignored and keep the distributed file key
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SetUserFileKeysRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SetUserFileKeysResponse
     */
	public function setUserFileKeys(
        \OpenAPI\OpenAPI\Models\Operations\SetUserFileKeysRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SetUserFileKeysResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/keys');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "userFileKeySetBatchRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SetUserFileKeysResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Mark or unmark a list of nodes (room, folder or file) as favorite
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.25.0</h3>
     * 
     * ### Description:  
     * Marks or unmarks a list of nodes (room, folder or file) as favorite.
     * 
     * ### Precondition:
     * Authenticated user is allowed to <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128065; see</span> the node (i.e. `isBrowsable = true`).
     * 
     * ### Postcondition:
     * Nodes gets marked as favorite.
     * 
     * ### Further Information:
     * Maximum number of nodes is 200.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateFavoritesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateFavoritesResponse
     */
	public function updateFavorites(
        \OpenAPI\OpenAPI\Models\Operations\UpdateFavoritesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateFavoritesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/favorites');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateFavoritesBulkRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateFavoritesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Updates a files metadata
     * 
     * ### Description:
     * Updates a list of files metadata.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change</span> permissions in parent room.
     * 
     * ### Postcondition:
     * File's metadata is changed.
     * 
     * 
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateFileRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateFileResponse
     */
	public function updateFile(
        \OpenAPI\OpenAPI\Models\Operations\UpdateFileRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateFileResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/{file_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateFileRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateFileRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateFileResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates a list of  files metadata
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.25.0</h3>
     * 
     * ### Description:  
     * Updates a list of files metadata.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change</span> permissions in parent room.
     * 
     * ### Postcondition:
     * File's metadata is changed.
     * 
     * ### Further Information:
     * Maximum number of files is 200
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateFilesResponse
     */
	public function updateFiles(
        \OpenAPI\OpenAPI\Models\Operations\UpdateFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateFilesBulkRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, '*/*')) {
                $response->body = $httpResponse->getBody()->getContents();
            }
        }

        return $response;
    }
	
    /**
     * Updates folders metadata
     * 
     * ### Description:  
     * Updates folders metadata.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; change</span> permissions in parent room.
     * 
     * ### Postcondition:
     * Folder's metadata is changed.
     * 
     * ### Further Information:
     * Notes are limited to **255** characters.
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateFolderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateFolderResponse
     */
	public function updateFolder(
        \OpenAPI\OpenAPI\Models\Operations\UpdateFolderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateFolderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/folders/{folder_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateFolderRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateFolderRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateFolderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Edit node comment
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128640; Since v4.10.0</h3>
     * 
     * ### Description:
     * Edit the text of an existing comment for a specific node.
     * 
     * ### Precondition:
     * User has <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; read</span> permissions on the node and is the creator of the comment.
     * 
     * ### Postcondition:
     * Comments text gets changed.
     * 
     * ### Further Information:
     * Maximum allowed text length: **65535** characters.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateNodeCommentRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateNodeCommentResponse
     */
	public function updateNodeComment(
        \OpenAPI\OpenAPI\Models\Operations\UpdateNodeCommentRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateNodeCommentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/comments/{comment_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateNodeCommentRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "changeNodeCommentRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateNodeCommentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->comment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Comment', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Updates rooms metadata
     * 
     * ### Description:  
     * Updates rooms metadata.
     * 
     * ### Precondition:
     * User is a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span> at superordinated level.
     * 
     * ### Postcondition:
     * Room's metadata is changed.
     * 
     * ### Further Information:
     * Notes are limited to **255** characters.
     * 
     * ### Node naming convention:
     * * Node (room, folder, file) names are limited to **150** characters.
     * * Illegal names:  
     * `'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9', (and any of those with an extension)`
     * * Illegal characters in names:  
     * `'\\', '<','>', ':', '\"', '|', '?', '*', '/', leading '-', trailing '.' `
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRoomRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRoomResponse
     */
	public function updateRoom(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRoomRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRoomResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateRoomRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "updateRoomRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRoomResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->node = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Node', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 409 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add or change room granted group(s)
     * 
     * ### Description:
     * All existing group permissions will be overwritten.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>. To add new members, the user needs the right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; non-members add</span>, which is included in any role.
     * 
     * ### Postcondition:
     * Group's permissions are changed.
     * 
     * ### Further Information:
     * Batch function.  
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRoomGroupsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRoomGroupsResponse
     */
	public function updateRoomGroups(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRoomGroupsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRoomGroupsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/groups', \OpenAPI\OpenAPI\Models\Operations\UpdateRoomGroupsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roomGroupsAddBatchRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRoomGroupsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Add or change room granted user(s)
     * 
     * ### Description:
     * All existing user permissions will be overwritten.
     * 
     * ### Precondition:
     * User needs to be a <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128100; Room Administrator</span>. To add new members, the user needs the right <span style='padding: 3px; background-color: #F6F7F8; border: 1px solid #000; border-radius: 5px; display: inline;'>&#128275; non-members add</span>, which is included in any role.
     * 
     * ### Postcondition:
     * User's permissions are changed.
     * 
     * ### Further Information:
     * Batch function.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateRoomUsersRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateRoomUsersResponse
     */
	public function updateRoomUsers(
        \OpenAPI\OpenAPI\Models\Operations\UpdateRoomUsersRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateRoomUsersResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/rooms/{room_id}/users', \OpenAPI\OpenAPI\Models\Operations\UpdateRoomUsersRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "roomUsersAddBatchRequest", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateRoomUsersResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Upload file
     * 
     * <h3 style='padding: 5px; background-color: #F6F7F8; border: 1px solid #AAA; border-radius: 5px; display: table-cell;'>&#128679; Deprecated since v4.9.0</h3>
     * 
     * ### Use `uploads` API
     * 
     * ### Description:  
     * Uploads a file or parts of it in an active upload channel.
     * 
     * ### Precondition:
     * An upload channel has been created.
     * 
     * ### Postcondition:
     * A file or parts of it are uploaded to a temporary location.
     * 
     * ### Further Information:
     * This endpoints supports chunked upload.  
     * 
     * Following `Content-Types` are supported by this API:
     * * `multipart/form-data`
     * * provided `Content-Type`   
     * 
     * For both file upload types set the correct `Content-Type` header and body.  
     * 
     * ### Examples:  
     * 
     * * `multipart/form-data`
     * ```
     * POST /api/v4/nodes/files/uploads/{upload_id} HTTP/1.1
     * 
     * Header:
     * ...
     * Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
     * ...
     * 
     * Body:
     * ------WebKitFormBoundary7MA4YWxkTrZu0gW
     * Content-Disposition: form-data; name="file"; filename="file.txt"
     * Content-Type: text/plain
     * 
     * Content of file.txt
     * ------WebKitFormBoundary7MA4YWxkTrZu0gW--
     * ```
     * 
     * * any other `Content-Type`  
     * ```
     * POST /api/v4/nodes/files/uploads/{upload_id}  HTTP/1.1
     * 
     * Header:
     * ...
     * Content-Type: { ... }
     * ...
     * 
     * Body:
     * raw content
     * ```
     * https://tools.ietf.org/html/rfc7233 - Range Requests
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartResponse
     * @see https://tools.ietf.org/html/rfc7233
     */
	public function uploadFileAsMultipart(
        \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v4/nodes/files/uploads/{upload_id}', \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "multipart");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UploadFileAsMultipartResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->chunkUploadResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ChunkUploadResponse', 'json');
            }
        }
        else if ($httpResponse->getStatusCode() === 400 or $httpResponse->getStatusCode() === 401 or $httpResponse->getStatusCode() === 403 or $httpResponse->getStatusCode() === 404 or $httpResponse->getStatusCode() === 406 or $httpResponse->getStatusCode() === 412 or $httpResponse->getStatusCode() === 507) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->errorResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ErrorResponse', 'json');
            }
        }

        return $response;
    }
}