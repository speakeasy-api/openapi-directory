"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

SERVERS = [
    "https://serverless.twilio.com",
]
"""Contains the list of servers available to the SDK"""

class SDK:
    r"""This is the public Twilio REST API."""

    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str = SERVERS[0]
    _language: str = "python"
    _sdk_version: str = "0.0.1"
    _gen_version: str = "internal"

    def __init__(self,
                 server_url: str = None,
                 url_params: dict[str, str] = None,
                 client: requests_http.Session = None
                 ) -> None:
        """Instantiates the SDK configuring it with the provided parameters.
        
        :param server_url: The server URL to use for all operations
        :type server_url: str
        :param url_params: Parameters to optionally template the server URL with
        :type url_params: dict[str, str]
        :param client: The requests.Session HTTP client to use for all operations
        :type client: requests_http.Session        
        """
        self._client = requests_http.Session()
        
        
        if server_url is not None:
            if url_params is not None:
                self._server_url = utils.template_url(server_url, url_params)
            else:
                self._server_url = server_url

        if client is not None:
            self._client = client
        
        self._security_client = self._client
        

        
    
    
    def create_asset(self, request: operations.CreateAssetRequest, security: operations.CreateAssetSecurity, server_url: Optional[str] = None) -> operations.CreateAssetResponse:
        r"""Create a new Asset resource."""
        base_url = operations.CREATE_ASSET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateAssetRequest, base_url, '/v1/Services/{ServiceSid}/Assets', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateAssetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceAsset])
                res.serverless_v1_service_asset = out

        return res

    def create_build(self, request: operations.CreateBuildRequest, security: operations.CreateBuildSecurity, server_url: Optional[str] = None) -> operations.CreateBuildResponse:
        r"""Create a new Build resource. At least one function version or asset version is required."""
        base_url = operations.CREATE_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateBuildRequest, base_url, '/v1/Services/{ServiceSid}/Builds', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceBuild])
                res.serverless_v1_service_build = out

        return res

    def create_deployment(self, request: operations.CreateDeploymentRequest, security: operations.CreateDeploymentSecurity, server_url: Optional[str] = None) -> operations.CreateDeploymentResponse:
        r"""Create a new Deployment."""
        base_url = operations.CREATE_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateDeploymentRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironmentDeployment])
                res.serverless_v1_service_environment_deployment = out

        return res

    def create_environment(self, request: operations.CreateEnvironmentRequest, security: operations.CreateEnvironmentSecurity, server_url: Optional[str] = None) -> operations.CreateEnvironmentResponse:
        r"""Create a new environment."""
        base_url = operations.CREATE_ENVIRONMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateEnvironmentRequest, base_url, '/v1/Services/{ServiceSid}/Environments', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateEnvironmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironment])
                res.serverless_v1_service_environment = out

        return res

    def create_function(self, request: operations.CreateFunctionRequest, security: operations.CreateFunctionSecurity, server_url: Optional[str] = None) -> operations.CreateFunctionResponse:
        r"""Create a new Function resource."""
        base_url = operations.CREATE_FUNCTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateFunctionRequest, base_url, '/v1/Services/{ServiceSid}/Functions', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateFunctionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceFunction])
                res.serverless_v1_service_function = out

        return res

    def create_service(self, request: operations.CreateServiceCreateServiceRequest, security: operations.CreateServiceSecurity, server_url: Optional[str] = None) -> operations.CreateServiceResponse:
        r"""Create a new Service resource."""
        base_url = operations.CREATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1Service])
                res.serverless_v1_service = out

        return res

    def create_variable(self, request: operations.CreateVariableRequest, security: operations.CreateVariableSecurity, server_url: Optional[str] = None) -> operations.CreateVariableResponse:
        r"""Create a new Variable."""
        base_url = operations.CREATE_VARIABLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.CreateVariableRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironmentVariable])
                res.serverless_v1_service_environment_variable = out

        return res

    def delete_asset(self, request: operations.DeleteAssetRequest, security: operations.DeleteAssetSecurity, server_url: Optional[str] = None) -> operations.DeleteAssetResponse:
        r"""Delete an Asset resource."""
        base_url = operations.DELETE_ASSET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteAssetRequest, base_url, '/v1/Services/{ServiceSid}/Assets/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAssetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_build(self, request: operations.DeleteBuildRequest, security: operations.DeleteBuildSecurity, server_url: Optional[str] = None) -> operations.DeleteBuildResponse:
        r"""Delete a Build resource."""
        base_url = operations.DELETE_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteBuildRequest, base_url, '/v1/Services/{ServiceSid}/Builds/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_environment(self, request: operations.DeleteEnvironmentRequest, security: operations.DeleteEnvironmentSecurity, server_url: Optional[str] = None) -> operations.DeleteEnvironmentResponse:
        r"""Delete a specific environment."""
        base_url = operations.DELETE_ENVIRONMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteEnvironmentRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteEnvironmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_function(self, request: operations.DeleteFunctionRequest, security: operations.DeleteFunctionSecurity, server_url: Optional[str] = None) -> operations.DeleteFunctionResponse:
        r"""Delete a Function resource."""
        base_url = operations.DELETE_FUNCTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteFunctionRequest, base_url, '/v1/Services/{ServiceSid}/Functions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteFunctionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_service(self, request: operations.DeleteServiceRequest, security: operations.DeleteServiceSecurity, server_url: Optional[str] = None) -> operations.DeleteServiceResponse:
        r"""Delete a Service resource."""
        base_url = operations.DELETE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def delete_variable(self, request: operations.DeleteVariableRequest, security: operations.DeleteVariableSecurity, server_url: Optional[str] = None) -> operations.DeleteVariableResponse:
        r"""Delete a specific Variable."""
        base_url = operations.DELETE_VARIABLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.DeleteVariableRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        

        return res

    def fetch_asset(self, request: operations.FetchAssetRequest, security: operations.FetchAssetSecurity, server_url: Optional[str] = None) -> operations.FetchAssetResponse:
        r"""Retrieve a specific Asset resource."""
        base_url = operations.FETCH_ASSET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAssetRequest, base_url, '/v1/Services/{ServiceSid}/Assets/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAssetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceAsset])
                res.serverless_v1_service_asset = out

        return res

    def fetch_asset_version(self, request: operations.FetchAssetVersionRequest, security: operations.FetchAssetVersionSecurity, server_url: Optional[str] = None) -> operations.FetchAssetVersionResponse:
        r"""Retrieve a specific Asset Version."""
        base_url = operations.FETCH_ASSET_VERSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchAssetVersionRequest, base_url, '/v1/Services/{ServiceSid}/Assets/{AssetSid}/Versions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchAssetVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceAssetAssetVersion])
                res.serverless_v1_service_asset_asset_version = out

        return res

    def fetch_build(self, request: operations.FetchBuildRequest, security: operations.FetchBuildSecurity, server_url: Optional[str] = None) -> operations.FetchBuildResponse:
        r"""Retrieve a specific Build resource."""
        base_url = operations.FETCH_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBuildRequest, base_url, '/v1/Services/{ServiceSid}/Builds/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceBuild])
                res.serverless_v1_service_build = out

        return res

    def fetch_build_status(self, request: operations.FetchBuildStatusRequest, security: operations.FetchBuildStatusSecurity, server_url: Optional[str] = None) -> operations.FetchBuildStatusResponse:
        r"""Retrieve a specific Build resource."""
        base_url = operations.FETCH_BUILD_STATUS_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchBuildStatusRequest, base_url, '/v1/Services/{ServiceSid}/Builds/{Sid}/Status', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchBuildStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceBuildBuildStatus])
                res.serverless_v1_service_build_build_status = out

        return res

    def fetch_deployment(self, request: operations.FetchDeploymentRequest, security: operations.FetchDeploymentSecurity, server_url: Optional[str] = None) -> operations.FetchDeploymentResponse:
        r"""Retrieve a specific Deployment."""
        base_url = operations.FETCH_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchDeploymentRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironmentDeployment])
                res.serverless_v1_service_environment_deployment = out

        return res

    def fetch_environment(self, request: operations.FetchEnvironmentRequest, security: operations.FetchEnvironmentSecurity, server_url: Optional[str] = None) -> operations.FetchEnvironmentResponse:
        r"""Retrieve a specific environment."""
        base_url = operations.FETCH_ENVIRONMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchEnvironmentRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchEnvironmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironment])
                res.serverless_v1_service_environment = out

        return res

    def fetch_function(self, request: operations.FetchFunctionRequest, security: operations.FetchFunctionSecurity, server_url: Optional[str] = None) -> operations.FetchFunctionResponse:
        r"""Retrieve a specific Function resource."""
        base_url = operations.FETCH_FUNCTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFunctionRequest, base_url, '/v1/Services/{ServiceSid}/Functions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFunctionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceFunction])
                res.serverless_v1_service_function = out

        return res

    def fetch_function_version(self, request: operations.FetchFunctionVersionRequest, security: operations.FetchFunctionVersionSecurity, server_url: Optional[str] = None) -> operations.FetchFunctionVersionResponse:
        r"""Retrieve a specific Function Version resource."""
        base_url = operations.FETCH_FUNCTION_VERSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFunctionVersionRequest, base_url, '/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFunctionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceFunctionFunctionVersion])
                res.serverless_v1_service_function_function_version = out

        return res

    def fetch_function_version_content(self, request: operations.FetchFunctionVersionContentRequest, security: operations.FetchFunctionVersionContentSecurity, server_url: Optional[str] = None) -> operations.FetchFunctionVersionContentResponse:
        r"""Retrieve a the content of a specific Function Version resource."""
        base_url = operations.FETCH_FUNCTION_VERSION_CONTENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchFunctionVersionContentRequest, base_url, '/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions/{Sid}/Content', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchFunctionVersionContentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceFunctionFunctionVersionFunctionVersionContent])
                res.serverless_v1_service_function_function_version_function_version_content = out

        return res

    def fetch_log(self, request: operations.FetchLogRequest, security: operations.FetchLogSecurity, server_url: Optional[str] = None) -> operations.FetchLogResponse:
        r"""Retrieve a specific log."""
        base_url = operations.FETCH_LOG_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchLogRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Logs/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchLogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironmentLog])
                res.serverless_v1_service_environment_log = out

        return res

    def fetch_service(self, request: operations.FetchServiceRequest, security: operations.FetchServiceSecurity, server_url: Optional[str] = None) -> operations.FetchServiceResponse:
        r"""Retrieve a specific Service resource."""
        base_url = operations.FETCH_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1Service])
                res.serverless_v1_service = out

        return res

    def fetch_variable(self, request: operations.FetchVariableRequest, security: operations.FetchVariableSecurity, server_url: Optional[str] = None) -> operations.FetchVariableResponse:
        r"""Retrieve a specific Variable."""
        base_url = operations.FETCH_VARIABLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.FetchVariableRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironmentVariable])
                res.serverless_v1_service_environment_variable = out

        return res

    def list_asset(self, request: operations.ListAssetRequest, security: operations.ListAssetSecurity, server_url: Optional[str] = None) -> operations.ListAssetResponse:
        r"""Retrieve a list of all Assets."""
        base_url = operations.LIST_ASSET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAssetRequest, base_url, '/v1/Services/{ServiceSid}/Assets', request)
        
        query_params = utils.get_query_params(operations.ListAssetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAssetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAssetListAssetResponse])
                res.list_asset_response = out

        return res

    def list_asset_version(self, request: operations.ListAssetVersionRequest, security: operations.ListAssetVersionSecurity, server_url: Optional[str] = None) -> operations.ListAssetVersionResponse:
        r"""Retrieve a list of all Asset Versions."""
        base_url = operations.LIST_ASSET_VERSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListAssetVersionRequest, base_url, '/v1/Services/{ServiceSid}/Assets/{AssetSid}/Versions', request)
        
        query_params = utils.get_query_params(operations.ListAssetVersionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListAssetVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListAssetVersionListAssetVersionResponse])
                res.list_asset_version_response = out

        return res

    def list_build(self, request: operations.ListBuildRequest, security: operations.ListBuildSecurity, server_url: Optional[str] = None) -> operations.ListBuildResponse:
        r"""Retrieve a list of all Builds."""
        base_url = operations.LIST_BUILD_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListBuildRequest, base_url, '/v1/Services/{ServiceSid}/Builds', request)
        
        query_params = utils.get_query_params(operations.ListBuildRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListBuildResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListBuildListBuildResponse])
                res.list_build_response = out

        return res

    def list_deployment(self, request: operations.ListDeploymentRequest, security: operations.ListDeploymentSecurity, server_url: Optional[str] = None) -> operations.ListDeploymentResponse:
        r"""Retrieve a list of all Deployments."""
        base_url = operations.LIST_DEPLOYMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListDeploymentRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Deployments', request)
        
        query_params = utils.get_query_params(operations.ListDeploymentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListDeploymentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListDeploymentListDeploymentResponse])
                res.list_deployment_response = out

        return res

    def list_environment(self, request: operations.ListEnvironmentRequest, security: operations.ListEnvironmentSecurity, server_url: Optional[str] = None) -> operations.ListEnvironmentResponse:
        r"""Retrieve a list of all environments."""
        base_url = operations.LIST_ENVIRONMENT_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListEnvironmentRequest, base_url, '/v1/Services/{ServiceSid}/Environments', request)
        
        query_params = utils.get_query_params(operations.ListEnvironmentRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListEnvironmentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListEnvironmentListEnvironmentResponse])
                res.list_environment_response = out

        return res

    def list_function(self, request: operations.ListFunctionRequest, security: operations.ListFunctionSecurity, server_url: Optional[str] = None) -> operations.ListFunctionResponse:
        r"""Retrieve a list of all Functions."""
        base_url = operations.LIST_FUNCTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListFunctionRequest, base_url, '/v1/Services/{ServiceSid}/Functions', request)
        
        query_params = utils.get_query_params(operations.ListFunctionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFunctionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListFunctionListFunctionResponse])
                res.list_function_response = out

        return res

    def list_function_version(self, request: operations.ListFunctionVersionRequest, security: operations.ListFunctionVersionSecurity, server_url: Optional[str] = None) -> operations.ListFunctionVersionResponse:
        r"""Retrieve a list of all Function Version resources."""
        base_url = operations.LIST_FUNCTION_VERSION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListFunctionVersionRequest, base_url, '/v1/Services/{ServiceSid}/Functions/{FunctionSid}/Versions', request)
        
        query_params = utils.get_query_params(operations.ListFunctionVersionRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListFunctionVersionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListFunctionVersionListFunctionVersionResponse])
                res.list_function_version_response = out

        return res

    def list_log(self, request: operations.ListLogRequest, security: operations.ListLogSecurity, server_url: Optional[str] = None) -> operations.ListLogResponse:
        r"""Retrieve a list of all logs."""
        base_url = operations.LIST_LOG_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListLogRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Logs', request)
        
        query_params = utils.get_query_params(operations.ListLogRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListLogResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListLogListLogResponse])
                res.list_log_response = out

        return res

    def list_service(self, request: operations.ListServiceRequest, security: operations.ListServiceSecurity, server_url: Optional[str] = None) -> operations.ListServiceResponse:
        r"""Retrieve a list of all Services."""
        base_url = operations.LIST_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/v1/Services'
        
        query_params = utils.get_query_params(operations.ListServiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListServiceListServiceResponse])
                res.list_service_response = out

        return res

    def list_variable(self, request: operations.ListVariableRequest, security: operations.ListVariableSecurity, server_url: Optional[str] = None) -> operations.ListVariableResponse:
        r"""Retrieve a list of all Variables."""
        base_url = operations.LIST_VARIABLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ListVariableRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables', request)
        
        query_params = utils.get_query_params(operations.ListVariableRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.ListVariableListVariableResponse])
                res.list_variable_response = out

        return res

    def update_asset(self, request: operations.UpdateAssetRequest, security: operations.UpdateAssetSecurity, server_url: Optional[str] = None) -> operations.UpdateAssetResponse:
        r"""Update a specific Asset resource."""
        base_url = operations.UPDATE_ASSET_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateAssetRequest, base_url, '/v1/Services/{ServiceSid}/Assets/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateAssetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceAsset])
                res.serverless_v1_service_asset = out

        return res

    def update_function(self, request: operations.UpdateFunctionRequest, security: operations.UpdateFunctionSecurity, server_url: Optional[str] = None) -> operations.UpdateFunctionResponse:
        r"""Update a specific Function resource."""
        base_url = operations.UPDATE_FUNCTION_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateFunctionRequest, base_url, '/v1/Services/{ServiceSid}/Functions/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateFunctionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceFunction])
                res.serverless_v1_service_function = out

        return res

    def update_service(self, request: operations.UpdateServiceRequest, security: operations.UpdateServiceSecurity, server_url: Optional[str] = None) -> operations.UpdateServiceResponse:
        r"""Update a specific Service resource."""
        base_url = operations.UPDATE_SERVICE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateServiceRequest, base_url, '/v1/Services/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateServiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1Service])
                res.serverless_v1_service = out

        return res

    def update_variable(self, request: operations.UpdateVariableRequest, security: operations.UpdateVariableSecurity, server_url: Optional[str] = None) -> operations.UpdateVariableResponse:
        r"""Update a specific Variable."""
        base_url = operations.UPDATE_VARIABLE_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.UpdateVariableRequest, base_url, '/v1/Services/{ServiceSid}/Environments/{EnvironmentSid}/Variables/{Sid}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'form')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateVariableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ServerlessV1ServiceEnvironmentVariable])
                res.serverless_v1_service_environment_variable = out

        return res

    