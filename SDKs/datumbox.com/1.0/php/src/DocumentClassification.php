<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class DocumentClassification 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Classifies the Document as adult or noadult
     * 
     * The Adult Content Detection function classifies the documents as adult or noadult based on their context. It can be used to detect whether a document contains content unsuitable for minors.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\AdultContentDetectionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AdultContentDetectionResponse
     */
	public function adultContentDetection(
        \OpenAPI\OpenAPI\Models\Operations\AdultContentDetectionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AdultContentDetectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/AdultContentDetection.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AdultContentDetectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Classifies the Document as commercial or nocommercial
     * 
     * The Commercial Detection function labels the documents as commercial or non-commercial based on their keywords and expressions. It can be used to detect whether a website is commercial or not.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CommercialDetectionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CommercialDetectionResponse
     */
	public function commercialDetection(
        \OpenAPI\OpenAPI\Models\Operations\CommercialDetectionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CommercialDetectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/CommercialDetection.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CommercialDetectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Classifies the Document as educational or noeducational
     * 
     * The Educational Detection function classifies the documents as educational or non-educational based on their context. It can be used to detect whether a website is educational or not.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\EducationalDetectionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\EducationalDetectionResponse
     */
	public function educationalDetection(
        \OpenAPI\OpenAPI\Models\Operations\EducationalDetectionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\EducationalDetectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/EducationalDetection.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\EducationalDetectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Gender Detection Service
     * 
     * The Gender Detection function identifies if a particular document is written-by or targets-to a man or a woman based on the context, the words and the idioms found in the text.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GenderDetectionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GenderDetectionResponse
     */
	public function genderDetection(
        \OpenAPI\OpenAPI\Models\Operations\GenderDetectionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GenderDetectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/GenderDetection.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GenderDetectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Identifies the Language of the Document
     * 
     * The Language Detection function identifies the natural language of the given document based on its words and context. This classifier is able to detect 96 different languages.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDetectionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDetectionResponse
     */
	public function languageDetection(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDetectionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDetectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/LanguageDetection.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDetectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Evaluates the Readability of the Document
     * 
     * The Readability Assessment function determines the degree of readability of a document based on its terms and idioms. The texts are classified as basic, intermediate and advanced depending their difficulty.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReadabilityAssessmentRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReadabilityAssessmentResponse
     */
	public function readabilityAssessment(
        \OpenAPI\OpenAPI\Models\Operations\ReadabilityAssessmentRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReadabilityAssessmentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/ReadabilityAssessment.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReadabilityAssessmentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Identifies the Sentiment of the Document
     * 
     * The Sentiment Analysis function classifies documents as positive, negative or neutral (lack of sentiment) depending on whether they express a positive, negative or neutral opinion.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SentimentAnalysisRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SentimentAnalysisResponse
     */
	public function sentimentAnalysis(
        \OpenAPI\OpenAPI\Models\Operations\SentimentAnalysisRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SentimentAnalysisResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/SentimentAnalysis.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SentimentAnalysisResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Classifies the Document as spam or nospam
     * 
     * The Spam Detection function labels documents as spam or nospam by taking into account their context. It can be used to filter out spam emails and comments.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SpamDetectionRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SpamDetectionResponse
     */
	public function spamDetection(
        \OpenAPI\OpenAPI\Models\Operations\SpamDetectionRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SpamDetectionResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/SpamDetection.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SpamDetectionResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Classifies Document as Subjective or Objective
     * 
     * The Subjectivity Analysis function categorizes documents as subjective or objective based on their writing style. Texts that express personal opinions are labeled as subjective and the others as objective.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\SubjectivityAnalysisRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\SubjectivityAnalysisResponse
     */
	public function subjectivityAnalysis(
        \OpenAPI\OpenAPI\Models\Operations\SubjectivityAnalysisRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\SubjectivityAnalysisResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/SubjectivityAnalysis.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\SubjectivityAnalysisResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Identifies the Topic of the Document
     * 
     * The Topic Classification function assigns documents in 12 thematic categories based on their keywords, idioms and jargon. It can be used to identify the topic of the texts.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\TopicClassificationRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\TopicClassificationResponse
     */
	public function topicClassification(
        \OpenAPI\OpenAPI\Models\Operations\TopicClassificationRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\TopicClassificationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/TopicClassification.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TopicClassificationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Identifies the Sentiment of Twitter Messages
     * 
     * The Twitter Sentiment Analysis function allows you to perform Sentiment Analysis on Twitter. It classifies the tweets as positive, negative or neutral depending on their context.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\TwitterSentimentAnalysisRequestBody $request
     * @return \OpenAPI\OpenAPI\Models\Operations\TwitterSentimentAnalysisResponse
     */
	public function twitterSentimentAnalysis(
        \OpenAPI\OpenAPI\Models\Operations\TwitterSentimentAnalysisRequestBody $request,
    ): \OpenAPI\OpenAPI\Models\Operations\TwitterSentimentAnalysisResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/1.0/TwitterSentimentAnalysis.json');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "form");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\TwitterSentimentAnalysisResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
}