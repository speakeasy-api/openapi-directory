/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * The Storage service allows you to manage your project files.
 */
export class Storage {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Create File
   *
   * @remarks
   * Create a new file. The user who creates the file will automatically be assigned to read and write access unless he has passed custom values for read and write arguments.
   */
  storageCreateFile(
    req: operations.StorageCreateFileRequestBody,
    security: operations.StorageCreateFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageCreateFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageCreateFileRequestBody(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/storage/files";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageCreateFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageCreateFileResponse =
        new operations.StorageCreateFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete File
   *
   * @remarks
   * Delete a file by its unique ID. Only users with write permissions have access to delete this resource.
   */
  storageDeleteFile(
    req: operations.StorageDeleteFileRequest,
    security: operations.StorageDeleteFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageDeleteFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageDeleteFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/storage/files/{fileId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageDeleteFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageDeleteFileResponse =
        new operations.StorageDeleteFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Get File
   *
   * @remarks
   * Get a file by its unique ID. This endpoint response returns a JSON object with the file metadata.
   */
  storageGetFile(
    req: operations.StorageGetFileRequest,
    security: operations.StorageGetFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageGetFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageGetFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/storage/files/{fileId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageGetFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageGetFileResponse =
        new operations.StorageGetFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get File for Download
   *
   * @remarks
   * Get a file content by its unique ID. The endpoint response return with a 'Content-Disposition: attachment' header that tells the browser to start downloading the file to user downloads directory.
   */
  storageGetFileDownload(
    req: operations.StorageGetFileDownloadRequest,
    security: operations.StorageGetFileDownloadSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageGetFileDownloadResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageGetFileDownloadRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/storage/files/{fileId}/download",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageGetFileDownloadSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageGetFileDownloadResponse =
        new operations.StorageGetFileDownloadResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get File Preview
   *
   * @remarks
   * Get a file preview image. Currently, this method supports preview for image files (jpg, png, and gif), other supported formats, like pdf, docs, slides, and spreadsheets, will return the file icon image. You can also pass query string arguments for cutting and resizing your preview image.
   */
  storageGetFilePreview(
    req: operations.StorageGetFilePreviewRequest,
    security: operations.StorageGetFilePreviewSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageGetFilePreviewResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageGetFilePreviewRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/storage/files/{fileId}/preview",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageGetFilePreviewSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageGetFilePreviewResponse =
        new operations.StorageGetFilePreviewResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Get File for View
   *
   * @remarks
   * Get a file content by its unique ID. This endpoint is similar to the download method but returns with no  'Content-Disposition: attachment' header.
   */
  storageGetFileView(
    req: operations.StorageGetFileViewRequest,
    security: operations.StorageGetFileViewSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageGetFileViewResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageGetFileViewRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/storage/files/{fileId}/view",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageGetFileViewSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageGetFileViewResponse =
        new operations.StorageGetFileViewResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * List Files
   *
   * @remarks
   * Get a list of all the user files. You can use the query params to filter your results. On admin mode, this endpoint will return a list of all of the project's files. [Learn more about different API modes](/docs/admin).
   */
  storageListFiles(
    req: operations.StorageListFilesRequest,
    security: operations.StorageListFilesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageListFilesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageListFilesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/storage/files";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageListFilesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageListFilesResponse =
        new operations.StorageListFilesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fileList = utils.objectToClass(httpRes?.data, shared.FileList);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update File
   *
   * @remarks
   * Update a file by its unique ID. Only users with write permissions have access to update this resource.
   */
  storageUpdateFile(
    req: operations.StorageUpdateFileRequest,
    security: operations.StorageUpdateFileSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.StorageUpdateFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.StorageUpdateFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/storage/files/{fileId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.StorageUpdateFileSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.StorageUpdateFileResponse =
        new operations.StorageUpdateFileResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.file = utils.objectToClass(httpRes?.data, shared.File);
          }
          break;
      }

      return res;
    });
  }
}
