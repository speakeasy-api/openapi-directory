/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Roles {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a role by name
   */
  deleteRealmClientsIdRolesRoleName(
    req: operations.DeleteRealmClientsIdRolesRoleNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmClientsIdRolesRoleNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmClientsIdRolesRoleNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmClientsIdRolesRoleNameResponse =
        new operations.DeleteRealmClientsIdRolesRoleNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Remove roles from the role’s composite
   */
  deleteRealmClientsIdRolesRoleNameComposites(
    req: operations.DeleteRealmClientsIdRolesRoleNameCompositesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmClientsIdRolesRoleNameCompositesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmClientsIdRolesRoleNameCompositesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/composites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmClientsIdRolesRoleNameCompositesResponse =
        new operations.DeleteRealmClientsIdRolesRoleNameCompositesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a role by name
   */
  deleteRealmRolesRoleName(
    req: operations.DeleteRealmRolesRoleNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmRolesRoleNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmRolesRoleNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmRolesRoleNameResponse =
        new operations.DeleteRealmRolesRoleNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Remove roles from the role’s composite
   */
  deleteRealmRolesRoleNameComposites(
    req: operations.DeleteRealmRolesRoleNameCompositesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteRealmRolesRoleNameCompositesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteRealmRolesRoleNameCompositesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/composites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteRealmRolesRoleNameCompositesResponse =
        new operations.DeleteRealmRolesRoleNameCompositesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Get all roles for the realm or client
   */
  getRealmClientsIdRoles(
    req: operations.GetRealmClientsIdRolesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmClientsIdRolesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesResponse =
        new operations.GetRealmClientsIdRolesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a role by name
   */
  getRealmClientsIdRolesRoleName(
    req: operations.GetRealmClientsIdRolesRoleNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmClientsIdRolesRoleNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameResponse =
        new operations.GetRealmClientsIdRolesRoleNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentation = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get composites of the role
   */
  getRealmClientsIdRolesRoleNameComposites(
    req: operations.GetRealmClientsIdRolesRoleNameCompositesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameCompositesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmClientsIdRolesRoleNameCompositesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/composites",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameCompositesResponse =
        new operations.GetRealmClientsIdRolesRoleNameCompositesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * An app-level roles for the specified app for the role’s composite
   */
  getRealmClientsIdRolesRoleNameCompositesClientsClient(
    req: operations.GetRealmClientsIdRolesRoleNameCompositesClientsClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameCompositesClientsClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmClientsIdRolesRoleNameCompositesClientsClientRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/composites/clients/{client}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameCompositesClientsClientResponse =
        new operations.GetRealmClientsIdRolesRoleNameCompositesClientsClientResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get realm-level roles of the role’s composite
   */
  getRealmClientsIdRolesRoleNameCompositesRealm(
    req: operations.GetRealmClientsIdRolesRoleNameCompositesRealmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameCompositesRealmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmClientsIdRolesRoleNameCompositesRealmRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/composites/realm",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameCompositesRealmResponse =
        new operations.GetRealmClientsIdRolesRoleNameCompositesRealmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return List of Groups that have the specified role name
   */
  getRealmClientsIdRolesRoleNameGroups(
    req: operations.GetRealmClientsIdRolesRoleNameGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmClientsIdRolesRoleNameGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/groups",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameGroupsResponse =
        new operations.GetRealmClientsIdRolesRoleNameGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groupRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.GroupRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return object stating whether role Authoirzation permissions have been initialized or not and a reference
   */
  getRealmClientsIdRolesRoleNameManagementPermissions(
    req: operations.GetRealmClientsIdRolesRoleNameManagementPermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameManagementPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.GetRealmClientsIdRolesRoleNameManagementPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/management/permissions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameManagementPermissionsResponse =
        new operations.GetRealmClientsIdRolesRoleNameManagementPermissionsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.managementPermissionReference = utils.objectToClass(
              httpRes?.data,
              shared.ManagementPermissionReference
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return List of Users that have the specified role name
   */
  getRealmClientsIdRolesRoleNameUsers(
    req: operations.GetRealmClientsIdRolesRoleNameUsersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmClientsIdRolesRoleNameUsersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmClientsIdRolesRoleNameUsersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/users",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmClientsIdRolesRoleNameUsersResponse =
        new operations.GetRealmClientsIdRolesRoleNameUsersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.userRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.UserRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get all roles for the realm or client
   */
  getRealmRoles(
    req: operations.GetRealmRolesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/{realm}/roles", req);

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesResponse =
        new operations.GetRealmRolesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a role by name
   */
  getRealmRolesRoleName(
    req: operations.GetRealmRolesRoleNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameResponse =
        new operations.GetRealmRolesRoleNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentation = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get composites of the role
   */
  getRealmRolesRoleNameComposites(
    req: operations.GetRealmRolesRoleNameCompositesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameCompositesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameCompositesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/composites",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameCompositesResponse =
        new operations.GetRealmRolesRoleNameCompositesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * An app-level roles for the specified app for the role’s composite
   */
  getRealmRolesRoleNameCompositesClientsClient(
    req: operations.GetRealmRolesRoleNameCompositesClientsClientRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameCompositesClientsClientResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameCompositesClientsClientRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/composites/clients/{client}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameCompositesClientsClientResponse =
        new operations.GetRealmRolesRoleNameCompositesClientsClientResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get realm-level roles of the role’s composite
   */
  getRealmRolesRoleNameCompositesRealm(
    req: operations.GetRealmRolesRoleNameCompositesRealmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameCompositesRealmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameCompositesRealmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/composites/realm",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameCompositesRealmResponse =
        new operations.GetRealmRolesRoleNameCompositesRealmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.roleRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.roleRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.RoleRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return List of Groups that have the specified role name
   */
  getRealmRolesRoleNameGroups(
    req: operations.GetRealmRolesRoleNameGroupsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameGroupsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameGroupsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/groups",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameGroupsResponse =
        new operations.GetRealmRolesRoleNameGroupsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.groupRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.groupRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.GroupRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return object stating whether role Authoirzation permissions have been initialized or not and a reference
   */
  getRealmRolesRoleNameManagementPermissions(
    req: operations.GetRealmRolesRoleNameManagementPermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameManagementPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameManagementPermissionsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/management/permissions",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameManagementPermissionsResponse =
        new operations.GetRealmRolesRoleNameManagementPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.managementPermissionReference = utils.objectToClass(
              httpRes?.data,
              shared.ManagementPermissionReference
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Return List of Users that have the specified role name
   */
  getRealmRolesRoleNameUsers(
    req: operations.GetRealmRolesRoleNameUsersRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.GetRealmRolesRoleNameUsersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetRealmRolesRoleNameUsersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/users",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetRealmRolesRoleNameUsersResponse =
        new operations.GetRealmRolesRoleNameUsersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.userRepresentations = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.userRepresentations = utils.objectToClass(
              httpRes?.data,
              shared.UserRepresentation,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new role for the realm or client
   */
  postRealmClientsIdRoles(
    req: operations.PostRealmClientsIdRolesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmClientsIdRolesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmClientsIdRolesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "roleRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmClientsIdRolesResponse =
        new operations.PostRealmClientsIdRolesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Add a composite to the role
   */
  postRealmClientsIdRolesRoleNameComposites(
    req: operations.PostRealmClientsIdRolesRoleNameCompositesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmClientsIdRolesRoleNameCompositesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmClientsIdRolesRoleNameCompositesRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/composites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmClientsIdRolesRoleNameCompositesResponse =
        new operations.PostRealmClientsIdRolesRoleNameCompositesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Create a new role for the realm or client
   */
  postRealmRoles(
    req: operations.PostRealmRolesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmRolesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmRolesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/{realm}/roles", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "roleRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmRolesResponse =
        new operations.PostRealmRolesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Add a composite to the role
   */
  postRealmRolesRoleNameComposites(
    req: operations.PostRealmRolesRoleNameCompositesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PostRealmRolesRoleNameCompositesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostRealmRolesRoleNameCompositesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/composites",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostRealmRolesRoleNameCompositesResponse =
        new operations.PostRealmRolesRoleNameCompositesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Update a role by name
   */
  putRealmClientsIdRolesRoleName(
    req: operations.PutRealmClientsIdRolesRoleNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmClientsIdRolesRoleNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRealmClientsIdRolesRoleNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "roleRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmClientsIdRolesRoleNameResponse =
        new operations.PutRealmClientsIdRolesRoleNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Return object stating whether role Authoirzation permissions have been initialized or not and a reference
   */
  putRealmClientsIdRolesRoleNameManagementPermissions(
    req: operations.PutRealmClientsIdRolesRoleNameManagementPermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmClientsIdRolesRoleNameManagementPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.PutRealmClientsIdRolesRoleNameManagementPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/clients/{id}/roles/{role-name}/management/permissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "managementPermissionReference",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmClientsIdRolesRoleNameManagementPermissionsResponse =
        new operations.PutRealmClientsIdRolesRoleNameManagementPermissionsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.managementPermissionReference = utils.objectToClass(
              httpRes?.data,
              shared.ManagementPermissionReference
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a role by name
   */
  putRealmRolesRoleName(
    req: operations.PutRealmRolesRoleNameRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmRolesRoleNameResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRealmRolesRoleNameRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "roleRepresentation",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmRolesRoleNameResponse =
        new operations.PutRealmRolesRoleNameResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          break;
      }

      return res;
    });
  }

  /**
   * Return object stating whether role Authoirzation permissions have been initialized or not and a reference
   */
  putRealmRolesRoleNameManagementPermissions(
    req: operations.PutRealmRolesRoleNameManagementPermissionsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.PutRealmRolesRoleNameManagementPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PutRealmRolesRoleNameManagementPermissionsRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/{realm}/roles/{role-name}/management/permissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "managementPermissionReference",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PutRealmRolesRoleNameManagementPermissionsResponse =
        new operations.PutRealmRolesRoleNameManagementPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status >= 200 && httpRes?.status < 300:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.managementPermissionReference = utils.objectToClass(
              httpRes?.data,
              shared.ManagementPermissionReference
            );
          }
          break;
      }

      return res;
    });
  }
}
