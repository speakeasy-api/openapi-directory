/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * List authorized domains.
   */
  runProjectsLocationsAuthorizeddomainsList(
    req: operations.RunProjectsLocationsAuthorizeddomainsListRequest,
    security: operations.RunProjectsLocationsAuthorizeddomainsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsAuthorizeddomainsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsAuthorizeddomainsListRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/authorizeddomains",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RunProjectsLocationsAuthorizeddomainsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsAuthorizeddomainsListResponse =
        new operations.RunProjectsLocationsAuthorizeddomainsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAuthorizedDomainsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAuthorizedDomainsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List configurations.
   */
  runProjectsLocationsConfigurationsList(
    req: operations.RunProjectsLocationsConfigurationsListRequest,
    security: operations.RunProjectsLocationsConfigurationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsConfigurationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsConfigurationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/configurations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsConfigurationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsConfigurationsListResponse =
        new operations.RunProjectsLocationsConfigurationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConfigurationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListConfigurationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new domain mapping.
   */
  runProjectsLocationsDomainmappingsCreate(
    req: operations.RunProjectsLocationsDomainmappingsCreateRequest,
    security: operations.RunProjectsLocationsDomainmappingsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsDomainmappingsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsDomainmappingsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/domainmappings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "domainMapping",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RunProjectsLocationsDomainmappingsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsDomainmappingsCreateResponse =
        new operations.RunProjectsLocationsDomainmappingsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.domainMapping = utils.objectToClass(
              httpRes?.data,
              shared.DomainMapping
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all domain mappings.
   */
  runProjectsLocationsDomainmappingsList(
    req: operations.RunProjectsLocationsDomainmappingsListRequest,
    security: operations.RunProjectsLocationsDomainmappingsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsDomainmappingsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsDomainmappingsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/domainmappings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsDomainmappingsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsDomainmappingsListResponse =
        new operations.RunProjectsLocationsDomainmappingsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDomainMappingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDomainMappingsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists information about the supported locations for this service.
   */
  runProjectsLocationsList(
    req: operations.RunProjectsLocationsListRequest,
    security: operations.RunProjectsLocationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}/locations", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsListResponse =
        new operations.RunProjectsLocationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLocationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLocationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List revisions.
   */
  runProjectsLocationsRevisionsList(
    req: operations.RunProjectsLocationsRevisionsListRequest,
    security: operations.RunProjectsLocationsRevisionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsRevisionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsRevisionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/revisions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsRevisionsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsRevisionsListResponse =
        new operations.RunProjectsLocationsRevisionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRevisionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRevisionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List routes.
   */
  runProjectsLocationsRoutesList(
    req: operations.RunProjectsLocationsRoutesListRequest,
    security: operations.RunProjectsLocationsRoutesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsRoutesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsRoutesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/routes", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsRoutesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsRoutesListResponse =
        new operations.RunProjectsLocationsRoutesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRoutesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRoutesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new Service. Service creation will trigger a new deployment. Use GetService, and check service.status to determine if the Service is ready.
   */
  runProjectsLocationsServicesCreate(
    req: operations.RunProjectsLocationsServicesCreateRequest,
    security: operations.RunProjectsLocationsServicesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/services",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "serviceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsServicesCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesCreateResponse =
        new operations.RunProjectsLocationsServicesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the provided service. This will cause the Service to stop serving traffic and will delete all associated Revisions.
   */
  runProjectsLocationsServicesDelete(
    req: operations.RunProjectsLocationsServicesDeleteRequest,
    security: operations.RunProjectsLocationsServicesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsServicesDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesDeleteResponse =
        new operations.RunProjectsLocationsServicesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets information about a service.
   */
  runProjectsLocationsServicesGet(
    req: operations.RunProjectsLocationsServicesGetRequest,
    security: operations.RunProjectsLocationsServicesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsServicesGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesGetResponse =
        new operations.RunProjectsLocationsServicesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the IAM Access Control policy currently in effect for the given Cloud Run service. This result does not include any inherited policies.
   */
  runProjectsLocationsServicesGetIamPolicy(
    req: operations.RunProjectsLocationsServicesGetIamPolicyRequest,
    security: operations.RunProjectsLocationsServicesGetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesGetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesGetIamPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:getIamPolicy",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RunProjectsLocationsServicesGetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesGetIamPolicyResponse =
        new operations.RunProjectsLocationsServicesGetIamPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists services for the given project and region.
   */
  runProjectsLocationsServicesList(
    req: operations.RunProjectsLocationsServicesListRequest,
    security: operations.RunProjectsLocationsServicesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/services",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunProjectsLocationsServicesListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesListResponse =
        new operations.RunProjectsLocationsServicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServicesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListServicesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replaces a service. Only the spec and metadata labels and annotations are modifiable. After the Update request, Cloud Run will work to make the 'status' match the requested 'spec'. May provide metadata.resourceVersion to enforce update from last read for optimistic concurrency control.
   */
  runProjectsLocationsServicesReplaceService(
    req: operations.RunProjectsLocationsServicesReplaceServiceRequest,
    security: operations.RunProjectsLocationsServicesReplaceServiceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesReplaceServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesReplaceServiceRequest(
        req
      );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "serviceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RunProjectsLocationsServicesReplaceServiceSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesReplaceServiceResponse =
        new operations.RunProjectsLocationsServicesReplaceServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the IAM Access control policy for the specified Service. Overwrites any existing policy.
   */
  runProjectsLocationsServicesSetIamPolicy(
    req: operations.RunProjectsLocationsServicesSetIamPolicyRequest,
    security: operations.RunProjectsLocationsServicesSetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesSetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunProjectsLocationsServicesSetIamPolicyRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:setIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setIamPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RunProjectsLocationsServicesSetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesSetIamPolicyResponse =
        new operations.RunProjectsLocationsServicesSetIamPolicyResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns permissions that a caller has on the specified Project. There are no permissions required for making this API call.
   */
  runProjectsLocationsServicesTestIamPermissions(
    req: operations.RunProjectsLocationsServicesTestIamPermissionsRequest,
    security: operations.RunProjectsLocationsServicesTestIamPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunProjectsLocationsServicesTestIamPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.RunProjectsLocationsServicesTestIamPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:testIamPermissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testIamPermissionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.RunProjectsLocationsServicesTestIamPermissionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunProjectsLocationsServicesTestIamPermissionsResponse =
        new operations.RunProjectsLocationsServicesTestIamPermissionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testIamPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestIamPermissionsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
