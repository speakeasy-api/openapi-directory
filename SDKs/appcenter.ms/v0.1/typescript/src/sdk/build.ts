/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Build {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Configures the branch for build
   */
  branchConfigurationsCreate(
    req: operations.BranchConfigurationsCreateRequest,
    security: operations.BranchConfigurationsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BranchConfigurationsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BranchConfigurationsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BranchConfigurationsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BranchConfigurationsCreateResponse =
        new operations.BranchConfigurationsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.branchConfigurationsCreate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BranchConfigurationsCreate200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the branch build configuration
   */
  branchConfigurationsDelete(
    req: operations.BranchConfigurationsDeleteRequest,
    security: operations.BranchConfigurationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BranchConfigurationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BranchConfigurationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BranchConfigurationsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BranchConfigurationsDeleteResponse =
        new operations.BranchConfigurationsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.branchConfigurationsDelete200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BranchConfigurationsDelete200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the branch configuration
   */
  branchConfigurationsGet(
    req: operations.BranchConfigurationsGetRequest,
    security: operations.BranchConfigurationsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BranchConfigurationsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BranchConfigurationsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BranchConfigurationsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BranchConfigurationsGetResponse =
        new operations.BranchConfigurationsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.branchConfigurationsGet200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BranchConfigurationsGet200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.branchConfigurationsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BranchConfigurationsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Reconfigures the branch for build
   */
  branchConfigurationsUpdate(
    req: operations.BranchConfigurationsUpdateRequest,
    security: operations.BranchConfigurationsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BranchConfigurationsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BranchConfigurationsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BranchConfigurationsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BranchConfigurationsUpdateResponse =
        new operations.BranchConfigurationsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.branchConfigurationsUpdate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BranchConfigurationsUpdate200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the build configuration in Azure pipeline YAML format
   */
  buildConfigurationsGet(
    req: operations.BuildConfigurationsGetRequest,
    security: operations.BuildConfigurationsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildConfigurationsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildConfigurationsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/export_config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildConfigurationsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildConfigurationsGetResponse =
        new operations.BuildConfigurationsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildConfigurationsGet200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildConfigurationsGet200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildConfigurationsGetDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildConfigurationsGetDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a build
   */
  buildsCreate(
    req: operations.BuildsCreateRequest,
    security: operations.BuildsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsCreateResponse =
        new operations.BuildsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsCreate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.BuildsCreate200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Distribute a build
   */
  buildsDistribute(
    req: operations.BuildsDistributeRequest,
    security: operations.BuildsDistributeSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsDistributeResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsDistributeRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/distribute",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsDistributeSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsDistributeResponse =
        new operations.BuildsDistributeResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsDistribute200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.BuildsDistribute200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the build detail for the given build ID
   */
  buildsGet(
    req: operations.BuildsGetRequest,
    security: operations.BuildsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsGetResponse =
        new operations.BuildsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsGet200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.BuildsGet200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the download URI
   */
  buildsGetDownloadUri(
    req: operations.BuildsGetDownloadUriRequest,
    security: operations.BuildsGetDownloadUriSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsGetDownloadUriResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsGetDownloadUriRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/downloads/{download_type}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsGetDownloadUriSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsGetDownloadUriResponse =
        new operations.BuildsGetDownloadUriResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsGetDownloadUri200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsGetDownloadUri200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get the build log
   */
  buildsGetLog(
    req: operations.BuildsGetLogRequest,
    security: operations.BuildsGetLogSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsGetLogResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsGetLogRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}/logs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsGetLogSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsGetLogResponse =
        new operations.BuildsGetLogResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsGetLog200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.BuildsGetLog200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Application specific build service status
   */
  buildsGetStatusByAppId(
    req: operations.BuildsGetStatusByAppIdRequest,
    security: operations.BuildsGetStatusByAppIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsGetStatusByAppIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsGetStatusByAppIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/build_service_status",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsGetStatusByAppIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsGetStatusByAppIdResponse =
        new operations.BuildsGetStatusByAppIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsGetStatusByAppId200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsGetStatusByAppId200ApplicationJSON
              );
          }
          break;
        default:
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of Git branches for this application
   */
  buildsListBranches(
    req: operations.BuildsListBranchesRequest,
    security: operations.BuildsListBranchesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsListBranchesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsListBranchesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsListBranchesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsListBranchesResponse =
        new operations.BuildsListBranchesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListBranches200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.buildsListBranches200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListBranches200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListBranchesDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListBranchesDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the list of builds for the branch
   */
  buildsListByBranch(
    req: operations.BuildsListByBranchRequest,
    security: operations.BuildsListByBranchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsListByBranchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsListByBranchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/builds",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsListByBranchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsListByBranchResponse =
        new operations.BuildsListByBranchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListByBranch200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.buildsListByBranch200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListByBranch200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the projects in the repository for the branch, for all toolsets
   */
  buildsListToolsetProjects(
    req: operations.BuildsListToolsetProjectsRequest,
    security: operations.BuildsListToolsetProjectsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsListToolsetProjectsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsListToolsetProjectsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/branches/{branch}/toolset_projects",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsListToolsetProjectsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsListToolsetProjectsResponse =
        new operations.BuildsListToolsetProjectsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListToolsetProjects200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListToolsetProjects200ApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns available toolsets for application
   */
  buildsListToolsets(
    req: operations.BuildsListToolsetsRequest,
    security: operations.BuildsListToolsetsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsListToolsetsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsListToolsetsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/toolsets",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsListToolsetsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsListToolsetsResponse =
        new operations.BuildsListToolsetsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListToolsets200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListToolsets200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListToolsetsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListToolsetsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the Xamarin SDK bundles available to this app
   */
  buildsListXamarinSDKBundles(
    req: operations.BuildsListXamarinSDKBundlesRequest,
    security: operations.BuildsListXamarinSDKBundlesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsListXamarinSDKBundlesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsListXamarinSDKBundlesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/xamarin_sdk_bundles",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsListXamarinSDKBundlesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsListXamarinSDKBundlesResponse =
        new operations.BuildsListXamarinSDKBundlesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListXamarinSDKBundles200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.buildsListXamarinSDKBundles200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListXamarinSDKBundles200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListXamarinSDKBundlesDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListXamarinSDKBundlesDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the Xcode versions available to this app
   */
  buildsListXcodeVersions(
    req: operations.BuildsListXcodeVersionsRequest,
    security: operations.BuildsListXcodeVersionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsListXcodeVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsListXcodeVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/xcode_versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsListXcodeVersionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsListXcodeVersionsResponse =
        new operations.BuildsListXcodeVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListXcodeVersions200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.buildsListXcodeVersions200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListXcodeVersions200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsListXcodeVersionsDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.BuildsListXcodeVersionsDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancels a build
   */
  buildsUpdate(
    req: operations.BuildsUpdateRequest,
    security: operations.BuildsUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BuildsUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/builds/{build_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.BuildsUpdateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsUpdateResponse =
        new operations.BuildsUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsUpdate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.BuildsUpdate200ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Public webhook sink
   */
  buildsWebhook(
    req: Record<string, any>,
    config?: AxiosRequestConfig
  ): Promise<operations.BuildsWebhookResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/v0.1/public/hooks";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BuildsWebhookResponse =
        new operations.BuildsWebhookResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.buildsWebhookDefaultApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.BuildsWebhookDefaultApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns commit information for a batch of shas
   */
  commitsListByShaList(
    req: operations.CommitsListByShaListRequest,
    security: operations.CommitsListByShaListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.CommitsListByShaListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CommitsListByShaListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/commits/batch",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.CommitsListByShaListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.CommitsListByShaListResponse =
        new operations.CommitsListByShaListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.commitsListByShaList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.commitsListByShaList200ApplicationJSONObjects =
              utils.objectToClass(
                httpRes?.data,
                operations.CommitsListByShaList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new asset to upload a file
   */
  fileAssetsCreate(
    req: operations.FileAssetsCreateRequest,
    security: operations.FileAssetsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.FileAssetsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.FileAssetsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/file_asset",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.FileAssetsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.FileAssetsCreateResponse =
        new operations.FileAssetsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fileAssetsCreate200ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.FileAssetsCreate200ApplicationJSON
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.fileAssetsCreateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.FileAssetsCreateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the repositories available from the source code host
   */
  repositoriesList(
    req: operations.RepositoriesListRequest,
    security: operations.RepositoriesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RepositoriesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RepositoriesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/source_hosts/{source_host}/repositories",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RepositoriesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RepositoriesListResponse =
        new operations.RepositoriesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoriesList200ApplicationJSONObjects = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.repositoriesList200ApplicationJSONObjects = utils.objectToClass(
              httpRes?.data,
              operations.RepositoriesList200ApplicationJSON,
              resFieldDepth
            );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoriesListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoriesListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Configures the repository for build
   */
  repositoryConfigurationsCreateOrUpdate(
    req: operations.RepositoryConfigurationsCreateOrUpdateRequest,
    security: operations.RepositoryConfigurationsCreateOrUpdateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RepositoryConfigurationsCreateOrUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RepositoryConfigurationsCreateOrUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/repo_config",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RepositoryConfigurationsCreateOrUpdateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RepositoryConfigurationsCreateOrUpdateResponse =
        new operations.RepositoryConfigurationsCreateOrUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoryConfigurationsCreateOrUpdate200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoryConfigurationsCreateOrUpdate200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoryConfigurationsCreateOrUpdateDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoryConfigurationsCreateOrUpdateDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes the configuration for the repository
   */
  repositoryConfigurationsDelete(
    req: operations.RepositoryConfigurationsDeleteRequest,
    security: operations.RepositoryConfigurationsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RepositoryConfigurationsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RepositoryConfigurationsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/repo_config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RepositoryConfigurationsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RepositoryConfigurationsDeleteResponse =
        new operations.RepositoryConfigurationsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoryConfigurationsDelete200ApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoryConfigurationsDelete200ApplicationJSON
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoryConfigurationsDeleteDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoryConfigurationsDeleteDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns the repository build configuration status of the app
   */
  repositoryConfigurationsList(
    req: operations.RepositoryConfigurationsListRequest,
    security: operations.RepositoryConfigurationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RepositoryConfigurationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RepositoryConfigurationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v0.1/apps/{owner_name}/{app_name}/repo_config",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RepositoryConfigurationsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RepositoryConfigurationsListResponse =
        new operations.RepositoryConfigurationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoryConfigurationsList200ApplicationJSONAnies = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.repositoryConfigurationsList200ApplicationJSONAnies =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoryConfigurationsList200ApplicationJSON,
                resFieldDepth
              );
          }
          break;
        default:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.repositoryConfigurationsListDefaultApplicationJSONObject =
              utils.objectToClass(
                httpRes?.data,
                operations.RepositoryConfigurationsListDefaultApplicationJSON
              );
          }
          break;
      }

      return res;
    });
  }
}
