/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
  /**
   * The AWS IoT Events Data multi-region endpoint
   */
  "http://data.iotevents.{region}.amazonaws.com",
  /**
   * The AWS IoT Events Data multi-region endpoint
   */
  "https://data.iotevents.{region}.amazonaws.com",
  /**
   * The AWS IoT Events Data endpoint for China (Beijing) and China (Ningxia)
   */
  "http://data.iotevents.{region}.amazonaws.com.cn",
  /**
   * The AWS IoT Events Data endpoint for China (Beijing) and China (Ningxia)
   */
  "https://data.iotevents.{region}.amazonaws.com.cn",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * The security details required to authenticate the SDK
   */
  security?: shared.Security;
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * <p>IoT Events monitors your equipment or device fleets for failures or changes in operation, and triggers actions when such events occur. You can use IoT Events Data API commands to send inputs to detectors, list detectors, and view or update a detector's status.</p> <p> For more information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/what-is-iotevents.html">What is IoT Events?</a> in the <i>IoT Events Developer Guide</i>.</p>
 *
 * @see {@link https://docs.aws.amazon.com/iotevents/} - Amazon Web Services documentation
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    if (props?.security) {
      let security: shared.Security = props.security;
      if (!(props.security instanceof utils.SpeakeasyBase))
        security = new shared.Security(props.security);
      this._securityClient = utils.createSecurityClient(
        this._defaultClient,
        security
      );
    } else {
      this._securityClient = this._defaultClient;
    }
  }

  /**
   * Acknowledges one or more alarms. The alarms change to the <code>ACKNOWLEDGED</code> state after you acknowledge them.
   */
  batchAcknowledgeAlarm(
    req: operations.BatchAcknowledgeAlarmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchAcknowledgeAlarmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchAcknowledgeAlarmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/alarms/acknowledge";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchAcknowledgeAlarmResponse =
        new operations.BatchAcknowledgeAlarmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchAcknowledgeAlarmResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchAcknowledgeAlarmResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes one or more detectors that were created. When a detector is deleted, its state will be cleared and the detector will be removed from the list of detectors. The deleted detector will no longer appear if referenced in the <a href="https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_ListDetectors.html">ListDetectors</a> API call.
   */
  batchDeleteDetector(
    req: operations.BatchDeleteDetectorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchDeleteDetectorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchDeleteDetectorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/detectors/delete";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchDeleteDetectorResponse =
        new operations.BatchDeleteDetectorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchDeleteDetectorResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchDeleteDetectorResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Disables one or more alarms. The alarms change to the <code>DISABLED</code> state after you disable them.
   */
  batchDisableAlarm(
    req: operations.BatchDisableAlarmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchDisableAlarmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchDisableAlarmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/alarms/disable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchDisableAlarmResponse =
        new operations.BatchDisableAlarmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchDisableAlarmResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchDisableAlarmResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Enables one or more alarms. The alarms change to the <code>NORMAL</code> state after you enable them.
   */
  batchEnableAlarm(
    req: operations.BatchEnableAlarmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchEnableAlarmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchEnableAlarmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/alarms/enable";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchEnableAlarmResponse =
        new operations.BatchEnableAlarmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchEnableAlarmResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchEnableAlarmResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sends a set of messages to the IoT Events system. Each message payload is transformed into the input you specify (<code>"inputName"</code>) and ingested into any detectors that monitor that input. If multiple messages are sent, the order in which the messages are processed isn't guaranteed. To guarantee ordering, you must send messages one at a time and wait for a successful response.
   */
  batchPutMessage(
    req: operations.BatchPutMessageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchPutMessageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchPutMessageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/inputs/messages";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchPutMessageResponse =
        new operations.BatchPutMessageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchPutMessageResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchPutMessageResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Resets one or more alarms. The alarms return to the <code>NORMAL</code> state after you reset them.
   */
  batchResetAlarm(
    req: operations.BatchResetAlarmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchResetAlarmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchResetAlarmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/alarms/reset";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchResetAlarmResponse =
        new operations.BatchResetAlarmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchResetAlarmResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchResetAlarmResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Changes one or more alarms to the snooze mode. The alarms change to the <code>SNOOZE_DISABLED</code> state after you set them to the snooze mode.
   */
  batchSnoozeAlarm(
    req: operations.BatchSnoozeAlarmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchSnoozeAlarmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchSnoozeAlarmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/alarms/snooze";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchSnoozeAlarmResponse =
        new operations.BatchSnoozeAlarmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 202:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchSnoozeAlarmResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchSnoozeAlarmResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the state, variable values, and timer settings of one or more detectors (instances) of a specified detector model.
   */
  batchUpdateDetector(
    req: operations.BatchUpdateDetectorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.BatchUpdateDetectorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.BatchUpdateDetectorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/detectors";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = {
      ...utils.getHeadersFromRequest(req),
      ...reqBodyHeaders,
      ...config?.headers,
    };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.BatchUpdateDetectorResponse =
        new operations.BatchUpdateDetectorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.batchUpdateDetectorResponse = utils.objectToClass(
              httpRes?.data,
              shared.BatchUpdateDetectorResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Retrieves information about an alarm.
   */
  describeAlarm(
    req: operations.DescribeAlarmRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DescribeAlarmResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DescribeAlarmRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/alarms/{alarmModelName}/keyValues/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DescribeAlarmResponse =
        new operations.DescribeAlarmResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.describeAlarmResponse = utils.objectToClass(
              httpRes?.data,
              shared.DescribeAlarmResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns information about the specified detector (instance).
   */
  describeDetector(
    req: operations.DescribeDetectorRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DescribeDetectorResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DescribeDetectorRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/detectors/{detectorModelName}/keyValues/",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DescribeDetectorResponse =
        new operations.DescribeDetectorResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.describeDetectorResponse = utils.objectToClass(
              httpRes?.data,
              shared.DescribeDetectorResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists one or more alarms. The operation returns only the metadata associated with each alarm.
   */
  listAlarms(
    req: operations.ListAlarmsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAlarmsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAlarmsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/alarms/{alarmModelName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAlarmsResponse =
        new operations.ListAlarmsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAlarmsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAlarmsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists detectors (the instances of a detector model).
   */
  listDetectors(
    req: operations.ListDetectorsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListDetectorsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListDetectorsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/detectors/{detectorModelName}",
      req
    );

    const client: AxiosInstance = this._securityClient || this._defaultClient;

    const headers = { ...utils.getHeadersFromRequest(req), ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      headers: headers,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListDetectorsResponse =
        new operations.ListDetectorsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDetectorsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDetectorsResponse
            );
          }
          break;
        case httpRes?.status == 480:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.invalidRequestException = httpRes?.data;
          }
          break;
        case httpRes?.status == 481:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resourceNotFoundException = httpRes?.data;
          }
          break;
        case httpRes?.status == 482:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.throttlingException = httpRes?.data;
          }
          break;
        case httpRes?.status == 483:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.internalFailureException = httpRes?.data;
          }
          break;
        case httpRes?.status == 484:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.serviceUnavailableException = httpRes?.data;
          }
          break;
      }

      return res;
    });
  }
}
