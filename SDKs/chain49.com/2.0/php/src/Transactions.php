<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Transactions 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Get Mempool V2
     * 
     * Get a list of transaction IDs currently in the mempool of the node (meaning unconfirmed transactions not included in any block yet)
     * 
     * Note: this route was implemented by us and is therefore not yet supported by existing blockbook clients.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Response
     */
	public function getMempoolV2(
        \OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{blockchain}/v2/mempool/', \OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Request::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMempoolV2Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getMempoolV2200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetMempoolV2200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Send transaction (in URL) V2
     * 
     * Sends new transaction to backend
     * 
     * It is recommended to use POST for sending transactions as there is a limit on how much data can be sent in the URL itself.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSendTxV2Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSendTxV2Response
     */
	public function getSendTxV2(
        \OpenAPI\OpenAPI\Models\Operations\GetSendTxV2Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSendTxV2Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{blockchain}/v2/sendtx/{hex}', \OpenAPI\OpenAPI\Models\Operations\GetSendTxV2Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSendTxV2Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getSendTxV2200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetSendTxV2200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get transaction V2
     * 
     * Get transaction returns "normalized" data about transaction, which has the same general structure for all supported coins. It does not return coin specific fields (for example information about Zcash shielded addresses).
     * 
     * A note about the blockTime field:
     * for already mined transaction (confirmations > 0), the field blockTime contains time of the block
     * for transactions in mempool (confirmations == 0), the field contains time when the running instance of Blockbook was first time notified about the transaction. This time may be different in different instances of Blockbook.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetTransactionV2Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetTransactionV2Response
     */
	public function getTransactionV2(
        \OpenAPI\OpenAPI\Models\Operations\GetTransactionV2Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetTransactionV2Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{blockchain}/v2/tx/{txId}', \OpenAPI\OpenAPI\Models\Operations\GetTransactionV2Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetTransactionV2Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getTransactionV2200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetTransactionV2200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get transaction (as is from Backend) V2
     * 
     * Returns transaction data in the exact format as returned by backend, including all coin specific fields
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetTxSpecificV2Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetTxSpecificV2Response
     */
	public function getTxSpecificV2(
        \OpenAPI\OpenAPI\Models\Operations\GetTxSpecificV2Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetTxSpecificV2Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{blockchain}/v2/tx-specific/{txId}', \OpenAPI\OpenAPI\Models\Operations\GetTxSpecificV2Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetTxSpecificV2Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getTxSpecificV2200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'array<string, mixed>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Send transaction (POST) V2
     * 
     * Sends new transaction to backend for broadcasting
     * 
     * The trailing slash '/' at the end is mandatory
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\PostSendTxV2Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\PostSendTxV2Response
     */
	public function postSendTxV2(
        \OpenAPI\OpenAPI\Models\Operations\PostSendTxV2Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\PostSendTxV2Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/{blockchain}/v2/sendtx/', \OpenAPI\OpenAPI\Models\Operations\PostSendTxV2Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "requestBody", "raw");
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\PostSendTxV2Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->postSendTxV2200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\PostSendTxV2200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}