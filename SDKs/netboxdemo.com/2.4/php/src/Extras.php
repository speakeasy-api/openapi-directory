<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Extras 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * extrasChoicesList
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesListResponse
     */
	public function extrasChoicesList(
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/_choices/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * extrasChoicesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesReadResponse
     */
	public function extrasChoicesRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/_choices/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasChoicesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * extrasConfigContextsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableConfigContextInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsCreateResponse
     */
	public function extrasConfigContextsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableConfigContextInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/config-contexts/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->configContext = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConfigContext', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasConfigContextsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsDeleteResponse
     */
	public function extrasConfigContextsDelete(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/config-contexts/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * extrasConfigContextsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsListResponse
     */
	public function extrasConfigContextsList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/config-contexts/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasConfigContextsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasConfigContextsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsPartialUpdateResponse
     */
	public function extrasConfigContextsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/config-contexts/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableConfigContextInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->configContext = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConfigContext', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasConfigContextsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsReadResponse
     */
	public function extrasConfigContextsRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/config-contexts/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->configContext = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConfigContext', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasConfigContextsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsUpdateResponse
     */
	public function extrasConfigContextsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/config-contexts/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableConfigContextInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasConfigContextsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->configContext = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ConfigContext', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasExportTemplatesCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\ExportTemplateInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesCreateResponse
     */
	public function extrasExportTemplatesCreate(
        \OpenAPI\OpenAPI\Models\Shared\ExportTemplateInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/export-templates/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exportTemplate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExportTemplate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasExportTemplatesDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesDeleteResponse
     */
	public function extrasExportTemplatesDelete(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/export-templates/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * extrasExportTemplatesList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesListResponse
     */
	public function extrasExportTemplatesList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/export-templates/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasExportTemplatesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasExportTemplatesPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesPartialUpdateResponse
     */
	public function extrasExportTemplatesPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/export-templates/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "exportTemplateInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exportTemplate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExportTemplate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasExportTemplatesRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesReadResponse
     */
	public function extrasExportTemplatesRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/export-templates/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exportTemplate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExportTemplate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasExportTemplatesUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesUpdateResponse
     */
	public function extrasExportTemplatesUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/export-templates/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "exportTemplateInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasExportTemplatesUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->exportTemplate = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ExportTemplate', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasGraphsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableGraphInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsCreateResponse
     */
	public function extrasGraphsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableGraphInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/graphs/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->graph = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Graph', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasGraphsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsDeleteResponse
     */
	public function extrasGraphsDelete(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/graphs/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * extrasGraphsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsListResponse
     */
	public function extrasGraphsList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/graphs/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasGraphsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasGraphsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsPartialUpdateResponse
     */
	public function extrasGraphsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/graphs/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableGraphInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->graph = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Graph', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasGraphsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsReadResponse
     */
	public function extrasGraphsRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/graphs/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->graph = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Graph', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasGraphsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsUpdateResponse
     */
	public function extrasGraphsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/graphs/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableGraphInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasGraphsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->graph = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Graph', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasImageAttachmentsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\ImageAttachmentInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsCreateResponse
     */
	public function extrasImageAttachmentsCreate(
        \OpenAPI\OpenAPI\Models\Shared\ImageAttachmentInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/image-attachments/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->imageAttachment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ImageAttachment', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasImageAttachmentsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsDeleteResponse
     */
	public function extrasImageAttachmentsDelete(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/image-attachments/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * extrasImageAttachmentsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsListResponse
     */
	public function extrasImageAttachmentsList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/image-attachments/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasImageAttachmentsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasImageAttachmentsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsPartialUpdateResponse
     */
	public function extrasImageAttachmentsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/image-attachments/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "imageAttachmentInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->imageAttachment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ImageAttachment', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasImageAttachmentsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsReadResponse
     */
	public function extrasImageAttachmentsRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/image-attachments/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->imageAttachment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ImageAttachment', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasImageAttachmentsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsUpdateResponse
     */
	public function extrasImageAttachmentsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/image-attachments/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "imageAttachmentInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasImageAttachmentsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->imageAttachment = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ImageAttachment', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a list of recent changes.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesListResponse
     */
	public function extrasObjectChangesList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/object-changes/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasObjectChangesList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Retrieve a list of recent changes.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesReadResponse
     */
	public function extrasObjectChangesRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/object-changes/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasObjectChangesReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->objectChange = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ObjectChange', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasRecentActivityList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityListResponse
     */
	public function extrasRecentActivityList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/recent-activity/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasRecentActivityList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasRecentActivityRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityReadResponse
     */
	public function extrasRecentActivityRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/recent-activity/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasRecentActivityReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->userAction = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\UserAction', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTagsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\TagInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsCreateResponse
     */
	public function extrasTagsCreate(
        \OpenAPI\OpenAPI\Models\Shared\TagInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/tags/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tag = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Tag', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTagsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsDeleteResponse
     */
	public function extrasTagsDelete(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/tags/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * extrasTagsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsListResponse
     */
	public function extrasTagsList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/tags/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasTagsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasTagsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasTagsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTagsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsPartialUpdateResponse
     */
	public function extrasTagsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/tags/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "tagInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tag = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Tag', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTagsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsReadResponse
     */
	public function extrasTagsRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/tags/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tag = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Tag', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTagsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsUpdateResponse
     */
	public function extrasTagsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/tags/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "tagInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTagsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->tag = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\Tag', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsCreate
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\WritableTopologyMapInput $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsCreateResponse
     */
	public function extrasTopologyMapsCreate(
        \OpenAPI\OpenAPI\Models\Shared\WritableTopologyMapInput $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsCreateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsCreateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 201) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->topologyMap = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TopologyMap', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsDelete
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsDeleteRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsDeleteResponse
     */
	public function extrasTopologyMapsDelete(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsDeleteRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsDeleteResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsDeleteRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsDeleteResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsList
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsListRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsListResponse
     */
	public function extrasTopologyMapsList(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsListRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsListResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsListRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsListResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->extrasTopologyMapsList200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsList200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsPartialUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsPartialUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsPartialUpdateResponse
     */
	public function extrasTopologyMapsPartialUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsPartialUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsPartialUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsPartialUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableTopologyMapInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsPartialUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->topologyMap = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TopologyMap', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsRead
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsReadRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsReadResponse
     */
	public function extrasTopologyMapsRead(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsReadRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsReadResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsReadRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsReadResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->topologyMap = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TopologyMap', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsRender
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsRenderRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsRenderResponse
     */
	public function extrasTopologyMapsRender(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsRenderRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsRenderResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/{id}/render/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsRenderRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsRenderResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->topologyMap = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TopologyMap', 'json');
            }
        }

        return $response;
    }
	
    /**
     * extrasTopologyMapsUpdate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsUpdateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsUpdateResponse
     */
	public function extrasTopologyMapsUpdate(
        \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsUpdateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsUpdateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/extras/topology-maps/{id}/', \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsUpdateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "writableTopologyMapInput", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PUT', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ExtrasTopologyMapsUpdateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->topologyMap = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\TopologyMap', 'json');
            }
        }

        return $response;
    }
}