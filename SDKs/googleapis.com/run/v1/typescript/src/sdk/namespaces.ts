/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Namespaces {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * List authorized domains.
   */
  runNamespacesAuthorizeddomainsList(
    req: operations.RunNamespacesAuthorizeddomainsListRequest,
    security: operations.RunNamespacesAuthorizeddomainsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesAuthorizeddomainsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesAuthorizeddomainsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/domains.cloudrun.com/v1/{parent}/authorizeddomains",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesAuthorizeddomainsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesAuthorizeddomainsListResponse =
        new operations.RunNamespacesAuthorizeddomainsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listAuthorizedDomainsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListAuthorizedDomainsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List configurations.
   */
  runNamespacesConfigurationsList(
    req: operations.RunNamespacesConfigurationsListRequest,
    security: operations.RunNamespacesConfigurationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesConfigurationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesConfigurationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{parent}/configurations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesConfigurationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesConfigurationsListResponse =
        new operations.RunNamespacesConfigurationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listConfigurationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListConfigurationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a new domain mapping.
   */
  runNamespacesDomainmappingsCreate(
    req: operations.RunNamespacesDomainmappingsCreateRequest,
    security: operations.RunNamespacesDomainmappingsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesDomainmappingsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesDomainmappingsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/domains.cloudrun.com/v1/{parent}/domainmappings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "domainMapping",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesDomainmappingsCreateSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesDomainmappingsCreateResponse =
        new operations.RunNamespacesDomainmappingsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.domainMapping = utils.objectToClass(
              httpRes?.data,
              shared.DomainMapping
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a domain mapping.
   */
  runNamespacesDomainmappingsDelete(
    req: operations.RunNamespacesDomainmappingsDeleteRequest,
    security: operations.RunNamespacesDomainmappingsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesDomainmappingsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesDomainmappingsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/domains.cloudrun.com/v1/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesDomainmappingsDeleteSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesDomainmappingsDeleteResponse =
        new operations.RunNamespacesDomainmappingsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get information about a domain mapping.
   */
  runNamespacesDomainmappingsGet(
    req: operations.RunNamespacesDomainmappingsGetRequest,
    security: operations.RunNamespacesDomainmappingsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesDomainmappingsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesDomainmappingsGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/domains.cloudrun.com/v1/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesDomainmappingsGetSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesDomainmappingsGetResponse =
        new operations.RunNamespacesDomainmappingsGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.domainMapping = utils.objectToClass(
              httpRes?.data,
              shared.DomainMapping
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List all domain mappings.
   */
  runNamespacesDomainmappingsList(
    req: operations.RunNamespacesDomainmappingsListRequest,
    security: operations.RunNamespacesDomainmappingsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesDomainmappingsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesDomainmappingsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/domains.cloudrun.com/v1/{parent}/domainmappings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesDomainmappingsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesDomainmappingsListResponse =
        new operations.RunNamespacesDomainmappingsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDomainMappingsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDomainMappingsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Cancel an execution.
   */
  runNamespacesExecutionsCancel(
    req: operations.RunNamespacesExecutionsCancelRequest,
    security: operations.RunNamespacesExecutionsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesExecutionsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesExecutionsCancelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{name}:cancel",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesExecutionsCancelSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesExecutionsCancelResponse =
        new operations.RunNamespacesExecutionsCancelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.execution = utils.objectToClass(
              httpRes?.data,
              shared.Execution
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List executions.
   */
  runNamespacesExecutionsList(
    req: operations.RunNamespacesExecutionsListRequest,
    security: operations.RunNamespacesExecutionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesExecutionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesExecutionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{parent}/executions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesExecutionsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesExecutionsListResponse =
        new operations.RunNamespacesExecutionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listExecutionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListExecutionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a job.
   */
  runNamespacesJobsCreate(
    req: operations.RunNamespacesJobsCreateRequest,
    security: operations.RunNamespacesJobsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesJobsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesJobsCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{parent}/jobs",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "job",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesJobsCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesJobsCreateResponse =
        new operations.RunNamespacesJobsCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.job = utils.objectToClass(httpRes?.data, shared.Job);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete a job.
   */
  runNamespacesJobsDelete(
    req: operations.RunNamespacesJobsDeleteRequest,
    security: operations.RunNamespacesJobsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesJobsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesJobsDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesJobsDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesJobsDeleteResponse =
        new operations.RunNamespacesJobsDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List jobs.
   */
  runNamespacesJobsList(
    req: operations.RunNamespacesJobsListRequest,
    security: operations.RunNamespacesJobsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesJobsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesJobsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{parent}/jobs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesJobsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesJobsListResponse =
        new operations.RunNamespacesJobsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listJobsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListJobsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replace a job. Only the spec and metadata labels and annotations are modifiable. After the Replace request, Cloud Run will work to make the 'status' match the requested 'spec'. May provide metadata.resourceVersion to enforce update from last read for optimistic concurrency control.
   */
  runNamespacesJobsReplaceJob(
    req: operations.RunNamespacesJobsReplaceJobRequest,
    security: operations.RunNamespacesJobsReplaceJobSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesJobsReplaceJobResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesJobsReplaceJobRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "job",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesJobsReplaceJobSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesJobsReplaceJobResponse =
        new operations.RunNamespacesJobsReplaceJobResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.job = utils.objectToClass(httpRes?.data, shared.Job);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Trigger creation of a new execution of this job.
   */
  runNamespacesJobsRun(
    req: operations.RunNamespacesJobsRunRequest,
    security: operations.RunNamespacesJobsRunSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesJobsRunResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesJobsRunRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{name}:run",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesJobsRunSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesJobsRunResponse =
        new operations.RunNamespacesJobsRunResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.execution = utils.objectToClass(
              httpRes?.data,
              shared.Execution
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List revisions.
   */
  runNamespacesRevisionsList(
    req: operations.RunNamespacesRevisionsListRequest,
    security: operations.RunNamespacesRevisionsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesRevisionsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesRevisionsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{parent}/revisions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesRevisionsListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesRevisionsListResponse =
        new operations.RunNamespacesRevisionsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRevisionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRevisionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List routes.
   */
  runNamespacesRoutesList(
    req: operations.RunNamespacesRoutesListRequest,
    security: operations.RunNamespacesRoutesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesRoutesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesRoutesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{parent}/routes",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesRoutesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesRoutesListResponse =
        new operations.RunNamespacesRoutesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listRoutesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListRoutesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a new Service. Service creation will trigger a new deployment. Use GetService, and check service.status to determine if the Service is ready.
   */
  runNamespacesServicesCreate(
    req: operations.RunNamespacesServicesCreateRequest,
    security: operations.RunNamespacesServicesCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesServicesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesServicesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{parent}/services",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "serviceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesServicesCreateSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesServicesCreateResponse =
        new operations.RunNamespacesServicesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes the provided service. This will cause the Service to stop serving traffic and will delete all associated Revisions.
   */
  runNamespacesServicesDelete(
    req: operations.RunNamespacesServicesDeleteRequest,
    security: operations.RunNamespacesServicesDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesServicesDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesServicesDeleteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesServicesDeleteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesServicesDeleteResponse =
        new operations.RunNamespacesServicesDeleteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.status = utils.objectToClass(httpRes?.data, shared.Status);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets information about a service.
   */
  runNamespacesServicesGet(
    req: operations.RunNamespacesServicesGetRequest,
    security: operations.RunNamespacesServicesGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesServicesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesServicesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesServicesGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesServicesGetResponse =
        new operations.RunNamespacesServicesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists services for the given project and region.
   */
  runNamespacesServicesList(
    req: operations.RunNamespacesServicesListRequest,
    security: operations.RunNamespacesServicesListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesServicesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesServicesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{parent}/services",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesServicesListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesServicesListResponse =
        new operations.RunNamespacesServicesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listServicesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListServicesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Replaces a service. Only the spec and metadata labels and annotations are modifiable. After the Update request, Cloud Run will work to make the 'status' match the requested 'spec'. May provide metadata.resourceVersion to enforce update from last read for optimistic concurrency control.
   */
  runNamespacesServicesReplaceService(
    req: operations.RunNamespacesServicesReplaceServiceRequest,
    security: operations.RunNamespacesServicesReplaceServiceSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesServicesReplaceServiceResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesServicesReplaceServiceRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/serving.knative.dev/v1/{name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "serviceInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesServicesReplaceServiceSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesServicesReplaceServiceResponse =
        new operations.RunNamespacesServicesReplaceServiceResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.service = utils.objectToClass(httpRes?.data, shared.Service);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get information about a task.
   */
  runNamespacesTasksGet(
    req: operations.RunNamespacesTasksGetRequest,
    security: operations.RunNamespacesTasksGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesTasksGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesTasksGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesTasksGetSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesTasksGetResponse =
        new operations.RunNamespacesTasksGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.task = utils.objectToClass(httpRes?.data, shared.Task);
          }
          break;
      }

      return res;
    });
  }

  /**
   * List tasks.
   */
  runNamespacesTasksList(
    req: operations.RunNamespacesTasksListRequest,
    security: operations.RunNamespacesTasksListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.RunNamespacesTasksListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RunNamespacesTasksListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/apis/run.googleapis.com/v1/{parent}/tasks",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.RunNamespacesTasksListSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.RunNamespacesTasksListResponse =
        new operations.RunNamespacesTasksListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listTasksResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListTasksResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
