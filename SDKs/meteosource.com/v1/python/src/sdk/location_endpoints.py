"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class LocationEndpoints:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def find_places_find_places_get(self, request: operations.FindPlacesFindPlacesGetRequest, security: operations.FindPlacesFindPlacesGetSecurity) -> operations.FindPlacesFindPlacesGetResponse:
        r"""Search for places. Complete words required.
        ## Search for places
        
        You can use this endpoint to obtain `place_id` of the location you want, to be used in `point` endpoint.
        The response also contains detailed information about the location, such as coordinates, timezone and the country the place belongs to.
        
        Unlike the `/find_place_prefix` endpoint, complete words are required here. You can search for cities,
        mountains, lakes, countries, ZIP codes, etc. The response can contain multiple places, sorted by relevance.
        You can then identify the one you want by coordinates, country, or the administrative area.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/find_places'
        
        query_params = utils.get_query_params(operations.FindPlacesFindPlacesGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindPlacesFindPlacesGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.FindPlacesModel]])
                res.find_places_models = out
        elif http_res.status_code in [400, 402, 403, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GeneralRequestError])
                res.general_request_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.HTTPValidationError])
                res.http_validation_error = out

        return res

    def find_places_prefix_find_places_prefix_get(self, request: operations.FindPlacesPrefixFindPlacesPrefixGetRequest, security: operations.FindPlacesPrefixFindPlacesPrefixGetSecurity) -> operations.FindPlacesPrefixFindPlacesPrefixGetResponse:
        r"""Prefix search for places. Useful for autocomplete forms.
        ## Search for places by prefix
        
        You can use this endpoint to obtain `place_id` of the location you want, to be used in `point` endpoint. The response also contains detailed information about the location, such as coordinates, timezone and the country the place belongs to.
        
        Unlike the `/find_places` endpoint, you should only specify the prefix of the place you are looking for. This is particularly useful for autocomplete forms. You can search for cities, mountains, lakes, countries, ZIP codes, etc. The response can contain multiple places, sorted by relevance. You can then identify the one you want by coordinates, country, or the administrative area.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/find_places_prefix'
        
        query_params = utils.get_query_params(operations.FindPlacesPrefixFindPlacesPrefixGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FindPlacesPrefixFindPlacesPrefixGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.FindPlacesModel]])
                res.find_places_models = out
        elif http_res.status_code in [400, 402, 403, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GeneralRequestError])
                res.general_request_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.HTTPValidationError])
                res.http_validation_error = out

        return res

    def nearest_place_nearest_place_get(self, request: operations.NearestPlaceNearestPlaceGetRequest, security: operations.NearestPlaceNearestPlaceGetSecurity) -> operations.NearestPlaceNearestPlaceGetResponse:
        r"""Returns the nearest named location for a given GPS coordinates.
        ## Search for nearest place by coordinates
        
        You can use this endpoint to find the nearest place from given coordinates.
        
        *Note: If you specify coordinates of a secluded place (e.g. middle of the ocean), the nearest point can be very far from the coordinates.*
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/nearest_place'
        
        query_params = utils.get_query_params(operations.NearestPlaceNearestPlaceGetRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.NearestPlaceNearestPlaceGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FindPlacesModel])
                res.find_places_model = out
        elif http_res.status_code in [400, 402, 403, 429]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GeneralRequestError])
                res.general_request_error = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.HTTPValidationError])
                res.http_validation_error = out

        return res

    