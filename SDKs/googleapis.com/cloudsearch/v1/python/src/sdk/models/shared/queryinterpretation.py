"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class QueryInterpretationInterpretationTypeEnum(str, Enum):
    NONE = 'NONE'
    BLEND = 'BLEND'
    REPLACE = 'REPLACE'

class QueryInterpretationReasonEnum(str, Enum):
    r"""The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE."""
    UNSPECIFIED = 'UNSPECIFIED'
    QUERY_HAS_NATURAL_LANGUAGE_INTENT = 'QUERY_HAS_NATURAL_LANGUAGE_INTENT'
    NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY = 'NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class QueryInterpretation:
    
    interpretation_type: Optional[QueryInterpretationInterpretationTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('interpretationType'), 'exclude': lambda f: f is None }})  
    interpreted_query: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('interpretedQuery'), 'exclude': lambda f: f is None }})
    r"""The interpretation of the query used in search. For example, queries with natural language intent like \\"email from john\\" will be interpreted as \\"from:john source:mail\\". This field will not be filled when the reason is NOT_ENOUGH_RESULTS_FOUND_FOR_USER_QUERY."""  
    reason: Optional[QueryInterpretationReasonEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reason'), 'exclude': lambda f: f is None }})
    r"""The reason for interpretation of the query. This field will not be UNSPECIFIED if the interpretation type is not NONE."""  
    