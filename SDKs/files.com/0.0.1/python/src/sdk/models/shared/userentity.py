"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional

class UserEntityAuthenticationMethodEnum(str, Enum):
    r"""How is this user authenticated?"""
    PASSWORD = 'password'
    UNUSED_FORMER_LDAP = 'unused_former_ldap'
    SSO = 'sso'
    NONE = 'none'
    EMAIL_SIGNUP = 'email_signup'
    PASSWORD_WITH_IMPORTED_HASH = 'password_with_imported_hash'

class UserEntityRequire2faEnum(str, Enum):
    r"""2FA required setting"""
    USE_SYSTEM_SETTING = 'use_system_setting'
    ALWAYS_REQUIRE = 'always_require'
    NEVER_REQUIRE = 'never_require'

class UserEntitySslRequiredEnum(str, Enum):
    r"""SSL required setting"""
    USE_SYSTEM_SETTING = 'use_system_setting'
    ALWAYS_REQUIRE = 'always_require'
    NEVER_REQUIRE = 'never_require'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserEntity:
    r"""Create User"""
    
    active_2fa: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active_2fa'), 'exclude': lambda f: f is None }})
    r"""Is 2fa active for the user?"""  
    admin_group_ids: Optional[list[int]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('admin_group_ids'), 'exclude': lambda f: f is None }})
    r"""List of group IDs of which this user is an administrator"""  
    allowed_ips: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowed_ips'), 'exclude': lambda f: f is None }})
    r"""A list of allowed IPs if applicable.  Newline delimited"""  
    api_keys_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('api_keys_count'), 'exclude': lambda f: f is None }})
    r"""Number of api keys associated with this user"""  
    attachments_permission: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('attachments_permission'), 'exclude': lambda f: f is None }})
    r"""DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead."""  
    authenticate_until: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authenticate_until'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Scheduled Date/Time at which user will be deactivated"""  
    authentication_method: Optional[UserEntityAuthenticationMethodEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_method'), 'exclude': lambda f: f is None }})
    r"""How is this user authenticated?"""  
    avatar_url: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('avatar_url'), 'exclude': lambda f: f is None }})
    r"""URL holding the user's avatar"""  
    billing_permission: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billing_permission'), 'exclude': lambda f: f is None }})
    r"""Allow this user to perform operations on the account, payments, and invoices?"""  
    bypass_inactive_disable: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bypass_inactive_disable'), 'exclude': lambda f: f is None }})
    r"""Exempt this user from being disabled based on inactivity?"""  
    bypass_site_allowed_ips: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bypass_site_allowed_ips'), 'exclude': lambda f: f is None }})
    r"""Allow this user to skip site-wide IP blacklists?"""  
    company: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('company'), 'exclude': lambda f: f is None }})
    r"""User's company"""  
    created_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('created_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""When this user was created"""  
    dav_permission: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dav_permission'), 'exclude': lambda f: f is None }})
    r"""Can the user connect with WebDAV?"""  
    days_remaining_until_password_expire: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('days_remaining_until_password_expire'), 'exclude': lambda f: f is None }})
    r"""Number of days remaining until password expires"""  
    disabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('disabled'), 'exclude': lambda f: f is None }})
    r"""Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting."""  
    email: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('email'), 'exclude': lambda f: f is None }})
    r"""User email address"""  
    externally_managed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('externally_managed'), 'exclude': lambda f: f is None }})
    r"""Is this user managed by a SsoStrategy?"""  
    first_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('first_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's first login time"""  
    ftp_permission: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ftp_permission'), 'exclude': lambda f: f is None }})
    r"""Can the user access with FTP/FTPS?"""  
    group_ids: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('group_ids'), 'exclude': lambda f: f is None }})
    r"""Comma-separated list of group IDs of which this user is a member"""  
    header_text: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('header_text'), 'exclude': lambda f: f is None }})
    r"""Text to display to the user in the header of the UI"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""User ID"""  
    language: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('language'), 'exclude': lambda f: f is None }})
    r"""Preferred language"""  
    last_active_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_active_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent activity time, which is the latest of most recent login, most recent API use, enablement, or creation"""  
    last_api_use_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_api_use_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent API use time"""  
    last_dav_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_dav_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via WebDAV"""  
    last_desktop_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_desktop_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via Desktop app"""  
    last_ftp_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_ftp_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via FTP"""  
    last_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via any protocol"""  
    last_protocol_cipher: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_protocol_cipher'), 'exclude': lambda f: f is None }})
    r"""The most recent protocol and cipher used"""  
    last_restapi_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_restapi_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via Rest API"""  
    last_sftp_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_sftp_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via SFTP"""  
    last_web_login_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('last_web_login_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""User's most recent login time via web"""  
    lockout_expires: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lockout_expires'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Time in the future that the user will no longer be locked out if applicable"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""User's full name"""  
    notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('notes'), 'exclude': lambda f: f is None }})
    r"""Any internal notes on the user"""  
    notification_daily_send_time: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('notification_daily_send_time'), 'exclude': lambda f: f is None }})
    r"""Hour of the day at which daily notifications should be sent. Can be in range 0 to 23"""  
    office_integration_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('office_integration_enabled'), 'exclude': lambda f: f is None }})
    r"""Enable integration with Office for the web?"""  
    password_expire_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password_expire_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Password expiration datetime"""  
    password_expired: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password_expired'), 'exclude': lambda f: f is None }})
    r"""Is user's password expired?"""  
    password_set_at: Optional[datetime] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password_set_at'), 'encoder': utils.datetimeisoformat(True), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})
    r"""Last time the user's password was set"""  
    password_validity_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('password_validity_days'), 'exclude': lambda f: f is None }})
    r"""Number of days to allow user to use the same password"""  
    public_keys_count: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('public_keys_count'), 'exclude': lambda f: f is None }})
    r"""Number of public keys associated with this user"""  
    receive_admin_alerts: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('receive_admin_alerts'), 'exclude': lambda f: f is None }})
    r"""Should the user receive admin alerts such a certificate expiration notifications and overages?"""  
    require_2fa: Optional[UserEntityRequire2faEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_2fa'), 'exclude': lambda f: f is None }})
    r"""2FA required setting"""  
    require_password_change: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_change'), 'exclude': lambda f: f is None }})
    r"""Is a password change required upon next user login?"""  
    restapi_permission: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('restapi_permission'), 'exclude': lambda f: f is None }})
    r"""Can this user access the REST API?"""  
    self_managed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('self_managed'), 'exclude': lambda f: f is None }})
    r"""Does this user manage it's own credentials or is it a shared/bot user?"""  
    sftp_permission: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sftp_permission'), 'exclude': lambda f: f is None }})
    r"""Can the user access with SFTP?"""  
    site_admin: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('site_admin'), 'exclude': lambda f: f is None }})
    r"""Is the user an administrator for this site?"""  
    skip_welcome_screen: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('skip_welcome_screen'), 'exclude': lambda f: f is None }})
    r"""Skip Welcome page in the UI?"""  
    ssl_required: Optional[UserEntitySslRequiredEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ssl_required'), 'exclude': lambda f: f is None }})
    r"""SSL required setting"""  
    sso_strategy_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sso_strategy_id'), 'exclude': lambda f: f is None }})
    r"""SSO (Single Sign On) strategy ID for the user, if applicable."""  
    subscribe_to_newsletter: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subscribe_to_newsletter'), 'exclude': lambda f: f is None }})
    r"""Is the user subscribed to the newsletter?"""  
    time_zone: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('time_zone'), 'exclude': lambda f: f is None }})
    r"""User time zone"""  
    type_of_2fa: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type_of_2fa'), 'exclude': lambda f: f is None }})
    r"""Type(s) of 2FA methods in use.  Will be either `sms`, `totp`, `u2f`, `yubi`, or multiple values sorted alphabetically and joined by an underscore."""  
    user_root: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('user_root'), 'exclude': lambda f: f is None }})
    r"""Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface."""  
    username: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('username'), 'exclude': lambda f: f is None }})
    r"""User's username"""  
    