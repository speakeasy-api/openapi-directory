"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import dateutil.parser
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from datetime import datetime
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclasses.dataclass
class GetPersonalCurrentAccountsRequest:
    
    if_modified_since: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'If-Modified-Since', 'style': 'simple', 'explode': False }})
    r"""Used for conditional request, to retrieve data only if modified since a given date"""  
    if_none_match: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'If-None-Match', 'style': 'simple', 'explode': False }})
    r"""Used for conditional request, to retrieve data only if the given Etag value does not match"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccountsErrorObject:
    r"""A standard error response."""
    
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})
    r"""Further details describing the error"""  
    status: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})
    r"""This corresponds to the HTTP status code"""  
    title: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title') }})
    r"""A short title of the type of error"""  
    
class GetPersonalCurrentAccounts503ErrorObjectDescriptionEnum(str, Enum):
    THE_SERVICE_IS_TEMPORARILY_UNAVAILABLE_ = 'The service is temporarily unavailable.'

class GetPersonalCurrentAccounts503ErrorObjectStatusEnum(str, Enum):
    FIVE_HUNDRED_AND_THREE = '503'

class GetPersonalCurrentAccounts503ErrorObjectTitleEnum(str, Enum):
    SERVICE_TEMPORARILY_UNAVAILABLE = 'Service temporarily unavailable'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts503ErrorObject:
    r"""The service is temporarily unavailable."""
    
    description: GetPersonalCurrentAccounts503ErrorObjectDescriptionEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})  
    status: GetPersonalCurrentAccounts503ErrorObjectStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})  
    title: GetPersonalCurrentAccounts503ErrorObjectTitleEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title') }})  
    
class GetPersonalCurrentAccounts500ErrorObjectDescriptionEnum(str, Enum):
    AN_ERROR_OCCURRED_ON_THE_SERVER_NO_FURTHER_INFORMATION_IS_AVAILABLE_ = 'An error occurred on the server. No further information is available.'

class GetPersonalCurrentAccounts500ErrorObjectStatusEnum(str, Enum):
    FIVE_HUNDRED = '500'

class GetPersonalCurrentAccounts500ErrorObjectTitleEnum(str, Enum):
    INTERNAL_SERVER_ERROR = 'Internal server error'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts500ErrorObject:
    r"""An error occurred on the server. No further information is available."""
    
    description: GetPersonalCurrentAccounts500ErrorObjectDescriptionEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})  
    status: GetPersonalCurrentAccounts500ErrorObjectStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})  
    title: GetPersonalCurrentAccounts500ErrorObjectTitleEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title') }})  
    
class GetPersonalCurrentAccounts429ErrorObjectDescriptionEnum(str, Enum):
    YOU_HAVE_REQUESTED_THIS_RESOURCE_TOO_OFTEN_SLOW_DOWN_ = 'You have requested this resource too often. Slow down.'

class GetPersonalCurrentAccounts429ErrorObjectStatusEnum(str, Enum):
    FOUR_HUNDRED_AND_TWENTY_NINE = '429'

class GetPersonalCurrentAccounts429ErrorObjectTitleEnum(str, Enum):
    TOO_MANY_REQUESTS = 'Too many requests'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts429ErrorObject:
    r"""You have requested this resource too often. Slow down."""
    
    description: GetPersonalCurrentAccounts429ErrorObjectDescriptionEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})  
    status: GetPersonalCurrentAccounts429ErrorObjectStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})  
    title: GetPersonalCurrentAccounts429ErrorObjectTitleEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title') }})  
    
class GetPersonalCurrentAccounts408ErrorObjectDescriptionEnum(str, Enum):
    YOUR_CLIENT_HAS_FAILED_TO_SUBMIT_A_REQUEST_AND_A_TIMEOUT_HAS_OCCURRED_ = 'Your client has failed to submit a request, and a timeout has occurred.'

class GetPersonalCurrentAccounts408ErrorObjectStatusEnum(str, Enum):
    FOUR_HUNDRED_AND_EIGHT = '408'

class GetPersonalCurrentAccounts408ErrorObjectTitleEnum(str, Enum):
    CLIENT_TIMEOUT = 'Client timeout'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts408ErrorObject:
    r"""Your client has failed to submit a request, and a timeout has occurred."""
    
    description: GetPersonalCurrentAccounts408ErrorObjectDescriptionEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})  
    status: GetPersonalCurrentAccounts408ErrorObjectStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})  
    title: GetPersonalCurrentAccounts408ErrorObjectTitleEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title') }})  
    
class GetPersonalCurrentAccounts400ErrorObjectDescriptionEnum(str, Enum):
    YOU_HAVE_SENT_A_REQUEST_WHICH_COULD_NOT_BE_UNDERSTOOD_ = 'You have sent a request which could not be understood.'

class GetPersonalCurrentAccounts400ErrorObjectStatusEnum(str, Enum):
    FOUR_HUNDRED = '400'

class GetPersonalCurrentAccounts400ErrorObjectTitleEnum(str, Enum):
    BAD_REQUEST = 'Bad request'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts400ErrorObject:
    r"""You have sent a request which could not be understood."""
    
    description: GetPersonalCurrentAccounts400ErrorObjectDescriptionEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description') }})  
    status: GetPersonalCurrentAccounts400ErrorObjectStatusEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status') }})  
    title: GetPersonalCurrentAccounts400ErrorObjectTitleEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('title') }})  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataAccessChannelsEnum(str, Enum):
    r"""Channel"""
    ATM = 'ATM'
    BRANCH = 'Branch'
    BUSINESS_COMMERCIAL_CENTRE = 'BusinessCommercialCentre'
    CALL_CENTRE = 'CallCentre'
    MOBILE_APPS = 'MobileApps'
    MOBILE_BANKING = 'MobileBanking'
    ONLINE = 'Online'
    PHONE = 'Phone'
    POST = 'Post'
    POST_OFFICE = 'PostOffice'
    RELATIONSHIP_MANAGER = 'RelationshipManager'
    TEXT = 'Text'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitItemBenefitDetailCriteriaTypeEnum(str, Enum):
    r"""Criteria that is required in order to be eligible for the Benefit"""
    CASH_DEPOSIT = 'CashDeposit'
    DEPOSIT = 'Deposit'
    DIRECT_DEBIT = 'DirectDebit'
    INITIAL_DEPOSIT = 'InitialDeposit'
    INTERNET_LOGON = 'InternetLogon'
    MOBILE_LOGON = 'MobileLogon'
    REGULAR_DEPOSIT = 'RegularDeposit'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitItemBenefitDetail:
    r"""Benefit detail"""
    
    benefit_description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitDescription'), 'exclude': lambda f: f is None }})
    r"""A textual explanation of what the benefit is"""  
    benefit_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitID'), 'exclude': lambda f: f is None }})
    r"""Unique benefit identifier per organisation"""  
    benefit_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitName'), 'exclude': lambda f: f is None }})
    r"""The name of the benefit"""  
    benefit_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitType'), 'exclude': lambda f: f is None }})
    r"""Type that represents the nature of the benefit"""  
    benefit_value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitValue'), 'exclude': lambda f: f is None }})
    r"""The value or values permissible for a specific benefit for an individual product representing a product characteristic"""  
    counter: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Counter'), 'exclude': lambda f: f is None }})
    r"""Counter for the criteria (e.g. number of DD)"""  
    criteria_type: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitItemBenefitDetailCriteriaTypeEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CriteriaType'), 'exclude': lambda f: f is None }})  
    default_to_accounts: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DefaultToAccounts'), 'exclude': lambda f: f is None }})
    r"""Is the benefit part of the default account"""  
    maximum_criteria: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaximumCriteria'), 'exclude': lambda f: f is None }})
    r"""Maximum amount for the criteria"""  
    minimum_criteria: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumCriteria'), 'exclude': lambda f: f is None }})
    r"""Minimum amount for the criteria"""  
    promotion_end_date: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('PromotionEndDate'), 'exclude': lambda f: f is None }})
    r"""If the benefit is temporal the end date is when the benefit is no longer applicable"""  
    promotion_start_date: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('PromotionStartDate'), 'exclude': lambda f: f is None }})
    r"""If the benefit is temporal the start date is when the benefit comes into effect"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitItem:
    r"""Benefit Item"""
    
    benefit_detail: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitItemBenefitDetail]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitDetail'), 'exclude': lambda f: f is None }})  
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date in days"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitSubTypeEnum(str, Enum):
    r"""Benefit Subtype Code"""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroup:
    r"""Benefit Interest Group"""
    
    benefit_item: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitItem = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitItem') }})
    r"""Benefit Item"""  
    benefit_sub_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroupBenefitSubTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitSubType'), 'exclude': lambda f: f is None }})
    r"""Benefit Subtype Code"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefits:
    r"""Benefit"""
    
    benefit: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Benefit') }})
    r"""Describe  one or more benefits if they exist"""  
    benefit_group: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefitsBenefitGroup]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BenefitGroup'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCAPricingCAPricingItem:
    r"""Card Pricing"""
    
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    exchange_rate_adjustment: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ExchangeRateAdjustment'), 'exclude': lambda f: f is None }})
    r"""The margin added, by certain card issuers, to the scheme rate in order to arrive at the exchange rate qouted as the reference exchange rate to the cardholder"""  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCAPricingProductStateEnum(str, Enum):
    r"""Describes if the offering is promotional or a description of a future state."""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCAPricing:
    r"""Card Price"""
    
    ca_pricing_item: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCAPricingCAPricingItem = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CAPricingItem') }})
    r"""Card Pricing"""  
    product_state: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCAPricingProductStateEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductState') }})
    r"""Describes if the offering is promotional or a description of a future state."""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCardTypeEnum(str, Enum):
    r"""Indicates the card scheme"""
    BASIC_CARD = 'BasicCard'
    BUSINESS_QUICK_LODGE_CARD = 'BusinessQuickLodgeCard'
    CASHCARD = 'Cashcard'
    CONTACTLESS_CASHCARD = 'ContactlessCashcard'
    CONTACTLESS_DEBIT_MASTERCARD = 'ContactlessDebitMastercard'
    CONTACTLESS_DEBIT_VISA = 'ContactlessDebitVisa'
    DEBIT_MASTERCARD = 'DebitMastercard'
    VISA_DEBIT = 'VisaDebit'
    DEPOSIT_CARD = 'DepositCard'
    OPERATOR_CARD = 'OperatorCard'
    POCA_CARD = 'POCACard'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemCalculationFrequencyEnum(str, Enum):
    r"""How often is interest applied to account"""
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemCalculationMethodEnum(str, Enum):
    r"""Method for interest calculation"""
    BANDED = 'Banded'
    TIERED = 'Tiered'
    WHOLE = 'Whole'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemInterestRateTypeEnum(str, Enum):
    r"""Credit Interest Payment Rate Type"""
    FIXED = 'Fixed'
    VARIABLE = 'Variable'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemInterestTiersRateComparisonTypeEnum(str, Enum):
    r"""Rate Comparison Type"""
    APR = 'APR'
    AER = 'AER'
    GROSS = 'Gross'
    NET = 'Net'
    REP_APR = 'RepApr'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemInterestTiers:
    r"""Credit Interest Tiers"""
    
    apraer_rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('APRAERRate'), 'exclude': lambda f: f is None }})
    r"""AER or APR Rate for comparison"""  
    daily_charge_for_maximum: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DailyChargeForMaximum'), 'exclude': lambda f: f is None }})
    r"""Special charge on tiered overdraft"""  
    daily_charge_for_minimum: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DailyChargeForMinimum'), 'exclude': lambda f: f is None }})
    r"""Special charge on tiered overdraft"""  
    interest_tier: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('InterestTier'), 'exclude': lambda f: f is None }})
    r"""Identifier for the tier"""  
    rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Rate'), 'exclude': lambda f: f is None }})
    r"""Rate being paid by the bank (gross)"""  
    rate_comparison_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemInterestTiersRateComparisonTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RateComparisonType'), 'exclude': lambda f: f is None }})
    r"""Rate Comparison Type"""  
    tier_value_maximum: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TierValueMaximum'), 'exclude': lambda f: f is None }})
    r"""Max Value of interst tier"""  
    tier_value_minimum: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TierValueMinimum'), 'exclude': lambda f: f is None }})
    r"""Lower value of interest tier"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemPaymentMethodEnum(str, Enum):
    r"""Credit Interest Payment Method Code"""
    COMPOUND = 'Compound'
    PAY_AWAY = 'PayAway'
    SELF_CREDIT = 'SelfCredit'
    SIMPLE_INTEREST = 'SimpleInterest'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItem:
    r"""Credit Interest item"""
    
    calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemCalculationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""How often is interest applied to account"""  
    calculation_method: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemCalculationMethodEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CalculationMethod'), 'exclude': lambda f: f is None }})
    r"""Method for interest calculation"""  
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    end_date: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EndDate'), 'exclude': lambda f: f is None }})
    r"""If interest is charged on a specific date range as end date (often used for promotion)"""  
    fixed_interest_length: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FixedInterestLength'), 'exclude': lambda f: f is None }})
    r"""Fixed interest length in days"""  
    interest_notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('InterestNotes'), 'exclude': lambda f: f is None }})
    r"""Additional notes to supplement the interest details"""  
    interest_rate_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemInterestRateTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('InterestRateType'), 'exclude': lambda f: f is None }})
    r"""Credit Interest Payment Rate Type"""  
    interest_tiers: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemInterestTiers]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('InterestTiers'), 'exclude': lambda f: f is None }})  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    payment_method: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItemPaymentMethodEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('PaymentMethod'), 'exclude': lambda f: f is None }})
    r"""Credit Interest Payment Method Code"""  
    start_date: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartDate'), 'exclude': lambda f: f is None }})
    r"""If interest is charged on a specific date range as start date (often used for promotion)"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupInterestTierSubTypeEnum(str, Enum):
    r"""Describes if the offering is promotional, regular or a description of a future state"""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroup:
    r"""Credit Interest Group"""
    
    credit_interest_item: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupCreditInterestItem = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditInterestItem') }})
    r"""Credit Interest item"""  
    interest_tier_sub_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroupInterestTierSubTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('InterestTierSubType'), 'exclude': lambda f: f is None }})
    r"""Describes if the offering is promotional, regular or a description of a future state"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterest:
    r"""Credit Interest"""
    
    credit_charged: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditCharged') }})
    r"""Is credit paid to the account. The answer will be the condition of all other fields to be filled"""  
    credit_interest_group: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterestCreditInterestGroup]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditInterestGroup'), 'exclude': lambda f: f is None }})  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScoreEnum(str, Enum):
    r"""Indicates the type of scoring"""
    HARD = 'Hard'
    SOFT = 'Soft'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScoreEnum(str, Enum):
    r"""Indicates the type of scoring"""
    HARD = 'Hard'
    SOFT = 'Soft'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityEligibilityTypeEnum(str, Enum):
    r"""Eligibility type"""
    ANY_BUSINESS_CUSTOMER = 'AnyBusinessCustomer'
    BUSINESS_ONLY = 'BusinessOnly'
    CREDIT_CARD = 'CreditCard'
    CREDIT_SCORING = 'CreditScoring'
    EMAIL_ADDRESS = 'EmailAddress'
    EXISTING_CUSTOMERS = 'ExistingCustomers'
    ID_AND_V = 'IdAndV'
    MORTGAGE = 'Mortgage'
    NO_ARREARS_ON_LOAN = 'NoArrearsOnLoan'
    NO_CUSTOMER_IN_ARREARS = 'NoCustomerInArrears'
    NO_OVER_OVERDRAFT_THIRTY_DAYS = 'NoOverOverdraftThirtyDays'
    NO_SOLE_UK_ACCOUNT_OR_BANKRUPT = 'NoSoleUkAccountOrBankrupt'
    NTB = 'NTB'
    NTB_BUSINESS = 'NTBBusiness'
    SOLE_STUDENT_ACCOUNT = 'SoleStudentAccount'
    SOLE_UK_ACCOUNT = 'SoleUkAccount'
    STUDENTS_ONLY = 'StudentsOnly'
    TWO_MONTHS_OF_COURSE_START = 'TwoMonthsOfCourseStart'
    UCAS_FULLTIME_TWO_YEARS = 'UCASFulltimeTwoYears'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityMarketingEligibilityEnum(str, Enum):
    r"""Specific eligibility for marketing"""
    EXISTING_CUSTOMERS = 'ExistingCustomers'
    NEW_CUSTOMERS_ONLY = 'NewCustomersOnly'
    SWITCHERS_ONLY = 'SwitchersOnly'
    START_UP = 'StartUp'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityMinimumIncomeFrequencyEnum(str, Enum):
    r"""The frequency that the minimum mentioned before is deposited in the account. Yearly is very important for premium accounts"""
    ACADEMIC_TERM = 'AcademicTerm'
    HALF_YEARLY = 'HalfYearly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    WEEKLY = 'Weekly'
    YEARLY = 'Yearly'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityResidencyRestrictedRegionEnum(str, Enum):
    r"""Indicates a customer must be current resident of a geographic area/country"""
    UK = 'UK'
    EEA = 'EEA'
    EU = 'EU'
    EFTA = 'EFTA'
    GB_ENG = 'GB - ENG'
    GB_NIR = 'GB - NIR'
    GB_SCT = 'GB - SCT'
    GB_WLS = 'GB - WLS'
    IRL = 'IRL'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilitySingleJointIncomeEnum(str, Enum):
    r"""Minimum Income Source. For certain products a minimum income is required. This can be mandated as to the single income or to a joint income. This field describes this"""
    JOINT = 'Joint'
    SOLE_INCOME = 'SoleIncome'
    SOLE_OR_JOINT = 'SoleOrJoint'
    TURNOVER = 'Turnover'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibility:
    r"""Eligibility"""
    
    age_restricted: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AgeRestricted') }})
    r"""Indicates a customer's age is part of eligibility criteria"""  
    description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description') }})
    r"""One paragraph detailing the eligibility"""  
    income_turnover_related: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('IncomeTurnoverRelated') }})
    r"""Indicates if eligibility linked to income"""  
    other_financial_holding_required: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OtherFinancialHoldingRequired') }})
    r"""Indicates that it is necessary to hold another product with the bank in order to be eligible for this product or feature"""  
    previous_bankruptcy: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('PreviousBankruptcy') }})
    r"""Describes if a previous bankruptcy / insolvency disqualfies for this account Details in ELI-280"""  
    residency_restricted: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ResidencyRestricted') }})
    r"""Indicates a customer's residency forms part of the eligibility criteria"""  
    third_sector_organisations: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ThirdSectorOrganisations') }})
    r"""Is the product available to operate as a Clubs or Societies account?"""  
    annual_business_turnover: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AnnualBusinessTurnover'), 'exclude': lambda f: f is None }})
    r"""Annual Business Turnover"""  
    annual_business_turnover_currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AnnualBusinessTurnoverCurrency'), 'exclude': lambda f: f is None }})
    r"""Annual Business Turnover Currency"""  
    eligibility_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EligibilityName'), 'exclude': lambda f: f is None }})
    r"""Free text description, denotes non standard eligibilities not included in the code list"""  
    eligibility_notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EligibilityNotes'), 'exclude': lambda f: f is None }})
    r"""Optional additional notes to supplement the eligibility conditions. Only used for very specific conditions"""  
    eligibility_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityEligibilityTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EligibilityType'), 'exclude': lambda f: f is None }})
    r"""Eligibility type"""  
    income_condition: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('IncomeCondition'), 'exclude': lambda f: f is None }})
    r"""Stipulates any particular definition of income that applies to the income eligibility and/or method by which income must paid into the account (eg Salary DD)"""  
    marketing_eligibility: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityMarketingEligibilityEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MarketingEligibility'), 'exclude': lambda f: f is None }})  
    maximum_age: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaximumAge'), 'exclude': lambda f: f is None }})
    r"""Maximum age, in years, allowed to hold the account"""  
    maximum_age_to_open: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaximumAgeToOpen'), 'exclude': lambda f: f is None }})
    r"""Maximum age, in years, to open an account"""  
    maximum_opening_amount: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaximumOpeningAmount'), 'exclude': lambda f: f is None }})
    r"""A maximum amount to be deposited at opening"""  
    max_number_of_accounts: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaxNumberOfAccounts'), 'exclude': lambda f: f is None }})
    r"""Maximum number of the same prodcut the customer may hold"""  
    minimum_age: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumAge'), 'exclude': lambda f: f is None }})
    r"""Minimum age, in years, required to hold an account"""  
    minimum_deposit: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumDeposit'), 'exclude': lambda f: f is None }})
    r"""A minimum deposit required to hold this account"""  
    minimum_income_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityMinimumIncomeFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumIncomeFrequency'), 'exclude': lambda f: f is None }})
    r"""The frequency that the minimum mentioned before is deposited in the account. Yearly is very important for premium accounts"""  
    minimum_income_turnover_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumIncomeTurnoverAmount'), 'exclude': lambda f: f is None }})
    r"""Minimum income / Turnover required to hold the product"""  
    minimum_income_turnover_currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumIncomeTurnoverCurrency'), 'exclude': lambda f: f is None }})
    r"""Minimum income / Turnover Currency"""  
    minimum_operating_balance: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumOperatingBalance'), 'exclude': lambda f: f is None }})
    r"""Minimum Operating Balance"""  
    minimum_operating_balance_currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumOperatingBalanceCurrency'), 'exclude': lambda f: f is None }})
    r"""Minimum Operating Balance currency"""  
    minimum_operating_balance_exists: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinimumOperatingBalanceExists'), 'exclude': lambda f: f is None }})
    r"""Is there a Minimum Operating Balance?"""  
    min_income_turnover_paid_into_account: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MinIncomeTurnoverPaidIntoAccount'), 'exclude': lambda f: f is None }})
    r"""Minimum Income Amount required to paid into the account"""  
    opening_deposit_maximum_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OpeningDepositMaximumAmount'), 'exclude': lambda f: f is None }})
    r"""Maximum Amount to be depositing at opening"""  
    opening_deposit_maximum_currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OpeningDepositMaximumCurrency'), 'exclude': lambda f: f is None }})
    r"""The currency of the Minimum Amount to be depositing at opening"""  
    opening_deposit_minimum: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OpeningDepositMinimum'), 'exclude': lambda f: f is None }})
    r"""Minimum Amount to be held on account"""  
    opening_deposit_minimum_currency: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OpeningDepositMinimumCurrency'), 'exclude': lambda f: f is None }})
    r"""The currency of the Minimum Amount to be depositing at opening"""  
    residency_restricted_region: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilityResidencyRestrictedRegionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ResidencyRestrictedRegion'), 'exclude': lambda f: f is None }})
    r"""Indicates a customer must be current resident of a geographic area/country"""  
    single_joint_income: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibilitySingleJointIncomeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('SingleJointIncome'), 'exclude': lambda f: f is None }})
    r"""Minimum Income Source. For certain products a minimum income is required. This can be mandated as to the single income or to a joint income. This field describes this"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeatureFeatureDetailsFeatureSubTypeEnum(str, Enum):
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeatureFeatureDetails:
    r"""Feature Details"""
    
    criteria_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CriteriaType'), 'exclude': lambda f: f is None }})
    r"""Criteria that is required in order to be eligible for the feature"""  
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    feature_description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeatureDescription'), 'exclude': lambda f: f is None }})
    r"""A textual explanation of what the feature"""  
    feature_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeatureName'), 'exclude': lambda f: f is None }})
    r"""The name of the feature"""  
    feature_sub_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeatureFeatureDetailsFeatureSubTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeatureSubType'), 'exclude': lambda f: f is None }})  
    feature_type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeatureType'), 'exclude': lambda f: f is None }})
    r"""Type that represents the nature of the feature"""  
    feature_value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeatureValue'), 'exclude': lambda f: f is None }})
    r"""The value or values permissible for a specific feature for an individual product representing a product characteristic"""  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeatureProductStateEnum(str, Enum):
    r"""Describes if the offering is promotional or a description of a future state."""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeature:
    r"""Account Features"""
    
    existing_feature: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ExistingFeature') }})
    r"""Indicates whether the account has any feature"""  
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    feature_details: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeatureFeatureDetails]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeatureDetails'), 'exclude': lambda f: f is None }})
    r"""Feature details"""  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    product_state: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeatureProductStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductState'), 'exclude': lambda f: f is None }})
    r"""Describes if the offering is promotional or a description of a future state."""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetailFeeSubDetailsFeeFrequencyEnum(str, Enum):
    r"""Triggering frequency of the fee"""
    ACADEMIC_TERM = 'AcademicTerm'
    ACCOUNT_CLOSING = 'AccountClosing'
    ACCOUNT_OPENING = 'AccountOpening'
    AT_TIME_OF_LOAN_REPAYMENT = 'AtTimeOfLoanRepayment'
    CHARGING_PERIOD = 'ChargingPeriod'
    DAILY = 'Daily'
    EVERY_FIVE_BUSINESS_DAYS = 'EveryFiveBusinessDays'
    ITEM = 'Item'
    MONTHLY = 'Monthly'
    ON_ACCOUNT_ANNIVERSARY = 'OnAccountAnniversary'
    PER_HOUR = 'PerHour'
    PER_OCCURRENCE = 'PerOccurrence'
    PER_SHEET = 'PerSheet'
    PER_TRANSACTION_AMOUNT = 'PerTransactionAmount'
    PER_TRANSACTION_PERCENTAGE = 'PerTransactionPercentage'
    QUARTERLY = 'Quarterly'
    SIX_MONTHLY = 'SixMonthly'
    START_OF_LOAN = 'StartOfLoan'
    STATEMENT_MONTHLY = 'StatementMonthly'
    WEEKLY = 'Weekly'
    YEARLY = 'Yearly'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetailFeeSubDetails:
    r"""Fee Sub Details"""
    
    fee_frequency: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetailFeeSubDetailsFeeFrequencyEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeFrequency') }})
    r"""Triggering frequency of the fee"""  
    negotiable: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Negotiable') }})
    r"""Indicates that this Fee Rate or Fee Amount is negotiable based on risk or other factor"""  
    fee_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeAmount'), 'exclude': lambda f: f is None }})
    r"""Fee in GBP"""  
    fee_higher_tier: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeHigherTier'), 'exclude': lambda f: f is None }})
    r"""Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range"""  
    fee_lower_tier: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeLowerTier'), 'exclude': lambda f: f is None }})
    r"""Lower occurrence / range boundary e.g. For returned cheques this could be 0, which means the first returned cheque fits into this range"""  
    fee_max: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeMax'), 'exclude': lambda f: f is None }})
    r"""Fee in GBP"""  
    fee_min: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeMin'), 'exclude': lambda f: f is None }})
    r"""Fee in GBP"""  
    fee_rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeRate'), 'exclude': lambda f: f is None }})
    r"""% Rate"""  
    fees_and_charges_notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeesAndChargesNotes'), 'exclude': lambda f: f is None }})
    r"""Supplementary information for fees and charges"""  
    representative_rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('RepresentativeRate'), 'exclude': lambda f: f is None }})
    r"""Representative Rate"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetailFeeTypeEnum(str, Enum):
    r"""A description of the Fee type"""
    OTHER = 'Other'
    ATM_DONATION = 'ATMDonation'
    ATM_DEPOS_ATM_PAID_IN = 'ATMDeposATMPaidIn'
    REPORT_CERT_BALANCE = 'ReportCertBalance'
    ATM_ABROAD_CON_VISA_CREDIT = 'ATMAbroadConVisaCredit'
    ATM_ABROAD_CON_VISA_DEBIT = 'ATMAbroadConVisaDebit'
    ATM_CARDNET_ENV_IN = 'ATMCardnetEnvIn'
    ATM_CASH_GROUP_ATM_CREDIT_CARD = 'ATMCashGroupATMCreditCard'
    ATM_CASH_NON_GROUP_ATM_CREDITTCARD = 'ATMCashNonGroupATMCredittcard'
    ATM_CASH_GROUP_ATM_DEBIT_CARD = 'ATMCashGroupATMDebitCard'
    ATM_CASH_NON_GROUP_ATM_DEBITCARD = 'ATMCashNonGroupATMDebitcard'
    ATM_CON_GROUP_ATM = 'ATMConGroupATM'
    ATM_ABROAD = 'ATMAbroad'
    ATM_FOREIGN_CASH_DEB_CARD = 'ATMForeignCashDebCard'
    ATM_ABROAD_GOLD_VISA_DEBIT = 'ATMAbroadGoldVisaDebit'
    ATM_SPAIN_CASH_CARD = 'ATMSpainCashCard'
    ATM_SPAIN_DEBIT_CARD = 'ATMSpainDebitCard'
    ATM_SPAIN_CONVERSION_DEBIT_CARD = 'ATMSpainConversionDebitCard'
    ATM_SPAIN_CONVERSION_CASH_CARD = 'ATMSpainConversionCashCard'
    ATM_NON_STERLING_WITHDRAWAL = 'ATMNonSterlingWithdrawal'
    ATM_ABROAD_VISA_CREDIT = 'ATMAbroadVisaCredit'
    ATM_ABROAD_VISA_DEBIT = 'ATMAbroadVisaDebit'
    ATM_ABROAD_CON_VISA_GOLD_DEBIT = 'ATMAbroadConVisaGoldDebit'
    ATM_WIDTHDRAW_CASH = 'ATMWidthdrawCash'
    BACS_ON_LINE_ANCILLIARY = 'BACSOnLineAncilliary'
    BACS_BATCH = 'BACSBatch'
    BACS_ON_LINE_FILE = 'BACSOnLineFile'
    BACS_FILE_ITEM = 'BACSFileItem'
    BACS_ON_LINE_SETUP = 'BACSOnLineSetup '
    BACS_ITEM = 'BACSItem'
    BACS_ITEM_INTERBRANCH = 'BACSItemInterbranch'
    BACS_BULK_BATCH = 'BACSBulkBatch'
    BACS_ON_LINE_OVERLIMIT = 'BACSOnLineOverlimit'
    BACS_ON_LINE_PAYMENT = 'BACSOnLinePayment'
    BACS_RECALL_ITEM = 'BACSRecallItem'
    BACS_ON_LINE_SERVICE = 'BACSOnLineService'
    BACS_BULK_INTERNET = 'BACSBulkInternet'
    BACSTEL_DIR_DEB_SMART_CARD = 'BACSTELDirDebSmartCard'
    BACSTEL_DIR_DEB_WEB_INIT = 'BACSTELDirDebWebInit'
    BACSTE_LIR_DEB_WEB_INIT = 'BACSTELirDebWebInit'
    BACSTEL_DIR_DEB_OVERLIMIT = 'BACSTELDirDebOverlimit'
    BACSTEL_DIR_DEB_PAYMENT = 'BACSTELDirDebPayment'
    BACSTEL_DIR_DEB_SERVICE = 'BACSTELDirDebService'
    BACSTEL_DIR_DEB_ANCILLIARY = 'BACSTELDirDebAncilliary'
    BACS_DIRECT_ITEM_PROFILE = 'BACSDirectItemProfile'
    BACSTEL_ANCILLIARY = 'BACSTELAncilliary'
    BACSTEL_SMART_CARD = 'BACSTELSmartCard'
    BACSTEL_FILE = 'BACSTELFile'
    BACSTEL_SETUP = 'BACSTELSetup '
    BACSTEL_OVERLIMIT = 'BACSTELOverlimit'
    BACSTEL_PAYMENT = 'BACSTELPayment'
    BACSTEL_SERVICE = 'BACSTELService'
    CHAPS_OUT_BRANCH = 'CHAPSOutBranch'
    CHAPS_CANCELLATION = 'CHAPSCancellation'
    CHAPS_OUT_ONLINE_DEPOSIT_ACC = 'CHAPSOutOnlineDepositAcc'
    CHAPS_IN = 'CHAPSIn'
    CHAPS_OUT_INTER_BANK = 'CHAPSOutInterBank'
    CHAPS_INTER_BANK = 'CHAPSInterBank'
    CHAPS_OUT_POST = 'CHAPSOutPost'
    CHAPS_OUT_INTER_BRANCH = 'CHAPSOutInterBranch'
    CHAPS_OUT = 'CHAPSOut'
    CHAPS_OUT_ONLINE = 'CHAPSOutOnline'
    CHAP_SAND_FOREIGN_PAY = 'CHAPSandForeignPay'
    CHAPS_OUT_MANUAL = 'CHAPSOutManual'
    CARD_CARD_REPLACEMENT = 'CardCardReplacement'
    DRAFTS_COUNTER = 'DraftsCounter'
    DRAFTS_BANKERS = 'DraftsBankers'
    DRAFTS_INTL_PAYABLE_ABROAD = 'DraftsIntlPayableAbroad'
    DRAFTS_LOST_STOLEN = 'DraftsLostStolen'
    CARD_PERSONALISED_CARD = 'CardPersonalisedCard'
    DRAFTS_INTL_STOPPED_CANCELLED = 'DraftsIntlStoppedCancelled'
    EURO_CHQ_X_LESS = 'EuroChqXLess'
    EURO_CHQ_X_PLUS = 'EuroChqXPlus'
    FPS_OUT_FUTURE_DATED = 'FPSOutFutureDated'
    FPS_OUT_IMMEDIATE = 'FPSOutImmediate'
    FPS_OUT = 'FPSOut'
    FPS_OUT_OWN = 'FPSOutOwn'
    FPS_IN_BRANCH = 'FPSInBranch'
    FPSUK_PAY_URGENT = 'FPSUKPayUrgent'
    LEGAL_ARTICLES_REPORT = 'LegalArticlesReport'
    LEGAL_SEALING = 'LegalSealing'
    LEGAL_BOND_AND_GUARANTEE = 'LegalBondAndGuarantee'
    LEGAL_COURT_ORDER = 'LegalCourtOrder'
    LEGAL_CO_SEARCH = 'LegalCoSearch'
    LEGAL_DEPOSIT_ASSIGNMENT = 'LegalDepositAssignment'
    LEGAL_GUARANTEE_PREP = 'LegalGuaranteePrep'
    LEGAL_LIFE_POLICY_PREP_CO = 'LegalLifePolicyPrepCo'
    LEGAL_LIFE_POLICY_PREP_PERSONAL = 'LegalLifePolicyPrepPersonal'
    LEGAL_PRIORITY_PARI_PASSU = 'LegalPriorityPariPassu'
    LEGAL_SUBORDINATION_AGREEMENT = 'LegalSubordinationAgreement'
    DIR_DEB_DIRECT_DEBIT_ADMIN = 'DirDebDirectDebitAdmin'
    DIR_DEB_DIRECT_DEBIT_CANCEL = 'DirDebDirectDebitCancel'
    INTL_PAY_BIB_FOREIGN_LIMIT = 'IntlPayBIBForeignLimit'
    INTL_PAY_CREDIT_TRANS_CUST = 'IntlPayCreditTransCust'
    INTL_PAY_CREDIT_TRANS_NON_CUST = 'IntlPayCreditTransNonCust'
    INTL_PAY_URGENT_PAYMENT_FOREIGN = 'IntlPayUrgentPaymentForeign'
    INTL_PAY_EXPRESS_MONEY_MOVER = 'IntlPayExpressMoneyMover'
    INTL_PAY_EEA_PAY_URGENT = 'IntlPayEEAPayUrgent'
    INTL_PAY_IRISH_PAY_URGENT = 'IntlPayIrishPayUrgent'
    INTL_PAY_EEA_PAY = 'IntlPayEEAPay'
    INTL_PAY_FOREIGN_IN1_C_PLUS = 'IntlPayForeignIn1CPlus'
    INTL_PAY_FOREIGN_PAYMENT_IN_UK_ACC = 'IntlPayForeignPaymentInUKAcc'
    INTL_PAY_FOREIGN_CHARGE = 'IntlPayForeignCharge'
    INTL_PAY_FOREIGN_CANCELLATION = 'IntlPayForeignCancellation'
    INTL_PAY_FOREIGN_STANDARD_EU_EURO_BIC = 'IntlPayForeignStandardEUEuroBIC'
    INTL_PAY_FX_FEE_RATE = 'IntlPayFXFeeRate'
    INTL_PAY_FOREIGN_INTERNET = 'IntlPayForeignInternet'
    INTL_PAY_FOREIGN = 'IntlPayForeign'
    INTL_PAY_FOREIGN_INBOUND = 'IntlPayForeignInbound'
    INTL_PAY_FX_PAYMENT_OUT = 'IntlPayFXPaymentOut'
    INTL_PAY_FOREIGN_IN_SUB1_C = 'IntlPayForeignInSub1C'
    INTL_PAY_FX_RATE = 'IntlPayFXRate'
    INTL_PAY_FOREIGN_STANDARD_EU_EURO_NO_BIC = 'IntlPayForeignStandardEUEuroNoBIC'
    INTL_PAY_FX_PAYMENT_OUT_IR = 'IntlPayFXPaymentOutIR'
    INTL_PAY_FX_FEE = 'IntlPayFXFee'
    INTL_PAY_PURCHASE_NON_STERLING = 'IntlPayPurchaseNonSterling'
    INTL_PAY_POST_PAYMENT_FOREIGN = 'IntlPayPostPaymentForeign'
    INTL_PAY_PURCHASE_RATE_NON_STERLING = 'IntlPayPurchaseRateNonSterling'
    INTL_PAY_PAYMENT_TRACING = 'IntlPayPaymentTracing'
    INTL_PAY_STANDARD_MONEY_MOVER = 'IntlPayStandardMoneyMover'
    INTL_PAY_MT101_TRANSACTION = 'IntlPayMT101Transaction'
    INTL_PAY_TRANS_NON_STERLING = 'IntlPayTransNonSterling'
    INTL_PAY_TRANS_RATE_NON_STERLING = 'IntlPayTransRateNonSterling'
    INTL_PAY_FOREIGN_URGENT_EU_EURO_BIC = 'IntlPayForeignUrgentEUEuroBIC'
    INTL_PAY_FOREIGN_URGENT_EU_EURO_NO_BIC = 'IntlPayForeignUrgentEUEuroNoBIC'
    INTL_PAY_URGENT_PAYMENT_GROUP = 'IntlPayUrgentPaymentGroup'
    INTL_PAY_URGENT_PAYMENT_UK = 'IntlPayUrgentPaymentUK'
    INTL_PAY_USA_PAY_URGENT = 'IntlPayUSAPayUrgent'
    INTL_PAY_CURRENCY_PURCHASE = 'IntlPayCurrencyPurchase'
    INTL_PAY_WORLDPAY_PAYMENT = 'IntlPayWorldpayPayment'
    INTL_PAY_CURRENCY_WITHDRAW = 'IntlPayCurrencyWithdraw'
    INV_PAY_BANK_DETAILS_WRONG = 'InvPayBankDetailsWrong'
    INV_PAY_FOREIGN_BCNR = 'InvPayForeignBCNR'
    INV_PAY_FOREIGN_RECALL = 'InvPayForeignRecall'
    INV_GENERAL_INQ = 'InvGeneralInq'
    INV_OLD_INSTRUCTION = 'InvOldInstruction'
    INV_PAY_PAYMENT_RECALL = 'InvPayPaymentRecall'
    INV_PAY_RETURN_DEBIT_XV_LESS = 'InvPayReturnDebitXVLess'
    INV_PAY_RETURN_DEBIT_XV_PLUS = 'InvPayReturnDebitXVPlus'
    INV_PAY_STOP_PAYMENT = 'InvPayStopPayment'
    INV_PAY_STANDING_ORD_UNPAID = 'InvPayStandingOrdUnpaid'
    SAFE_KEEP_ACCESS = 'SafeKeepAccess'
    SAFE_KEEP_DEED_MEDIUM = 'SafeKeepDeedMedium'
    SAFE_KEEPING_ENVELOPE = 'SafeKeepingEnvelope'
    SAFE_KEEPING_INSPECTION = 'SafeKeepingInspection'
    SAFE_KEEPING_LARGE_ITEM = 'SafeKeepingLargeItem'
    SAFE_KEEP_MULTIPLE_ITEMS = 'SafeKeepMultipleItems'
    SAFE_KEEPING_PARCEL = 'SafeKeepingParcel'
    SAFE_KEEP_DEED_SMALL = 'SafeKeepDeedSmall'
    SAFE_KEEP_ONE_ITEM = 'SafeKeepOneItem'
    SAFE_KEEP_SAFE_CUSTODY = 'SafeKeepSafeCustody'
    LOAN_ARRANGEMENT_FEE_PC = 'LoanArrangementFeePC'
    LOAN_ARRANGEMENT = 'LoanArrangement'
    LOAN_EARLY_REPAYMENT = 'LoanEarlyRepayment'
    LOAN_LATE_PAYMENT = 'LoanLatePayment'
    LOAN_SME_UNSECURED_LOAN = 'LoanSMEUnsecuredLoan'
    LOAN_TIERED_ARRANGEMENT = 'LoanTieredArrangement'
    NIGHT_SAFE_NIGHT_SAFE_BANK_OPEN = 'NightSafeNightSafeBankOpen'
    NIGHT_SAFE_CREDIT_SUB5_K = 'NightSafeCreditSub5K'
    NIGHT_SAFE_NIGHT_SAFE = 'NightSafeNightSafe'
    NIGHT_SAFE_NIGHT_SAFE_PAID_IN = 'NightSafeNightSafePaidIn'
    OVERDRAFT_ANNUAL_REVIEW = 'OverdraftAnnualReview'
    OVERDRAFT_TEMP_OVERDRAFT = 'OverdraftTempOverdraft'
    OVERDRAFT_UNAUTHORISED_BORROWING = 'OverdraftUnauthorisedBorrowing'
    PO_POST_OFFICE_COUNTER_CREDIT = 'POPostOfficeCounterCredit'
    PO_POST_OFFICE_CASH_CREDIT = 'POPostOfficeCashCredit'
    PO_POST_OFFICE_CASH_OUT = 'POPostOfficeCashOut'
    PO_POST_OFFICE_WITHDRAWAL = 'POPostOfficeWithdrawal'
    CHQ_BOOK_THEFT_LOSS_ALL_STOPPED = 'ChqBookTheftLossAllStopped'
    CHQ_ISSUED_CURRENCY_ACC = 'ChqIssuedCurrencyAcc'
    CHQ_COPY = 'ChqCopy'
    CHQ_DRAFT = 'ChqDraft'
    CHQ_IN = 'ChqIn'
    CHQ_DRAFT_STERLING = 'ChqDraftSterling'
    CHQ_OUT_ISSUED = 'ChqOutIssued'
    CHQ_SPECIAL_CHQ_PRESENTATION = 'ChqSpecialChqPresentation'
    CHQ_COUNTER_CHEQUE = 'ChqCounterCheque'
    CHQ_CHEQUESWITH_STATEMENT = 'ChqChequeswithStatement'
    CHQ_STOPPED = 'ChqStopped'
    CHQ_TRANS = 'ChqTrans'
    CHQ_DRAFT_FX = 'ChqDraftFX'
    CHQ_FOREIGN_COURIER = 'ChqForeignCourier'
    CHQ_FOREIGN_NEG_TEN_THOU = 'ChqForeignNegTenThou'
    CHQ_FOREIGN_NEG_HUNDRED = 'ChqForeignNegHundred'
    CHEQUE_FOREIGN_BANK_DIVI = 'ChequeForeignBankDivi'
    CHQ_FOREIGN_NEG_FIFTY_THOU = 'ChqForeignNegFiftyThou'
    CHQ_PENSION_CHEQUE = 'ChqPensionCheque'
    CHEQUE_FOREIGN_OTHER_DIVI = 'ChequeForeignOtherDivi'
    CHQ_FOREIGN_NEG_FIVE_THOU = 'ChqForeignNegFiveThou'
    CHQ_FOREIGN_NEG_MAX = 'ChqForeignNegMax'
    CHQ_FOREIGN_GBPMMD_PLUS = 'ChqForeignGBPMMDPlus'
    CHQ_GIFT_CHEQUE = 'ChqGiftCheque'
    CHQ_COUNTER_LODGEMENT = 'ChqCounterLodgement'
    CHQ_CASH_DROP_LODGEMENT = 'ChqCashDropLodgement'
    CHQ_CHEQUE_PHOTOCOPY = 'ChqChequePhotocopy'
    CHQ_POST_OFFICE_CREDIT = 'ChqPostOfficeCredit'
    CHQ_POST_OFFICE_CHEQUE_COLLECTED = 'ChqPostOfficeChequeCollected'
    CHQ_CHEQUE_RETRIEVAL = 'ChqChequeRetrieval'
    CHQ_RECONCILLIATION_PER_TRANS = 'ChqReconcilliationPerTrans'
    CHQ_SPECIAL_PRESENTATION_COUNT = 'ChqSpecialPresentationCount'
    CHQ_SPECIAL_PRESENTATION_PTT = 'ChqSpecialPresentationPTT'
    CHQ_UNPAID_CHARGE = 'ChqUnpaidCharge'
    CHQ_UNPAID_TRANS_IN = 'ChqUnpaidTransIn'
    CHQ_UNPAID_TRANS_OUT = 'ChqUnpaidTransOut'
    CHQ_UNPAID_CHEQUE = 'ChqUnpaidCheque'
    REPORT_AUDIT_LETTER = 'ReportAuditLetter'
    REPORT_FAX_ADVICE_ADDITIONAL = 'ReportFAXAdviceAdditional'
    REPORT_TEL_ADVICE_ADDITIONAL = 'ReportTelAdviceAdditional'
    REPORT_CREDIT_HISTORY = 'ReportCreditHistory'
    REPORT_CERT_INTEREST_DUPLICATE = 'ReportCertInterestDuplicate'
    REPORT_CERT_INTEREST = 'ReportCertInterest'
    REPORT_CREDIT_HISTORY_ADDITIONAL_IN_YEAR = 'ReportCreditHistoryAdditionalInYear'
    REPORT_FOREIGN_STATUS_ENQ_ELEC = 'ReportForeignStatusEnqElec'
    REPORT_FOREIGN_STATUS_ENQ = 'ReportForeignStatusEnq'
    REPORT_CASH_BACKOR_INTEREST_ANAL = 'ReportCashBackorInterestAnal'
    REPORT_STATEMENT_CHQ_DAILY = 'ReportStatementChqDaily'
    REPORT_STATEMENT_CHQ_FORTNIGHTLY = 'ReportStatementChqFortnightly'
    REPORT_STATEMENT_CHQ_MONTHLY = 'ReportStatementChqMonthly'
    REPORT_STATEMENT_CHQ_WEEKLY = 'ReportStatementChqWeekly'
    REPORT_STATEMENT_AND_DIVI_CHQ = 'ReportStatementAndDiviChq'
    REPORT_REFERENCE = 'ReportReference'
    REPORT_REFERRAL_ITEM = 'ReportReferralItem'
    REPORT_STATEMENT_BY_ATM = 'ReportStatementByATM'
    REPORT_STATEMENT_BY_BRANCH = 'ReportStatementByBranch'
    REPORT_STATEMENT_COPY_REGULAR = 'ReportStatementCopyRegular'
    REPORT_STATUS_ENQUIRY = 'ReportStatusEnquiry'
    REPORT_STATEMENT_FREQUENT = 'ReportStatementFrequent'
    REPORT_STATEMENT_MONTHLY = 'ReportStatementMonthly'
    REPORT_STATEMENT_COPY1 = 'ReportStatementCopy1'
    REPORT_STATEMENT_TO_BRANCH = 'ReportStatementToBranch'
    REPORT_SMS_TEXT_MINI_STATEMENTOR_ALERT = 'ReportSMSTextMiniStatementorAlert'
    REPORT_STATEMENT_FORTNIGHTLY = 'ReportStatementFortnightly'
    REPORT_SMS_TEXT_MINI_STATEMENT_WO_M = 'ReportSMSTextMiniStatementWoM'
    REPORT_SMS_TEXT_ALERT_BALANCE = 'ReportSMSTextAlertBalance'
    REPORT_SMS_TEXT_ALERT = 'ReportSMSTextAlert'
    REPORT_TAX_CERT = 'ReportTaxCert'
    REPORT_WEEKLY_STATEMENT = 'ReportWeeklyStatement'
    REPORT_TEXT_MESSAGE_BANKING = 'ReportTextMessageBanking'
    SEPA_CANCELLATION = 'SEPACancellation'
    SEPA_BRANCH = 'SEPABranch'
    SEPA_CREDIT = 'SEPACredit'
    SEPA_DIRECT_DEBIT = 'SEPADirectDebit'
    SEPA_IN = 'SEPAIn'
    SEPA_EURO = 'SEPAEuro'
    SEPA_OUT = 'SEPAOut'
    SEPA_UNPAID = 'SEPAUnpaid'
    SEPA_WINBITS_ANNUAL_SERVICE = 'SEPAWinbitsAnnual Service'
    SEPA_WINBITS_TRANSACTION = 'SEPAWinbitsTransaction'
    TRANS_BILL_PAYMENT_BRANCH = 'TransBillPaymentBranch'
    TRANS_BILL_COLLECT = 'TransBillCollect'
    TRANS_TELEPHONE_BILL_PAYMENT = 'TransTelephoneBillPayment'
    TRANS_BANK_PAYMENT = 'TransBankPayment'
    TRANS_BILL_PAYMENT_TELEPHONE = 'TransBillPaymentTelephone'
    TRANS_CORRESPONDENT_BANK_FEE = 'TransCorrespondentBankFee'
    TRANS_CREDIT_TRANSFER_UK_DIFFERENT = 'TransCreditTransferUKDifferent'
    TRANS_CREDIT_TRANSFER_UK_SAME = 'TransCreditTransferUKSame'
    TRANS_CREDIT = 'TransCredit'
    TRANS_CREDIT_TRANSFER = 'TransCreditTransfer'
    TRANS_BRANCH_CREDIT = 'TransBranchCredit'
    TRANS_DEBIT = 'TransDebit'
    TRANS_DEB_CARD_DEB = 'TransDebCardDeb'
    TRANS_UK_DIR_DEB = 'TransUKDirDeb'
    TRANS_MANUAL_DEB = 'TransManualDeb'
    TRANS_BUY_FOREIGN_WITH_GBP = 'TransBuyForeignWithGBP'
    TRANS_GOOD_VALUE_REQ = 'TransGoodValueReq'
    TRANS_SWIFT_OUT_UK_FOREIGN = 'TransSWIFTOutUKForeign'
    TRANS_INCONPLETE_INSTRUCTION = 'TransInconpleteInstruction'
    TRANS_MANUAL_ENTRIES = 'TransManualEntries'
    TRANS_MANUAL_TRANS = 'TransManualTrans'
    TRANS_NON_STERLING = 'TransNonSterling'
    TRANS_POS_SALE_FOREIGN = 'TransPOSSaleForeign'
    TRANS_PRI_PAYMENT_POST = 'TransPriPaymentPost'
    TRANS_POS_SALE_UK = 'TransPOSSaleUK'
    TRANS_RETURN_PAYMENT = 'TransReturnPayment'
    TRANS_RECONCILIATION_PER_TRANS = 'TransReconciliationPerTrans'
    TRANS_STANDING_ORD_ADMIN = 'TransStandingOrdAdmin'
    TRANS_STANDING_ORD = 'TransStandingOrd'
    TRANS_STANDING_ORD_MAN_PAY = 'TransStandingOrdManPay'
    TRANS_TRAVELLERS_CHQ_OTHER_BANK = 'TransTravellersChqOtherBank'
    TRANS_TEL_BUSI_PRI_PAYMENT_FOREIGN_TO_UK_ACC = 'TransTelBusiPriPaymentForeignToUKAcc'
    TRANS_TELE_ITEM = 'TransTeleItem'
    TRANS_TEL_BUSI_PRI_PAYMENT_TO_GRP_ACC = 'TransTelBusiPriPaymentToGrpAcc'
    TRANS_TRAVELLERS_CHQ_RATE = 'TransTravellersChqRate'
    TRANS_TRANSFER_EX_GROUP = 'TransTransferExGroup'
    TRANS_UNAUTHORISED_PAID_TRANS = 'TransUnauthorisedPaidTrans'
    TRANS_URGENT_PAYMENT_POSTAL = 'TransUrgentPaymentPostal'
    TRANS_UNPAID_TRANS = 'TransUnpaidTrans'
    TRANS_TEL_BUSI_PRI_PAYMENT_TO_NON_GRP_ACC = 'TransTelBusiPriPaymentToNonGrpAcc'
    TRANS_SWIFT_OUT_NON_EEA_STERLING = 'TransSWIFTOutNonEEASterling'
    AUTO_AUTO_CREDIT = 'AutoAutoCredit'
    AUTO_AUTOMATED_ENTRIES = 'AutoAutomatedEntries'
    AUTO_AUTO_CREDIT_PHONE_INET = 'AutoAutoCreditPhoneInet'
    AUTO_AUTOMATED_TRANS = 'AutoAutomatedTrans'
    AUTO_DEBIT_CARD_COMMERCIAL = 'AutoDebitCardCommercial'
    AUTO_FPS_AUTO_CREDIT = 'AutoFPSAutoCredit'
    VISA_CONVERT_ABROAD_FOREIGN = 'VisaConvertAbroadForeign'
    VISA_BUREAU_DE_CHANGE = 'VisaBureauDeChange'
    VISA_TRAVELLERS_CHQOR_CURRENCY = 'VisaTravellersChqorCurrency'
    ONLINE_INTERNET_BILL_PAYMENT = 'OnlineInternetBillPayment'
    ONLINE_BUSINESS_ONLINE_EURO_PAYMENT = 'OnlineBusinessOnlineEuroPayment'
    ONLINE_BUSINESS_ONLINE_URGENT_EURO_PAYMENT = 'OnlineBusinessOnlineUrgentEuroPayment'
    ONLINE_BUSINESS_ONLINE_FOREIGN_PAYMENT = 'OnlineBusinessOnlineForeignPayment'
    ONLINE_INTERBANK_TRANSFER = 'OnlineInterbankTransfer'
    ONLINE_INTERBANK_PER_TRANSFER = 'OnlineInterbankPerTransfer'
    ONLINE_INTERBRANCH_TRANSFER = 'OnlineInterbranchTransfer'
    ONLINE_INTERBRANCH_PER_TRANSFER = 'OnlineInterbranchPerTransfer'
    ONLINE_SUBSCRIPTION_MONTHLY = 'OnlineSubscriptionMonthly'
    ONLINE_BANKING_PAYMENT = 'OnlineBankingPayment'
    ONLINE_BANKING_SUBSCRIPTION = 'OnlineBankingSubscription'
    ONLINE_POS_SALE = 'OnlinePOSSale'
    ONLINE_PERSONAL_CUST_ANCILLARYS = 'OnlinePersonalCustAncillarys'
    ONLINE_PERSONAL_CUST_SERVICE = 'OnlinePersonalCustService'
    ONLINE_PERSONAL_CUST_OVERLIMITS = 'OnlinePersonalCustOverlimits'
    ONLINE_REPLACEMENT_CARD_READER = 'OnlineReplacementCardReader'
    ONLINE_PERSONAL_CUST_SET_UP = 'OnlinePersonalCustSetUp'
    ONLINE_PERSONAL_CUST_TRANSACTION = 'OnlinePersonalCustTransaction'
    ONLINE_PAYMENTIN_GB_PTO_UK = 'OnlinePaymentinGBPtoUK'
    ONLINE_URGENT_PAYMENT = 'OnlineUrgentPayment'
    ONLINE_PAYMENTIN_US_DTO_US = 'OnlinePaymentinUSDtoUS'
    ONLINE_BULK_DIRECT_DEB_STERLING = 'OnlineBulkDirectDebSterling'
    FOREIGN_CHQ_SENT = 'ForeignChqSent'
    FOREIGN_CHQ_SELF = 'ForeignChqSelf'
    FOREIGN_CHQ_ENCASHMENT = 'ForeignChqEncashment'
    FOREIGN_FX_INWARDS_CUST = 'ForeignFXInwardsCust'
    FOREIGN_FX_TRANSFERS_ROI = 'ForeignFXTransfersROI'
    FOREIGN_FX_FORWARD_TRANS = 'ForeignFXForwardTrans'
    FOREIGN_FX_TRANSFERS_BOI = 'ForeignFXTransfersBOI'
    FOREIGN_EX_MAINTENANCE = 'ForeignExMaintenance'
    FOREIGN_FX_INWARDS_NON_CUST = 'ForeignFXInwardsNonCust'
    FOREIGN_FX_OUTWARDS = 'ForeignFXOutwards'
    FOREIGN_PURCHASE = 'ForeignPurchase'
    FOREIGN_STATUS_REP = 'ForeignStatusRep'
    FOREIGN_CHQ_DRAFT = 'ForeignChqDraft'
    FOREIGN_CHQ_C_LESS = 'ForeignChqCLess'
    FOREIGN_CHQ_M_LESS = 'ForeignChqMLess'
    FOREIGN_CHQ_OTHER = 'ForeignChqOther'
    FOREIGN_CHQ_M_PLUS = 'ForeignChqMPlus'
    FOREIGN_CHQ_CCC = 'ForeignChqCCC'
    SERVICE_C_ACCOUNT_FEE = 'ServiceCAccountFee'
    SERVICE_C_ACCOUNT_FEE_MONTHLY = 'ServiceCAccountFeeMonthly'
    SERVICE_C_ACCOUNT_FEE_QUARTERLY = 'ServiceCAccountFeeQuarterly'
    SERVICE_C_BALANCE_HANDLING = 'ServiceCBalanceHandling'
    SERVICE_C_FIXED_TARIFF = 'ServiceCFixedTariff'
    SERVICE_C_BUSI_DEP_ACC_BREAKAGE = 'ServiceCBusiDepAccBreakage'
    SERVICE_C_MONITOR_DAILY = 'ServiceCMonitorDaily'
    SERVICE_C_MANAGEMENT_FEE = 'ServiceCManagementFee'
    SERVICE_C_MINIMUM_MONTHLY_FEE = 'ServiceCMinimumMonthlyFee'
    SERVICE_C_MONITOR_MONTHLY = 'ServiceCMonitorMonthly'
    SERVICE_C_MONITOR_WEEKLY = 'ServiceCMonitorWeekly'
    SERVICE_C_SECURITY_FEE = 'ServiceCSecurityFee'
    SERVICE_CMT940_ACCOUNT_FIRST = 'ServiceCMT940AccountFirst'
    SERVICE_CMT940_ACCOUNT_SUBSEQUENT = 'ServiceCMT940AccountSubsequent'
    SERVICE_C_OTHER = 'ServiceCOther'
    COUNTER_COIN_HANDLING = 'CounterCoinHandling'
    COUNTER_CASH_IN = 'CounterCashIn'
    COUNTER_CASH_IN_NOT_US = 'CounterCashInNotUs'
    COUNTER_CASH_OUT = 'CounterCashOut'
    COUNTER_CASH_X = 'CounterCashX'
    COUNTER_FOREIGN_CASH_MAX = 'CounterForeignCashMax'
    COUNTER_FOREIGN_NOTE_HANDLING = 'CounterForeignNoteHandling'
    COUNTER_FOREIGN_CASH_OUT = 'CounterForeignCashOut'
    COUNTER_CASH_FEE_RATE = 'CounterCashFeeRate'
    COUNTER_FOREIGN_CASH_OUT_TX = 'CounterForeignCashOutTx'
    COUNTER_COUNTER_LODGEMENT = 'CounterCounterLodgement'
    COUNTER_CASH_DROP_LODGEMENT = 'CounterCashDropLodgement'
    COUNTER_NOTES_LODGED = 'CounterNotesLodged'
    COUNTER_NOTES_OUT = 'CounterNotesOut'
    COUNTER_CASH_IN_OWN = 'CounterCashInOwn'
    COUNTER_PAID_TRANS = 'CounterPaidTrans'
    COUNTER_CASH_FEE_PERCENT = 'CounterCashFeePercent'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetail:
    r"""Fee Detail"""
    
    fee_sub_details: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetailFeeSubDetails = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeSubDetails') }})
    r"""Fee Sub Details"""  
    fee_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetailFeeTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeType') }})
    r"""A description of the Fee type"""  
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    other: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Other'), 'exclude': lambda f: f is None }})
    r"""Describe other fee type"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeSubTypeEnum(str, Enum):
    r"""Fee Sub Type code"""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetails:
    r"""Fee Details"""
    
    fee_detail: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeDetail = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeDetail') }})
    r"""Fee Detail"""  
    fee_sub_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetailsFeeSubTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeSubType') }})
    r"""Fee Sub Type code"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFees:
    r"""Fees"""
    
    fee_details: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFeesFeeDetails] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeDetails') }})  
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    fee_higher_tier: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeHigherTier'), 'exclude': lambda f: f is None }})
    r"""Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range"""  
    fee_lower_tier: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeLowerTier'), 'exclude': lambda f: f is None }})
    r"""Lower occurrence / range boundary e.g.. For returned cheques this could be 0, which means the first returned cheque fits into this range"""  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesProductStateEnum(str, Enum):
    r"""Describes if the offering is promotional or a description of a future state."""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndCharges:
    r"""Fees And Charges"""
    
    fees: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesFees = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Fees') }})
    r"""Fees"""  
    product_state: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndChargesProductStateEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductState') }})
    r"""Describes if the offering is promotional or a description of a future state."""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataMobileWalletEnum(str, Enum):
    r"""Mobile wallet supported by this product. A mobile wallet being any electronic device that allows an individual to make electronic commerce transactions"""
    ANDROID_PAY = 'AndroidPay'
    APPLE_PAY = 'ApplePay'
    ISSUER_MOBILE_APP = 'IssuerMobileApp'
    MOBILE_BANKING_APP = 'MobileBankingApp'
    OTHER = 'Other'
    PAY_M = 'PayM'
    SAMSUNG_PAY = 'SamsungPay'
    VODAFONE_WALLET = 'VodafoneWallet'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationBrandTrademarkIPOCodeEnum(str, Enum):
    r"""The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)"""
    UK = 'UK'
    EU = 'EU'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationBrand:
    r"""Brand"""
    
    trademark_id: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TrademarkID') }})
    r"""The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted"""  
    trademark_ipo_code: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationBrandTrademarkIPOCodeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TrademarkIPOCode') }})
    r"""The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationParentOrganisationOrganisationName:
    r"""Organisation Name"""
    
    legal_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LegalName') }})
    r"""Legal Name of the organisation"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationParentOrganisation:
    r"""Parent organisation"""
    
    organisation_name: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationParentOrganisationOrganisationName = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OrganisationName') }})
    r"""Organisation Name"""  
    bic: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BIC'), 'exclude': lambda f: f is None }})
    r"""The BIC from the organisation"""  
    lei: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LEI'), 'exclude': lambda f: f is None }})
    r"""The LEI ID of the organisation"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisation:
    r"""Organisation"""
    
    brand: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationBrand = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Brand') }})
    r"""Brand"""  
    parent_organisation: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisationParentOrganisation = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ParentOrganisation') }})
    r"""Parent organisation"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeeChargeNegotiableIndicatorEnum(str, Enum):
    r"""Fee Charge negotiable Indicator"""
    NO = 'No'
    YES = 'Yes'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeApplicationFrequencyEnum(str, Enum):
    r"""Frequency with which the rate, or amount is charged"""
    ACADEMIC_TERM = 'AcademicTerm'
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeCalculationFrequencyEnum(str, Enum):
    r"""Frequency with which the rate, or amount is calculated"""
    ACADEMIC_TERM = 'AcademicTerm'
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'
    OTHER = 'Other'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeOtherApplicationFrequency:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeOtherCalculationFrequency:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeRateOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeRateTypeEnum(str, Enum):
    r"""Rate type other than EAR"""
    GROSS = 'Gross'
    NET = 'Net'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeTypeEnum(str, Enum):
    r"""Type of fee or charge"""
    PERIODIC = 'Periodic'
    MINIMUM = 'Minimum'
    MAXIMUM = 'Maximum'
    SETUP = 'Setup'
    REVIEW = 'Review'
    RENEWAL = 'Renewal'
    MINIMUM_SETUP = 'MinimumSetup'
    MAXIMUM_SETUP = 'MaximumSetup'
    TOTAL = 'Total'
    ITEM = 'Item'
    EMERGENCY_LENDING = 'EmergencyLending'
    OTHER = 'Other'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndCharges:
    r"""Overdraft Fees Charges"""
    
    fee_charge_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeType') }})
    r"""Type of fee or charge"""  
    fee_charge_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeAmount'), 'exclude': lambda f: f is None }})
    r"""Charge applied to tier"""  
    fee_charge_application_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeApplicationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeApplicationFrequency'), 'exclude': lambda f: f is None }})
    r"""Frequency with which the rate, or amount is charged"""  
    fee_charge_calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeCalculationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeCalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""Frequency with which the rate, or amount is calculated"""  
    fee_charge_other_application_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeOtherApplicationFrequency] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherApplicationFrequency'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_other_calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeOtherCalculationFrequency] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherCalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRate'), 'exclude': lambda f: f is None }})
    r"""Fee charge rate applied to tier"""  
    fee_charge_rate_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeRateOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRateOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_rate_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndChargesFeeChargeRateTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRateType'), 'exclude': lambda f: f is None }})
    r"""Rate type other than EAR"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftProductStateEnum(str, Enum):
    r"""Describes if the offering is promotional or a description of a future state."""
    FUTURE_MULTIPLE_TERMS = 'FutureMultipleTerms'
    PROMOTIONAL = 'Promotional'
    REGULAR = 'Regular'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetArrangementOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetArrangementTypeEnum(str, Enum):
    r"""Defines the arrangement of the overdraft"""
    UNARRANGED = 'Unarranged'
    ARRANGED = 'Arranged'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeApplicationFrequencyEnum(str, Enum):
    r"""Frequency with which the rate, or amount is charged"""
    ACADEMIC_TERM = 'AcademicTerm'
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeCalculationFrequencyEnum(str, Enum):
    r"""Frequency with which the rate, or amount is calculated"""
    ACADEMIC_TERM = 'AcademicTerm'
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'
    OTHER = 'Other'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeOtherApplicationFrequency:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeOtherCalculationFrequency:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeRateOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeRateTypeEnum(str, Enum):
    r"""Rate type other than EAR"""
    GROSS = 'Gross'
    NET = 'Net'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeTypeEnum(str, Enum):
    r"""Type of fee or charge"""
    PERIODIC = 'Periodic'
    MINIMUM = 'Minimum'
    MAXIMUM = 'Maximum'
    SETUP = 'Setup'
    REVIEW = 'Review'
    RENEWAL = 'Renewal'
    MINIMUM_SETUP = 'MinimumSetup'
    MAXIMUM_SETUP = 'MaximumSetup'
    TOTAL = 'Total'
    ITEM = 'Item'
    EMERGENCY_LENDING = 'EmergencyLending'
    OTHER = 'Other'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndCharges:
    r"""Overdraft Fees Charges"""
    
    fee_charge_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeType') }})
    r"""Type of fee or charge"""  
    fee_charge_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeAmount'), 'exclude': lambda f: f is None }})
    r"""Charge applied to tier"""  
    fee_charge_application_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeApplicationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeApplicationFrequency'), 'exclude': lambda f: f is None }})
    r"""Frequency with which the rate, or amount is charged"""  
    fee_charge_calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeCalculationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeCalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""Frequency with which the rate, or amount is calculated"""  
    fee_charge_other_application_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeOtherApplicationFrequency] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherApplicationFrequency'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_other_calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeOtherCalculationFrequency] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherCalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRate'), 'exclude': lambda f: f is None }})
    r"""Fee charge rate applied to tier"""  
    fee_charge_rate_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeRateOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRateOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_rate_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndChargesFeeChargeRateTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRateType'), 'exclude': lambda f: f is None }})
    r"""Rate type other than EAR"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeApplicationFrequencyEnum(str, Enum):
    r"""Frequency with which the rate, or amount is charged"""
    ACADEMIC_TERM = 'AcademicTerm'
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeCalculationFrequencyEnum(str, Enum):
    r"""Frequency with which the rate, or amount is calculated"""
    ACADEMIC_TERM = 'AcademicTerm'
    DAILY = 'Daily'
    WEEKLY = 'Weekly'
    MONTHLY = 'Monthly'
    QUARTERLY = 'Quarterly'
    HALF_YEARLY = 'Half-Yearly'
    YEARLY = 'Yearly'
    OVERNIGHT = 'Overnight'
    OTHER = 'Other'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeOtherApplicationFrequency:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeOtherCalculationFrequency:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeRateOtherType:
    r"""Other Code Type"""
    
    code: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Code'), 'exclude': lambda f: f is None }})
    r"""Code mnemonic for 'Other' code set value applicable to specified attribute"""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Description'), 'exclude': lambda f: f is None }})
    r"""Description for 'Other' code set value applicable to specified attribute"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Name'), 'exclude': lambda f: f is None }})
    r"""Name of 'Other' code set value applicable to specified attribute"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeRateTypeEnum(str, Enum):
    r"""Rate type other than EAR"""
    GROSS = 'Gross'
    NET = 'Net'
    OTHER = 'Other'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeTypeEnum(str, Enum):
    r"""Type of fee or charge"""
    PERIODIC = 'Periodic'
    MINIMUM = 'Minimum'
    MAXIMUM = 'Maximum'
    SETUP = 'Setup'
    REVIEW = 'Review'
    RENEWAL = 'Renewal'
    MINIMUM_SETUP = 'MinimumSetup'
    MAXIMUM_SETUP = 'MaximumSetup'
    TOTAL = 'Total'
    ITEM = 'Item'
    EMERGENCY_LENDING = 'EmergencyLending'
    OTHER = 'Other'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndCharges:
    r"""Overdraft Fees Charges"""
    
    fee_charge_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeType') }})
    r"""Type of fee or charge"""  
    fee_charge_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeAmount'), 'exclude': lambda f: f is None }})
    r"""Charge applied to tier"""  
    fee_charge_application_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeApplicationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeApplicationFrequency'), 'exclude': lambda f: f is None }})
    r"""Frequency with which the rate, or amount is charged"""  
    fee_charge_calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeCalculationFrequencyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeCalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""Frequency with which the rate, or amount is calculated"""  
    fee_charge_other_application_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeOtherApplicationFrequency] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherApplicationFrequency'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_other_calculation_frequency: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeOtherCalculationFrequency] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherCalculationFrequency'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_rate: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRate'), 'exclude': lambda f: f is None }})
    r"""Fee charge rate applied to tier"""  
    fee_charge_rate_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeRateOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRateOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    fee_charge_rate_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndChargesFeeChargeRateTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeRateType'), 'exclude': lambda f: f is None }})
    r"""Rate type other than EAR"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBand:
    r"""Tiers"""
    
    tier_value_maximum: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TierValueMaximum') }})
    r"""Maximum value of the tier"""  
    tier_value_minimum: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TierValueMinimum') }})
    r"""Minimum value of the tier"""  
    ear: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EAR'), 'exclude': lambda f: f is None }})
    r"""EAR of the Tier"""  
    fees_and_charges: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBandFeesAndCharges]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeesAndCharges'), 'exclude': lambda f: f is None }})  
    notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Notes'), 'exclude': lambda f: f is None }})
    r"""Notes on the Overdraft"""  
    tier_band_identification: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TierBandIdentification'), 'exclude': lambda f: f is None }})
    r"""Identification of the tier or band"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSet:
    r"""Tier Bandset"""
    
    arrangement_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetArrangementTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ArrangementType') }})
    r"""Defines the arrangement of the overdraft"""  
    cma_defined_indicator: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CMADefinedIndicator') }})
    r"""describes that the tiers and bands are set by the CMA order, as opposed to be set by the banks"""  
    arrangement_other_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetArrangementOtherType] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ArrangementOtherType'), 'exclude': lambda f: f is None }})
    r"""Other Code Type"""  
    buffer_amount: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('BufferAmount'), 'exclude': lambda f: f is None }})
    r"""Amount on overdraft that is prearranged"""  
    ear: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('EAR'), 'exclude': lambda f: f is None }})
    r"""EAR of the Overdraft Set"""  
    fees_and_charges: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetFeesAndCharges]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeesAndCharges'), 'exclude': lambda f: f is None }})
    r"""Type of fee or charge"""  
    notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Notes'), 'exclude': lambda f: f is None }})
    r"""Notes on the Overdraft"""  
    overdraft_tier_band: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSetOverdraftTierBand]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OverdraftTierBand'), 'exclude': lambda f: f is None }})  
    tier_band_set_identification: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TierBandSetIdentification'), 'exclude': lambda f: f is None }})
    r"""Identification of the set of tiers or bands"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTypeEnum(str, Enum):
    r"""Defines if the overdraft facility is committed"""
    COMMITTED = 'Committed'
    ON_DEMAND = 'OnDemand'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraft:
    r"""Overdraft"""
    
    date_of_change: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('DateOfChange'), 'exclude': lambda f: f is None }})
    r"""Date of the change if it refers to future terms"""  
    fee_charge_negotiable_indicator: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeeChargeNegotiableIndicatorEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeeChargeNegotiableIndicator'), 'exclude': lambda f: f is None }})
    r"""Fee Charge negotiable Indicator"""  
    fees_and_charges: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftFeesAndCharges]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeesAndCharges'), 'exclude': lambda f: f is None }})  
    length_promotional_in_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LengthPromotionalInDays'), 'exclude': lambda f: f is None }})
    r"""Describes the length if only a duration is given instead of a date"""  
    maximum_monthly_overdraft_charge: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaximumMonthlyOverdraftCharge'), 'exclude': lambda f: f is None }})
    r"""Maximum Monthly Charge (MMC) for Overdraft fee and charges."""  
    notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Notes'), 'exclude': lambda f: f is None }})
    r"""Notes on the overdraft"""  
    overdraft_product_state: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftProductStateEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OverdraftProductState'), 'exclude': lambda f: f is None }})
    r"""Describes if the offering is promotional or a description of a future state."""  
    overdraft_tier_band_set: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTierBandSet]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OverdraftTierBandSet'), 'exclude': lambda f: f is None }})
    r"""Overdraft Tier Band Set"""  
    overdraft_type: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraftOverdraftTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OverdraftType'), 'exclude': lambda f: f is None }})
    r"""Defines if the overdraft facility is committed"""  
    start_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StartPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the start date"""  
    stop_promotion_or_future_terms: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('StopPromotionOrFutureTerms'), 'exclude': lambda f: f is None }})
    r"""Describes the end date"""  
    term: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Term'), 'exclude': lambda f: f is None }})
    r"""The duration of the overdraft, if it is non permanent"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataProductSegmentEnum(str, Enum):
    r"""Marketing or industry segment that the product is designed for"""
    BASIC = 'Basic'
    BUSINESS = 'Business'
    GENERAL = 'General'
    GRADUATE = 'Graduate'
    INTERNATIONAL = 'International'
    PACKAGED = 'Packaged'
    PERSONAL = 'Personal'
    PREMIUM = 'Premium'
    REWARD = 'Reward'
    SME = 'SME'
    STUDENT = 'Student'
    YOUNG_ADULT = 'YoungAdult'
    YOUTH = 'Youth'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataProductTypeEnum(str, Enum):
    r"""Descriptive code for the product category"""
    PCA = 'PCA'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONData:
    r"""Personal Current Account"""
    
    access_channels: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataAccessChannelsEnum] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('AccessChannels') }})
    r"""Ways to interact with the bank when managing account"""  
    benefits: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataBenefits = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Benefits') }})
    r"""Benefit"""  
    ca_pricing: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCAPricing] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CAPricing') }})  
    card_type: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCardTypeEnum] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CardType') }})
    r"""Card Type available"""  
    card_withdrawal_limit: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CardWithdrawalLimit') }})
    r"""The daily Limit that a customer can get via the ATM. This describes the default limit rather than the maximum"""  
    cheque_book_available: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ChequeBookAvailable') }})
    r"""Can a chequebook be issued"""  
    contactless: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Contactless') }})
    r"""Does the card issued have contactless facility"""  
    credit_interest: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditInterest = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditInterest') }})
    r"""Credit Interest"""  
    credit_scoring_part_of_account_opening_for_getting_an_account: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditScoringPartOfAccountOpeningForGettingAnAccount') }})
    r"""Indicates whether a credit check performed on an inquiry to open an account is submitted"""  
    currency: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Currency') }})
    r"""Currency of the Account. Default to GBP at present"""  
    eligibility: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataEligibility = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Eligibility') }})
    r"""Eligibility"""  
    fees_and_charges: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeesAndCharges] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('FeesAndCharges') }})  
    international_payments_supported: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('InternationalPaymentsSupported') }})
    r"""Indicates that the account supports international payments"""  
    organisation: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOrganisation = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Organisation') }})
    r"""Organisation"""  
    overdraft_offered: bool = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('OverdraftOffered') }})
    r"""Indicates whether an overdraft offered for this account"""  
    product_description: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductDescription') }})
    r"""Description of the product provided by the parent organisation"""  
    product_identifier: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductIdentifier') }})
    r"""Identifier within the parent organisation for the product. Must be unique in the organisation"""  
    product_segment: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataProductSegmentEnum] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductSegment') }})  
    product_type: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataProductTypeEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductType') }})
    r"""Descriptive code for the product category"""  
    product_url: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductURL') }})
    r"""URL provided by the organisation which redirects to the product (on live products only). There might be more than one product at a given URL"""  
    tsand_cs: list[str] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TsandCs') }})
    r"""URL provided by the parent organisation which redirects to the current T&Cs"""  
    card_notes: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CardNotes'), 'exclude': lambda f: f is None }})
    r"""Optional additional notes to supplement the card details"""  
    credit_scoring_part_of_account_opening_for_id_verification: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditScoringPartOfAccountOpeningForIDVerification'), 'exclude': lambda f: f is None }})
    r"""Indicates whether a credit check is used to check the address of a potential new account holder"""  
    credit_scoring_part_of_account_opening_id_verification_is_a_hard_or_soft_credit_score: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScoreEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScore'), 'exclude': lambda f: f is None }})  
    credit_scoring_part_of_account_opening_id_verification_text: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditScoringPartOfAccountOpeningIDVerificationText'), 'exclude': lambda f: f is None }})
    r"""Details on the specific credit scoring"""  
    credit_scoring_part_of_account_opening_is_a_hard_or_soft_credit_score: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataCreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScoreEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScore'), 'exclude': lambda f: f is None }})
    r"""Describes the type of credit scoring"""  
    credit_scoring_part_of_account_opening_text: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('CreditScoringPartOfAccountOpeningText'), 'exclude': lambda f: f is None }})
    r"""Details on the specific credit scoring"""  
    feature: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataFeature]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Feature'), 'exclude': lambda f: f is None }})  
    maximum_monthly_charge: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MaximumMonthlyCharge'), 'exclude': lambda f: f is None }})
    r"""The maximum Relevant Charges that could accrue"""  
    mobile_wallet: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataMobileWalletEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('MobileWallet'), 'exclude': lambda f: f is None }})
    r"""Mobile wallet supported by this product. A mobile wallet being any electronic device that allows an individual to make electronic commerce transactions"""  
    overdraft: Optional[list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONDataOverdraft]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Overdraft'), 'exclude': lambda f: f is None }})  
    product_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ProductName'), 'exclude': lambda f: f is None }})
    r"""The name of the product used for marketing purposes from a customer perspective. i.e. what the customer would recognise"""  
    
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaDataAgreementEnum(str, Enum):
    USE_OF_THE_AP_IS_AND_ANY_RELATED_DATA_WILL_BE_SUBJECT_TO_THE_TERMS_OF_THE_OPEN_LICENCE_AND_SUBJECT_TO_TERMS_AND_CONDITIONS = 'Use of the APIs and any related data will be subject to the terms of the Open Licence and subject to terms and conditions'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaDataLicenseEnum(str, Enum):
    r"""Open Banking License"""
    HTTPS_WWW_OPENBANKING_ORG_UK_OPEN_LICENCE = 'https://www.openbanking.org.uk/open-licence'

class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaDataTermsOfUseEnum(str, Enum):
    r"""Open Banking Terms of Use"""
    HTTPS_WWW_OPENBANKING_ORG_UK_TERMS = 'https://www.openbanking.org.uk/terms'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaData:
    
    agreement: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaDataAgreementEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('Agreement') }})  
    last_updated: datetime = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('LastUpdated'), 'encoder': utils.datetimeisoformat(False), 'decoder': dateutil.parser.isoparse, 'mm_field': fields.DateTime(format='iso') }})  
    license: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaDataLicenseEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('License') }})
    r"""Open Banking License"""  
    terms_of_use: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaDataTermsOfUseEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TermsOfUse') }})
    r"""Open Banking Terms of Use"""  
    total_results: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('TotalResults') }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSON:
    r"""Successful response with a list of `Personal Current Account` data"""
    
    data: list[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONData] = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data') }})  
    meta: GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSONMetaData = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meta') }})  
    

@dataclasses.dataclass
class GetPersonalCurrentAccountsResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    four_hundred_error_object: Optional[GetPersonalCurrentAccounts400ErrorObject] = dataclasses.field(default=None)
    r"""You have sent a request which could not be understood."""  
    four_hundred_and_eight_error_object: Optional[GetPersonalCurrentAccounts408ErrorObject] = dataclasses.field(default=None)
    r"""Your client has failed to submit a request, and a timeout has occurred."""  
    four_hundred_and_twenty_nine_error_object: Optional[GetPersonalCurrentAccounts429ErrorObject] = dataclasses.field(default=None)
    r"""You have requested this resource too often. Slow down."""  
    five_hundred_error_object: Optional[GetPersonalCurrentAccounts500ErrorObject] = dataclasses.field(default=None)
    r"""An error occurred on the server. No further information is available."""  
    five_hundred_and_three_error_object: Optional[GetPersonalCurrentAccounts503ErrorObject] = dataclasses.field(default=None)
    r"""The service is temporarily unavailable."""  
    error_object: Optional[GetPersonalCurrentAccountsErrorObject] = dataclasses.field(default=None)
    r"""A standard error response."""  
    get_personal_current_accounts_200_application_prs_openbanking_opendata_v1_3_plus_json_object: Optional[GetPersonalCurrentAccounts200ApplicationPrsOpenbankingOpendataV13PlusJSON] = dataclasses.field(default=None)
    r"""Successful response with a list of `Personal Current Account` data"""  
    headers: Optional[dict[str, list[str]]] = dataclasses.field(default=None)  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    