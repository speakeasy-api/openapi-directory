"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclasses.dataclass
class UserSettingsUpdateSecurity:
    
    o_auth: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'oauth2', 'field_name': 'Authorization' }})  
    
class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum(str, Enum):
    r"""Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
    `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
    
    `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
    """
    ENHANCED_ENCRYPTION = 'enhanced_encryption'
    E2EE = 'e2ee'

class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum(str, Enum):
    ZERO = '0'
    FOUR = '4'
    FIVE = '5'
    SIX = '6'
    SEVEN = '7'
    EIGHT = '8'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement:
    r"""Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604)."""
    
    consecutive_characters_length: Optional[UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirementConsecutiveCharactersLengthEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('consecutive_characters_length'), 'exclude': lambda f: f is None }})  
    have_letter: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_letter'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...)."""  
    have_number: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_number'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...)."""  
    have_special_character: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_special_character'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must have at least 1 special character (!,@,#...)."""  
    have_upper_and_lower_characters: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_upper_and_lower_characters'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must include both uppercase and lowercase characters."""  
    length: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('length'), 'exclude': lambda f: f is None }})
    r"""The minimum length that the meeting/webinar passcode needs to have."""  
    only_allow_numeric: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('only_allow_numeric'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must only contain numbers and no other characters."""  
    weak_enhance_detection: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('weak_enhance_detection'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, users will be informed if the provided passcode is weak."""  
    
class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum(str, Enum):
    r"""Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
    `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
    """
    ZERO = '0'
    ONE = '1'
    TWO = '2'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings:
    r"""Specify the settings to be applied if waiting room is enabled."""
    
    participants_to_place_in_waiting_room: Optional[UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettingsParticipantsToPlaceInWaitingRoomEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('participants_to_place_in_waiting_room'), 'exclude': lambda f: f is None }})
    r"""Specify who should be admitted to the waiting room. The value of this field can be one of the following:<br>
    `0`: All attendees<br> `1`: Users who are not in your account<br> `2`: Users who are not in your account and are not part of your whitelisted domains that are specified in
    """  
    users_who_can_admit_participants_from_waiting_room: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('users_who_can_admit_participants_from_waiting_room'), 'exclude': lambda f: f is None }})
    r"""Specify who can admit participants from the waiting room. The value of this field can be one of the following:<br>
    `0`: Host and co-hosts only<br> `1`: Host, co-hosts, and anyone who bypassed the waiting room (only if host and co-hosts are not present).
    """  
    whitelisted_domains_for_waiting_room: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('whitelisted_domains_for_waiting_room'), 'exclude': lambda f: f is None }})
    r"""If the value of the `participants_to_place_in_waiting_room` field is `2`, use this setting to specify the domains that can bypass the waiting room feature. Separate multiple domains with commas(example: \\"aaa.com,bbb.com\\")."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurity:
    
    auto_security: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auto_security'), 'exclude': lambda f: f is None }})
    r"""`true`: Require that all meetings are secured with at least one security option.
    
    This setting can only be disabled by Enterprise, ISV, Business (with more than 100 licenses), and Education accounts. [Learn more](https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#meeting-security).
    """  
    embed_password_in_join_link: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('embed_password_in_join_link'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, meeting passcode will be encrypted and included in the invite link to allow participants to join with just one click without having to enter the passcode."""  
    encryption_type: Optional[UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityEncryptionTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('encryption_type'), 'exclude': lambda f: f is None }})
    r"""Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
    `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
    
    `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
    """  
    end_to_end_encrypted_meetings: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('end_to_end_encrypted_meetings'), 'exclude': lambda f: f is None }})
    r"""Allow use of end-to-end encryption for meetings. If set to `true`, you can specify the encryption type in `encryption_type` field."""  
    meeting_password: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_password'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, all instant, and scheduled meetings that users can join via client, or room systems will be passcode-protected. The Personal Meeting ID (PMI) meetings are not included in this setting."""  
    meeting_password_requirement: Optional[UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityMeetingPasswordRequirement] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_password_requirement'), 'exclude': lambda f: f is None }})
    r"""Meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604)."""  
    phone_password: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('phone_password'), 'exclude': lambda f: f is None }})
    r"""Require passcode for participants joining by phone. If set to `true`, a numeric passcode will be required for participants joining by phone if your meeting has a passcode. For meeting with an alphanumeric passcode, a numeric version will be generated."""  
    pmi_password: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pmi_password'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, all Personal Meeting ID (PMI) meetings that users can join via client, or room systems will be passcode-protected."""  
    require_password_for_scheduled_meeting: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_for_scheduled_meeting'), 'exclude': lambda f: f is None }})
    r"""Require a passcode for meetings which have already been scheduled."""  
    require_password_for_scheduled_webinar: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_for_scheduled_webinar'), 'exclude': lambda f: f is None }})
    r"""Require a passcode for webinars which have already been scheduled."""  
    waiting_room: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('waiting_room'), 'exclude': lambda f: f is None }})
    r"""When participants join a meeting, place them in a waiting room and require the host to admit them individually. Enabling the waiting room automatically disables the setting for allowing participants to join before host."""  
    waiting_room_settings: Optional[UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurityWaitingRoomSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('waiting_room_settings'), 'exclude': lambda f: f is None }})
    r"""Specify the settings to be applied if waiting room is enabled."""  
    webinar_password: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('webinar_password'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, a passcode will be generated when scheduling a Webinar and participants require the passcode to join the Webinar."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettings:
    
    meeting_security: Optional[UserSettingsUpdateApplicationJSONMeetingWebinarSecuritySettingsMeetingSecurity] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_security'), 'exclude': lambda f: f is None }})  
    
class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionActionEnum(str, Enum):
    r"""Authentication action"""
    UPDATE = 'update'
    SHOW = 'show'
    HIDE = 'hide'

class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionTypeEnum1(str, Enum):
    r"""Authentication type"""
    INTERNALLY = 'internally'
    ENFORCE_LOGIN = 'enforce_login'
    ENFORCE_LOGIN_WITH_DOMAINS = 'enforce_login_with_domains'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOption1:
    r"""Authentication Options"""
    
    action: Optional[UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionActionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('action'), 'exclude': lambda f: f is None }})
    r"""Authentication action"""  
    default_option: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('default_option'), 'exclude': lambda f: f is None }})
    r"""Authentication default option"""  
    domians: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('domians'), 'exclude': lambda f: f is None }})
    r"""Authentication domians"""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Authentication id"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Authentication name"""  
    type: Optional[UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionTypeEnum1] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Authentication type"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdate1:
    
    authentication_option: Optional[UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOption1] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_option'), 'exclude': lambda f: f is None }})
    r"""Authentication Options"""  
    recording_authentication: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_authentication'), 'exclude': lambda f: f is None }})
    r"""Only authenticated users can view cloud recordings"""  
    
class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionTypeEnum(str, Enum):
    r"""Authentication type. Specify one of the following authentication types for the authentication profile:<br>
     * `enforce_login`: This option allows any users to join the meeting or webinar, as long as they are signed into their Zoom account.
     * `enforce_login_with_domains`: This option, allows you to specify a rule so that only those Zoom users whose email addresses contain a certain domain, can join the meeting or webinar. You can either add multiple domains using a comma in between and/or use a wildcard for listing domains.<br>
     * `enforce_login_with_same_account`: This option allows users to join the meeting or webinar with the same Zoom account.
    """
    ENFORCE_LOGIN = 'enforce_login'
    ENFORCE_LOGIN_WITH_SAME_ACCOUNT = 'enforce_login_with_same_account'
    ENFORCE_LOGIN_WITH_DOMAINS = 'enforce_login_with_domains'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOption:
    r"""Meeting Authentication Options"""
    
    action: Optional[UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionActionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('action'), 'exclude': lambda f: f is None }})
    r"""Authentication action"""  
    default_option: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('default_option'), 'exclude': lambda f: f is None }})
    r"""Authentication default option"""  
    domains: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('domains'), 'exclude': lambda f: f is None }})
    r"""Authentication domains"""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Authentication id"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""Authentication name"""  
    type: Optional[UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOptionTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""Authentication type. Specify one of the following authentication types for the authentication profile:<br>
     * `enforce_login`: This option allows any users to join the meeting or webinar, as long as they are signed into their Zoom account.
     * `enforce_login_with_domains`: This option, allows you to specify a rule so that only those Zoom users whose email addresses contain a certain domain, can join the meeting or webinar. You can either add multiple domains using a comma in between and/or use a wildcard for listing domains.<br>
     * `enforce_login_with_same_account`: This option allows users to join the meeting or webinar with the same Zoom account.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdate:
    
    authentication_option: Optional[UserSettingsUpdateApplicationJSON2GroupSettingsAuthenticationUpdateAuthenticationOption] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('authentication_option'), 'exclude': lambda f: f is None }})
    r"""Meeting Authentication Options"""  
    meeting_authentication: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_authentication'), 'exclude': lambda f: f is None }})
    r"""Only authenticated users can join meetings"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsNotificationSettings:
    
    alternative_host_reminder: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('alternative_host_reminder'), 'exclude': lambda f: f is None }})
    r"""When an alternative host is set or removed from a meeting."""  
    cancel_meeting_reminder: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cancel_meeting_reminder'), 'exclude': lambda f: f is None }})
    r"""When a meeting is cancelled."""  
    jbh_reminder: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('jbh_reminder'), 'exclude': lambda f: f is None }})
    r"""When attendees join meeting before host."""  
    schedule_for_reminder: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedule_for_reminder'), 'exclude': lambda f: f is None }})
    r"""Notify the host there is a meeting is scheduled, rescheduled, or cancelled."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsFeatureSettings:
    
    large_meeting: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('large_meeting'), 'exclude': lambda f: f is None }})
    r"""Enable [large meeting](https://support.zoom.us/hc/en-us/articles/201362823-What-is-a-Large-Meeting-) feature for the user."""  
    large_meeting_capacity: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('large_meeting_capacity'), 'exclude': lambda f: f is None }})
    r"""Set the meeting capacity for the user if the user has **Large meeting** feature enabled. The value for the field can be either 500 or 1000."""  
    meeting_capacity: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_capacity'), 'exclude': lambda f: f is None }})
    r"""Set a user's meeting capacity. User’s meeting capacity denotes the maximum number of participants that can join a meeting scheduled by the user."""  
    webinar: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('webinar'), 'exclude': lambda f: f is None }})
    r"""Enable Webinar feature for the user."""  
    webinar_capacity: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('webinar_capacity'), 'exclude': lambda f: f is None }})
    r"""Set the Webinar capacity for a user who has the Webinar feature enabled. The value of this field can be 100, 500, 1000, 3000, 5000 or 10000."""  
    zoom_phone: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('zoom_phone'), 'exclude': lambda f: f is None }})
    r"""Zoom phone feature."""  
    
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum(str, Enum):
    r"""If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: [\\"DE\\", \\"NL\\", \\"HK\\", \\"AU\\", \\"IN\\", \\"LA\\", \\"TY\\", \\"CN\\", \\"US\\", \\"CA\\"])."""
    HK = 'HK'
    AU = 'AU'
    IN = 'IN'
    TY = 'TY'
    CN = 'CN'
    US = 'US'
    CA = 'CA'
    DE = 'DE'
    NL = 'NL'
    LA = 'LA'

class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum(str, Enum):
    r"""Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound."""
    HOST = 'host'
    ALL = 'all'
    NONE = 'none'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettingsFiles:
    
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""Unique identifier of the file."""  
    is_default: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('is_default'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not this file is the default virtual background file."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""File name."""  
    size: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('size'), 'exclude': lambda f: f is None }})
    r"""File size."""  
    type: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""File type."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings:
    r"""Settings to manage virtual background."""
    
    allow_upload_custom: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allow_upload_custom'), 'exclude': lambda f: f is None }})
    r"""Allow user to upload custom backgrounds."""  
    allow_videos: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allow_videos'), 'exclude': lambda f: f is None }})
    r"""Allow use of videos for virtual backgrounds."""  
    enable: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enable'), 'exclude': lambda f: f is None }})
    r"""Enable virtual background."""  
    files: Optional[list[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettingsFiles]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('files'), 'exclude': lambda f: f is None }})  
    
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum(str, Enum):
    r"""Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
    `host`: Only host can share the screen.<br>
    `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    """
    HOST = 'host'
    ALL = 'all'

class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum(str, Enum):
    r"""Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
    `host`: Only a host can share the screen when someone else is sharing.<br>
    `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    """
    HOST = 'host'
    ALL = 'all'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettings:
    
    allow_live_streaming: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allow_live_streaming'), 'exclude': lambda f: f is None }})
    r"""Allow live streaming."""  
    annotation: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('annotation'), 'exclude': lambda f: f is None }})
    r"""Allow participants to use annotation tools."""  
    attendee_on_hold: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('attendee_on_hold'), 'exclude': lambda f: f is None }})
    r"""Allow host to put attendee on hold.
    
    **This field has been deprecated and is no longer supported.**
    """  
    auto_saving_chat: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auto_saving_chat'), 'exclude': lambda f: f is None }})
    r"""Auto save all in-meeting chats."""  
    breakout_room: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('breakout_room'), 'exclude': lambda f: f is None }})
    r"""Allow host to split meeting participants into separate breakout rooms."""  
    chat: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('chat'), 'exclude': lambda f: f is None }})
    r"""Enable chat during meeting for all participants."""  
    closed_caption: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('closed_caption'), 'exclude': lambda f: f is None }})
    r"""Enable closed captions."""  
    co_host: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('co_host'), 'exclude': lambda f: f is None }})
    r"""Allow the host to add co-hosts."""  
    custom_data_center_regions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom_data_center_regions'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, you can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting your real-time meeting and webinar traffic. These regions can be provided in the `data_center_regions` field. If set to `false`, the regions cannot be customized and the default regions will be used."""  
    custom_live_streaming_service: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom_live_streaming_service'), 'exclude': lambda f: f is None }})
    r"""Allow custom live streaming."""  
    custom_service_instructions: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('custom_service_instructions'), 'exclude': lambda f: f is None }})
    r"""Custom service instructions."""  
    data_center_regions: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsDataCenterRegionsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('data_center_regions'), 'exclude': lambda f: f is None }})
    r"""If you have set the value of `custom_data_center_regions` to `true`, specify the data center regions that you would like to opt in to (country codes from among: [\\"DE\\", \\"NL\\", \\"HK\\", \\"AU\\", \\"IN\\", \\"LA\\", \\"TY\\", \\"CN\\", \\"US\\", \\"CA\\"])."""  
    e2e_encryption: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('e2e_encryption'), 'exclude': lambda f: f is None }})
    r"""Zoom requires encryption for all data between the Zoom cloud, Zoom client, and Zoom Room. Require encryption for 3rd party endpoints (H323/SIP)."""  
    entry_exit_chime: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsEntryExitChimeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('entry_exit_chime'), 'exclude': lambda f: f is None }})
    r"""Play sound when participants join or leave:<br>`host` - When host joins or leaves.<br>`all` - When any participant joins or leaves.<br>`none` - No join or leave sound."""  
    far_end_camera_control: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('far_end_camera_control'), 'exclude': lambda f: f is None }})
    r"""Allow another user to take control of the camera."""  
    feedback: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('feedback'), 'exclude': lambda f: f is None }})
    r"""Enable option to send feedback to Zoom at the end of the meeting."""  
    file_transfer: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('file_transfer'), 'exclude': lambda f: f is None }})
    r"""Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not."""  
    group_hd: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('group_hd'), 'exclude': lambda f: f is None }})
    r"""Enable group HD video."""  
    non_verbal_feedback: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('non_verbal_feedback'), 'exclude': lambda f: f is None }})
    r"""Enable non-verbal feedback through screens."""  
    polling: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('polling'), 'exclude': lambda f: f is None }})
    r"""Add polls to the meeting controls."""  
    private_chat: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('private_chat'), 'exclude': lambda f: f is None }})
    r"""Enable 1:1 private chat between participants during meetings."""  
    record_play_voice: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('record_play_voice'), 'exclude': lambda f: f is None }})
    r"""Record and play their own voice."""  
    remote_control: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('remote_control'), 'exclude': lambda f: f is None }})
    r"""Enable remote control during screensharing."""  
    remote_support: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('remote_support'), 'exclude': lambda f: f is None }})
    r"""Allow host to provide 1:1 remote support to a participant."""  
    request_permission_to_unmute: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('request_permission_to_unmute'), 'exclude': lambda f: f is None }})
    r"""Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not."""  
    screen_sharing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('screen_sharing'), 'exclude': lambda f: f is None }})
    r"""Allow host and participants to share their screen or content during meetings"""  
    share_dual_camera: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('share_dual_camera'), 'exclude': lambda f: f is None }})
    r"""Share dual camera (deprecated)."""  
    show_meeting_control_toolbar: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_meeting_control_toolbar'), 'exclude': lambda f: f is None }})
    r"""Always show meeting controls during a meeting."""  
    virtual_background: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('virtual_background'), 'exclude': lambda f: f is None }})
    r"""Enable virtual background."""  
    virtual_background_settings: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsVirtualBackgroundSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('virtual_background_settings'), 'exclude': lambda f: f is None }})
    r"""Settings to manage virtual background."""  
    waiting_room: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('waiting_room'), 'exclude': lambda f: f is None }})
    r"""Enable Waiting room - if enabled, attendees can only join after host approves."""  
    who_can_share_screen: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('who_can_share_screen'), 'exclude': lambda f: f is None }})
    r"""Indicates who can share their screen or content during meetings. The value can be one of the following: <br>
    `host`: Only host can share the screen.<br>
    `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    """  
    who_can_share_screen_when_someone_is_sharing: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsWhoCanShareScreenWhenSomeoneIsSharingEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('who_can_share_screen_when_someone_is_sharing'), 'exclude': lambda f: f is None }})
    r"""Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:<br>
    `host`: Only a host can share the screen when someone else is sharing.<br>
    `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
    """  
    workplace_by_facebook: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('workplace_by_facebook'), 'exclude': lambda f: f is None }})
    r"""Allow livestreaming by host through Workplace by Facebook."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsProfileRecordingStorageLocation:
    
    allowed_values: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowed_values'), 'exclude': lambda f: f is None }})
    r"""Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
    
    Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
    """  
    value: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('value'), 'exclude': lambda f: f is None }})
    r"""Abbreviated country code."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsProfile:
    
    recording_storage_location: Optional[UserSettingsUpdateApplicationJSONUserSettingsProfileRecordingStorageLocation] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_storage_location'), 'exclude': lambda f: f is None }})  
    
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum(str, Enum):
    r"""Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled."""
    LOCAL = 'local'
    CLOUD = 'cloud'
    NONE = 'none'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl:
    r"""Setting to allow cloud recording access only from specific IP address ranges."""
    
    enable: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enable'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property."""  
    ip_addresses_or_ranges: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip_addresses_or_ranges'), 'exclude': lambda f: f is None }})
    r"""IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
    
    Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement:
    r"""This object represents the minimum passcode requirements set for recordings via Account Recording Settings."""
    
    have_letter: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_letter'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not passcode must contain at least one alphabetical letter (a, b, c..)."""  
    have_number: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_number'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not passcode must contain at least one number(1, 2, 3..)."""  
    have_special_character: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_special_character'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not passcode must contain at least one special character(!, @, #..)."""  
    length: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('length'), 'exclude': lambda f: f is None }})
    r"""Minimum required length for the passcode."""  
    only_allow_numeric: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('only_allow_numeric'), 'exclude': lambda f: f is None }})
    r"""Indicates whether or not passcode must contain only numeric characters."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettings:
    
    ask_host_to_confirm_disclaimer: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ask_host_to_confirm_disclaimer'), 'exclude': lambda f: f is None }})
    r"""Ask host to confirm the disclaimer."""  
    ask_participants_to_consent_disclaimer: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ask_participants_to_consent_disclaimer'), 'exclude': lambda f: f is None }})
    r"""This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:<br>
    * `true`: Ask participants for consent when a recording starts. <br>
    * `false`: Do not ask participants for consent when a recording starts.
    """  
    auto_delete_cmr: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auto_delete_cmr'), 'exclude': lambda f: f is None }})
    r"""Auto delete cloud recordings."""  
    auto_delete_cmr_days: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auto_delete_cmr_days'), 'exclude': lambda f: f is None }})
    r"""A specified number of days of auto delete cloud recordings."""  
    auto_recording: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettingsAutoRecordingEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('auto_recording'), 'exclude': lambda f: f is None }})
    r"""Automatic recording:<br>`local` - Record on local.<br>`cloud` - Record on cloud.<br>`none` - Disabled."""  
    cloud_recording: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cloud_recording'), 'exclude': lambda f: f is None }})
    r"""Cloud recording."""  
    host_pause_stop_recording: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host_pause_stop_recording'), 'exclude': lambda f: f is None }})
    r"""Host can pause/stop the auto recording in the cloud."""  
    ip_address_access_control: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettingsIPAddressAccessControl] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ip_address_access_control'), 'exclude': lambda f: f is None }})
    r"""Setting to allow cloud recording access only from specific IP address ranges."""  
    local_recording: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('local_recording'), 'exclude': lambda f: f is None }})
    r"""Local recording."""  
    record_audio_file: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('record_audio_file'), 'exclude': lambda f: f is None }})
    r"""Record an audio only file."""  
    record_gallery_view: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('record_gallery_view'), 'exclude': lambda f: f is None }})
    r"""Record the gallery view."""  
    record_speaker_view: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('record_speaker_view'), 'exclude': lambda f: f is None }})
    r"""Record the active speaker view."""  
    recording_audio_transcript: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_audio_transcript'), 'exclude': lambda f: f is None }})
    r"""Audio transcript."""  
    recording_disclaimer: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_disclaimer'), 'exclude': lambda f: f is None }})
    r"""Show a disclaimer to participants before a recording starts"""  
    recording_password_requirement: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettingsRecordingPasswordRequirement] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording_password_requirement'), 'exclude': lambda f: f is None }})
    r"""This object represents the minimum passcode requirements set for recordings via Account Recording Settings."""  
    save_chat_text: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('save_chat_text'), 'exclude': lambda f: f is None }})
    r"""Save chat text from the meeting."""  
    show_timestamp: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_timestamp'), 'exclude': lambda f: f is None }})
    r"""Show timestamp on video."""  
    
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum(str, Enum):
    r"""Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference."""
    BOTH = 'both'
    TELEPHONY = 'telephony'
    VOIP = 'voip'
    THIRD_PARTY = 'thirdParty'

class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum(str, Enum):
    ZERO = '0'
    FOUR = '4'
    FIVE = '5'
    SIX = '6'
    SEVEN = '7'
    EIGHT = '8'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement:
    r"""Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604)."""
    
    consecutive_characters_length: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirementConsecutiveCharactersLengthEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('consecutive_characters_length'), 'exclude': lambda f: f is None }})  
    have_letter: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_letter'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must contain at least 1 letter (such as a,b,c...)."""  
    have_number: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_number'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must contain at least 1 number (such as 1,2,3...)."""  
    have_special_character: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_special_character'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must have at least 1 special character (!,@,#...)."""  
    have_upper_and_lower_characters: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('have_upper_and_lower_characters'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must include both uppercase and lowercase characters."""  
    length: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('length'), 'exclude': lambda f: f is None }})
    r"""The minimum length that the meeting/webinar passcode needs to have."""  
    only_allow_numeric: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('only_allow_numeric'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, the passcode must only contain numbers and no other characters."""  
    weak_enhance_detection: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('weak_enhance_detection'), 'exclude': lambda f: f is None }})
    r"""If set to `true`, users will be informed if the provided passcode is weak."""  
    
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum(str, Enum):
    r"""Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts."""
    JBH_ONLY = 'jbh_only'
    ALL = 'all'
    NONE = 'none'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettings1:
    
    audio_type: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsAudioTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('audio_type'), 'exclude': lambda f: f is None }})
    r"""Determine how participants can join the audio portion of the meeting:<br>`both` - Telephony and VoIP.<br>`telephony` - Audio PSTN telephony only.<br>`voip` - VoIP only.<br>`thirdParty` - Third party audio conference."""  
    default_password_for_scheduled_meetings: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('default_password_for_scheduled_meetings'), 'exclude': lambda f: f is None }})
    r"""Passcode for already scheduled meetings"""  
    embed_password_in_join_link: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('embed_password_in_join_link'), 'exclude': lambda f: f is None }})
    r"""If the value is set to `true`, the meeting passcode will be encrypted and included in the join meeting link to allow participants to join with just one click without having to enter the passcode."""  
    force_pmi_jbh_password: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('force_pmi_jbh_password'), 'exclude': lambda f: f is None }})
    r"""Require a passcode for personal meetings if attendees can join before host."""  
    host_video: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('host_video'), 'exclude': lambda f: f is None }})
    r"""Start meetings with host video on."""  
    join_before_host: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('join_before_host'), 'exclude': lambda f: f is None }})
    r"""Join the meeting before host arrives."""  
    meeting_password_requirement: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsMeetingPasswordRequirement] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('meeting_password_requirement'), 'exclude': lambda f: f is None }})
    r"""Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604)."""  
    participants_video: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('participants_video'), 'exclude': lambda f: f is None }})
    r"""Start meetings with participants video on."""  
    personal_meeting: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('personal_meeting'), 'exclude': lambda f: f is None }})
    r"""Personal Meeting Setting.<br><br>
    `true`: Indicates that the **\"Enable Personal Meeting ID\"** setting is turned on. Users can choose to use personal meeting ID for their meetings. <br><br>
    `false`: Indicates that the **\"Enable Personal Meeting ID\"** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled, meetings that were scheduled with PMI will be invalid. Scheduled meetings will need to be manually updated.
    For Zoom Phone only:If a user has been assigned a desk phone, **\"Elevate to Zoom Meeting\"** on desk phone will be disabled.
    """  
    pmi_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pmi_password'), 'exclude': lambda f: f is None }})
    r"""PMI passcode"""  
    pstn_password_protected: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pstn_password_protected'), 'exclude': lambda f: f is None }})
    r"""Generate and require passcode for participants joining by phone."""  
    require_password_for_instant_meetings: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_for_instant_meetings'), 'exclude': lambda f: f is None }})
    r"""Require a passcode for instant meetings. If you use PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts."""  
    require_password_for_pmi_meetings: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettingsRequirePasswordForPmiMeetingsEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_for_pmi_meetings'), 'exclude': lambda f: f is None }})
    r"""Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts."""  
    require_password_for_scheduled_meetings: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_for_scheduled_meetings'), 'exclude': lambda f: f is None }})
    r"""Require a passcode for meetings which have already been scheduled"""  
    require_password_for_scheduling_new_meetings: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('require_password_for_scheduling_new_meetings'), 'exclude': lambda f: f is None }})
    r"""Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts."""  
    use_pmi_for_instant_meetings: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('use_pmi_for_instant_meetings'), 'exclude': lambda f: f is None }})
    r"""Use Personal Meeting ID (PMI) when starting an instant meeting"""  
    use_pmi_for_scheduled_meetings: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('use_pmi_for_scheduled_meetings'), 'exclude': lambda f: f is None }})
    r"""Use Personal Meeting ID (PMI) when scheduling a meeting"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsTelephonyUpdateSettingsMeetingSettingsTelephonyRegions:
    r"""Indicates where most of the participants call into or call from duriing a meeting."""
    
    selection_values: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('selection_values'), 'exclude': lambda f: f is None }})
    r"""Telephony regions selected by the account to indicate where most of the participants call into or call from during a meeting."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsTelephonyUpdateSettingsMeetingSettings:
    
    audio_conference_info: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('audio_conference_info'), 'exclude': lambda f: f is None }})
    r"""Third party audio conference info."""  
    show_international_numbers_link: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_international_numbers_link'), 'exclude': lambda f: f is None }})
    r"""Show the international numbers link on the invitation email."""  
    telephony_regions: Optional[UserSettingsUpdateApplicationJSONUserSettingsTelephonyUpdateSettingsMeetingSettingsTelephonyRegions] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('telephony_regions'), 'exclude': lambda f: f is None }})
    r"""Indicates where most of the participants call into or call from duriing a meeting."""  
    third_party_audio: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('third_party_audio'), 'exclude': lambda f: f is None }})
    r"""Third party audio conference."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettingsUserSettingsTSPSettings:
    r"""Account Settings: TSP."""
    
    call_out: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('call_out'), 'exclude': lambda f: f is None }})
    r"""Call Out"""  
    call_out_countries: Optional[list[Any]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('call_out_countries'), 'exclude': lambda f: f is None }})
    r"""Call Out Countries/Regions"""  
    show_international_numbers_link: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('show_international_numbers_link'), 'exclude': lambda f: f is None }})
    r"""Show international numbers link on the invitation email"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UserSettingsUpdateApplicationJSONUserSettings:
    
    email_notification: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsNotificationSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('email_notification'), 'exclude': lambda f: f is None }})  
    feature: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsFeatureSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('feature'), 'exclude': lambda f: f is None }})  
    in_meeting: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('in_meeting'), 'exclude': lambda f: f is None }})  
    profile: Optional[UserSettingsUpdateApplicationJSONUserSettingsProfile] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('profile'), 'exclude': lambda f: f is None }})  
    recording: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsRecordingSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recording'), 'exclude': lambda f: f is None }})  
    schedule_meeting: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsMeetingSettings1] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedule_meeting'), 'exclude': lambda f: f is None }})  
    telephony: Optional[UserSettingsUpdateApplicationJSONUserSettingsTelephonyUpdateSettingsMeetingSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('telephony'), 'exclude': lambda f: f is None }})  
    tsp: Optional[UserSettingsUpdateApplicationJSONUserSettingsUserSettingsTSPSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tsp'), 'exclude': lambda f: f is None }})
    r"""Account Settings: TSP."""  
    
class UserSettingsUpdateOptionEnum(str, Enum):
    MEETING_AUTHENTICATION = 'meeting_authentication'
    RECORDING_AUTHENTICATION = 'recording_authentication'
    MEETING_SECUIRTY = 'meeting_secuirty'


@dataclasses.dataclass
class UserSettingsUpdateRequest:
    
    request_body: Any = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})
    r"""User Settings"""  
    user_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'userId', 'style': 'simple', 'explode': False }})
    r"""The user ID or email address of the user. For user-level apps, pass `me` as the value for userId."""  
    option: Optional[UserSettingsUpdateOptionEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'option', 'style': 'form', 'explode': True }})  
    

@dataclasses.dataclass
class UserSettingsUpdateResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    