/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.operations;

import org.openapis.openapi.utils.SpeakeasyMetadata;

public class GetRouteQueryParams {
    /**
     * Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
     * With `alternative_route`, we give you not one but several routes that are close to optimal, but
     * not too similar to each other. 
     * With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
     * a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
     * You can control both of these features with additional parameters, see below. 
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=algorithm")
    public GetRouteAlgorithmEnum algorithm;
    public GetRouteQueryParams withAlgorithm(GetRouteAlgorithmEnum algorithm) {
        this.algorithm = algorithm;
        return this;
    }
    
    /**
     * If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=alternative_route.max_paths")
    public Integer alternativeRouteMaxPaths;
    public GetRouteQueryParams withAlternativeRouteMaxPaths(Integer alternativeRouteMaxPaths) {
        this.alternativeRouteMaxPaths = alternativeRouteMaxPaths;
        return this;
    }
    
    /**
     * If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=alternative_route.max_share_factor")
    public Double alternativeRouteMaxShareFactor;
    public GetRouteQueryParams withAlternativeRouteMaxShareFactor(Double alternativeRouteMaxShareFactor) {
        this.alternativeRouteMaxShareFactor = alternativeRouteMaxShareFactor;
        return this;
    }
    
    /**
     * If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=alternative_route.max_weight_factor")
    public Double alternativeRouteMaxWeightFactor;
    public GetRouteQueryParams withAlternativeRouteMaxWeightFactor(Double alternativeRouteMaxWeightFactor) {
        this.alternativeRouteMaxWeightFactor = alternativeRouteMaxWeightFactor;
        return this;
    }
    
    /**
     * Specify which road classes and environments you would like to avoid. 
     * Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
     * Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=avoid")
    public String avoid;
    public GetRouteQueryParams withAvoid(String avoid) {
        this.avoid = avoid;
        return this;
    }
    
    /**
     * Block road access by specifying a point close to the road segment to be blocked, with the format `lat,lon`.
     * You can also block all road segments crossing a geometric shape. Specify a circle using the format `lat,lon,radius`, or a polygon using the format `lat1,lon1,lat2,lon2,...,latN,lonN`.
     * You can specify several shapes, separating them with `;`. Requires `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=block_area")
    public String blockArea;
    public GetRouteQueryParams withBlockArea(String blockArea) {
        this.blockArea = blockArea;
        return this;
    }
    
    /**
     * If the points for the route should be calculated at all.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=calc_points")
    public Boolean calcPoints;
    public GetRouteQueryParams withCalcPoints(Boolean calcPoints) {
        this.calcPoints = calcPoints;
        return this;
    }
    
    /**
     * Use this parameter in combination with one or more parameters from below.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=ch.disable")
    public Boolean chDisable;
    public GetRouteQueryParams withChDisable(Boolean chDisable) {
        this.chDisable = chDisable;
        return this;
    }
    
    /**
     * Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=curbside")
    public GetRouteCurbsideEnum[] curbside;
    public GetRouteQueryParams withCurbside(GetRouteCurbsideEnum[] curbside) {
        this.curbside = curbside;
        return this;
    }
    
    /**
     * If `true`, the output will be formatted.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=debug")
    public Boolean debug;
    public GetRouteQueryParams withDebug(Boolean debug) {
        this.debug = debug;
        return this;
    }
    
    /**
     * Optional parameter to retrieve path details. You can request additional details for the route: `street_name`, 
     * `time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=details")
    public String[] details;
    public GetRouteQueryParams withDetails(String[] details) {
        this.details = details;
        return this;
    }
    
    /**
     * If `true`, a third coordinate, the altitude, is included with all positions in the response.
     * This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
     * encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
     * client side that can handle three-dimensional coordinates.
     * A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=elevation")
    public Boolean elevation;
    public GetRouteQueryParams withElevation(Boolean elevation) {
        this.elevation = elevation;
        return this;
    }
    
    /**
     * Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
     * In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
     * This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=heading")
    public Integer[] heading;
    public GetRouteQueryParams withHeading(Integer[] heading) {
        this.heading = heading;
        return this;
    }
    
    /**
     * Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=heading_penalty")
    public Integer headingPenalty;
    public GetRouteQueryParams withHeadingPenalty(Integer headingPenalty) {
        this.headingPenalty = headingPenalty;
        return this;
    }
    
    /**
     * If instructions should be calculated and returned
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=instructions")
    public Boolean instructions;
    public GetRouteQueryParams withInstructions(Boolean instructions) {
        this.instructions = instructions;
        return this;
    }
    
    /**
     * The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=locale")
    public String locale;
    public GetRouteQueryParams withLocale(String locale) {
        this.locale = locale;
        return this;
    }
    
    /**
     * Normally, the calculated route will visit the points in the order you specified them.
     * If you have more than two points, you can set this parameter to `"true"` and the points may be re-ordered to minimize the total travel time.
     * Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=optimize")
    public String optimize;
    public GetRouteQueryParams withOptimize(String optimize) {
        this.optimize = optimize;
        return this;
    }
    
    /**
     * If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=pass_through")
    public Boolean passThrough;
    public GetRouteQueryParams withPassThrough(Boolean passThrough) {
        this.passThrough = passThrough;
        return this;
    }
    
    /**
     * The points for which the route should be calculated. Format: `[latitude,longitude]`. Specify at least an origin and a destination. Via points are possible.
     * The maximum number depends on your plan.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=point")
    public String[] point;
    public GetRouteQueryParams withPoint(String[] point) {
        this.point = point;
        return this;
    }
    
    /**
     * The `point_hint` is typically a road name to which the associated `point` parameter should be snapped to. Specify no `point_hint` parameter or the same number as you have `point` parameters.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=point_hint")
    public String[] pointHint;
    public GetRouteQueryParams withPointHint(String[] pointHint) {
        this.pointHint = pointHint;
        return this;
    }
    
    /**
     * Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
     * but requires special client code to unpack. (We provide it in our JavaScript client library!)
     * Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
     * See the description of the response format for more information.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=points_encoded")
    public Boolean pointsEncoded;
    public GetRouteQueryParams withPointsEncoded(Boolean pointsEncoded) {
        this.pointsEncoded = pointsEncoded;
        return this;
    }
    
    /**
     * If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=round_trip.distance")
    public Integer roundTripDistance;
    public GetRouteQueryParams withRoundTripDistance(Integer roundTripDistance) {
        this.roundTripDistance = roundTripDistance;
        return this;
    }
    
    /**
     * If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=round_trip.seed")
    public Long roundTripSeed;
    public GetRouteQueryParams withRoundTripSeed(Long roundTripSeed) {
        this.roundTripSeed = roundTripSeed;
        return this;
    }
    
    /**
     * Optional parameter to avoid snapping to a certain road class or road environment. Currently supported values are `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&amp;snap_prevention=motorway`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=snap_prevention")
    public String[] snapPrevention;
    public GetRouteQueryParams withSnapPrevention(String[] snapPrevention) {
        this.snapPrevention = snapPrevention;
        return this;
    }
    
    /**
     * Specifies if turn restrictions should be considered. Enabling this option increases the route computation time. Only supported for motor vehicles and OpenStreetMap.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=turn_costs")
    public Boolean turnCosts;
    public GetRouteQueryParams withTurnCosts(Boolean turnCosts) {
        this.turnCosts = turnCosts;
        return this;
    }
    
    /**
     * The vehicle profile for which the route should be calculated.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=vehicle")
    public org.openapis.openapi.models.shared.VehicleProfileIdEnum vehicle;
    public GetRouteQueryParams withVehicle(org.openapis.openapi.models.shared.VehicleProfileIdEnum vehicle) {
        this.vehicle = vehicle;
        return this;
    }
    
    /**
     * Determines the way the "best" route is calculated. Besides `fastest` you can use `short_fastest` which finds a reasonable balance between the distance influence (`shortest`) and the time (`fastest`). You could also use `shortest` but is deprecated and not recommended for motor vehicles. All except `fastest` require `ch.disable=true`.
     * 
     */
    @SpeakeasyMetadata("queryParam:style=form,explode=true,name=weighting")
    public String weighting;
    public GetRouteQueryParams withWeighting(String weighting) {
        this.weighting = weighting;
        return this;
    }
    
}
