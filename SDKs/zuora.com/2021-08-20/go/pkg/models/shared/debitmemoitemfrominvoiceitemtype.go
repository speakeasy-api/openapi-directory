// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
	"openapi/pkg/types"
)

// DebitMemoItemFromInvoiceItemTypeFinanceInformation - Container for the finance information related to the debit memo item.
type DebitMemoItemFromInvoiceItemTypeFinanceInformation struct {
	// The accounting code for the deferred revenue, such as Monthly Recurring Liability.
	//
	DeferredRevenueAccountingCode *string `json:"deferredRevenueAccountingCode,omitempty"`
	// The accounting code for the recognized revenue, such as Monthly Recurring Charges or Overage Charges.
	//
	RecognizedRevenueAccountingCode *string `json:"recognizedRevenueAccountingCode,omitempty"`
	// The name of the revenue recognition rule governing the revenue schedule.
	//
	RevenueRecognitionRuleName *string `json:"revenueRecognitionRuleName,omitempty"`
}

// DebitMemoItemFromInvoiceItemTypeTaxModeEnum - The tax mode of the debit memo item, indicating whether the amount of the debit memo item includes tax.
//
// **Note**: You can set this field to `TaxInclusive` only if the `taxAutoCalculation` field is set to `true`.
//
// If you set `taxMode` to `TaxInclusive`, you cannot input tax amounts for debit memo items. The corresponding invoice item must use the same tax engine as the debit memo item to calculate tax amounts.
type DebitMemoItemFromInvoiceItemTypeTaxModeEnum string

const (
	DebitMemoItemFromInvoiceItemTypeTaxModeEnumTaxExclusive DebitMemoItemFromInvoiceItemTypeTaxModeEnum = "TaxExclusive"
	DebitMemoItemFromInvoiceItemTypeTaxModeEnumTaxInclusive DebitMemoItemFromInvoiceItemTypeTaxModeEnum = "TaxInclusive"
)

func (e *DebitMemoItemFromInvoiceItemTypeTaxModeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "TaxExclusive":
		fallthrough
	case "TaxInclusive":
		*e = DebitMemoItemFromInvoiceItemTypeTaxModeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for DebitMemoItemFromInvoiceItemTypeTaxModeEnum: %s", s)
	}
}

// DebitMemoItemFromInvoiceItemType - Container for custom fields of a Debit Memo Item object.
type DebitMemoItemFromInvoiceItemType struct {
	// The amount of the debit memo item.
	//
	Amount float64 `json:"amount"`
	// Comments about the debit memo item.
	//
	// **Note**: This field is not available if you set the `zuora-version` request header to `257.0` or later.
	//
	Comment *string `json:"comment,omitempty"`
	// The description of the debit memo item.
	//
	// **Note**: This field is only available if you set the `zuora-version` request header to `257.0` or later.
	//
	Description *string `json:"description,omitempty"`
	// Container for the finance information related to the debit memo item.
	//
	FinanceInformation *DebitMemoItemFromInvoiceItemTypeFinanceInformation `json:"financeInformation,omitempty"`
	// The ID of the invoice item.
	//
	InvoiceItemID *string `json:"invoiceItemId,omitempty"`
	// The number of units for the debit memo item.
	//
	Quantity *float64 `json:"quantity,omitempty"`
	// The service end date of the debit memo item.
	//
	ServiceEndDate *types.Date `json:"serviceEndDate,omitempty"`
	// The service start date of the debit memo item.
	//
	ServiceStartDate *types.Date `json:"serviceStartDate,omitempty"`
	// TThe name of the charge associated with the invoice.
	//
	SkuName string `json:"skuName"`
	// Container for taxation items.
	//
	TaxItems []DebitMemoTaxItemFromInvoiceTaxItemType `json:"taxItems,omitempty"`
	// The tax mode of the debit memo item, indicating whether the amount of the debit memo item includes tax.
	//
	// **Note**: You can set this field to `TaxInclusive` only if the `taxAutoCalculation` field is set to `true`.
	//
	// If you set `taxMode` to `TaxInclusive`, you cannot input tax amounts for debit memo items. The corresponding invoice item must use the same tax engine as the debit memo item to calculate tax amounts.
	//
	TaxMode *DebitMemoItemFromInvoiceItemTypeTaxModeEnum `json:"taxMode,omitempty"`
	// The definable unit that you measure when determining charges.
	//
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}
