<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class RootMssql 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Assign SLA properties to SQL Server objects
     * 
     * Assigns SLA Domain properties to SQL Server objects. Hosts and Windows clusters cannot be assigned SLA Domains directly. The SLA Domains are instead applied to the SQL Server child objects within the Host or Windows Cluster object. Newly discovered SQL Server objects within a given Host or Windows Cluster object do not inherit SLA Domain properties from other child SQL Server objects with the same parent object.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\MssqlSlaDomainAssignInfo $request
     * @return \OpenAPI\OpenAPI\Models\Operations\AssignMssqlSlaPropertiesResponse
     */
	public function assignMssqlSlaProperties(
        \OpenAPI\OpenAPI\Models\Shared\MssqlSlaDomainAssignInfo $request,
    ): \OpenAPI\OpenAPI\Models\Operations\AssignMssqlSlaPropertiesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/sla_domain/assign');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\AssignMssqlSlaPropertiesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * List snapshots and logs from a Microsoft SQL database
     * 
     * When a recovery point is set, this API endpoint returns the snapshot and list of logs needed to restore the database to the recovery point. When a time range or LSN range is specified, this API endpoint returns the snapshots and logs that overlap the specified range.
     * Specify only a recovery point or a range. Specify only LSNs or times.
     * This endpoint is only used to fetch data, but uses POST instead of GET due to limitations on parameters used in the body of a GET request. The parameter set for this endpoint is shared with the download_file endpoint.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\BrowseMssqlBackupFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BrowseMssqlBackupFilesResponse
     */
	public function browseMssqlBackupFiles(
        \OpenAPI\OpenAPI\Models\Operations\BrowseMssqlBackupFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BrowseMssqlBackupFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/browse', \OpenAPI\OpenAPI\Models\Operations\BrowseMssqlBackupFilesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlBackupSelection", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BrowseMssqlBackupFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlBackups = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlBackups', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update multiple Microsoft SQL databases
     * 
     * Update multiple Microsoft SQL databases with the specified properties.
     * 
     * @param array<\OpenAPI\OpenAPI\Models\Shared\MssqlDbUpdateId> $request
     * @return \OpenAPI\OpenAPI\Models\Operations\BulkUpdateMssqlDbV1Response
     */
	public function bulkUpdateMssqlDbV1(
        array $request,
    ): \OpenAPI\OpenAPI\Models\Operations\BulkUpdateMssqlDbV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/bulk');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\BulkUpdateMssqlDbV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbDetails = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\MssqlDbDetail>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a count of Microsoft SQL databases
     * 
     * Returns a count of Microsoft SQL databases.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CountMssqlDbV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CountMssqlDbV1Response
     */
	public function countMssqlDbV1(
        \OpenAPI\OpenAPI\Models\Operations\CountMssqlDbV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CountMssqlDbV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/count');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CountMssqlDbV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CountMssqlDbV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->protectedObjectsCount = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ProtectedObjectsCount', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a count of Microsoft SQL instances
     * 
     * Returns a count of all Microsoft SQL instances.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\CountMssqlInstanceV1Response
     */
	public function countMssqlInstanceV1(
    ): \OpenAPI\OpenAPI\Models\Operations\CountMssqlInstanceV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/instance/count');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CountMssqlInstanceV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->countResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\CountResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Download snapshots and logs backups from a Microsoft SQL Database
     * 
     * Starts an asynchronous request to download a set of backup files as a single compressed zipfile.
     * When a recovery point is set, this API endpoint returns the snapshot and list of logs that Rubrik CDM would use to restore the database to the recovery point. When a time range or LSN range is specified, this API endpoint returns the snapshots and logs that overlap the specified range.
     * Specify only a point in time or a range. Specify only LSNs or times.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesResponse
     */
	public function createDownloadMssqlBackupFiles(
        \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/download_files', \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlBackupSelection", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Downloads a list of snapshot and log backups from a Microsoft SQL database
     * 
     * Downloads a list of snapshot and log backups from a Microsoft SQL database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesByIdRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesByIdResponse
     */
	public function createDownloadMssqlBackupFilesById(
        \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesByIdRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesByIdResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/download_files_by_id', \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesByIdRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "downloadMssqlBackupFilesByIdJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateDownloadMssqlBackupFilesByIdResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Export a Microsoft SQL database to a new location
     * 
     * Create a request to export a Microsoft SQL database. To check the result of the request, poll /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateExportMssqlDbRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateExportMssqlDbResponse
     */
	public function createExportMssqlDb(
        \OpenAPI\OpenAPI\Models\Operations\CreateExportMssqlDbRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateExportMssqlDbResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/export', \OpenAPI\OpenAPI\Models\Operations\CreateExportMssqlDbRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "exportMssqlDbJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateExportMssqlDbResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a log shipping configuration
     * 
     * Create a log shipping configuration between a specified primary database and a specified secondary database. The transaction logs from the primary database are regularly restored to the secondary database in order to maintain the secondary database as a point-in-time copy of the primary database. The primary database must have log backups configured, and it must be in the full or bulk-logged recovery model.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateLogShippingConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateLogShippingConfigurationResponse
     */
	public function createLogShippingConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\CreateLogShippingConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateLogShippingConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/log_shipping', \OpenAPI\OpenAPI\Models\Operations\CreateLogShippingConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlLogShippingCreateConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateLogShippingConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Create a SQL Server host configuration
     * 
     * Creates a SQL Server host configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\MssqlHostConfigurationWithHostId $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateMssqlHostConfigResponse
     */
	public function createMssqlHostConfig(
        \OpenAPI\OpenAPI\Models\Shared\MssqlHostConfigurationWithHostId $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateMssqlHostConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/host/configuration');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateMssqlHostConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHostConfiguration = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHostConfiguration', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Live Mount SQL Server database from a point in time copy
     * 
     * Create an asynchronous request to create a Live Mount SQL Server database. Poll the task status by using /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateMssqlMountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateMssqlMountResponse
     */
	public function createMssqlMount(
        \OpenAPI\OpenAPI\Models\Operations\CreateMssqlMountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateMssqlMountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/mount', \OpenAPI\OpenAPI\Models\Operations\CreateMssqlMountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mountMssqlDbConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateMssqlMountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a Live Mount of a SQL Server database
     * 
     * Create an async request to delete a Live Mount of a SQL Server database. Poll the task status by using /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountResponse
     */
	public function createMssqlUnmount(
        \OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/mount/{id}', \OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateMssqlUnmountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Take an on-demand backup of a Microsoft SQL database
     * 
     * Take an on-demand backup of a Microsoft SQL database. The forceFullSnapshot property can be set to true to force a full snapshot. To check the result of the request, poll /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBackupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBackupResponse
     */
	public function createOnDemandMssqlBackup(
        \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBackupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBackupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBackupRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlBackupJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBackupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Take an on-demand backup of multiple Microsoft SQL databases
     * 
     * Take an on-demand backup of one or more Microsoft SQL databases. Set the forceFullSnapshot property to true to force a full snapshot for every database that is specified. Only one snapshot will be taken for each database, even if a database is included multiple times in the fields of the request body. To check the result of the request, poll /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\MssqlBatchBackupJobConfig $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBatchBackupV1Response
     */
	public function createOnDemandMssqlBatchBackupV1(
        \OpenAPI\OpenAPI\Models\Shared\MssqlBatchBackupJobConfig $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBatchBackupV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/bulk/snapshot');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlBatchBackupV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Take an on-demand log backup for a Microsoft SQL database
     * 
     * Take an on-demand log backup for a Microsoft SQL database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlLogBackupRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlLogBackupResponse
     */
	public function createOnDemandMssqlLogBackup(
        \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlLogBackupRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlLogBackupResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/log_backup', \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlLogBackupRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateOnDemandMssqlLogBackupResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Restore a Microsoft SQL database
     * 
     * Create a request to restore a SQL Server database. To check the result of the request, poll /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CreateRestoreMssqlDbRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CreateRestoreMssqlDbResponse
     */
	public function createRestoreMssqlDb(
        \OpenAPI\OpenAPI\Models\Operations\CreateRestoreMssqlDbRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CreateRestoreMssqlDbResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/restore', \OpenAPI\OpenAPI\Models\Operations\CreateRestoreMssqlDbRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "restoreMssqlDbJobConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CreateRestoreMssqlDbResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete downloaded recoverable ranges of a Microsoft SQL database
     * 
     * Deletes all local snapshots and logs that have previously been downloaded. Provide a begin or end time to delete only the downloaded snapshots and logs that fall within this time frame. The time is relative to when the snapshot or log backup was originally taken, not downloaded. Parts of the window may not be deleted if certain log files must be kept to preserve times outside the window. Data is deleted in the background. To check the status of the deletion, poll /mssql/db/recoverable_range/download/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Response
     */
	public function deleteDownloadedMssqlDbRecoverableRangesV1(
        \OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/recoverable_range/download', \OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteDownloadedMssqlDbRecoverableRangesV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->jobScheduledResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\JobScheduledResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete a specified log shipping configuration
     * 
     * Deletes the specified log shipping configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationResponse
     */
	public function deleteLogShippingConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/log_shipping/{id}', \OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteLogShippingConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Delete all snapshots of a Microsoft SQL database
     * 
     * Deletes all snapshots of a Microsoft SQL database. The database must be unprotected for the operation to succeed.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlDbSnapshotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlDbSnapshotsResponse
     */
	public function deleteMssqlDbSnapshots(
        \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlDbSnapshotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlDbSnapshotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlDbSnapshotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlDbSnapshotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Delete the SQL Server host configuration
     * 
     * Deletes the SQL Server host configuration. The host falls back to use values from the global configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlHostConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlHostConfigResponse
     */
	public function deleteMssqlHostConfig(
        \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlHostConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlHostConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/host/configuration/{host_id}', \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlHostConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('DELETE', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DeleteMssqlHostConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 204) {
        }

        return $response;
    }
	
    /**
     * Download snapshots and log backups from archival
     * 
     * Starts an asynchronous request to download snapshots and logs from archival for a given database and recovery point.
     * If the specified point in time is already available locally, this endpoint throws an error.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\DownloadFromArchiveRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\DownloadFromArchiveResponse
     */
	public function downloadFromArchive(
        \OpenAPI\OpenAPI\Models\Operations\DownloadFromArchiveRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\DownloadFromArchiveResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/download', \OpenAPI\OpenAPI\Models\Operations\DownloadFromArchiveRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlDownloadFromArchiveConfig", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\DownloadFromArchiveResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get compatible instances for the recovery of a Microsoft SQL database
     * 
     * Returns all compatible instances for export for the specified recovery time.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Response
     */
	public function getCompatibleMssqlInstancesV1(
        \OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/compatible_instance', \OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetCompatibleMssqlInstancesV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlInstanceSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlInstanceSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the current default properties for Microsoft SQL databases
     * 
     * The default properties are Log Backup Frequency (in seconds), Log Retention Time (in hours) and CBT status. New databases added to the Rubrik cluster are provided the log backup frequency value and log backup retention value by default. New hosts added to the Rubrik cluster are provided the CBT status by default.
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDefaultDbPropertiesV1Response
     */
	public function getDefaultDbPropertiesV1(
    ): \OpenAPI\OpenAPI\Models\Operations\GetDefaultDbPropertiesV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/defaults');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDefaultDbPropertiesV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbDefaults = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbDefaults', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the deletion status of downloaded recoverable ranges
     * 
     * Get the details of the progress made in deleting recoverable ranges. The recoverable ranges to delete are those specified by the DELETE request to /mssql/db/{id}/recoverable_range/download which yielded the response with the job id.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetDeleteMssqlDbRecoverableRangesStatusV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetDeleteMssqlDbRecoverableRangesStatusV1Response
     */
	public function getDeleteMssqlDbRecoverableRangesStatusV1(
        \OpenAPI\OpenAPI\Models\Operations\GetDeleteMssqlDbRecoverableRangesStatusV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetDeleteMssqlDbRecoverableRangesStatusV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/recoverable_range/download/{id}', \OpenAPI\OpenAPI\Models\Operations\GetDeleteMssqlDbRecoverableRangesStatusV1Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetDeleteMssqlDbRecoverableRangesStatusV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->internalJobInstanceDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\InternalJobInstanceDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get a log shipping configuration
     * 
     * Retrieves a particular log shipping configuration with all the details of the configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetLogShippingConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetLogShippingConfigurationResponse
     */
	public function getLogShippingConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\GetLogShippingConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetLogShippingConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/log_shipping/{id}', \OpenAPI\OpenAPI\Models\Operations\GetLogShippingConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetLogShippingConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlLogShippingDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlLogShippingDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for missed snapshots of a SQL database
     * 
     * Returns a list of summary information for the missed snapshots of a Microsoft SQL database, including the time of day and the locations where the snapshot was missed.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsResponse
     */
	public function getMissedMssqlDbSnapshots(
        \OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/missed_snapshot', \OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMissedMssqlDbSnapshotsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->missedSnapshotListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MissedSnapshotListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get details for an async request
     * 
     * Returns the task object for an async request related to SQL Server databases.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlAsyncRequestStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlAsyncRequestStatusResponse
     */
	public function getMssqlAsyncRequestStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlAsyncRequestStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlAsyncRequestStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/request/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlAsyncRequestStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlAsyncRequestStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns detailed information for a Microsoft SQL availability group
     * 
     * Returns a detailed view of a Microsoft SQL availability group.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlAvailabilityGroupV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlAvailabilityGroupV1Response
     */
	public function getMssqlAvailabilityGroupV1(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlAvailabilityGroupV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlAvailabilityGroupV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/availability_group/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlAvailabilityGroupV1Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlAvailabilityGroupV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlAvailabilityGroupSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlAvailabilityGroupSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get detailed information for a Microsoft SQL database
     * 
     * Returns a detailed view of a Microsoft SQL database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbResponse
     */
	public function getMssqlDb(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get missed recoverable ranges of a Microsoft SQL database
     * 
     * Retrieve a list of missed recoverable ranges for a Microsoft SQL database. For each run of one type of error, the first and last occurrence of the error are given.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesResponse
     */
	public function getMssqlDbMissedRecoverableRanges(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/missed_recoverable_range', \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbMissedRecoverableRangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlMissedRecoverableRangeListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlMissedRecoverableRangeListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get recoverable ranges of a Microsoft SQL database
     * 
     * Retrieve the recoverable ranges for a specified Microsoft SQL database. A begin and/or end timestamp can be provided to retrieve only the ranges that fall within the window.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesResponse
     */
	public function getMssqlDbRecoverableRanges(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/recoverable_range', \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbRecoverableRangesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlRecoverableRangeListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlRecoverableRangeListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get details information about a Microsoft SQL database snapshot
     * 
     * Returns detailed information about a Microsoft SQL database snapshot.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbSnapshotResponse
     */
	public function getMssqlDbSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/snapshot/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlDbSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbSnapshotDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbSnapshotDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of immediate descendant objects
     * 
     * Retrieve the list of immediate descendant objects for the specified parent.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenResponse
     */
	public function getMssqlHierarchyChildren(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/hierarchy/{id}/children', \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyChildrenResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHierarchyObjectSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHierarchyObjectSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of descendant objects
     * 
     * Retrieve the list of descendant objects for the specified parent.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsResponse
     */
	public function getMssqlHierarchyDescendants(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/hierarchy/{id}/descendants', \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyDescendantsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHierarchyObjectSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHierarchyObjectSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary of a SQL Server hierarchy object
     * 
     * Retrieve details for the specified object in the SQL Server hierarchy.
     * 
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyObjectRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyObjectResponse
     */
	public function getMssqlHierarchyObject(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyObjectRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyObjectResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/hierarchy/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyObjectRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlHierarchyObjectResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHierarchyObjectSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHierarchyObjectSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the configuration for a specific host
     * 
     * Returns the configuration for the specified SQL Server host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlHostConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlHostConfigResponse
     */
	public function getMssqlHostConfig(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlHostConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlHostConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/host/configuration/{host_id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlHostConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlHostConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHostConfiguration = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHostConfiguration', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get detailed information for a Microsoft SQL instance
     * 
     * Returns a detailed view of a Microsoft SQL instance.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlInstanceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlInstanceResponse
     */
	public function getMssqlInstance(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlInstanceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlInstanceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/instance/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlInstanceRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlInstanceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlInstanceSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlInstanceSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get detailed information for a Live Mount of a SQL Server database
     * 
     * Returns detailed information for the specified Live Mount of a SQL Server database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetMssqlMountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetMssqlMountResponse
     */
	public function getMssqlMount(
        \OpenAPI\OpenAPI\Models\Operations\GetMssqlMountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetMssqlMountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/mount/{id}', \OpenAPI\OpenAPI\Models\Operations\GetMssqlMountRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetMssqlMountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlMountDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlMountDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns details for an on-demand backup of multiple Microsoft SQL databases
     * 
     * Returns the details for an on-demand backup of multiple Microsoft SQL databases. This only returns details for requests that have finished successfully. To check the status of the request, poll /mssql/request/{id}.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetOnDemandMssqlBatchBackupResultV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetOnDemandMssqlBatchBackupResultV1Response
     */
	public function getOnDemandMssqlBatchBackupResultV1(
        \OpenAPI\OpenAPI\Models\Operations\GetOnDemandMssqlBatchBackupResultV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetOnDemandMssqlBatchBackupResultV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/bulk/snapshot/{id}', \OpenAPI\OpenAPI\Models\Operations\GetOnDemandMssqlBatchBackupResultV1Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetOnDemandMssqlBatchBackupResultV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlBatchBackupSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlBatchBackupSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a list all database files to be restored
     * 
     * Provides a list of database files to be restored for the specified restore or export operation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Response
     */
	public function mssqlGetRestoreFilesV1(
        \OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/restore_files', \OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MssqlGetRestoreFilesV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlRestoreFiles = $serializer->deserialize((string)$httpResponse->getBody(), 'array<OpenAPI\OpenAPI\Models\Shared\MssqlRestoreFile>', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns the snappableId for a Microsoft SQL database
     * 
     * Returns the snappableId for a Microsoft SQL database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MssqlGetSnappableIdV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MssqlGetSnappableIdV1Response
     */
	public function mssqlGetSnappableIdV1(
        \OpenAPI\OpenAPI\Models\Operations\MssqlGetSnappableIdV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MssqlGetSnappableIdV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/snappable_id', \OpenAPI\OpenAPI\Models\Operations\MssqlGetSnappableIdV1Request::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MssqlGetSnappableIdV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlSnappableId = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlSnappableId', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns a size estimate for a restore or export
     * 
     * Provides an estimate of resources needed for the specified restore or export operation.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Response
     */
	public function mssqlRestoreEstimateV1(
        \OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/restore_estimate', \OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\MssqlRestoreEstimateV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlRestoreEstimateResult = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlRestoreEstimateResult', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get log shipping configurations
     * 
     * Retrieves all log shipping configuration objects. Results can be filtered and sorted.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryLogShippingConfigurationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryLogShippingConfigurationsResponse
     */
	public function queryLogShippingConfigurations(
        \OpenAPI\OpenAPI\Models\Operations\QueryLogShippingConfigurationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryLogShippingConfigurationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/log_shipping');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryLogShippingConfigurationsRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryLogShippingConfigurationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlLogShippingSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlLogShippingSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Returns summary information for Microsoft SQL availability groups
     * 
     * Returns a list of summary information for Microsoft SQL availability groups.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMssqlAvailabilityGroupV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMssqlAvailabilityGroupV1Response
     */
	public function queryMssqlAvailabilityGroupV1(
        \OpenAPI\OpenAPI\Models\Operations\QueryMssqlAvailabilityGroupV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMssqlAvailabilityGroupV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/availability_group');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMssqlAvailabilityGroupV1Request::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMssqlAvailabilityGroupV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlAvailabilityGroupSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlAvailabilityGroupSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for SQL Server databases
     * 
     * Returns a list of summary information for Microsoft SQL databases.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbResponse
     */
	public function queryMssqlDb(
        \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for snapshots of a Microsoft SQL database
     * 
     * Returns a list of summary information for snapshots of a Microsoft SQL database.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotResponse
     */
	public function queryMssqlDbSnapshot(
        \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}/snapshot', \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMssqlDbSnapshotResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbSnapshotSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbSnapshotSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the summary of SQL Server host configurations
     * 
     * Returns a list of customized SQL Server host configurations.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMssqlHostConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMssqlHostConfigResponse
     */
	public function queryMssqlHostConfig(
        \OpenAPI\OpenAPI\Models\Operations\QueryMssqlHostConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMssqlHostConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/host/configuration');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMssqlHostConfigRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMssqlHostConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHostConfigurationWithHostIdListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHostConfigurationWithHostIdListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for Microsoft SQL instances
     * 
     * Returns a list of summary information for Microsoft SQL instances.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMssqlInstanceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMssqlInstanceResponse
     */
	public function queryMssqlInstance(
        \OpenAPI\OpenAPI\Models\Operations\QueryMssqlInstanceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMssqlInstanceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/instance');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMssqlInstanceRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMssqlInstanceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlInstanceSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlInstanceSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get summary information for all Live Mounts SQL Server databases
     * 
     * Returns a list with summary information for all Live Mount SQL Server databases.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\QueryMssqlMountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\QueryMssqlMountResponse
     */
	public function queryMssqlMount(
        \OpenAPI\OpenAPI\Models\Operations\QueryMssqlMountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\QueryMssqlMountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/mount');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\QueryMssqlMountRequest::class, $request, null));
        
        $httpResponse = $this->_securityClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\QueryMssqlMountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlMountSummaryListResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlMountSummaryListResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Reseed a secondary database
     * 
     * Starts an asynchronous job to reseed a secondary database. Reseeding restores the data in the secondary database based on a log shipping configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\ReseedSecondaryRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\ReseedSecondaryResponse
     */
	public function reseedSecondary(
        \OpenAPI\OpenAPI\Models\Operations\ReseedSecondaryRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\ReseedSecondaryResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/log_shipping/{id}/reseed', \OpenAPI\OpenAPI\Models\Operations\ReseedSecondaryRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlLogShippingTargetStateOptions", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\ReseedSecondaryResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update the default properties for Microsoft SQL databases
     * 
     * The default properties are Log Backup Frequency (in seconds), Log Retention Time (in hours) and CBT status. New databases added to the Rubrik cluster are provided the log backup frequency value and log backup retention value by default. New hosts added to the Rubrik cluster are provided the CBT status by default.
     * 
     * @param \OpenAPI\OpenAPI\Models\Shared\MssqlDbDefaultsUpdate $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateDefaultDbPropertiesV1Response
     */
	public function updateDefaultDbPropertiesV1(
        \OpenAPI\OpenAPI\Models\Shared\MssqlDbDefaultsUpdate $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateDefaultDbPropertiesV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/defaults');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "request", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateDefaultDbPropertiesV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbDefaults = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbDefaults', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a specified log shipping configuration
     * 
     * Updates a specified log shipping configuration.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateLogShippingConfigurationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateLogShippingConfigurationResponse
     */
	public function updateLogShippingConfiguration(
        \OpenAPI\OpenAPI\Models\Operations\UpdateLogShippingConfigurationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateLogShippingConfigurationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/log_shipping/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateLogShippingConfigurationRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlLogShippingTargetStateOptions", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateLogShippingConfigurationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 202) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->asyncRequestStatus = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AsyncRequestStatus', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Microsoft SQL availability group
     * 
     * Update a Microsoft SQL availability group with the specified properties.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlAvailabilityGroupV1Request $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlAvailabilityGroupV1Response
     */
	public function updateMssqlAvailabilityGroupV1(
        \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlAvailabilityGroupV1Request $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlAvailabilityGroupV1Response
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/availability_group/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlAvailabilityGroupV1Request::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlSlaPatchProperties", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlAvailabilityGroupV1Response();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlAvailabilityGroupSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlAvailabilityGroupSummary', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Microsoft SQL database
     * 
     * Update a Microsoft SQL database with the specified properties.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlDbRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlDbResponse
     */
	public function updateMssqlDb(
        \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlDbRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlDbResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/db/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlDbRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlDbUpdate", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlDbResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlDbDetail = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlDbDetail', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update host configuration
     * 
     * Updates the configuration for a specified host.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlHostConfigRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlHostConfigResponse
     */
	public function updateMssqlHostConfig(
        \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlHostConfigRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlHostConfigResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/host/configuration/{host_id}', \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlHostConfigRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlHostConfiguration", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlHostConfigResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlHostConfiguration = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlHostConfiguration', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Update a Microsoft SQL instance
     * 
     * Update a Microsoft SQL instance with specified properties.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlInstanceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlInstanceResponse
     */
	public function updateMssqlInstance(
        \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlInstanceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlInstanceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/mssql/instance/{id}', \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlInstanceRequest::class, $request);
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "mssqlSlaPatchProperties", "json");
        if ($body === null) {
            throw new \Exception('Request body is required');
        }
        $options = array_merge_recursive($options, $body);
        
        $httpResponse = $this->_securityClient->request('PATCH', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\UpdateMssqlInstanceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->mssqlInstanceSummary = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\MssqlInstanceSummary', 'json');
            }
        }

        return $response;
    }
}