/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import java.time.OffsetDateTime;
import org.openapis.openapi.utils.DateTimeDeserializer;
import org.openapis.openapi.utils.DateTimeSerializer;

public class JobMonitoringInfo {
    /**
     * Amount of data to transfer in bytes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dataToTransfer")
    public Long dataToTransfer;

    public JobMonitoringInfo withDataToTransfer(Long dataToTransfer) {
        this.dataToTransfer = dataToTransfer;
        return this;
    }
    
    /**
     * The amount of data transferred as part of the job in bytes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("dataTransferred")
    public Long dataTransferred;

    public JobMonitoringInfo withDataTransferred(Long dataTransferred) {
        this.dataTransferred = dataTransferred;
        return this;
    }
    
    /**
     * The number of seconds since the job started to active jobs. The number of seconds the job ran for completed jobs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("duration")
    public Long duration;

    public JobMonitoringInfo withDuration(Long duration) {
        this.duration = duration;
        return this;
    }
    
    /**
     * End time of the job. Leave this value empty for queued and running jobs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("endTime")
    public OffsetDateTime endTime;

    public JobMonitoringInfo withEndTime(OffsetDateTime endTime) {
        this.endTime = endTime;
        return this;
    }
    
    /**
     * Description of error information for the job.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("errorInfo")
    public String errorInfo;

    public JobMonitoringInfo withErrorInfo(String errorInfo) {
        this.errorInfo = errorInfo;
        return this;
    }
    
    /**
     * The event series id associated with the job.
     */
    @JsonProperty("eventSeriesId")
    public String eventSeriesId;

    public JobMonitoringInfo withEventSeriesId(String eventSeriesId) {
        this.eventSeriesId = eventSeriesId;
        return this;
    }
    
    /**
     * A Boolean value that determines whether or not the job associated with the event is a first full snapshot backup.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("isFirstFullSnapshot")
    public Boolean isFirstFullSnapshot;

    public JobMonitoringInfo withIsFirstFullSnapshot(Boolean isFirstFullSnapshot) {
        this.isFirstFullSnapshot = isFirstFullSnapshot;
        return this;
    }
    
    /**
     * A boolean value indication if the job is a log related job.
     */
    @JsonProperty("isLogTask")
    public Boolean isLogTask;

    public JobMonitoringInfo withIsLogTask(Boolean isLogTask) {
        this.isLogTask = isLogTask;
        return this;
    }
    
    /**
     * A boolean value indication if the job is a an on demand job.
     */
    @JsonProperty("isOnDemand")
    public Boolean isOnDemand;

    public JobMonitoringInfo withIsOnDemand(Boolean isOnDemand) {
        this.isOnDemand = isOnDemand;
        return this;
    }
    
    /**
     * Monitoring state of the job used for monitoring tabs.
     */
    @JsonProperty("jobMonitoringState")
    public JobMonitoringStateEnum jobMonitoringState;

    public JobMonitoringInfo withJobMonitoringState(JobMonitoringStateEnum jobMonitoringState) {
        this.jobMonitoringState = jobMonitoringState;
        return this;
    }
    
    /**
     * Monitoring status of the job break down.
     */
    @JsonProperty("jobStatus")
    public JobMonitoringStatusEnum jobStatus;

    public JobMonitoringInfo withJobStatus(JobMonitoringStatusEnum jobStatus) {
        this.jobStatus = jobStatus;
        return this;
    }
    
    /**
     * Task type.
     */
    @JsonProperty("jobType")
    public JobMonitoringTaskTypeEnum jobType;

    public JobMonitoringInfo withJobType(JobMonitoringTaskTypeEnum jobType) {
        this.jobType = jobType;
        return this;
    }
    
    /**
     * Time of the last successful job of the same job type. The return value is None if no successful jobs are present.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("lastSuccessfulJobTime")
    public OffsetDateTime lastSuccessfulJobTime;

    public JobMonitoringInfo withLastSuccessfulJobTime(OffsetDateTime lastSuccessfulJobTime) {
        this.lastSuccessfulJobTime = lastSuccessfulJobTime;
        return this;
    }
    
    /**
     * The time the status for the job has been updated.
     */
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("lastUpdatedTime")
    public OffsetDateTime lastUpdatedTime;

    public JobMonitoringInfo withLastUpdatedTime(OffsetDateTime lastUpdatedTime) {
        this.lastUpdatedTime = lastUpdatedTime;
        return this;
    }
    
    /**
     * Id of the location of the object.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locationId")
    public String locationId;

    public JobMonitoringInfo withLocationId(String locationId) {
        this.locationId = locationId;
        return this;
    }
    
    /**
     * Location Name.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("locationName")
    public String locationName;

    public JobMonitoringInfo withLocationName(String locationName) {
        this.locationName = locationName;
        return this;
    }
    
    /**
     * The maximum number of times the job will run in case of a failure.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("maximumAttemptsForJob")
    public Integer maximumAttemptsForJob;

    public JobMonitoringInfo withMaximumAttemptsForJob(Integer maximumAttemptsForJob) {
        this.maximumAttemptsForJob = maximumAttemptsForJob;
        return this;
    }
    
    /**
     * Expected start time of the next job of the same job type. The return value is None if no new job is scheduled.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("nextJobTime")
    public OffsetDateTime nextJobTime;

    public JobMonitoringInfo withNextJobTime(OffsetDateTime nextJobTime) {
        this.nextJobTime = nextJobTime;
        return this;
    }
    
    /**
     * Id of the node the job is running on.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("nodeId")
    public String nodeId;

    public JobMonitoringInfo withNodeId(String nodeId) {
        this.nodeId = nodeId;
        return this;
    }
    
    /**
     * The managed id of the object.
     */
    @JsonProperty("objectId")
    public String objectId;

    public JobMonitoringInfo withObjectId(String objectId) {
        this.objectId = objectId;
        return this;
    }
    
    /**
     * The object size in bytes.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("objectLogicalSize")
    public Long objectLogicalSize;

    public JobMonitoringInfo withObjectLogicalSize(Long objectLogicalSize) {
        this.objectLogicalSize = objectLogicalSize;
        return this;
    }
    
    /**
     * The name of the object in the job.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("objectName")
    public String objectName;

    public JobMonitoringInfo withObjectName(String objectName) {
        this.objectName = objectName;
        return this;
    }
    
    /**
     * Object types that are reported on.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("objectType")
    public ReportableObjectTypeEnum objectType;

    public JobMonitoringInfo withObjectType(ReportableObjectTypeEnum objectType) {
        this.objectType = objectType;
        return this;
    }
    
    /**
     * The number of times the job has retired.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("retryCount")
    public Integer retryCount;

    public JobMonitoringInfo withRetryCount(Integer retryCount) {
        this.retryCount = retryCount;
        return this;
    }
    
    /**
     * Monitoring retry status of the job (default is NotRetried).
     */
    @JsonProperty("retryStatus")
    public JobMonitoringRetryStatusEnum retryStatus;

    public JobMonitoringInfo withRetryStatus(JobMonitoringRetryStatusEnum retryStatus) {
        this.retryStatus = retryStatus;
        return this;
    }
    
    /**
     * Sla Domain Id.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("slaDomainId")
    public String slaDomainId;

    public JobMonitoringInfo withSlaDomainId(String slaDomainId) {
        this.slaDomainId = slaDomainId;
        return this;
    }
    
    /**
     * Sla Domain name.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("slaDomainName")
    public String slaDomainName;

    public JobMonitoringInfo withSlaDomainName(String slaDomainName) {
        this.slaDomainName = slaDomainName;
        return this;
    }
    
    /**
     * For replication jobs, this stores the source cluster name. Leave this value empty for other jobs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("sourceClusterName")
    public String sourceClusterName;

    public JobMonitoringInfo withSourceClusterName(String sourceClusterName) {
        this.sourceClusterName = sourceClusterName;
        return this;
    }
    
    /**
     * Start time for running or completed jobs. It is the scheduled start time for Queued jobs.
     */
    @JsonSerialize(using = DateTimeSerializer.class)
    @JsonDeserialize(using = DateTimeDeserializer.class)
    @JsonProperty("startTime")
    public OffsetDateTime startTime;

    public JobMonitoringInfo withStartTime(OffsetDateTime startTime) {
        this.startTime = startTime;
        return this;
    }
    
    /**
     * The throughput for running or completed jobs (measured in bytes/s). When no running or completed jobs exist no value is provided.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("throughput")
    public Long throughput;

    public JobMonitoringInfo withThroughput(Long throughput) {
        this.throughput = throughput;
        return this;
    }
    
    /**
     * The number of warning events in the event series associated with the job.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("warningCount")
    public Integer warningCount;

    public JobMonitoringInfo withWarningCount(Integer warningCount) {
        this.warningCount = warningCount;
        return this;
    }
    
    public JobMonitoringInfo(@JsonProperty("eventSeriesId") String eventSeriesId, @JsonProperty("isLogTask") Boolean isLogTask, @JsonProperty("isOnDemand") Boolean isOnDemand, @JsonProperty("jobMonitoringState") JobMonitoringStateEnum jobMonitoringState, @JsonProperty("jobStatus") JobMonitoringStatusEnum jobStatus, @JsonProperty("jobType") JobMonitoringTaskTypeEnum jobType, @JsonProperty("lastUpdatedTime") OffsetDateTime lastUpdatedTime, @JsonProperty("objectId") String objectId, @JsonProperty("retryStatus") JobMonitoringRetryStatusEnum retryStatus, @JsonProperty("startTime") OffsetDateTime startTime) {
        this.eventSeriesId = eventSeriesId;
        this.isLogTask = isLogTask;
        this.isOnDemand = isOnDemand;
        this.jobMonitoringState = jobMonitoringState;
        this.jobStatus = jobStatus;
        this.jobType = jobType;
        this.lastUpdatedTime = lastUpdatedTime;
        this.objectId = objectId;
        this.retryStatus = retryStatus;
        this.startTime = startTime;
  }
}
