/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Accounts {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Sets a private note on a user.
   */
  getApiV1AccountsRelationships(
    req: operations.GetApiV1AccountsRelationshipsRequest,
    security: operations.GetApiV1AccountsRelationshipsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsRelationshipsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsRelationshipsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/accounts/relationships";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsRelationshipsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsRelationshipsResponse =
        new operations.GetApiV1AccountsRelationshipsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationships = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.relationships = utils.objectToClass(
              httpRes?.data,
              shared.Relationship,
              resFieldDepth
            );
          }
          break;
        case [401, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Search for matching accounts by username or display name.
   */
  getApiV1AccountsSearch(
    req: operations.GetApiV1AccountsSearchRequest,
    security: operations.GetApiV1AccountsSearchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/accounts/search";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsSearchSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsSearchResponse =
        new operations.GetApiV1AccountsSearchResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Test to make sure that the user token works.
   */
  getApiV1AccountsVerifyCredentials(
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsVerifyCredentialsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/accounts/verify_credentials";

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsVerifyCredentialsResponse =
        new operations.GetApiV1AccountsVerifyCredentialsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        case [401, 403].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  getApiV1AccountsId(
    req: operations.GetApiV1AccountsIdRequest,
    security: operations.GetApiV1AccountsIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdResponse =
        new operations.GetApiV1AccountsIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 410:
          break;
      }

      return res;
    });
  }

  /**
   * Tags featured by this account.
   */
  getApiV1AccountsIdFeaturedTags(
    req: operations.GetApiV1AccountsIdFeaturedTagsRequest,
    security: operations.GetApiV1AccountsIdFeaturedTagsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdFeaturedTagsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdFeaturedTagsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/featured_tags",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdFeaturedTagsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdFeaturedTagsResponse =
        new operations.GetApiV1AccountsIdFeaturedTagsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.featuredTags = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.featuredTags = utils.objectToClass(
              httpRes?.data,
              shared.FeaturedTag,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Accounts which follow the given account, if network is not hidden by the account owner.
   */
  getApiV1AccountsIdFollowers(
    req: operations.GetApiV1AccountsIdFollowersRequest,
    security: operations.GetApiV1AccountsIdFollowersSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdFollowersResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdFollowersRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/followers",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdFollowersSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdFollowersResponse =
        new operations.GetApiV1AccountsIdFollowersResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 410:
          break;
      }

      return res;
    });
  }

  /**
   * Accounts which the given account is following, if network is not hidden by the account owner.
   */
  getApiV1AccountsIdFollowing(
    req: operations.GetApiV1AccountsIdFollowingRequest,
    security: operations.GetApiV1AccountsIdFollowingSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdFollowingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdFollowingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/following",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdFollowingSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdFollowingResponse =
        new operations.GetApiV1AccountsIdFollowingResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.accounts = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.accounts = utils.objectToClass(
              httpRes?.data,
              shared.Account,
              resFieldDepth
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 410:
          break;
      }

      return res;
    });
  }

  /**
   * Array of IdentityProof
   */
  getApiV1AccountsIdIdentityProofs(
    req: operations.GetApiV1AccountsIdIdentityProofsRequest,
    security: operations.GetApiV1AccountsIdIdentityProofsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdIdentityProofsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdIdentityProofsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/identity_proofs",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdIdentityProofsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdIdentityProofsResponse =
        new operations.GetApiV1AccountsIdIdentityProofsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.identityProofs = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.identityProofs = utils.objectToClass(
              httpRes?.data,
              shared.IdentityProof,
              resFieldDepth
            );
          }
          break;
        case [404, 422].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 410:
          break;
      }

      return res;
    });
  }

  /**
   * User lists that you have added this account to.
   */
  getApiV1AccountsIdLists(
    req: operations.GetApiV1AccountsIdListsRequest,
    security: operations.GetApiV1AccountsIdListsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdListsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdListsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/lists",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdListsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdListsResponse =
        new operations.GetApiV1AccountsIdListsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.lists = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.lists = utils.objectToClass(
              httpRes?.data,
              shared.List,
              resFieldDepth
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 410:
          break;
      }

      return res;
    });
  }

  /**
   * Statuses posted to the given account.
   */
  getApiV1AccountsIdStatuses(
    req: operations.GetApiV1AccountsIdStatusesRequest,
    security: operations.GetApiV1AccountsIdStatusesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetApiV1AccountsIdStatusesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetApiV1AccountsIdStatusesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/statuses",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetApiV1AccountsIdStatusesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetApiV1AccountsIdStatusesResponse =
        new operations.GetApiV1AccountsIdStatusesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.statuses = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.statuses = utils.objectToClass(
              httpRes?.data,
              shared.Status,
              resFieldDepth
            );
          }
          break;
        case [401, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 410:
          break;
      }

      return res;
    });
  }

  /**
   * Update the user's display and preferences.
   */
  patchApiV1AccountsUpdateCredentials(
    req: Uint8Array,
    security: operations.PatchApiV1AccountsUpdateCredentialsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchApiV1AccountsUpdateCredentialsResponse> {
    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/v1/accounts/update_credentials";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchApiV1AccountsUpdateCredentialsSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchApiV1AccountsUpdateCredentialsResponse =
        new operations.PatchApiV1AccountsUpdateCredentialsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.account = utils.objectToClass(httpRes?.data, shared.Account);
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a user and account records. Returns an account access token for the app that initiated the request. The app should save this token for later, and should wait for the user to confirm their account by clicking a link in their email inbox.
   */
  postApiV1Accounts(
    req: Uint8Array,
    security: operations.PostApiV1AccountsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/v1/accounts";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsResponse =
        new operations.PostApiV1AccountsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case [200, 401].includes(httpRes?.status):
          break;
      }

      return res;
    });
  }

  /**
   * Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline).
   */
  postApiV1AccountsIdBlock(
    req: operations.PostApiV1AccountsIdBlockRequest,
    security: operations.PostApiV1AccountsIdBlockSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdBlockResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdBlockRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/block",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdBlockSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdBlockResponse =
        new operations.PostApiV1AccountsIdBlockResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Follow the given account. Can also be used to update whether to show reblogs or enable notifications.
   */
  postApiV1AccountsIdFollow(
    req: operations.PostApiV1AccountsIdFollowRequest,
    security: operations.PostApiV1AccountsIdFollowSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdFollowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdFollowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/follow",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdFollowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdFollowResponse =
        new operations.PostApiV1AccountsIdFollowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 403:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Mute the given account. Clients should filter statuses and notifications from this account, if received (e.g. due to a boost in the Home timeline).
   */
  postApiV1AccountsIdMute(
    req: operations.PostApiV1AccountsIdMuteRequest,
    security: operations.PostApiV1AccountsIdMuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdMuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdMuteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/mute",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdMuteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdMuteResponse =
        new operations.PostApiV1AccountsIdMuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets a private note on a user.
   */
  postApiV1AccountsIdNote(
    req: operations.PostApiV1AccountsIdNoteRequest,
    security: operations.PostApiV1AccountsIdNoteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdNoteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdNoteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/note",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "raw"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdNoteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdNoteResponse =
        new operations.PostApiV1AccountsIdNoteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 422:
          break;
      }

      return res;
    });
  }

  /**
   * Add the given account to the user's featured profiles. (Featured profiles are currently shown on the user's own public profile.)
   */
  postApiV1AccountsIdPin(
    req: operations.PostApiV1AccountsIdPinRequest,
    security: operations.PostApiV1AccountsIdPinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdPinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdPinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/pin",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdPinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdPinResponse =
        new operations.PostApiV1AccountsIdPinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case [401, 403, 422, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline).
   */
  postApiV1AccountsIdUnblock(
    req: operations.PostApiV1AccountsIdUnblockRequest,
    security: operations.PostApiV1AccountsIdUnblockSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdUnblockResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdUnblockRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/unblock",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdUnblockSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdUnblockResponse =
        new operations.PostApiV1AccountsIdUnblockResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unfollow the given account.
   */
  postApiV1AccountsIdUnfollow(
    req: operations.PostApiV1AccountsIdUnfollowRequest,
    security: operations.PostApiV1AccountsIdUnfollowSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdUnfollowResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdUnfollowRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/unfollow",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdUnfollowSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdUnfollowResponse =
        new operations.PostApiV1AccountsIdUnfollowResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unmute the given account.
   */
  postApiV1AccountsIdUnmute(
    req: operations.PostApiV1AccountsIdUnmuteRequest,
    security: operations.PostApiV1AccountsIdUnmuteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdUnmuteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdUnmuteRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/unmute",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdUnmuteSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdUnmuteResponse =
        new operations.PostApiV1AccountsIdUnmuteResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove the given account from the user's featured profiles.
   */
  postApiV1AccountsIdUnpin(
    req: operations.PostApiV1AccountsIdUnpinRequest,
    security: operations.PostApiV1AccountsIdUnpinSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostApiV1AccountsIdUnpinResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PostApiV1AccountsIdUnpinRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/v1/accounts/{id}/unpin",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostApiV1AccountsIdUnpinSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "post",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostApiV1AccountsIdUnpinResponse =
        new operations.PostApiV1AccountsIdUnpinResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.relationship = utils.objectToClass(
              httpRes?.data,
              shared.Relationship
            );
          }
          break;
        case httpRes?.status == 401:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.error = utils.objectToClass(httpRes?.data, shared.ErrorT);
          }
          break;
        case httpRes?.status == 422:
          break;
      }

      return res;
    });
  }
}
