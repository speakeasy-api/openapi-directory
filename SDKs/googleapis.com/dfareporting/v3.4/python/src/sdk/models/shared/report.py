"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import activities as shared_activities
from ..shared import channelgrouping as shared_channelgrouping
from ..shared import customrichmediaevents as shared_customrichmediaevents
from ..shared import daterange as shared_daterange
from ..shared import dimensionvalue as shared_dimensionvalue
from ..shared import pathfilter as shared_pathfilter
from ..shared import recipient as shared_recipient
from ..shared import sorteddimension as shared_sorteddimension
from dataclasses_json import Undefined, dataclass_json
from datetime import date
from enum import Enum
from marshmallow import fields
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportCriteria:
    r"""The report criteria for a report of type \\"STANDARD\\"."""
    
    activities: Optional[shared_activities.Activities] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activities'), 'exclude': lambda f: f is None }})
    r"""Represents an activity group."""  
    custom_rich_media_events: Optional[shared_customrichmediaevents.CustomRichMediaEvents] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customRichMediaEvents'), 'exclude': lambda f: f is None }})
    r"""Represents a Custom Rich Media Events group."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    dimension_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensionFilters'), 'exclude': lambda f: f is None }})
    r"""The list of filters on which dimensions are filtered. Filters for different dimensions are ANDed, filters for the same dimension are grouped together and ORed."""  
    dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensions'), 'exclude': lambda f: f is None }})
    r"""The list of standard dimensions the report should include."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    
class ReportCrossDimensionReachCriteriaDimensionEnum(str, Enum):
    r"""The dimension option."""
    ADVERTISER = 'ADVERTISER'
    CAMPAIGN = 'CAMPAIGN'
    SITE_BY_ADVERTISER = 'SITE_BY_ADVERTISER'
    SITE_BY_CAMPAIGN = 'SITE_BY_CAMPAIGN'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportCrossDimensionReachCriteria:
    r"""The report criteria for a report of type \\"CROSS_DIMENSION_REACH\\"."""
    
    breakdown: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('breakdown'), 'exclude': lambda f: f is None }})
    r"""The list of dimensions the report should include."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    dimension: Optional[ReportCrossDimensionReachCriteriaDimensionEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimension'), 'exclude': lambda f: f is None }})
    r"""The dimension option."""  
    dimension_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensionFilters'), 'exclude': lambda f: f is None }})
    r"""The list of filters on which dimensions are filtered."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    overlap_metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('overlapMetricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of overlap metrics the report should include."""  
    pivoted: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pivoted'), 'exclude': lambda f: f is None }})
    r"""Whether the report is pivoted or not. Defaults to true."""  
    
class ReportDeliveryEmailOwnerDeliveryTypeEnum(str, Enum):
    r"""The type of delivery for the owner to receive, if enabled."""
    LINK = 'LINK'
    ATTACHMENT = 'ATTACHMENT'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportDelivery:
    r"""The report's email delivery settings."""
    
    email_owner: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emailOwner'), 'exclude': lambda f: f is None }})
    r"""Whether the report should be emailed to the report owner."""  
    email_owner_delivery_type: Optional[ReportDeliveryEmailOwnerDeliveryTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emailOwnerDeliveryType'), 'exclude': lambda f: f is None }})
    r"""The type of delivery for the owner to receive, if enabled."""  
    message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('message'), 'exclude': lambda f: f is None }})
    r"""The message to be sent with each email."""  
    recipients: Optional[list[shared_recipient.Recipient]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recipients'), 'exclude': lambda f: f is None }})
    r"""The list of recipients to which to email the report."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportFloodlightCriteriaReportProperties:
    r"""The properties of the report."""
    
    include_attributed_ip_conversions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includeAttributedIPConversions'), 'exclude': lambda f: f is None }})
    r"""Include conversions that have no cookie, but do have an exposure path."""  
    include_unattributed_cookie_conversions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includeUnattributedCookieConversions'), 'exclude': lambda f: f is None }})
    r"""Include conversions of users with a DoubleClick cookie but without an exposure. That means the user did not click or see an ad from the advertiser within the Floodlight group, or that the interaction happened outside the lookback window."""  
    include_unattributed_ip_conversions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includeUnattributedIPConversions'), 'exclude': lambda f: f is None }})
    r"""Include conversions that have no associated cookies and no exposures. It’s therefore impossible to know how the user was exposed to your ads during the lookback window prior to a conversion."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportFloodlightCriteria:
    r"""The report criteria for a report of type \\"FLOODLIGHT\\"."""
    
    custom_rich_media_events: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customRichMediaEvents'), 'exclude': lambda f: f is None }})
    r"""The list of custom rich media events to include."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    dimension_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensionFilters'), 'exclude': lambda f: f is None }})
    r"""The list of filters on which dimensions are filtered. Filters for different dimensions are ANDed, filters for the same dimension are grouped together and ORed."""  
    dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensions'), 'exclude': lambda f: f is None }})
    r"""The list of dimensions the report should include."""  
    floodlight_config_id: Optional[shared_dimensionvalue.DimensionValue] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('floodlightConfigId'), 'exclude': lambda f: f is None }})
    r"""Represents a DimensionValue resource."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    report_properties: Optional[ReportFloodlightCriteriaReportProperties] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reportProperties'), 'exclude': lambda f: f is None }})
    r"""The properties of the report."""  
    
class ReportFormatEnum(str, Enum):
    r"""The output format of the report. If not specified, default format is \\"CSV\\". Note that the actual format in the completed report file might differ if for instance the report's size exceeds the format's capabilities. \\"CSV\\" will then be the fallback format."""
    CSV = 'CSV'
    EXCEL = 'EXCEL'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportPathAttributionCriteria:
    r"""The report criteria for a report of type \\"PATH_ATTRIBUTION\\"."""
    
    activity_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activityFilters'), 'exclude': lambda f: f is None }})
    r"""The list of 'dfa:activity' values to filter on."""  
    custom_channel_grouping: Optional[shared_channelgrouping.ChannelGrouping] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customChannelGrouping'), 'exclude': lambda f: f is None }})
    r"""Represents a DfaReporting channel grouping."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensions'), 'exclude': lambda f: f is None }})
    r"""The list of dimensions the report should include."""  
    floodlight_config_id: Optional[shared_dimensionvalue.DimensionValue] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('floodlightConfigId'), 'exclude': lambda f: f is None }})
    r"""Represents a DimensionValue resource."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    path_filters: Optional[list[shared_pathfilter.PathFilter]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pathFilters'), 'exclude': lambda f: f is None }})
    r"""Path Filters."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportPathCriteria:
    r"""The report criteria for a report of type \\"PATH\\"."""
    
    activity_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activityFilters'), 'exclude': lambda f: f is None }})
    r"""The list of 'dfa:activity' values to filter on."""  
    custom_channel_grouping: Optional[shared_channelgrouping.ChannelGrouping] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customChannelGrouping'), 'exclude': lambda f: f is None }})
    r"""Represents a DfaReporting channel grouping."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensions'), 'exclude': lambda f: f is None }})
    r"""The list of dimensions the report should include."""  
    floodlight_config_id: Optional[shared_dimensionvalue.DimensionValue] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('floodlightConfigId'), 'exclude': lambda f: f is None }})
    r"""Represents a DimensionValue resource."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    path_filters: Optional[list[shared_pathfilter.PathFilter]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pathFilters'), 'exclude': lambda f: f is None }})
    r"""Path Filters."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportPathToConversionCriteriaReportProperties:
    r"""The properties of the report."""
    
    clicks_lookback_window: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('clicksLookbackWindow'), 'exclude': lambda f: f is None }})
    r"""CM360 checks to see if a click interaction occurred within the specified period of time before a conversion. By default the value is pulled from Floodlight or you can manually enter a custom value. Valid values: 1-90."""  
    impressions_lookback_window: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('impressionsLookbackWindow'), 'exclude': lambda f: f is None }})
    r"""CM360 checks to see if an impression interaction occurred within the specified period of time before a conversion. By default the value is pulled from Floodlight or you can manually enter a custom value. Valid values: 1-90."""  
    include_attributed_ip_conversions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includeAttributedIPConversions'), 'exclude': lambda f: f is None }})
    r"""Deprecated: has no effect."""  
    include_unattributed_cookie_conversions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includeUnattributedCookieConversions'), 'exclude': lambda f: f is None }})
    r"""Include conversions of users with a DoubleClick cookie but without an exposure. That means the user did not click or see an ad from the advertiser within the Floodlight group, or that the interaction happened outside the lookback window."""  
    include_unattributed_ip_conversions: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('includeUnattributedIPConversions'), 'exclude': lambda f: f is None }})
    r"""Include conversions that have no associated cookies and no exposures. It’s therefore impossible to know how the user was exposed to your ads during the lookback window prior to a conversion."""  
    maximum_click_interactions: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maximumClickInteractions'), 'exclude': lambda f: f is None }})
    r"""The maximum number of click interactions to include in the report. Advertisers currently paying for E2C reports get up to 200 (100 clicks, 100 impressions). If another advertiser in your network is paying for E2C, you can have up to 5 total exposures per report."""  
    maximum_impression_interactions: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maximumImpressionInteractions'), 'exclude': lambda f: f is None }})
    r"""The maximum number of click interactions to include in the report. Advertisers currently paying for E2C reports get up to 200 (100 clicks, 100 impressions). If another advertiser in your network is paying for E2C, you can have up to 5 total exposures per report."""  
    maximum_interaction_gap: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maximumInteractionGap'), 'exclude': lambda f: f is None }})
    r"""The maximum amount of time that can take place between interactions (clicks or impressions) by the same user. Valid values: 1-90."""  
    pivot_on_interaction_path: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pivotOnInteractionPath'), 'exclude': lambda f: f is None }})
    r"""Enable pivoting on interaction path."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportPathToConversionCriteria:
    r"""The report criteria for a report of type \\"PATH_TO_CONVERSION\\"."""
    
    activity_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activityFilters'), 'exclude': lambda f: f is None }})
    r"""The list of 'dfa:activity' values to filter on."""  
    conversion_dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conversionDimensions'), 'exclude': lambda f: f is None }})
    r"""The list of conversion dimensions the report should include."""  
    custom_floodlight_variables: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customFloodlightVariables'), 'exclude': lambda f: f is None }})
    r"""The list of custom floodlight variables the report should include."""  
    custom_rich_media_events: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customRichMediaEvents'), 'exclude': lambda f: f is None }})
    r"""The list of custom rich media events to include."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    floodlight_config_id: Optional[shared_dimensionvalue.DimensionValue] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('floodlightConfigId'), 'exclude': lambda f: f is None }})
    r"""Represents a DimensionValue resource."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    per_interaction_dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('perInteractionDimensions'), 'exclude': lambda f: f is None }})
    r"""The list of per interaction dimensions the report should include."""  
    report_properties: Optional[ReportPathToConversionCriteriaReportProperties] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reportProperties'), 'exclude': lambda f: f is None }})
    r"""The properties of the report."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportReachCriteria:
    r"""The report criteria for a report of type \\"REACH\\"."""
    
    activities: Optional[shared_activities.Activities] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('activities'), 'exclude': lambda f: f is None }})
    r"""Represents an activity group."""  
    custom_rich_media_events: Optional[shared_customrichmediaevents.CustomRichMediaEvents] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customRichMediaEvents'), 'exclude': lambda f: f is None }})
    r"""Represents a Custom Rich Media Events group."""  
    date_range: Optional[shared_daterange.DateRange] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dateRange'), 'exclude': lambda f: f is None }})
    r"""Represents a date range."""  
    dimension_filters: Optional[list[shared_dimensionvalue.DimensionValue]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensionFilters'), 'exclude': lambda f: f is None }})
    r"""The list of filters on which dimensions are filtered. Filters for different dimensions are ANDed, filters for the same dimension are grouped together and ORed."""  
    dimensions: Optional[list[shared_sorteddimension.SortedDimension]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dimensions'), 'exclude': lambda f: f is None }})
    r"""The list of dimensions the report should include."""  
    enable_all_dimension_combinations: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enableAllDimensionCombinations'), 'exclude': lambda f: f is None }})
    r"""Whether to enable all reach dimension combinations in the report. Defaults to false. If enabled, the date range of the report should be within the last 42 days."""  
    metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('metricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of metrics the report should include."""  
    reach_by_frequency_metric_names: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reachByFrequencyMetricNames'), 'exclude': lambda f: f is None }})
    r"""The list of names of Reach By Frequency metrics the report should include."""  
    
class ReportScheduleRepeatsOnWeekDaysEnum(str, Enum):
    SUNDAY = 'SUNDAY'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'

class ReportScheduleRunsOnDayOfMonthEnum(str, Enum):
    r"""Enum to define for \\"MONTHLY\\" scheduled reports whether reports should be repeated on the same day of the month as \\"startDate\\" or the same day of the week of the month. Example: If 'startDate' is Monday, April 2nd 2012 (2012-04-02), \\"DAY_OF_MONTH\\" would run subsequent reports on the 2nd of every Month, and \\"WEEK_OF_MONTH\\" would run subsequent reports on the first Monday of the month."""
    DAY_OF_MONTH = 'DAY_OF_MONTH'
    WEEK_OF_MONTH = 'WEEK_OF_MONTH'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ReportSchedule:
    r"""The report's schedule. Can only be set if the report's 'dateRange' is a relative date range and the relative date range is not \\"TODAY\\"."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})
    r"""Whether the schedule is active or not. Must be set to either true or false."""  
    every: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('every'), 'exclude': lambda f: f is None }})
    r"""Defines every how many days, weeks or months the report should be run. Needs to be set when \\"repeats\\" is either \\"DAILY\\", \\"WEEKLY\\" or \\"MONTHLY\\"."""  
    expiration_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('expirationDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    repeats: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('repeats'), 'exclude': lambda f: f is None }})
    r"""The interval for which the report is repeated. Note: - \\"DAILY\\" also requires field \\"every\\" to be set. - \\"WEEKLY\\" also requires fields \\"every\\" and \\"repeatsOnWeekDays\\" to be set. - \\"MONTHLY\\" also requires fields \\"every\\" and \\"runsOnDayOfMonth\\" to be set."""  
    repeats_on_week_days: Optional[list[ReportScheduleRepeatsOnWeekDaysEnum]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('repeatsOnWeekDays'), 'exclude': lambda f: f is None }})
    r"""List of week days \\"WEEKLY\\" on which scheduled reports should run."""  
    runs_on_day_of_month: Optional[ReportScheduleRunsOnDayOfMonthEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runsOnDayOfMonth'), 'exclude': lambda f: f is None }})
    r"""Enum to define for \\"MONTHLY\\" scheduled reports whether reports should be repeated on the same day of the month as \\"startDate\\" or the same day of the week of the month. Example: If 'startDate' is Monday, April 2nd 2012 (2012-04-02), \\"DAY_OF_MONTH\\" would run subsequent reports on the 2nd of every Month, and \\"WEEK_OF_MONTH\\" would run subsequent reports on the first Monday of the month."""  
    start_date: Optional[date] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('startDate'), 'encoder': utils.dateisoformat(True), 'decoder': utils.datefromisoformat, 'mm_field': fields.DateTime(format='iso'), 'exclude': lambda f: f is None }})  
    
class ReportTypeEnum(str, Enum):
    r"""The type of the report."""
    STANDARD = 'STANDARD'
    REACH = 'REACH'
    PATH_TO_CONVERSION = 'PATH_TO_CONVERSION'
    CROSS_DIMENSION_REACH = 'CROSS_DIMENSION_REACH'
    FLOODLIGHT = 'FLOODLIGHT'
    PATH = 'PATH'
    PATH_ATTRIBUTION = 'PATH_ATTRIBUTION'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class Report:
    r"""Represents a Report resource."""
    
    account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('accountId'), 'exclude': lambda f: f is None }})
    r"""The account ID to which this report belongs."""  
    criteria: Optional[ReportCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('criteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"STANDARD\\"."""  
    cross_dimension_reach_criteria: Optional[ReportCrossDimensionReachCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('crossDimensionReachCriteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"CROSS_DIMENSION_REACH\\"."""  
    delivery: Optional[ReportDelivery] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('delivery'), 'exclude': lambda f: f is None }})
    r"""The report's email delivery settings."""  
    etag: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('etag'), 'exclude': lambda f: f is None }})
    r"""The eTag of this response for caching purposes."""  
    file_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fileName'), 'exclude': lambda f: f is None }})
    r"""The filename used when generating report files for this report."""  
    floodlight_criteria: Optional[ReportFloodlightCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('floodlightCriteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"FLOODLIGHT\\"."""  
    format: Optional[ReportFormatEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('format'), 'exclude': lambda f: f is None }})
    r"""The output format of the report. If not specified, default format is \\"CSV\\". Note that the actual format in the completed report file might differ if for instance the report's size exceeds the format's capabilities. \\"CSV\\" will then be the fallback format."""  
    id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""The unique ID identifying this report resource."""  
    kind: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kind'), 'exclude': lambda f: f is None }})
    r"""The kind of resource this is, in this case dfareporting#report."""  
    last_modified_time: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModifiedTime'), 'exclude': lambda f: f is None }})
    r"""The timestamp (in milliseconds since epoch) of when this report was last modified."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""The name of the report."""  
    owner_profile_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ownerProfileId'), 'exclude': lambda f: f is None }})
    r"""The user profile id of the owner of this report."""  
    path_attribution_criteria: Optional[ReportPathAttributionCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pathAttributionCriteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"PATH_ATTRIBUTION\\"."""  
    path_criteria: Optional[ReportPathCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pathCriteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"PATH\\"."""  
    path_to_conversion_criteria: Optional[ReportPathToConversionCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('pathToConversionCriteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"PATH_TO_CONVERSION\\"."""  
    reach_criteria: Optional[ReportReachCriteria] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reachCriteria'), 'exclude': lambda f: f is None }})
    r"""The report criteria for a report of type \\"REACH\\"."""  
    schedule: Optional[ReportSchedule] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedule'), 'exclude': lambda f: f is None }})
    r"""The report's schedule. Can only be set if the report's 'dateRange' is a relative date range and the relative date range is not \\"TODAY\\"."""  
    sub_account_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subAccountId'), 'exclude': lambda f: f is None }})
    r"""The subaccount ID to which this report belongs if applicable."""  
    type: Optional[ReportTypeEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('type'), 'exclude': lambda f: f is None }})
    r"""The type of the report."""  
    