<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class ODWeather 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Get forecast and realtime information for known points<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\CompareStationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\CompareStationResponse
     */
	public function compareStation(
        \OpenAPI\OpenAPI\Models\Operations\CompareStationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\CompareStationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/compareStation/{stationName}/', \OpenAPI\OpenAPI\Models\Operations\CompareStationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\CompareStationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get data from the aemet stations<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetAemetStationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetAemetStationResponse
     */
	public function getAemetStation(
        \OpenAPI\OpenAPI\Models\Operations\GetAemetStationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetAemetStationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getAemetStation/{stationName}/{period}/', \OpenAPI\OpenAPI\Models\Operations\GetAemetStationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetAemetStationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get data from the easywind weather stations<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEasywindRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEasywindResponse
     */
	public function getEasywind(
        \OpenAPI\OpenAPI\Models\Operations\GetEasywindRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEasywindResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getEasyWind/{easywindId}/', \OpenAPI\OpenAPI\Models\Operations\GetEasywindRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetEasywindRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEasywindResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get stations in an event<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEventStationsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEventStationsResponse
     */
	public function getEventStations(
        \OpenAPI\OpenAPI\Models\Operations\GetEventStationsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEventStationsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getEventStations/{eventId}/', \OpenAPI\OpenAPI\Models\Operations\GetEventStationsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEventStationsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get forecast points of a yatchclub<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetForecastPointsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetForecastPointsResponse
     */
	public function getForecastPoints(
        \OpenAPI\OpenAPI\Models\Operations\GetForecastPointsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetForecastPointsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getForecastPoints/{yatchclubid}/language/{language}', \OpenAPI\OpenAPI\Models\Operations\GetForecastPointsRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetForecastPointsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get timeseries forecast information<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesResponse
     */
	public function getForecastTimeSeries(
        \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getForecastTimeSeries/{latitude}/{longitude}/', \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get timeseries forecast information<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfResponse
     */
	public function getForecastTimeSeriesWrf(
        \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getForecastTimeSeriesWrf/{latitude}/{longitude}/', \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetForecastTimeSeriesWrfResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get data from the socib bahia de palma buoy<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetSocibWeatherStationRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetSocibWeatherStationResponse
     */
	public function getSocibWeatherStation(
        \OpenAPI\OpenAPI\Models\Operations\GetSocibWeatherStationRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetSocibWeatherStationResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getSocibWeatherStation/{stationName}/{period}/', \OpenAPI\OpenAPI\Models\Operations\GetSocibWeatherStationRequest::class, $request);
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetSocibWeatherStationResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get data from the weather display software<br/>None
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayResponse
     */
	public function getWeatherDisplay(
        \OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getWeatherDisplay/{stationName}/', \OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayRequest::class, $request, null));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWeatherDisplayResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
	
    /**
     * Get forecast and realtime information for known points<br/>None
     * 
     * @return \OpenAPI\OpenAPI\Models\Operations\GetWebCamsResponse
     */
	public function getWebCams(
    ): \OpenAPI\OpenAPI\Models\Operations\GetWebCamsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1.0/getWebCams/');
        
        $options = ['http_errors' => false];
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetWebCamsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
        }

        return $response;
    }
}