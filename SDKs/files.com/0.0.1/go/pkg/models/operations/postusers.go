// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
	"time"
)

// PostUsersRequestBodyAuthenticationMethodEnum - How is this user authenticated?
type PostUsersRequestBodyAuthenticationMethodEnum string

const (
	PostUsersRequestBodyAuthenticationMethodEnumPassword                 PostUsersRequestBodyAuthenticationMethodEnum = "password"
	PostUsersRequestBodyAuthenticationMethodEnumUnusedFormerLdap         PostUsersRequestBodyAuthenticationMethodEnum = "unused_former_ldap"
	PostUsersRequestBodyAuthenticationMethodEnumSso                      PostUsersRequestBodyAuthenticationMethodEnum = "sso"
	PostUsersRequestBodyAuthenticationMethodEnumNone                     PostUsersRequestBodyAuthenticationMethodEnum = "none"
	PostUsersRequestBodyAuthenticationMethodEnumEmailSignup              PostUsersRequestBodyAuthenticationMethodEnum = "email_signup"
	PostUsersRequestBodyAuthenticationMethodEnumPasswordWithImportedHash PostUsersRequestBodyAuthenticationMethodEnum = "password_with_imported_hash"
)

func (e PostUsersRequestBodyAuthenticationMethodEnum) ToPointer() *PostUsersRequestBodyAuthenticationMethodEnum {
	return &e
}

func (e *PostUsersRequestBodyAuthenticationMethodEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "password":
		fallthrough
	case "unused_former_ldap":
		fallthrough
	case "sso":
		fallthrough
	case "none":
		fallthrough
	case "email_signup":
		fallthrough
	case "password_with_imported_hash":
		*e = PostUsersRequestBodyAuthenticationMethodEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PostUsersRequestBodyAuthenticationMethodEnum: %v", v)
	}
}

type PostUsersRequestBodyAvatarFile struct {
	AvatarFile string `multipartForm:"name=avatar_file"`
	Content    []byte `multipartForm:"content"`
}

// PostUsersRequestBodyRequire2faEnum - 2FA required setting
type PostUsersRequestBodyRequire2faEnum string

const (
	PostUsersRequestBodyRequire2faEnumUseSystemSetting PostUsersRequestBodyRequire2faEnum = "use_system_setting"
	PostUsersRequestBodyRequire2faEnumAlwaysRequire    PostUsersRequestBodyRequire2faEnum = "always_require"
	PostUsersRequestBodyRequire2faEnumNeverRequire     PostUsersRequestBodyRequire2faEnum = "never_require"
)

func (e PostUsersRequestBodyRequire2faEnum) ToPointer() *PostUsersRequestBodyRequire2faEnum {
	return &e
}

func (e *PostUsersRequestBodyRequire2faEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "use_system_setting":
		fallthrough
	case "always_require":
		fallthrough
	case "never_require":
		*e = PostUsersRequestBodyRequire2faEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PostUsersRequestBodyRequire2faEnum: %v", v)
	}
}

// PostUsersRequestBodySslRequiredEnum - SSL required setting
type PostUsersRequestBodySslRequiredEnum string

const (
	PostUsersRequestBodySslRequiredEnumUseSystemSetting PostUsersRequestBodySslRequiredEnum = "use_system_setting"
	PostUsersRequestBodySslRequiredEnumAlwaysRequire    PostUsersRequestBodySslRequiredEnum = "always_require"
	PostUsersRequestBodySslRequiredEnumNeverRequire     PostUsersRequestBodySslRequiredEnum = "never_require"
)

func (e PostUsersRequestBodySslRequiredEnum) ToPointer() *PostUsersRequestBodySslRequiredEnum {
	return &e
}

func (e *PostUsersRequestBodySslRequiredEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "use_system_setting":
		fallthrough
	case "always_require":
		fallthrough
	case "never_require":
		*e = PostUsersRequestBodySslRequiredEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PostUsersRequestBodySslRequiredEnum: %v", v)
	}
}

type PostUsersRequestBody struct {
	// A list of allowed IPs if applicable.  Newline delimited
	AllowedIps *string `multipartForm:"name=allowed_ips"`
	// Signifies that the user has read all the announcements in the UI.
	AnnouncementsRead *bool `multipartForm:"name=announcements_read"`
	// DEPRECATED: Can the user create Bundles (aka Share Links)? Use the bundle permission instead.
	AttachmentsPermission *bool `multipartForm:"name=attachments_permission"`
	// Scheduled Date/Time at which user will be deactivated
	AuthenticateUntil *time.Time `multipartForm:"name=authenticate_until"`
	// How is this user authenticated?
	AuthenticationMethod *PostUsersRequestBodyAuthenticationMethodEnum `multipartForm:"name=authentication_method"`
	// If true, the avatar will be deleted.
	AvatarDelete *bool `multipartForm:"name=avatar_delete"`
	// An image file for your user avatar.
	AvatarFile *PostUsersRequestBodyAvatarFile `multipartForm:"file"`
	// Allow this user to perform operations on the account, payments, and invoices?
	BillingPermission *bool `multipartForm:"name=billing_permission"`
	// Exempt this user from being disabled based on inactivity?
	BypassInactiveDisable *bool `multipartForm:"name=bypass_inactive_disable"`
	// Allow this user to skip site-wide IP blacklists?
	BypassSiteAllowedIps *bool `multipartForm:"name=bypass_site_allowed_ips"`
	// Used for changing a password on an existing user.
	ChangePassword *string `multipartForm:"name=change_password"`
	// Optional, but if provided, we will ensure that it matches the value sent in `change_password`.
	ChangePasswordConfirmation *string `multipartForm:"name=change_password_confirmation"`
	// User's company
	Company *string `multipartForm:"name=company"`
	// Can the user connect with WebDAV?
	DavPermission *bool `multipartForm:"name=dav_permission"`
	// Is user disabled? Disabled users cannot log in, and do not count for billing purposes.  Users can be automatically disabled after an inactivity period via a Site setting.
	Disabled *bool `multipartForm:"name=disabled"`
	// User's email.
	Email *string `multipartForm:"name=email"`
	// Can the user access with FTP/FTPS?
	FtpPermission *bool `multipartForm:"name=ftp_permission"`
	// Permission to grant on the user root.  Can be blank or `full`, `read`, `write`, `list`, `read+write`, or `list+write`
	GrantPermission *string `multipartForm:"name=grant_permission"`
	// Group ID to associate this user with.
	GroupID *int `multipartForm:"name=group_id"`
	// A list of group ids to associate this user with.  Comma delimited.
	GroupIds *string `multipartForm:"name=group_ids"`
	// Text to display to the user in the header of the UI
	HeaderText *string `multipartForm:"name=header_text"`
	// Pre-calculated hash of the user's password. If supplied, this will be used to authenticate the user on first login. Supported hash menthods are MD5, SHA1, and SHA256.
	ImportedPasswordHash *string `multipartForm:"name=imported_password_hash"`
	// Preferred language
	Language *string `multipartForm:"name=language"`
	// User's full name
	Name *string `multipartForm:"name=name"`
	// Any internal notes on the user
	Notes *string `multipartForm:"name=notes"`
	// Hour of the day at which daily notifications should be sent. Can be in range 0 to 23
	NotificationDailySendTime *int `multipartForm:"name=notification_daily_send_time"`
	// Enable integration with Office for the web?
	OfficeIntegrationEnabled *bool `multipartForm:"name=office_integration_enabled"`
	// User password.
	Password *string `multipartForm:"name=password"`
	// Optional, but if provided, we will ensure that it matches the value sent in `password`.
	PasswordConfirmation *string `multipartForm:"name=password_confirmation"`
	// Number of days to allow user to use the same password
	PasswordValidityDays *int `multipartForm:"name=password_validity_days"`
	// Should the user receive admin alerts such a certificate expiration notifications and overages?
	ReceiveAdminAlerts *bool `multipartForm:"name=receive_admin_alerts"`
	// 2FA required setting
	Require2fa *PostUsersRequestBodyRequire2faEnum `multipartForm:"name=require_2fa"`
	// Is a password change required upon next user login?
	RequirePasswordChange *bool `multipartForm:"name=require_password_change"`
	// Can this user access the REST API?
	RestapiPermission *bool `multipartForm:"name=restapi_permission"`
	// Does this user manage it's own credentials or is it a shared/bot user?
	SelfManaged *bool `multipartForm:"name=self_managed"`
	// Can the user access with SFTP?
	SftpPermission *bool `multipartForm:"name=sftp_permission"`
	// Is the user an administrator for this site?
	SiteAdmin *bool `multipartForm:"name=site_admin"`
	// Skip Welcome page in the UI?
	SkipWelcomeScreen *bool `multipartForm:"name=skip_welcome_screen"`
	// SSL required setting
	SslRequired *PostUsersRequestBodySslRequiredEnum `multipartForm:"name=ssl_required"`
	// SSO (Single Sign On) strategy ID for the user, if applicable.
	SsoStrategyID *int `multipartForm:"name=sso_strategy_id"`
	// Is the user subscribed to the newsletter?
	SubscribeToNewsletter *bool `multipartForm:"name=subscribe_to_newsletter"`
	// User time zone
	TimeZone *string `multipartForm:"name=time_zone"`
	// Root folder for FTP (and optionally SFTP if the appropriate site-wide setting is set.)  Note that this is not used for API, Desktop, or Web interface.
	UserRoot *string `multipartForm:"name=user_root"`
	// User's username
	Username *string `multipartForm:"name=username"`
}

type PostUsersResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// The Users object.
	UserEntity *shared.UserEntity
}
