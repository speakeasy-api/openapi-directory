// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum - Type of the origin
type CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum string

const (
	CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnumIndependent CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum = "independent"
	CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnumInternet    CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum = "internet"
)

func (e CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum) ToPointer() *CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum {
	return &e
}

func (e *CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "independent":
		fallthrough
	case "internet":
		*e = CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum: %v", v)
	}
}

// CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOrigin - The origin of the prefix
type CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOrigin struct {
	// Interfaces associated with the prefix
	Interfaces []string `json:"interfaces,omitempty"`
	// Type of the origin
	Type CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOriginTypeEnum `json:"type"`
}

type CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignments struct {
	// Auto assign a /64 prefix from the origin to the VLAN
	Autonomous *bool `json:"autonomous,omitempty"`
	// The origin of the prefix
	Origin *CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignmentsOrigin `json:"origin,omitempty"`
	// Manual configuration of the IPv6 Appliance IP
	StaticApplianceIp6 *string `json:"staticApplianceIp6,omitempty"`
	// Manual configuration of a /64 prefix on the VLAN
	StaticPrefix *string `json:"staticPrefix,omitempty"`
}

// CreateNetworkApplianceVlanRequestBodyIpv6 - IPv6 configuration on the VLAN
type CreateNetworkApplianceVlanRequestBodyIpv6 struct {
	// Enable IPv6 on VLAN.
	Enabled *bool `json:"enabled,omitempty"`
	// Prefix assignments on the VLAN
	PrefixAssignments []CreateNetworkApplianceVlanRequestBodyIpv6PrefixAssignments `json:"prefixAssignments,omitempty"`
}

// CreateNetworkApplianceVlanRequestBodyMandatoryDhcp - Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
type CreateNetworkApplianceVlanRequestBodyMandatoryDhcp struct {
	// Enable Mandatory DHCP on VLAN.
	Enabled *bool `json:"enabled,omitempty"`
}

// CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum - Type of subnetting of the VLAN. Applicable only for template network.
type CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum string

const (
	CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnumSame   CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum = "same"
	CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnumUnique CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum = "unique"
)

func (e CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum) ToPointer() *CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum {
	return &e
}

func (e *CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "same":
		fallthrough
	case "unique":
		*e = CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum: %v", v)
	}
}

type CreateNetworkApplianceVlanRequestBody struct {
	// The local IP of the appliance on the VLAN
	ApplianceIP *string `json:"applianceIp,omitempty"`
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr *string `json:"cidr,omitempty"`
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyID *string `json:"groupPolicyId,omitempty"`
	// The VLAN ID of the new VLAN (must be between 1 and 4094)
	ID string `json:"id"`
	// IPv6 configuration on the VLAN
	Ipv6 *CreateNetworkApplianceVlanRequestBodyIpv6 `json:"ipv6,omitempty"`
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp *CreateNetworkApplianceVlanRequestBodyMandatoryDhcp `json:"mandatoryDhcp,omitempty"`
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask *int64 `json:"mask,omitempty"`
	// The name of the new VLAN
	Name string `json:"name"`
	// The subnet of the VLAN
	Subnet *string `json:"subnet,omitempty"`
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType *CreateNetworkApplianceVlanRequestBodyTemplateVlanTypeEnum `json:"templateVlanType,omitempty"`
}

type CreateNetworkApplianceVlanRequest struct {
	RequestBody CreateNetworkApplianceVlanRequestBody `request:"mediaType=application/json"`
	NetworkID   string                                `pathParam:"style=simple,explode=false,name=networkId"`
}

// CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum - Type of the origin
type CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum string

const (
	CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnumIndependent CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum = "independent"
	CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnumInternet    CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum = "internet"
)

func (e CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum) ToPointer() *CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum {
	return &e
}

func (e *CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "independent":
		fallthrough
	case "internet":
		*e = CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum: %v", v)
	}
}

// CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOrigin - The origin of the prefix
type CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOrigin struct {
	// Interfaces associated with the prefix
	Interfaces []string `json:"interfaces,omitempty"`
	// Type of the origin
	Type *CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOriginTypeEnum `json:"type,omitempty"`
}

type CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignments struct {
	// Auto assign a /64 prefix from the origin to the VLAN
	Autonomous *bool `json:"autonomous,omitempty"`
	// The origin of the prefix
	Origin *CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignmentsOrigin `json:"origin,omitempty"`
	// Manual configuration of the IPv6 Appliance IP
	StaticApplianceIp6 *string `json:"staticApplianceIp6,omitempty"`
	// Manual configuration of a /64 prefix on the VLAN
	StaticPrefix *string `json:"staticPrefix,omitempty"`
}

// CreateNetworkApplianceVlan201ApplicationJSONIpv6 - IPv6 configuration on the VLAN
type CreateNetworkApplianceVlan201ApplicationJSONIpv6 struct {
	// Enable IPv6 on VLAN
	Enabled *bool `json:"enabled,omitempty"`
	// Prefix assignments on the VLAN
	PrefixAssignments []CreateNetworkApplianceVlan201ApplicationJSONIpv6PrefixAssignments `json:"prefixAssignments,omitempty"`
}

// CreateNetworkApplianceVlan201ApplicationJSONMandatoryDhcp - Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
type CreateNetworkApplianceVlan201ApplicationJSONMandatoryDhcp struct {
	// Enable Mandatory DHCP on VLAN.
	Enabled *bool `json:"enabled,omitempty"`
}

// CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum - Type of subnetting of the VLAN. Applicable only for template network.
type CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum string

const (
	CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnumSame   CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum = "same"
	CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnumUnique CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum = "unique"
)

func (e CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum) ToPointer() *CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum {
	return &e
}

func (e *CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "same":
		fallthrough
	case "unique":
		*e = CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum: %v", v)
	}
}

// CreateNetworkApplianceVlan201ApplicationJSON - Successful operation
type CreateNetworkApplianceVlan201ApplicationJSON struct {
	// The local IP of the appliance on the VLAN
	ApplianceIP *string `json:"applianceIp,omitempty"`
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr *string `json:"cidr,omitempty"`
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyID *string `json:"groupPolicyId,omitempty"`
	// The VLAN ID of the VLAN
	ID *string `json:"id,omitempty"`
	// The interface ID of the VLAN
	InterfaceID *string `json:"interfaceId,omitempty"`
	// IPv6 configuration on the VLAN
	Ipv6 *CreateNetworkApplianceVlan201ApplicationJSONIpv6 `json:"ipv6,omitempty"`
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp *CreateNetworkApplianceVlan201ApplicationJSONMandatoryDhcp `json:"mandatoryDhcp,omitempty"`
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask *int64 `json:"mask,omitempty"`
	// The name of the VLAN
	Name *string `json:"name,omitempty"`
	// The subnet of the VLAN
	Subnet *string `json:"subnet,omitempty"`
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType *CreateNetworkApplianceVlan201ApplicationJSONTemplateVlanTypeEnum `json:"templateVlanType,omitempty"`
}

type CreateNetworkApplianceVlanResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	CreateNetworkApplianceVlan201ApplicationJSONObject *CreateNetworkApplianceVlan201ApplicationJSON
}
