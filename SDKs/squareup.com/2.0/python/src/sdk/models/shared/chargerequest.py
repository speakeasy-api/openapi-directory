"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import additionalrecipient as shared_additionalrecipient
from ..shared import address as shared_address
from ..shared import money as shared_money
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ChargeRequest:
    r"""Defines the parameters that can be included in the body of
    a request to the [Charge](https://developer.squareup.com/reference/square_2021-08-18/transactions-api/charge) endpoint.
    
    Deprecated - recommend using [CreatePayment](https://developer.squareup.com/reference/square_2021-08-18/payments-api/create-payment)
    """
    
    amount_money: shared_money.Money = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('amount_money') }})
    r"""Represents an amount of money. `Money` fields can be signed or unsigned.
    Fields that do not explicitly define whether they are signed or unsigned are
    considered unsigned and can only hold positive amounts. For signed fields, the
    sign of the value indicates the purpose of the money transfer. See
    [Working with Monetary Amounts](https://developer.squareup.com/docs/build-basics/working-with-monetary-amounts)
    for more information.
    """  
    idempotency_key: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('idempotency_key') }})
    r"""A value you specify that uniquely identifies this
    transaction among transactions you've created.
    
    If you're unsure whether a particular transaction succeeded,
    you can reattempt it with the same idempotency key without
    worrying about double-charging the buyer.
    
    See [Idempotency keys](https://developer.squareup.com/docs/working-with-apis/idempotency) for more information.
    """  
    additional_recipients: Optional[list[shared_additionalrecipient.AdditionalRecipient]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('additional_recipients'), 'exclude': lambda f: f is None }})
    r"""The basic primitive of multi-party transaction. The value is optional.
    The transaction facilitated by you can be split from here.
    
    If you provide this value, the `amount_money` value in your additional_recipients
    must not be more than 90% of the `amount_money` value in the charge request.
    The `location_id` must be the valid location of the app owner merchant.
    
    This field requires the `PAYMENTS_WRITE_ADDITIONAL_RECIPIENTS` OAuth permission.
    
    This field is currently not supported in sandbox.
    """  
    billing_address: Optional[shared_address.Address] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('billing_address'), 'exclude': lambda f: f is None }})
    r"""Represents a postal address in a country. The address format is based
    on an [open-source library from Google](https://github.com/google/libaddressinput). For more information, 
    see [AddressValidationMetadata](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata). 
    This format has dedicated fields for four address components: postal code, 
    locality (city), administrative district (state, prefecture, or province), and 
    sublocality (town or village). These components have dedicated fields in the 
    `Address` object because software sometimes behaves differently based on them. 
    For example, sales tax software may charge different amounts of sales tax 
    based on the postal code, and some software is only available in 
    certain states due to compliance reasons.
    
    For the remaining address components, the `Address` type provides the 
    `address_line_1` and `address_line_2` fields for free-form data entry. 
    These fields are free-form because the remaining address components have 
    too many variations around the world and typical software does not parse 
    these components. These fields enable users to enter anything they want. 
    
    Note that, in the current implementation, all other `Address` type fields are blank. 
    These include `address_line_3`, `sublocality_2`, `sublocality_3`, 
    `administrative_district_level_2`, `administrative_district_level_3`, 
    `first_name`, `last_name`, and `organization`. 
    
    When it comes to localization, the seller's language preferences 
    (see [Language preferences](https://developer.squareup.com/docs/locations-api#location-specific-and-seller-level-language-preferences)) 
    are ignored for addresses. Even though Square products (such as Square Point of Sale 
    and the Seller Dashboard) mostly use a seller's language preference in 
    communication, when it comes to addresses, they will use English for a US address, 
    Japanese for an address in Japan, and so on.
    """  
    buyer_email_address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('buyer_email_address'), 'exclude': lambda f: f is None }})
    r"""The buyer's email address, if available. This value is optional,
    but this transaction is ineligible for chargeback protection if it is not
    provided.
    """  
    card_nonce: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('card_nonce'), 'exclude': lambda f: f is None }})
    r"""A payment token generated from the [Card.tokenize()](https://developer.squareup.com/reference/sdks/web/payments/objects/Card#Card.tokenize) that represents the card
    to charge.
    
    The application that provides a payment token to this endpoint must be the
    _same application_ that generated the payment token with the Web Payments SDK.
    Otherwise, the nonce is invalid.
    
    Do not provide a value for this field if you provide a value for
    `customer_card_id`.
    """  
    customer_card_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customer_card_id'), 'exclude': lambda f: f is None }})
    r"""The ID of the customer card on file to charge. Do
    not provide a value for this field if you provide a value for `card_nonce`.
    
    If you provide this value, you _must_ also provide a value for
    `customer_id`.
    """  
    customer_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('customer_id'), 'exclude': lambda f: f is None }})
    r"""The ID of the customer to associate this transaction with. This field
    is required if you provide a value for `customer_card_id`, and optional
    otherwise.
    """  
    delay_capture: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('delay_capture'), 'exclude': lambda f: f is None }})
    r"""If `true`, the request will only perform an Auth on the provided
    card. You can then later perform either a Capture (with the
    [CaptureTransaction](https://developer.squareup.com/reference/square_2021-08-18/transactions-api/capture-transaction) endpoint) or a Void
    (with the [VoidTransaction](https://developer.squareup.com/reference/square_2021-08-18/transactions-api/void-transaction) endpoint).
    
    Default value: `false`
    """  
    note: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('note'), 'exclude': lambda f: f is None }})
    r"""An optional note to associate with the transaction.
    
    This value cannot exceed 60 characters.
    """  
    order_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('order_id'), 'exclude': lambda f: f is None }})
    r"""The ID of the order to associate with this transaction.
    
    If you provide this value, the `amount_money` value of your request must
    __exactly match__ the value of the order's `total_money` field.
    """  
    reference_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reference_id'), 'exclude': lambda f: f is None }})
    r"""An optional ID you can associate with the transaction for your own
    purposes (such as to associate the transaction with an entity ID in your
    own database).
    
    This value cannot exceed 40 characters.
    """  
    shipping_address: Optional[shared_address.Address] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('shipping_address'), 'exclude': lambda f: f is None }})
    r"""Represents a postal address in a country. The address format is based
    on an [open-source library from Google](https://github.com/google/libaddressinput). For more information, 
    see [AddressValidationMetadata](https://github.com/google/libaddressinput/wiki/AddressValidationMetadata). 
    This format has dedicated fields for four address components: postal code, 
    locality (city), administrative district (state, prefecture, or province), and 
    sublocality (town or village). These components have dedicated fields in the 
    `Address` object because software sometimes behaves differently based on them. 
    For example, sales tax software may charge different amounts of sales tax 
    based on the postal code, and some software is only available in 
    certain states due to compliance reasons.
    
    For the remaining address components, the `Address` type provides the 
    `address_line_1` and `address_line_2` fields for free-form data entry. 
    These fields are free-form because the remaining address components have 
    too many variations around the world and typical software does not parse 
    these components. These fields enable users to enter anything they want. 
    
    Note that, in the current implementation, all other `Address` type fields are blank. 
    These include `address_line_3`, `sublocality_2`, `sublocality_3`, 
    `administrative_district_level_2`, `administrative_district_level_3`, 
    `first_name`, `last_name`, and `organization`. 
    
    When it comes to localization, the seller's language preferences 
    (see [Language preferences](https://developer.squareup.com/docs/locations-api#location-specific-and-seller-level-language-preferences)) 
    are ignored for addresses. Even though Square products (such as Square Point of Sale 
    and the Seller Dashboard) mostly use a seller's language preference in 
    communication, when it comes to addresses, they will use English for a US address, 
    Japanese for an address in Japan, and so on.
    """  
    verification_token: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('verification_token'), 'exclude': lambda f: f is None }})
    r"""A token generated by SqPaymentForm's verifyBuyer() that represents
    customer's device info and 3ds challenge result.
    """  
    