<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class PaymentsAPI 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Get estimated price
     * 
     * This is a method for calculating the approximate price in cryptocurrency for a given value in Fiat currency. You will need to provide the initial cost in the Fiat currency (amount, currency_from) and the necessary cryptocurrency (currency_to)
     * Currently following fiat currencies are available: usd, eur, nzd, brl, gbp.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetEstimatedPriceRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetEstimatedPriceResponse
     */
	public function getEstimatedPrice(
        \OpenAPI\OpenAPI\Models\Operations\GetEstimatedPriceRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetEstimatedPriceResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/estimate');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetEstimatedPriceRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetEstimatedPriceResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getEstimatedPrice200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetEstimatedPrice200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get list of payments
     * 
     * Returns the entire list of all transactions, created with certain API key.
     * The list of optional parameters:
     * - limit - number of records in one page. (possible values: from 1 to 500)
     * - page - the page number you want to get (possible values: from 0 to **page count - 1**)
     * - sortBy - sort the received list by a paramenter. Set to **created_at** by default (possible values: payment_id, payment_status, pay_address, price_amount, price_currency, pay_amount, actually_paid, pay_currency, order_id, order_description, purchase_id, outcome_amount, outcome_currency)
     * - orderBy - display the list in ascending or descending order. Set to **asc** by default (possible values: asc, desc)
     * - dateFrom - select the displayed period start date (date format: YYYY-MM-DD or yy-MM-ddTHH:mm:ss.SSSZ).
     * - dateTo - select the displayed period end date (date format: YYYY-MM-DD or yy-MM-ddTHH:mm:ss.SSSZ).
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetListOfPaymentsRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetListOfPaymentsResponse
     */
	public function getListOfPayments(
        \OpenAPI\OpenAPI\Models\Operations\GetListOfPaymentsRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetListOfPaymentsResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/payment/');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetListOfPaymentsRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetListOfPaymentsResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getListOfPayments200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetListOfPayments200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get payment status
     * 
     * Get the actual information about the payment. You need to provide the ID of the payment in the request.
     * 
     * NOTE! You should make the get payment status request with the same API key that you used in the create payment request.
     * Here is the list of avalable statuses:
     * - waiting - waiting for the customer to send the payment. The initial status of each payment.
     * - confirming - the transaction is being processed on the blockchain. Appears when NOWPayments detect the funds from the user on the blockchain.
     * - confirmed -  the process is confirmed by the blockchain. Customer’s funds have accumulated enough confirmations.
     * - sending - the funds are being sent to your personal wallet. We are in the process of sending the funds to you.
     * - partially_paid -  it shows that the customer sent the less than the actual price. Appears when the funds have arrived in your wallet.
     * - finished - the funds have reached your personal address and the payment is finished.
     * - failed -  the payment wasn't completed due to the error of some kind.
     * - refunded -  the funds were refunded back to the user.
     * - expired - the user didn't send the funds to the specified address in the 24 hour time window.
     * 
     * Additional info:
     * - outcome_amount - this parameter shows the amount that will be (or is already) received on your Outcome Wallet once the transaction is settled.
     * - outcome_currency - this parameter shows the currency in which the transaction will be settled.
     * - invoice_id - this parameter shows invoice ID from which the payment was created
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetPaymentStatusRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetPaymentStatusResponse
     */
	public function getPaymentStatus(
        \OpenAPI\OpenAPI\Models\Operations\GetPaymentStatusRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetPaymentStatusResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/payment/{payment_id}', \OpenAPI\OpenAPI\Models\Operations\GetPaymentStatusRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetPaymentStatusResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getPaymentStatus200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetPaymentStatus200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get the minimum payment amount
     * 
     * Get the minimum payment amount for a specific pair.
     * 
     * You can provide both currencies in the pair or just currency\_from, and we will calculate the minimum payment amount for currency\_from and currency which you have specified as the outcome in the Store Settings.
     * 
     * You can also specify one of the fiat currencies in the currency\_from. In this case, the minimum payment will be calculated in this fiat currency.
     * 
     * You can also add field fiat\_equivalent (optional field) to get the fiat equivalent of the minimum amount.
     * 
     * In the case of several outcome wallets we will calculate the minimum amount in the same way we route your payment to a specific wallet.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmountRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmountResponse
     */
	public function getTheMinimumPaymentAmount(
        \OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmountRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmountResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/min-amount');
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmountRequest::class, $request, null));
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('GET', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmountResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getTheMinimumPaymentAmount200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetTheMinimumPaymentAmount200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Get/Update payment estimate
     * 
     * This endpoint is required to get the current estimate on the payment, and update the current estimate.  
     * Please note! Calling this estimate before `expiration_estimate_date` will return the current estimate, it won’t be updated.
     * 
     * `:id` \- payment ID, for which you want to get the estimate
     * 
     * Response:  
     * `id` \- payment ID  
     * `token_id` - id of api key used to create this payment (please discard this parameter)  
     * `pay_amount` - payment estimate, the exact amount the user will have to send to complete the payment  
     * `expiration_estimate_date` - expiration date of this estimate
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimateRequest $request
     * @return \OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimateResponse
     */
	public function getUpdatePaymentEstimate(
        \OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimateRequest $request,
    ): \OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimateResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/payment/{id}/update-merchant-estimate', \OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimateRequest::class, $request);
        
        $options = ['http_errors' => false];
        $options = array_merge_recursive($options, Utils\Utils::getHeaders($request));
        
        $httpResponse = $this->_defaultClient->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimateResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            $response->headers = $httpResponse->getHeaders();
            
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->getUpdatePaymentEstimate200ApplicationJSONObject = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Operations\GetUpdatePaymentEstimate200ApplicationJSON', 'json');
            }
        }

        return $response;
    }
}