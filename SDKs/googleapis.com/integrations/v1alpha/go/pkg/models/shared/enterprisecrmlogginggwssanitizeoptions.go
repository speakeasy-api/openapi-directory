// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum string

const (
	EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnumLogTypeUnspecified EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum = "LOG_TYPE_UNSPECIFIED"
	EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnumGws                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum = "GWS"
	EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnumGts                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum = "GTS"
	EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnumAll                EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum = "ALL"
)

func (e *EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "LOG_TYPE_UNSPECIFIED":
		fallthrough
	case "GWS":
		fallthrough
	case "GTS":
		fallthrough
	case "ALL":
		*e = EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum: %s", s)
	}
}

type EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum string

const (
	EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnumPrivacyTypeUnspecified EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum = "PRIVACY_TYPE_UNSPECIFIED"
	EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnumNotPii                 EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum = "NOT_PII"
	EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnumPii                    EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum = "PII"
	EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnumSpii                   EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum = "SPII"
	EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnumUnsure                 EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum = "UNSURE"
)

func (e *EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "PRIVACY_TYPE_UNSPECIFIED":
		fallthrough
	case "NOT_PII":
		fallthrough
	case "PII":
		fallthrough
	case "SPII":
		fallthrough
	case "UNSURE":
		*e = EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum: %s", s)
	}
}

type EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum string

const (
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumSanitizeTypeUnspecified    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "SANITIZE_TYPE_UNSPECIFIED"
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumScrub                      EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "SCRUB"
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumAnonymize                  EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "ANONYMIZE"
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumAnonymizeLimitedRepeatable EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "ANONYMIZE_LIMITED_REPEATABLE"
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumObfuscate                  EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "OBFUSCATE"
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumEncrypt                    EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "ENCRYPT"
	EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnumDoNotSanitize              EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum = "DO_NOT_SANITIZE"
)

func (e *EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "SANITIZE_TYPE_UNSPECIFIED":
		fallthrough
	case "SCRUB":
		fallthrough
	case "ANONYMIZE":
		fallthrough
	case "ANONYMIZE_LIMITED_REPEATABLE":
		fallthrough
	case "OBFUSCATE":
		fallthrough
	case "ENCRYPT":
		fallthrough
	case "DO_NOT_SANITIZE":
		*e = EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum: %s", s)
	}
}

// EnterpriseCrmLoggingGwsSanitizeOptions - Identifies whether a field contains, or may contain, PII or sensitive data, and how to sanitize the field if it does. If a field's privacy type cannot be determined then it is sanitized (e.g., scrubbed). The specific sanitizer implementation is determined by run-time configuration and environment options (e.g., prod vs. qa). next_id: 5
type EnterpriseCrmLoggingGwsSanitizeOptions struct {
	// If true, the value has already been sanitized and needs no further sanitization. For instance, a D3 customer id is already an obfuscated entity and *might not* need further sanitization.
	IsAlreadySanitized *bool `json:"isAlreadySanitized,omitempty"`
	// To which type(s) of logs the sanitize options apply.
	LogType      []EnterpriseCrmLoggingGwsSanitizeOptionsLogTypeEnum     `json:"logType,omitempty"`
	Privacy      *EnterpriseCrmLoggingGwsSanitizeOptionsPrivacyEnum      `json:"privacy,omitempty"`
	SanitizeType *EnterpriseCrmLoggingGwsSanitizeOptionsSanitizeTypeEnum `json:"sanitizeType,omitempty"`
}
