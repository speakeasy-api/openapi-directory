"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import localtimerestriction as shared_localtimerestriction
from ..shared import media as shared_media
from ..shared import schedule as shared_schedule
from ..shared import textrecipient as shared_textrecipient
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class TextBroadcastBigMessageStrategyEnum(str, Enum):
    r"""If message length exceeds 160 characters, multiple messages will be sent, SEND_MULTIPLE strategy is chosen by default. Available values: SEND_MULTIPLE - send text as multiple messages, DO_NOT_SEND - do not send text if it exceeds 160 characters, TRIM - trims text message to 160 characters"""
    SEND_MULTIPLE = 'SEND_MULTIPLE'
    DO_NOT_SEND = 'DO_NOT_SEND'
    TRIM = 'TRIM'
    MMS = 'MMS'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class TextBroadcastInput:
    r"""A text campaign allows you to send a text message to a number of recipients. It supports scheduling, retry logic and pattern-based messages"""
    
    big_message_strategy: Optional[TextBroadcastBigMessageStrategyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bigMessageStrategy'), 'exclude': lambda f: f is None }})
    r"""If message length exceeds 160 characters, multiple messages will be sent, SEND_MULTIPLE strategy is chosen by default. Available values: SEND_MULTIPLE - send text as multiple messages, DO_NOT_SEND - do not send text if it exceeds 160 characters, TRIM - trims text message to 160 characters"""  
    from_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromNumber'), 'exclude': lambda f: f is None }})
    r"""A phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076, etc"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""A unique id of a broadcast"""  
    labels: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""A labels of a broadcast"""  
    local_time_restriction: Optional[shared_localtimerestriction.LocalTimeRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('localTimeRestriction'), 'exclude': lambda f: f is None }})
    r"""Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number"""  
    max_active: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxActive'), 'exclude': lambda f: f is None }})
    r"""A maximum number of texts that CallFire dials at once"""  
    media: Optional[list[shared_media.Media]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('media'), 'exclude': lambda f: f is None }})
    r"""~"""  
    message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('message'), 'exclude': lambda f: f is None }})
    r"""A text message"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""A name of a broadcast"""  
    recipients: Optional[list[shared_textrecipient.TextRecipient]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recipients'), 'exclude': lambda f: f is None }})
    r"""Recipients of a text campaign, can be an existing contacts or a new one"""  
    resume_next_day: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resumeNextDay'), 'exclude': lambda f: f is None }})
    r"""~"""  
    schedules: Optional[list[shared_schedule.Schedule]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedules'), 'exclude': lambda f: f is None }})
    r"""~"""  
    
class TextBroadcastStatusEnum(str, Enum):
    r"""A status of a broadcast. SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived"""
    TEST = 'TEST'
    SETUP = 'SETUP'
    START_PENDING = 'START_PENDING'
    RUNNING = 'RUNNING'
    SCHEDULED = 'SCHEDULED'
    STOPPED = 'STOPPED'
    SUSPENDED = 'SUSPENDED'
    FINISHED = 'FINISHED'
    ARCHIVED = 'ARCHIVED'
    VALIDATING_START = 'VALIDATING_START'
    VALIDATING_EMAIL = 'VALIDATING_EMAIL'
    BLOCKED_SUSPICIOUS = 'BLOCKED_SUSPICIOUS'
    DECLINED = 'DECLINED'
    APPROVED = 'APPROVED'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class TextBroadcast:
    r"""A text campaign allows you to send a text message to a number of recipients. It supports scheduling, retry logic and pattern-based messages"""
    
    big_message_strategy: Optional[TextBroadcastBigMessageStrategyEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('bigMessageStrategy'), 'exclude': lambda f: f is None }})
    r"""If message length exceeds 160 characters, multiple messages will be sent, SEND_MULTIPLE strategy is chosen by default. Available values: SEND_MULTIPLE - send text as multiple messages, DO_NOT_SEND - do not send text if it exceeds 160 characters, TRIM - trims text message to 160 characters"""  
    from_number: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fromNumber'), 'exclude': lambda f: f is None }})
    r"""A phone number in E.164 format (11-digit) or short code. Example: 12132000384, 67076, etc"""  
    id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id'), 'exclude': lambda f: f is None }})
    r"""A unique id of a broadcast"""  
    labels: Optional[list[str]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('labels'), 'exclude': lambda f: f is None }})
    r"""A labels of a broadcast"""  
    last_modified: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('lastModified'), 'exclude': lambda f: f is None }})
    r"""A time when the given resource was updated, formatted in unix time milliseconds (read only). Example: 1473781817000"""  
    local_time_restriction: Optional[shared_localtimerestriction.LocalTimeRestriction] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('localTimeRestriction'), 'exclude': lambda f: f is None }})
    r"""Represents a range of time during which CallFire will send a call or text to recipients. Timeframe uses the local timezone of recipient's number"""  
    max_active: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('maxActive'), 'exclude': lambda f: f is None }})
    r"""A maximum number of texts that CallFire dials at once"""  
    media: Optional[list[shared_media.Media]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('media'), 'exclude': lambda f: f is None }})
    r"""~"""  
    message: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('message'), 'exclude': lambda f: f is None }})
    r"""A text message"""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""A name of a broadcast"""  
    recipients: Optional[list[shared_textrecipient.TextRecipient]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('recipients'), 'exclude': lambda f: f is None }})
    r"""Recipients of a text campaign, can be an existing contacts or a new one"""  
    resume_next_day: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('resumeNextDay'), 'exclude': lambda f: f is None }})
    r"""~"""  
    schedules: Optional[list[shared_schedule.Schedule]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('schedules'), 'exclude': lambda f: f is None }})
    r"""~"""  
    status: Optional[TextBroadcastStatusEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('status'), 'exclude': lambda f: f is None }})
    r"""A status of a broadcast. SETUP - campaign isn't configured yet; START_PENDING - waiting for contact batch population; RUNNING - campaign is running; STOPPED - campaign is stopped; FINISHED - campaign is finished; ARCHIVED - campaign was archived"""  
    