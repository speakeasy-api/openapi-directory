"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import gherror as shared_gherror
from ..shared import routeresponse as shared_routeresponse
from ..shared import vehicleprofileid_enum as shared_vehicleprofileid_enum
from enum import Enum
from typing import Optional

class GetRouteAlgorithmEnum(str, Enum):
    r"""Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
    With `alternative_route`, we give you not one but several routes that are close to optimal, but
    not too similar to each other. 
    With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
    a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
    You can control both of these features with additional parameters, see below.
    """
    ROUND_TRIP = 'round_trip'
    ALTERNATIVE_ROUTE = 'alternative_route'

class GetRouteCurbsideEnum(str, Enum):
    ANY = 'any'
    RIGHT = 'right'
    LEFT = 'left'


@dataclasses.dataclass
class GetRouteRequest:
    
    point: list[str] = dataclasses.field(metadata={'query_param': { 'field_name': 'point', 'style': 'form', 'explode': True }})
    r"""The points for which the route should be calculated. Format: `[latitude,longitude]`. Specify at least an origin and a destination. Via points are possible.
    The maximum number depends on your plan.
    """  
    algorithm: Optional[GetRouteAlgorithmEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'algorithm', 'style': 'form', 'explode': True }})
    r"""Rather than looking for the shortest or fastest path, this parameter lets you solve two different problems related to routing:
    With `alternative_route`, we give you not one but several routes that are close to optimal, but
    not too similar to each other. 
    With `round_trip`, the route will get you back to where you started. This is meant for fun (think of
    a bike trip), so we will add some randomness. The `round_trip` option requires `ch.disable=true`.
    You can control both of these features with additional parameters, see below.
    """  
    alternative_route_max_paths: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'alternative_route.max_paths', 'style': 'form', 'explode': True }})
    r"""If `algorithm=alternative_route`, this parameter sets the number of maximum paths which should be calculated. Increasing can lead to worse alternatives."""  
    alternative_route_max_share_factor: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'alternative_route.max_share_factor', 'style': 'form', 'explode': True }})
    r"""If `algorithm=alternative_route`, this parameter specifies how similar an alternative route can be to the optimal route. Increasing can lead to worse alternatives."""  
    alternative_route_max_weight_factor: Optional[float] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'alternative_route.max_weight_factor', 'style': 'form', 'explode': True }})
    r"""If `algorithm=alternative_route`, this parameter sets the factor by which the alternatives routes can be longer than the optimal route. Increasing can lead to worse alternatives."""  
    avoid: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'avoid', 'style': 'form', 'explode': True }})
    r"""Specify which road classes and environments you would like to avoid.
    Possible values are `motorway`, `steps`, `track`, `toll`, `ferry`, `tunnel` and `bridge`.
    Separate several values with `;`. Obviously not all the values make sense for all vehicle profiles e.g. `bike` is already forbidden on a `motorway`. Requires `ch.disable=true`.
    """  
    block_area: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'block_area', 'style': 'form', 'explode': True }})
    r"""Block road access by specifying a point close to the road segment to be blocked, with the format `lat,lon`.
    You can also block all road segments crossing a geometric shape. Specify a circle using the format `lat,lon,radius`, or a polygon using the format `lat1,lon1,lat2,lon2,...,latN,lonN`.
    You can specify several shapes, separating them with `;`. Requires `ch.disable=true`.
    """  
    calc_points: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'calc_points', 'style': 'form', 'explode': True }})
    r"""If the points for the route should be calculated at all."""  
    ch_disable: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'ch.disable', 'style': 'form', 'explode': True }})
    r"""Use this parameter in combination with one or more parameters from below."""  
    curbside: Optional[list[GetRouteCurbsideEnum]] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'curbside', 'style': 'form', 'explode': True }})
    r"""Optional parameter. It specifies on which side a point should be relative to the driver when she leaves/arrives at a start/target/via point. You need to specify this parameter for either none or all points. Only supported for motor vehicles and OpenStreetMap."""  
    debug: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'debug', 'style': 'form', 'explode': True }})
    r"""If `true`, the output will be formatted."""  
    details: Optional[list[str]] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'details', 'style': 'form', 'explode': True }})
    r"""Optional parameter to retrieve path details. You can request additional details for the route: `street_name`,
    `time`, `distance`, `max_speed`, `toll`, `road_class`, `road_class_link`, `road_access`, `road_environment`, `lanes`, and `surface`. Read more about the usage of path details [here](https://discuss.graphhopper.com/t/2539).
    """  
    elevation: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'elevation', 'style': 'form', 'explode': True }})
    r"""If `true`, a third coordinate, the altitude, is included with all positions in the response.
    This changes the format of the `points` and `snapped_waypoints` fields of the response, in both their
    encodings. Unless you switch off the `points_encoded` parameter, you need special code on the
    client side that can handle three-dimensional coordinates.
    A request can fail if the vehicle profile does not support elevation. See the features object for every vehicle profile.
    """  
    heading: Optional[list[int]] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'heading', 'style': 'form', 'explode': True }})
    r"""Favour a heading direction for a certain point. Specify either one heading for the start point or as many as there are points.
    In this case headings are associated by their order to the specific points. Headings are given as north based clockwise angle between 0 and 360 degree.
    This parameter also influences the tour generated with `algorithm=round_trip` and forces the initial direction.  Requires `ch.disable=true`.
    """  
    heading_penalty: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'heading_penalty', 'style': 'form', 'explode': True }})
    r"""Time penalty in seconds for not obeying a specified heading. Requires `ch.disable=true`."""  
    instructions: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'instructions', 'style': 'form', 'explode': True }})
    r"""If instructions should be calculated and returned"""  
    locale: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'locale', 'style': 'form', 'explode': True }})
    r"""The locale of the resulting turn instructions. E.g. `pt_PT` for Portuguese or `de` for German."""  
    optimize: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'optimize', 'style': 'form', 'explode': True }})
    r"""Normally, the calculated route will visit the points in the order you specified them.
    If you have more than two points, you can set this parameter to `\"true\"` and the points may be re-ordered to minimize the total travel time.
    Keep in mind that the limits on the number of locations of the Route Optimization API applies, and the request costs more credits.
    """  
    pass_through: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'pass_through', 'style': 'form', 'explode': True }})
    r"""If `true`, u-turns are avoided at via-points with regard to the `heading_penalty`. Requires `ch.disable=true`."""  
    point_hint: Optional[list[str]] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'point_hint', 'style': 'form', 'explode': True }})
    r"""The `point_hint` is typically a road name to which the associated `point` parameter should be snapped to. Specify no `point_hint` parameter or the same number as you have `point` parameters."""  
    points_encoded: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'points_encoded', 'style': 'form', 'explode': True }})
    r"""Allows changing the encoding of location data in the response. The default is polyline encoding, which is compact
    but requires special client code to unpack. (We provide it in our JavaScript client library!)
    Set this parameter to `false` to switch the encoding to simple coordinate pairs like `[lon,lat]`, or `[lon,lat,elevation]`.
    See the description of the response format for more information.
    """  
    round_trip_distance: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'round_trip.distance', 'style': 'form', 'explode': True }})
    r"""If `algorithm=round_trip`, this parameter configures approximative length of the resulting round trip. Requires `ch.disable=true`."""  
    round_trip_seed: Optional[int] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'round_trip.seed', 'style': 'form', 'explode': True }})
    r"""If `algorithm=round_trip`, this sets the random seed. Change this to get a different tour for each value."""  
    snap_prevention: Optional[list[str]] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'snap_prevention', 'style': 'form', 'explode': True }})
    r"""Optional parameter to avoid snapping to a certain road class or road environment. Currently supported values are `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&snap_prevention=motorway`."""  
    turn_costs: Optional[bool] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'turn_costs', 'style': 'form', 'explode': True }})
    r"""Specifies if turn restrictions should be considered. Enabling this option increases the route computation time. Only supported for motor vehicles and OpenStreetMap."""  
    vehicle: Optional[shared_vehicleprofileid_enum.VehicleProfileIDEnum] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'vehicle', 'style': 'form', 'explode': True }})
    r"""The vehicle profile for which the route should be calculated."""  
    weighting: Optional[str] = dataclasses.field(default=None, metadata={'query_param': { 'field_name': 'weighting', 'style': 'form', 'explode': True }})
    r"""Determines the way the \\"best\\" route is calculated. Besides `fastest` you can use `short_fastest` which finds a reasonable balance between the distance influence (`shortest`) and the time (`fastest`). You could also use `shortest` but is deprecated and not recommended for motor vehicles. All except `fastest` require `ch.disable=true`."""  
    

@dataclasses.dataclass
class GetRouteResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    gh_error: Optional[shared_gherror.GHError] = dataclasses.field(default=None)
    r"""Your request is not valid. For example, you specified too few or too many points."""  
    headers: Optional[dict[str, list[str]]] = dataclasses.field(default=None)  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    route_response: Optional[shared_routeresponse.RouteResponse] = dataclasses.field(default=None)
    r"""Routing Result"""  
    