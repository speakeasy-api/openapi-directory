// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"openapi/pkg/models/shared"
)

type NodeDetailsPathParams struct {
	// Id of the target node
	NodeID string `pathParam:"style=simple,explode=false,name=nodeId"`
}

type NodeDetailsQueryParams struct {
	// Level of information to include from the node inventory. Some base levels are defined (**minimal**, **default**, **full**). You can add fields you want to a base level by adding them to the list, possible values are keys from json answer. If you don't provide a base level, they will be added to `default` level, so if you only want os details, use `minimal,os` as the value for this parameter.
	// * **minimal** includes: `id`, `hostname` and `status`
	// * **default** includes **minimal** plus `architectureDescription`, `description`, `ipAddresses`, `lastRunDate`, `lastInventoryDate`, `machine`, `os`, `managementTechnology`, `policyServerId`, `properties` (be careful! Only node own properties, if you also need inherited properties, look at the dedicated `/nodes/{id}/inheritedProperties` endpoint), `policyMode `, `ram` and `timezone`
	// * **full** includes: **default** plus `accounts`, `bios`, `controllers`, `environmentVariables`, `fileSystems`, `managementTechnologyDetails`, `memories`, `networkInterfaces`, `ports`, `processes`, `processors`, `slots`, `software`, `sound`, `storage`, `videos` and `virtualMachines`
	Include *string `queryParam:"style=form,explode=true,name=include"`
}

type NodeDetailsRequest struct {
	PathParams  NodeDetailsPathParams
	QueryParams NodeDetailsQueryParams
}

// NodeDetails200ApplicationJSONActionEnum - The id of the action
type NodeDetails200ApplicationJSONActionEnum string

const (
	NodeDetails200ApplicationJSONActionEnumNodeDetails NodeDetails200ApplicationJSONActionEnum = "nodeDetails"
)

func (e *NodeDetails200ApplicationJSONActionEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "nodeDetails":
		*e = NodeDetails200ApplicationJSONActionEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for NodeDetails200ApplicationJSONActionEnum: %s", s)
	}
}

// NodeDetails200ApplicationJSONData - Information about the node
type NodeDetails200ApplicationJSONData struct {
	Nodes []shared.NodeFull `json:"nodes"`
}

// NodeDetails200ApplicationJSONResultEnum - Result of the request
type NodeDetails200ApplicationJSONResultEnum string

const (
	NodeDetails200ApplicationJSONResultEnumSuccess NodeDetails200ApplicationJSONResultEnum = "success"
	NodeDetails200ApplicationJSONResultEnumError   NodeDetails200ApplicationJSONResultEnum = "error"
)

func (e *NodeDetails200ApplicationJSONResultEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "success":
		fallthrough
	case "error":
		*e = NodeDetails200ApplicationJSONResultEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for NodeDetails200ApplicationJSONResultEnum: %s", s)
	}
}

// NodeDetails200ApplicationJSON - Nodes
type NodeDetails200ApplicationJSON struct {
	// The id of the action
	Action NodeDetails200ApplicationJSONActionEnum `json:"action"`
	// Information about the node
	Data NodeDetails200ApplicationJSONData `json:"data"`
	// Result of the request
	Result NodeDetails200ApplicationJSONResultEnum `json:"result"`
}

type NodeDetailsResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Nodes
	NodeDetails200ApplicationJSONObject *NodeDetails200ApplicationJSON
}
