"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Any, Optional

class Addon:
    r"""The addon resource is intended to use used by Bitbucket Cloud Connect
    Apps, and only supports JWT authentication.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_addon(self) -> operations.DeleteAddonResponse:
        r"""Delete an app
        Deletes the application for the user.
        
        This endpoint is intended to be used by Bitbucket Connect apps
        and only supports JWT authentication -- that is how Bitbucket
        identifies the particular installation of the app. Developers
        with applications registered in the \"Develop Apps\" section
        of Bitbucket Marketplace need not use this endpoint as
        updates for those applications can be sent out via the
        UI of that section.
        
        ```
        $ curl -X DELETE https://api.bitbucket.org/2.0/addon \
          -H \"Authorization: JWT <JWT Token>\"
        ```
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/addon'
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAddonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [401, 403]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_addon_linkers_linker_key_values(self, request: operations.DeleteAddonLinkersLinkerKeyValuesRequest, security: operations.DeleteAddonLinkersLinkerKeyValuesSecurity) -> operations.DeleteAddonLinkersLinkerKeyValuesResponse:
        r"""Delete all linker values
        Delete all [linker](/cloud/bitbucket/modules/linker/) values for the
        specified linker of the authenticated application.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAddonLinkersLinkerKeyValuesRequest, base_url, '/addon/linkers/{linker_key}/values', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAddonLinkersLinkerKeyValuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def delete_addon_linkers_linker_key_values_value_id_(self, request: operations.DeleteAddonLinkersLinkerKeyValuesValueIDRequest, security: operations.DeleteAddonLinkersLinkerKeyValuesValueIDSecurity) -> operations.DeleteAddonLinkersLinkerKeyValuesValueIDResponse:
        r"""Delete a linker value
        Delete a single [linker](/cloud/bitbucket/modules/linker/) value
        of the authenticated application.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteAddonLinkersLinkerKeyValuesValueIDRequest, base_url, '/addon/linkers/{linker_key}/values/{value_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteAddonLinkersLinkerKeyValuesValueIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_addon_linkers(self) -> operations.GetAddonLinkersResponse:
        r"""List linkers for an app
        Gets a list of all [linkers](/cloud/bitbucket/modules/linker/)
        for the authenticated application.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/addon/linkers'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAddonLinkersResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_addon_linkers_linker_key_(self, request: operations.GetAddonLinkersLinkerKeyRequest, security: operations.GetAddonLinkersLinkerKeySecurity) -> operations.GetAddonLinkersLinkerKeyResponse:
        r"""Get a linker for an app
        Gets a [linker](/cloud/bitbucket/modules/linker/) specified by `linker_key`
        for the authenticated application.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAddonLinkersLinkerKeyRequest, base_url, '/addon/linkers/{linker_key}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAddonLinkersLinkerKeyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_addon_linkers_linker_key_values(self, request: operations.GetAddonLinkersLinkerKeyValuesRequest, security: operations.GetAddonLinkersLinkerKeyValuesSecurity) -> operations.GetAddonLinkersLinkerKeyValuesResponse:
        r"""List linker values for a linker
        Gets a list of all [linker](/cloud/bitbucket/modules/linker/) values for the
        specified linker of the authenticated application.
        
        A linker value lets applications supply values to modify its regular expression.
        
        The base regular expression must use a Bitbucket-specific match group `(?K)`
        which will be translated to `([\w\-]+)`. A value must match this pattern.
        
        [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAddonLinkersLinkerKeyValuesRequest, base_url, '/addon/linkers/{linker_key}/values', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAddonLinkersLinkerKeyValuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def get_addon_linkers_linker_key_values_value_id_(self, request: operations.GetAddonLinkersLinkerKeyValuesValueIDRequest, security: operations.GetAddonLinkersLinkerKeyValuesValueIDSecurity) -> operations.GetAddonLinkersLinkerKeyValuesValueIDResponse:
        r"""Get a linker value
        Get a single [linker](/cloud/bitbucket/modules/linker/) value
        of the authenticated application.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetAddonLinkersLinkerKeyValuesValueIDRequest, base_url, '/addon/linkers/{linker_key}/values/{value_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetAddonLinkersLinkerKeyValuesValueIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code in [401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def post_addon_linkers_linker_key_values(self, request: operations.PostAddonLinkersLinkerKeyValuesRequest, security: operations.PostAddonLinkersLinkerKeyValuesSecurity) -> operations.PostAddonLinkersLinkerKeyValuesResponse:
        r"""Create a linker value
        Creates a [linker](/cloud/bitbucket/modules/linker/) value for the specified
        linker of authenticated application.
        
        A linker value lets applications supply values to modify its regular expression.
        
        The base regular expression must use a Bitbucket-specific match group `(?K)`
        which will be translated to `([\w\-]+)`. A value must match this pattern.
        
        [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PostAddonLinkersLinkerKeyValuesRequest, base_url, '/addon/linkers/{linker_key}/values', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PostAddonLinkersLinkerKeyValuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            pass
        elif http_res.status_code in [401, 404, 409]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_addon(self) -> operations.PutAddonResponse:
        r"""Update an installed app
        Updates the application installation for the user.
        
        This endpoint is intended to be used by Bitbucket Connect apps
        and only supports JWT authentication -- that is how Bitbucket
        identifies the particular installation of the app. Developers
        with applications registered in the \"Develop Apps\" section
        of Bitbucket need not use this endpoint as updates for those
        applications can be sent out via the UI of that section.
        
        Passing an empty body will update the installation using the
        existing descriptor URL.
        
        ```
        $ curl -X PUT https://api.bitbucket.org/2.0/addon \
          -H \"Authorization: JWT <JWT Token>\" \
          --header \"Content-Type: application/json\" \
          --data '{}'
        ```
        
        The new `descriptor` for the installation can be also provided
        in the body directly.
        
        ```
        $ curl -X PUT https://api.bitbucket.org/2.0/addon \
          -H \"Authorization: JWT <JWT Token>\" \
          --header \"Content-Type: application/json\" \
          --data '{\"descriptor\": $NEW_DESCRIPTOR}'
        ```
        
        In both these modes the URL of the descriptor cannot be changed. To
        change the descriptor location and upgrade an installation
        the request must be made exclusively with a `descriptor_url`.
        
         ```
        $ curl -X PUT https://api.bitbucket.org/2.0/addon \
          -H \"Authorization: JWT <JWT Token>\" \
          --header \"Content-Type: application/json\" \
          --data '{\"descriptor_url\": $NEW_URL}'
        ```
        
        The `descriptor_url` must exactly match the marketplace registration
        that Atlassian has for the application. Contact your Atlassian
        developer advocate to update this registration. Once the registration
        has been updated you may call this resource for each installation.
        
        Note that the scopes of the application cannot be increased
        in the new descriptor nor reduced to none.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/addon'
        
        
        client = self._client
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAddonResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [400, 401, 403]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    def put_addon_linkers_linker_key_values(self, request: operations.PutAddonLinkersLinkerKeyValuesRequest, security: operations.PutAddonLinkersLinkerKeyValuesSecurity) -> operations.PutAddonLinkersLinkerKeyValuesResponse:
        r"""Update a linker value
        Bulk update [linker](/cloud/bitbucket/modules/linker/) values for the specified
        linker of the authenticated application.
        
        A linker value lets applications supply values to modify its regular expression.
        
        The base regular expression must use a Bitbucket-specific match group `(?K)`
        which will be translated to `([\w\-]+)`. A value must match this pattern.
        
        [Read more about linker values](/cloud/bitbucket/modules/linker/#usingthebitbucketapitosupplyvalues)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PutAddonLinkersLinkerKeyValuesRequest, base_url, '/addon/linkers/{linker_key}/values', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PutAddonLinkersLinkerKeyValuesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [400, 401, 404]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[dict[str, Any]])
                res.error = out

        return res

    