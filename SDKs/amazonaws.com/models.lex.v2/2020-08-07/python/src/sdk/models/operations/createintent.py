"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from ..shared import conditionalspecification as shared_conditionalspecification
from ..shared import createintentresponse as shared_createintentresponse
from ..shared import dialogcodehookinvocationsetting as shared_dialogcodehookinvocationsetting
from ..shared import dialogstate as shared_dialogstate
from ..shared import elicitationcodehookinvocationsetting as shared_elicitationcodehookinvocationsetting
from ..shared import fulfillmentupdatesspecification as shared_fulfillmentupdatesspecification
from ..shared import inputcontext as shared_inputcontext
from ..shared import outputcontext as shared_outputcontext
from ..shared import postfulfillmentstatusspecification as shared_postfulfillmentstatusspecification
from ..shared import promptspecification as shared_promptspecification
from ..shared import responsespecification as shared_responsespecification
from ..shared import sampleutterance as shared_sampleutterance
from dataclasses_json import Undefined, dataclass_json
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBodyDialogCodeHook:
    r"""Settings that determine the Lambda function that Amazon Lex uses for processing user responses."""
    
    enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBodyFulfillmentCodeHook:
    r"""Determines if a Lambda function should be invoked for a specific intent."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})  
    enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('enabled'), 'exclude': lambda f: f is None }})  
    fulfillment_updates_specification: Optional[shared_fulfillmentupdatesspecification.FulfillmentUpdatesSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fulfillmentUpdatesSpecification'), 'exclude': lambda f: f is None }})  
    post_fulfillment_status_specification: Optional[shared_postfulfillmentstatusspecification.PostFulfillmentStatusSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('postFulfillmentStatusSpecification'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBodyInitialResponseSetting:
    r"""Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots."""
    
    code_hook: Optional[shared_dialogcodehookinvocationsetting.DialogCodeHookInvocationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('codeHook'), 'exclude': lambda f: f is None }})
    r"""Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation."""  
    conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conditional'), 'exclude': lambda f: f is None }})
    r"""Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition."""  
    initial_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('initialResponse'), 'exclude': lambda f: f is None }})
    r"""Specifies a list of message groups that Amazon Lex uses to respond the user input."""  
    next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nextStep'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBodyIntentClosingSetting:
    r"""Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})  
    closing_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('closingResponse'), 'exclude': lambda f: f is None }})  
    conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('conditional'), 'exclude': lambda f: f is None }})  
    next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nextStep'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBodyIntentConfirmationSetting:
    r"""Provides a prompt for making sure that the user is ready for the intent to be fulfilled."""
    
    active: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('active'), 'exclude': lambda f: f is None }})  
    code_hook: Optional[shared_dialogcodehookinvocationsetting.DialogCodeHookInvocationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('codeHook'), 'exclude': lambda f: f is None }})  
    confirmation_conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmationConditional'), 'exclude': lambda f: f is None }})  
    confirmation_next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmationNextStep'), 'exclude': lambda f: f is None }})  
    confirmation_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('confirmationResponse'), 'exclude': lambda f: f is None }})
    r"""Specifies a list of message groups that Amazon Lex uses to respond the user input."""  
    declination_conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('declinationConditional'), 'exclude': lambda f: f is None }})  
    declination_next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('declinationNextStep'), 'exclude': lambda f: f is None }})  
    declination_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('declinationResponse'), 'exclude': lambda f: f is None }})  
    elicitation_code_hook: Optional[shared_elicitationcodehookinvocationsetting.ElicitationCodeHookInvocationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('elicitationCodeHook'), 'exclude': lambda f: f is None }})  
    failure_conditional: Optional[shared_conditionalspecification.ConditionalSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failureConditional'), 'exclude': lambda f: f is None }})
    r"""Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition."""  
    failure_next_step: Optional[shared_dialogstate.DialogState] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failureNextStep'), 'exclude': lambda f: f is None }})  
    failure_response: Optional[shared_responsespecification.ResponseSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('failureResponse'), 'exclude': lambda f: f is None }})
    r"""Specifies a list of message groups that Amazon Lex uses to respond the user input."""  
    prompt_specification: Optional[shared_promptspecification.PromptSpecification] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('promptSpecification'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBodyKendraConfiguration:
    r"""Provides configuration information for the AMAZON.KendraSearchIntent intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance."""
    
    kendra_index: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kendraIndex'), 'exclude': lambda f: f is None }})  
    query_filter_string: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('queryFilterString'), 'exclude': lambda f: f is None }})  
    query_filter_string_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('queryFilterStringEnabled'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CreateIntentRequestBody:
    
    intent_name: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intentName') }})
    r"""The name of the intent. Intent names must be unique in the locale that contains the intent and cannot match the name of any built-in intent."""  
    description: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('description'), 'exclude': lambda f: f is None }})
    r"""A description of the intent. Use the description to help identify the intent in lists."""  
    dialog_code_hook: Optional[CreateIntentRequestBodyDialogCodeHook] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('dialogCodeHook'), 'exclude': lambda f: f is None }})
    r"""Settings that determine the Lambda function that Amazon Lex uses for processing user responses."""  
    fulfillment_code_hook: Optional[CreateIntentRequestBodyFulfillmentCodeHook] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fulfillmentCodeHook'), 'exclude': lambda f: f is None }})
    r"""Determines if a Lambda function should be invoked for a specific intent."""  
    initial_response_setting: Optional[CreateIntentRequestBodyInitialResponseSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('initialResponseSetting'), 'exclude': lambda f: f is None }})
    r"""Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots."""  
    input_contexts: Optional[list[shared_inputcontext.InputContext]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('inputContexts'), 'exclude': lambda f: f is None }})
    r"""<p>A list of contexts that must be active for this intent to be considered by Amazon Lex.</p> <p>When an intent has an input context list, Amazon Lex only considers using the intent in an interaction with the user when the specified contexts are included in the active context list for the session. If the contexts are not active, then Amazon Lex will not use the intent.</p> <p>A context can be automatically activated using the <code>outputContexts</code> property or it can be set at runtime.</p> <p> For example, if there are two intents with different input contexts that respond to the same utterances, only the intent with the active context will respond.</p> <p>An intent may have up to 5 input contexts. If an intent has multiple input contexts, all of the contexts must be active to consider the intent.</p>"""  
    intent_closing_setting: Optional[CreateIntentRequestBodyIntentClosingSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intentClosingSetting'), 'exclude': lambda f: f is None }})
    r"""Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled."""  
    intent_confirmation_setting: Optional[CreateIntentRequestBodyIntentConfirmationSetting] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('intentConfirmationSetting'), 'exclude': lambda f: f is None }})
    r"""Provides a prompt for making sure that the user is ready for the intent to be fulfilled."""  
    kendra_configuration: Optional[CreateIntentRequestBodyKendraConfiguration] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('kendraConfiguration'), 'exclude': lambda f: f is None }})
    r"""Provides configuration information for the AMAZON.KendraSearchIntent intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance."""  
    output_contexts: Optional[list[shared_outputcontext.OutputContext]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('outputContexts'), 'exclude': lambda f: f is None }})
    r"""<p>A lists of contexts that the intent activates when it is fulfilled.</p> <p>You can use an output context to indicate the intents that Amazon Lex should consider for the next turn of the conversation with a customer. </p> <p>When you use the <code>outputContextsList</code> property, all of the contexts specified in the list are activated when the intent is fulfilled. You can set up to 10 output contexts. You can also set the number of conversation turns that the context should be active, or the length of time that the context should be active.</p>"""  
    parent_intent_signature: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('parentIntentSignature'), 'exclude': lambda f: f is None }})
    r"""A unique identifier for the built-in intent to base this intent on."""  
    sample_utterances: Optional[list[shared_sampleutterance.SampleUtterance]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sampleUtterances'), 'exclude': lambda f: f is None }})
    r"""<p>An array of strings that a user might say to signal the intent. For example, \\"I want a pizza\\", or \\"I want a {PizzaSize} pizza\\". </p> <p>In an utterance, slot names are enclosed in curly braces (\\"{\\", \\"}\\") to indicate where they should be displayed in the utterance shown to the user.. </p>"""  
    

@dataclasses.dataclass
class CreateIntentRequest:
    
    bot_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'botId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the bot associated with this intent."""  
    bot_version: str = dataclasses.field(metadata={'path_param': { 'field_name': 'botVersion', 'style': 'simple', 'explode': False }})
    r"""The identifier of the version of the bot associated with this intent."""  
    locale_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'localeId', 'style': 'simple', 'explode': False }})
    r"""The identifier of the language and locale where this intent is used. All of the bots, slot types, and slots used by the intent must have the same locale. For more information, see <a href=\\"https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html\\">Supported languages</a>."""  
    request_body: CreateIntentRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})  
    x_amz_algorithm: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Algorithm', 'style': 'simple', 'explode': False }})  
    x_amz_content_sha256: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Content-Sha256', 'style': 'simple', 'explode': False }})  
    x_amz_credential: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Credential', 'style': 'simple', 'explode': False }})  
    x_amz_date: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Date', 'style': 'simple', 'explode': False }})  
    x_amz_security_token: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Security-Token', 'style': 'simple', 'explode': False }})  
    x_amz_signature: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-Signature', 'style': 'simple', 'explode': False }})  
    x_amz_signed_headers: Optional[str] = dataclasses.field(default=None, metadata={'header': { 'field_name': 'X-Amz-SignedHeaders', 'style': 'simple', 'explode': False }})  
    

@dataclasses.dataclass
class CreateIntentResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    conflict_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ConflictException"""  
    create_intent_response: Optional[shared_createintentresponse.CreateIntentResponse] = dataclasses.field(default=None)
    r"""Success"""  
    internal_server_exception: Optional[Any] = dataclasses.field(default=None)
    r"""InternalServerException"""  
    precondition_failed_exception: Optional[Any] = dataclasses.field(default=None)
    r"""PreconditionFailedException"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    service_quota_exceeded_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ServiceQuotaExceededException"""  
    throttling_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ThrottlingException"""  
    validation_exception: Optional[Any] = dataclasses.field(default=None)
    r"""ValidationException"""  
    