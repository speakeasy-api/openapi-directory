/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = ["http://redhat.local", "/"] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
  /**
   * Allows overriding the default axios client used by the SDK
   */
  defaultClient?: AxiosInstance;
  /**
   * Allows overriding the default server URL used by the SDK
   */
  serverURL?: string;
};

/**
 * API of the Patch application on [cloud.redhat.com](cloud.redhat.com)
 *
 * @remarks
 *
 * Syntax of the `filter[name]` query parameters is described in  [Filters documentation](https://github.com/RedHatInsights/patchman-engine/wiki/API-custom-filters)
 */
export class SDK {
  public _defaultClient: AxiosInstance;
  public _securityClient: AxiosInstance;
  public _serverURL: string;
  private _language = "typescript";
  private _sdkVersion = "0.0.1";
  private _genVersion = "internal";
  private _globals: any;

  constructor(props?: SDKProps) {
    this._serverURL = props?.serverURL ?? ServerList[0];

    this._defaultClient =
      props?.defaultClient ?? axios.create({ baseURL: this._serverURL });
    this._securityClient = this._defaultClient;
  }

  /**
   * Show me metadata of selected package
   *
   * @remarks
   * Show me metadata of selected package
   */
  latestPackage(
    req: operations.LatestPackageRequest,
    security: operations.LatestPackageSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.LatestPackageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.LatestPackageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/packages/{package_name}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.LatestPackageSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.LatestPackageResponse =
        new operations.LatestPackageResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersPackageDetailResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersPackageDetailResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete system by inventory id
   *
   * @remarks
   * Delete system by inventory id
   */
  deletesystem(
    req: operations.DeletesystemRequest,
    security: operations.DeletesystemSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeletesystemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeletesystemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/systems/{inventory_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeletesystemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeletesystemResponse =
        new operations.DeletesystemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          break;
      }

      return res;
    });
  }

  /**
   * Show me details an advisory by given advisory name
   *
   * @remarks
   * Show me details an advisory by given advisory name
   */
  detailAdvisory(
    req: operations.DetailAdvisoryRequest,
    security: operations.DetailAdvisorySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DetailAdvisoryResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DetailAdvisoryRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/advisories/{advisory_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DetailAdvisorySecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DetailAdvisoryResponse =
        new operations.DetailAdvisoryResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersAdvisoryDetailResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersAdvisoryDetailResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me details about a system by given inventory id
   *
   * @remarks
   * Show me details about a system by given inventory id
   */
  detailSystem(
    req: operations.DetailSystemRequest,
    security: operations.DetailSystemSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DetailSystemResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DetailSystemRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/systems/{inventory_id}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DetailSystemSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DetailSystemResponse =
        new operations.DetailSystemResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemDetailResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemDetailResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Export applicable advisories for all my systems
   *
   * @remarks
   * Export applicable advisories for all my systems
   */
  exportAdvisories(
    req: operations.ExportAdvisoriesRequest,
    security: operations.ExportAdvisoriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAdvisoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportAdvisoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patch/v1/export/advisories";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportAdvisoriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAdvisoriesResponse =
        new operations.ExportAdvisoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersAdvisoryInlineItems = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersAdvisoryInlineItems = utils.objectToClass(
              httpRes?.data,
              shared.ControllersAdvisoryInlineItem,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Export systems for my account
   *
   * @remarks
   * Export systems for my account
   */
  exportAdvisorySystems(
    req: operations.ExportAdvisorySystemsRequest,
    security: operations.ExportAdvisorySystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportAdvisorySystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportAdvisorySystemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/export/advisories/{advisory_id}/systems",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportAdvisorySystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportAdvisorySystemsResponse =
        new operations.ExportAdvisorySystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemInlineItems = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersSystemInlineItems = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemInlineItem,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all my systems which have a package installed
   *
   * @remarks
   * Show me all my systems which have a package installed
   */
  exportPackageSystems(
    req: operations.ExportPackageSystemsRequest,
    security: operations.ExportPackageSystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportPackageSystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportPackageSystemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/export/packages/{package_name}/systems",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportPackageSystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportPackageSystemsResponse =
        new operations.ExportPackageSystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersPackageSystemItems = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersPackageSystemItems = utils.objectToClass(
              httpRes?.data,
              shared.ControllersPackageSystemItem,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all installed packages across my systems
   *
   * @remarks
   * Show me all installed packages across my systems
   */
  exportPackages(
    req: operations.ExportPackagesRequest,
    security: operations.ExportPackagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportPackagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportPackagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patch/v1/export/packages";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportPackagesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportPackagesResponse =
        new operations.ExportPackagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersPackageItems = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersPackageItems = utils.objectToClass(
              httpRes?.data,
              shared.ControllersPackageItem,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Export applicable advisories for all my systems
   *
   * @remarks
   * Export applicable advisories for all my systems
   */
  exportSystemAdvisories(
    req: operations.ExportSystemAdvisoriesRequest,
    security: operations.ExportSystemAdvisoriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSystemAdvisoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportSystemAdvisoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/export/systems/{inventory_id}/advisories",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportSystemAdvisoriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSystemAdvisoriesResponse =
        new operations.ExportSystemAdvisoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemAdvisoriesDBLookups = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersSystemAdvisoriesDBLookups = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemAdvisoriesDBLookup,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me details about a system packages by given inventory id
   *
   * @remarks
   * Show me details about a system packages by given inventory id
   */
  exportSystemPackages(
    req: operations.ExportSystemPackagesRequest,
    security: operations.ExportSystemPackagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSystemPackagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportSystemPackagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/export/systems/{inventory_id}/packages",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportSystemPackagesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSystemPackagesResponse =
        new operations.ExportSystemPackagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemPackageInlines = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersSystemPackageInlines = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemPackageInline,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Export systems for my account
   *
   * @remarks
   * Export systems for my account
   */
  exportSystems(
    req: operations.ExportSystemsRequest,
    security: operations.ExportSystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ExportSystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ExportSystemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patch/v1/export/systems";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ExportSystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ExportSystemsResponse =
        new operations.ExportSystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemInlineItems = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.controllersSystemInlineItems = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemInlineItem,
              resFieldDepth
            );
          }
          if (utils.matchContentType(contentType, `text/csv`)) {
            const resBody: string = JSON.stringify(httpRes?.data, null, 0);
            const out: Uint8Array = new Uint8Array(resBody.length);
            for (let i = 0; i < resBody.length; i++)
              out[i] = resBody.charCodeAt(i);
            res.body = out;
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all applicable advisories for all my systems
   *
   * @remarks
   * Show me all applicable advisories for all my systems
   */
  listAdvisories(
    req: operations.ListAdvisoriesRequest,
    security: operations.ListAdvisoriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAdvisoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAdvisoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patch/v1/advisories";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAdvisoriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAdvisoriesResponse =
        new operations.ListAdvisoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersAdvisoriesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersAdvisoriesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me systems on which the given advisory is applicable
   *
   * @remarks
   * Show me systems on which the given advisory is applicable
   */
  listAdvisorySystems(
    req: operations.ListAdvisorySystemsRequest,
    security: operations.ListAdvisorySystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListAdvisorySystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListAdvisorySystemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/advisories/{advisory_id}/systems",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListAdvisorySystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListAdvisorySystemsResponse =
        new operations.ListAdvisorySystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersAdvisorySystemsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersAdvisorySystemsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all installed packages across my systems
   *
   * @remarks
   * Show me all installed packages across my systems
   */
  listPackages(
    req: operations.ListPackagesRequest,
    security: operations.ListPackagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListPackagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListPackagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patch/v1/packages/";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListPackagesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListPackagesResponse =
        new operations.ListPackagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersPackagesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersPackagesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me advisories for a system by given inventory id
   *
   * @remarks
   * Show me advisories for a system by given inventory id
   */
  listSystemAdvisories(
    req: operations.ListSystemAdvisoriesRequest,
    security: operations.ListSystemAdvisoriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSystemAdvisoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSystemAdvisoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/systems/{inventory_id}/advisories",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSystemAdvisoriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSystemAdvisoriesResponse =
        new operations.ListSystemAdvisoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemAdvisoriesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemAdvisoriesResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all my systems
   *
   * @remarks
   * Show me all my systems
   */
  listSystems(
    req: operations.ListSystemsRequest,
    security: operations.ListSystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ListSystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListSystemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/api/patch/v1/systems";
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ListSystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ListSystemsResponse =
        new operations.ListSystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all my systems which have a package installed
   *
   * @remarks
   * Show me all my systems which have a package installed
   */
  packageSystems(
    req: operations.PackageSystemsRequest,
    security: operations.PackageSystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PackageSystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PackageSystemsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/packages/{package_name}/systems",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PackageSystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PackageSystemsResponse =
        new operations.PackageSystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersPackageSystemsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersPackageSystemsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me all package versions installed on some system
   *
   * @remarks
   * Show me all package versions installed on some system
   */
  packageVersions(
    req: operations.PackageVersionsRequest,
    security: operations.PackageVersionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PackageVersionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PackageVersionsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/packages/{package_name}/versions",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PackageVersionsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PackageVersionsResponse =
        new operations.PackageVersionsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersPackageVersionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersPackageVersionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Show me details about a system packages by given inventory id
   *
   * @remarks
   * Show me details about a system packages by given inventory id
   */
  systemPackages(
    req: operations.SystemPackagesRequest,
    security: operations.SystemPackagesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.SystemPackagesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.SystemPackagesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/api/patch/v1/systems/{inventory_id}/packages",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.SystemPackagesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.SystemPackagesResponse =
        new operations.SystemPackagesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemPackageResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemPackageResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View advisory-system pairs for selected systems and advisories
   *
   * @remarks
   * View advisory-system pairs for selected systems and advisories
   */
  viewAdvisoriesSystems(
    req: shared.ControllersSystemsAdvisoriesRequest,
    security: operations.ViewAdvisoriesSystemsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ViewAdvisoriesSystemsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ControllersSystemsAdvisoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patch/v1/views/advisories/systems";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ViewAdvisoriesSystemsSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ViewAdvisoriesSystemsResponse =
        new operations.ViewAdvisoriesSystemsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersAdvisoriesSystemsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersAdvisoriesSystemsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * View system-advisory pairs for selected systems and advisories
   *
   * @remarks
   * View system-advisory pairs for selected systems and advisories
   */
  viewSystemsAdvisories(
    req: shared.ControllersSystemsAdvisoriesRequest,
    security: operations.ViewSystemsAdvisoriesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ViewSystemsAdvisoriesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.ControllersSystemsAdvisoriesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string =
      baseURL.replace(/\/$/, "") + "/api/patch/v1/views/systems/advisories";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ViewSystemsAdvisoriesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ViewSystemsAdvisoriesResponse =
        new operations.ViewSystemsAdvisoriesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.controllersSystemsAdvisoriesResponse = utils.objectToClass(
              httpRes?.data,
              shared.ControllersSystemsAdvisoriesResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
