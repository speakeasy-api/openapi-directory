// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type SceneElementsType string

const (
	SceneElementsTypeVideo     SceneElementsType = "video"
	SceneElementsTypeImage     SceneElementsType = "image"
	SceneElementsTypeText      SceneElementsType = "text"
	SceneElementsTypeHTML      SceneElementsType = "html"
	SceneElementsTypeComponent SceneElementsType = "component"
	SceneElementsTypeAudio     SceneElementsType = "audio"
	SceneElementsTypeVoice     SceneElementsType = "voice"
)

type SceneElements struct {
	Video     *Video
	Image     *Image
	Text      *Text
	HTML      *HTML
	Component *Component
	Audio     *Audio
	Voice     *Voice

	Type SceneElementsType
}

func CreateSceneElementsVideo(video Video) SceneElements {
	typ := SceneElementsTypeVideo
	typStr := VideoTypeEnum(typ)
	video.Type = typStr

	return SceneElements{
		Video: &video,
		Type:  typ,
	}
}

func CreateSceneElementsImage(image Image) SceneElements {
	typ := SceneElementsTypeImage
	typStr := ImageTypeEnum(typ)
	image.Type = &typStr

	return SceneElements{
		Image: &image,
		Type:  typ,
	}
}

func CreateSceneElementsText(text Text) SceneElements {
	typ := SceneElementsTypeText
	typStr := TextTypeEnum(typ)
	text.Type = typStr

	return SceneElements{
		Text: &text,
		Type: typ,
	}
}

func CreateSceneElementsHTML(html HTML) SceneElements {
	typ := SceneElementsTypeHTML
	typStr := HTMLTypeEnum(typ)
	html.Type = typStr

	return SceneElements{
		HTML: &html,
		Type: typ,
	}
}

func CreateSceneElementsComponent(component Component) SceneElements {
	typ := SceneElementsTypeComponent
	typStr := ComponentTypeEnum(typ)
	component.Type = typStr

	return SceneElements{
		Component: &component,
		Type:      typ,
	}
}

func CreateSceneElementsAudio(audio Audio) SceneElements {
	typ := SceneElementsTypeAudio
	typStr := AudioTypeEnum(typ)
	audio.Type = &typStr

	return SceneElements{
		Audio: &audio,
		Type:  typ,
	}
}

func CreateSceneElementsVoice(voice Voice) SceneElements {
	typ := SceneElementsTypeVoice
	typStr := VoiceTypeEnum(typ)
	voice.Type = typStr

	return SceneElements{
		Voice: &voice,
		Type:  typ,
	}
}

func (u *SceneElements) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	type discriminator struct {
		Type string
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "video":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		video := new(Video)
		if err := d.Decode(&video); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Video = video
		u.Type = SceneElementsTypeVideo
		return nil
	case "image":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		image := new(Image)
		if err := d.Decode(&image); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Image = image
		u.Type = SceneElementsTypeImage
		return nil
	case "text":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		text := new(Text)
		if err := d.Decode(&text); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Text = text
		u.Type = SceneElementsTypeText
		return nil
	case "html":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		html := new(HTML)
		if err := d.Decode(&html); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.HTML = html
		u.Type = SceneElementsTypeHTML
		return nil
	case "component":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		component := new(Component)
		if err := d.Decode(&component); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Component = component
		u.Type = SceneElementsTypeComponent
		return nil
	case "audio":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		audio := new(Audio)
		if err := d.Decode(&audio); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Audio = audio
		u.Type = SceneElementsTypeAudio
		return nil
	case "voice":
		d = json.NewDecoder(bytes.NewReader(data))
		d.DisallowUnknownFields()
		voice := new(Voice)
		if err := d.Decode(&voice); err != nil {
			return fmt.Errorf("could not unmarshal expected type: %w", err)
		}

		u.Voice = voice
		u.Type = SceneElementsTypeVoice
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SceneElements) MarshalJSON() ([]byte, error) {
	if u.Video != nil {
		return json.Marshal(u.Video)
	}

	if u.Image != nil {
		return json.Marshal(u.Image)
	}

	if u.Text != nil {
		return json.Marshal(u.Text)
	}

	if u.HTML != nil {
		return json.Marshal(u.HTML)
	}

	if u.Component != nil {
		return json.Marshal(u.Component)
	}

	if u.Audio != nil {
		return json.Marshal(u.Audio)
	}

	if u.Voice != nil {
		return json.Marshal(u.Voice)
	}

	return nil, nil
}

type SceneTransitionStyleEnum string

const (
	SceneTransitionStyleEnumFade        SceneTransitionStyleEnum = "fade"
	SceneTransitionStyleEnumWipeleft    SceneTransitionStyleEnum = "wipeleft"
	SceneTransitionStyleEnumWiperight   SceneTransitionStyleEnum = "wiperight"
	SceneTransitionStyleEnumWipeup      SceneTransitionStyleEnum = "wipeup"
	SceneTransitionStyleEnumWipedown    SceneTransitionStyleEnum = "wipedown"
	SceneTransitionStyleEnumSlideleft   SceneTransitionStyleEnum = "slideleft"
	SceneTransitionStyleEnumSlideright  SceneTransitionStyleEnum = "slideright"
	SceneTransitionStyleEnumSlideup     SceneTransitionStyleEnum = "slideup"
	SceneTransitionStyleEnumSlidedown   SceneTransitionStyleEnum = "slidedown"
	SceneTransitionStyleEnumCirclecrop  SceneTransitionStyleEnum = "circlecrop"
	SceneTransitionStyleEnumRectcrop    SceneTransitionStyleEnum = "rectcrop"
	SceneTransitionStyleEnumDistance    SceneTransitionStyleEnum = "distance"
	SceneTransitionStyleEnumFadeblack   SceneTransitionStyleEnum = "fadeblack"
	SceneTransitionStyleEnumFadewhite   SceneTransitionStyleEnum = "fadewhite"
	SceneTransitionStyleEnumRadial      SceneTransitionStyleEnum = "radial"
	SceneTransitionStyleEnumSmoothleft  SceneTransitionStyleEnum = "smoothleft"
	SceneTransitionStyleEnumSmoothright SceneTransitionStyleEnum = "smoothright"
	SceneTransitionStyleEnumSmoothup    SceneTransitionStyleEnum = "smoothup"
	SceneTransitionStyleEnumSmoothdown  SceneTransitionStyleEnum = "smoothdown"
	SceneTransitionStyleEnumCircleopen  SceneTransitionStyleEnum = "circleopen"
	SceneTransitionStyleEnumCircleclose SceneTransitionStyleEnum = "circleclose"
	SceneTransitionStyleEnumVertopen    SceneTransitionStyleEnum = "vertopen"
	SceneTransitionStyleEnumVertclose   SceneTransitionStyleEnum = "vertclose"
	SceneTransitionStyleEnumHorzopen    SceneTransitionStyleEnum = "horzopen"
	SceneTransitionStyleEnumHorzclose   SceneTransitionStyleEnum = "horzclose"
	SceneTransitionStyleEnumDissolve    SceneTransitionStyleEnum = "dissolve"
	SceneTransitionStyleEnumPixelize    SceneTransitionStyleEnum = "pixelize"
	SceneTransitionStyleEnumDiagtl      SceneTransitionStyleEnum = "diagtl"
	SceneTransitionStyleEnumDiagtr      SceneTransitionStyleEnum = "diagtr"
	SceneTransitionStyleEnumDiagbl      SceneTransitionStyleEnum = "diagbl"
	SceneTransitionStyleEnumDiagbr      SceneTransitionStyleEnum = "diagbr"
	SceneTransitionStyleEnumHlslice     SceneTransitionStyleEnum = "hlslice"
	SceneTransitionStyleEnumHrslice     SceneTransitionStyleEnum = "hrslice"
	SceneTransitionStyleEnumVuslice     SceneTransitionStyleEnum = "vuslice"
	SceneTransitionStyleEnumVdslice     SceneTransitionStyleEnum = "vdslice"
	SceneTransitionStyleEnumHblur       SceneTransitionStyleEnum = "hblur"
	SceneTransitionStyleEnumFadegrays   SceneTransitionStyleEnum = "fadegrays"
	SceneTransitionStyleEnumWipetl      SceneTransitionStyleEnum = "wipetl"
	SceneTransitionStyleEnumWipetr      SceneTransitionStyleEnum = "wipetr"
	SceneTransitionStyleEnumWipebl      SceneTransitionStyleEnum = "wipebl"
	SceneTransitionStyleEnumWipebr      SceneTransitionStyleEnum = "wipebr"
	SceneTransitionStyleEnumSqueezeh    SceneTransitionStyleEnum = "squeezeh"
	SceneTransitionStyleEnumSqueezev    SceneTransitionStyleEnum = "squeezev"
	SceneTransitionStyleEnumZoomin      SceneTransitionStyleEnum = "zoomin"
)

func (e *SceneTransitionStyleEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "fade":
		fallthrough
	case "wipeleft":
		fallthrough
	case "wiperight":
		fallthrough
	case "wipeup":
		fallthrough
	case "wipedown":
		fallthrough
	case "slideleft":
		fallthrough
	case "slideright":
		fallthrough
	case "slideup":
		fallthrough
	case "slidedown":
		fallthrough
	case "circlecrop":
		fallthrough
	case "rectcrop":
		fallthrough
	case "distance":
		fallthrough
	case "fadeblack":
		fallthrough
	case "fadewhite":
		fallthrough
	case "radial":
		fallthrough
	case "smoothleft":
		fallthrough
	case "smoothright":
		fallthrough
	case "smoothup":
		fallthrough
	case "smoothdown":
		fallthrough
	case "circleopen":
		fallthrough
	case "circleclose":
		fallthrough
	case "vertopen":
		fallthrough
	case "vertclose":
		fallthrough
	case "horzopen":
		fallthrough
	case "horzclose":
		fallthrough
	case "dissolve":
		fallthrough
	case "pixelize":
		fallthrough
	case "diagtl":
		fallthrough
	case "diagtr":
		fallthrough
	case "diagbl":
		fallthrough
	case "diagbr":
		fallthrough
	case "hlslice":
		fallthrough
	case "hrslice":
		fallthrough
	case "vuslice":
		fallthrough
	case "vdslice":
		fallthrough
	case "hblur":
		fallthrough
	case "fadegrays":
		fallthrough
	case "wipetl":
		fallthrough
	case "wipetr":
		fallthrough
	case "wipebl":
		fallthrough
	case "wipebr":
		fallthrough
	case "squeezeh":
		fallthrough
	case "squeezev":
		fallthrough
	case "zoomin":
		*e = SceneTransitionStyleEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SceneTransitionStyleEnum: %s", s)
	}
}

type SceneTransitionTypeEnum string

const (
	SceneTransitionTypeEnumXfade SceneTransitionTypeEnum = "xfade"
)

func (e *SceneTransitionTypeEnum) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	switch s {
	case "xfade":
		*e = SceneTransitionTypeEnum(s)
		return nil
	default:
		return fmt.Errorf("invalid value for SceneTransitionTypeEnum: %s", s)
	}
}

type SceneTransition struct {
	// Duration of the transition in seconds
	Duration *float32                  `json:"duration,omitempty"`
	Style    *SceneTransitionStyleEnum `json:"style,omitempty"`
	Type     *SceneTransitionTypeEnum  `json:"type,omitempty"`
}

type Scene struct {
	// A hexadecimal representation of a color or 'transparent'
	BackgroundColor *string `json:"background-color,omitempty"`
	Cache           *bool   `json:"cache,omitempty"`
	// Used for adding your comments
	Comment    *string          `json:"comment,omitempty"`
	Duration   *float32         `json:"duration,omitempty"`
	Elements   []SceneElements  `json:"elements,omitempty"`
	Transition *SceneTransition `json:"transition,omitempty"`
}
