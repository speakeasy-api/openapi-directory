"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional


@dataclasses.dataclass
class BranchConfigurationsUpdateSecurity:
    
    api_token: str = dataclasses.field(metadata={'security': { 'scheme': True, 'type': 'apiKey', 'sub_type': 'header', 'field_name': 'X-API-Token' }})  
    
class BranchConfigurationsUpdateRequestBodyArtifactVersioningBuildNumberFormatEnum(str, Enum):
    BUILD_ID = 'buildId'
    TIMESTAMP = 'timestamp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyArtifactVersioning:
    r"""The versioning configuration for artifacts built for this branch"""
    
    build_number_format: Optional[BranchConfigurationsUpdateRequestBodyArtifactVersioningBuildNumberFormatEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('buildNumberFormat'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyToolsetsAndroid:
    r"""Build configuration for Android projects"""
    
    automatic_signing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('automaticSigning'), 'exclude': lambda f: f is None }})
    r"""Whether to apply automatic signing or not"""  
    build_variant: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('buildVariant'), 'exclude': lambda f: f is None }})
    r"""The Android build variant to build"""  
    gradle_wrapper_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gradleWrapperPath'), 'exclude': lambda f: f is None }})
    r"""Path to the Gradle wrapper script"""  
    is_root: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isRoot'), 'exclude': lambda f: f is None }})
    r"""Whether it is the root module or not"""  
    key_alias: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keyAlias'), 'exclude': lambda f: f is None }})
    r"""The key alias"""  
    key_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keyPassword'), 'exclude': lambda f: f is None }})
    r"""The key password"""  
    keystore_encoded: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keystoreEncoded'), 'exclude': lambda f: f is None }})
    r"""The keystore encoded value"""  
    keystore_filename: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keystoreFilename'), 'exclude': lambda f: f is None }})
    r"""The name of the keystore file"""  
    keystore_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keystorePassword'), 'exclude': lambda f: f is None }})
    r"""The password of the keystore"""  
    module: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('module'), 'exclude': lambda f: f is None }})
    r"""The Gradle module to build"""  
    run_lint: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runLint'), 'exclude': lambda f: f is None }})
    r"""Whether to run lint checks during the build (default)"""  
    run_tests: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runTests'), 'exclude': lambda f: f is None }})
    r"""Whether to run unit tests during the build (default)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyToolsetsJavascript:
    r"""Build configuration when React Native, or other JavaScript tech, is part of the build steps"""
    
    package_json_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('packageJsonPath'), 'exclude': lambda f: f is None }})
    r"""Path to package.json file for the main project, e.g. \\"package.json\\" or \\"myapp/package.json\\" """  
    react_native_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reactNativeVersion'), 'exclude': lambda f: f is None }})
    r"""Version of React Native from package.json files"""  
    run_tests: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runTests'), 'exclude': lambda f: f is None }})
    r"""Whether to run Jest unit tests, via npm test, during the build"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyToolsetsXamarin:
    r"""Build configuration for Xamarin projects"""
    
    args: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('args'), 'exclude': lambda f: f is None }})  
    configuration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('configuration'), 'exclude': lambda f: f is None }})  
    is_sim_build: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isSimBuild'), 'exclude': lambda f: f is None }})  
    mono_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('monoVersion'), 'exclude': lambda f: f is None }})  
    p12_file: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('p12File'), 'exclude': lambda f: f is None }})  
    p12_pwd: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('p12Pwd'), 'exclude': lambda f: f is None }})  
    prov_profile: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provProfile'), 'exclude': lambda f: f is None }})  
    sdk_bundle: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sdkBundle'), 'exclude': lambda f: f is None }})  
    sln_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slnPath'), 'exclude': lambda f: f is None }})  
    symlink: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('symlink'), 'exclude': lambda f: f is None }})
    r"""Symlink of the SDK Bundle and Mono installation.
    The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyToolsetsXcodeAppExtensionProvisioningProfileFiles:
    r"""Provisioning profile fetch and store information"""
    
    file_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fileId'), 'exclude': lambda f: f is None }})
    r"""File id from secure file storage"""  
    file_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fileName'), 'exclude': lambda f: f is None }})
    r"""Name of uploaded provisioning profile"""  
    target_bundle_identifier: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targetBundleIdentifier'), 'exclude': lambda f: f is None }})
    r"""Target the provisioning profile is used to sign"""  
    upload_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uploadId'), 'exclude': lambda f: f is None }})
    r"""Upload id to App Center File Upload Store"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyToolsetsXcode:
    r"""Build configuration when Xcode is part of the build steps"""
    
    app_extension_provisioning_profile_files: Optional[list[BranchConfigurationsUpdateRequestBodyToolsetsXcodeAppExtensionProvisioningProfileFiles]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appExtensionProvisioningProfileFiles'), 'exclude': lambda f: f is None }})  
    archive_configuration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('archiveConfiguration'), 'exclude': lambda f: f is None }})
    r"""The build configuration of the target to archive"""  
    automatic_signing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('automaticSigning'), 'exclude': lambda f: f is None }})  
    cartfile_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cartfilePath'), 'exclude': lambda f: f is None }})
    r"""Path to Carthage file, if present"""  
    certificate_encoded: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateEncoded'), 'exclude': lambda f: f is None }})  
    certificate_file_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateFileId'), 'exclude': lambda f: f is None }})  
    certificate_filename: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateFilename'), 'exclude': lambda f: f is None }})  
    certificate_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificatePassword'), 'exclude': lambda f: f is None }})  
    certificate_upload_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateUploadId'), 'exclude': lambda f: f is None }})  
    force_legacy_build_system: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('forceLegacyBuildSystem'), 'exclude': lambda f: f is None }})
    r"""Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.
    By default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.
    """  
    podfile_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('podfilePath'), 'exclude': lambda f: f is None }})
    r"""Path to CococaPods file, if present"""  
    project_or_workspace_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('projectOrWorkspacePath'), 'exclude': lambda f: f is None }})
    r"""Xcode project/workspace path"""  
    provisioning_profile_encoded: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileEncoded'), 'exclude': lambda f: f is None }})  
    provisioning_profile_file_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileFileId'), 'exclude': lambda f: f is None }})  
    provisioning_profile_filename: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileFilename'), 'exclude': lambda f: f is None }})  
    provisioning_profile_upload_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileUploadId'), 'exclude': lambda f: f is None }})  
    scheme: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scheme'), 'exclude': lambda f: f is None }})  
    target_to_archive: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targetToArchive'), 'exclude': lambda f: f is None }})
    r"""The target id of the selected scheme to archive"""  
    team_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('teamId'), 'exclude': lambda f: f is None }})  
    xcode_project_sha: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xcodeProjectSha'), 'exclude': lambda f: f is None }})
    r"""The selected pbxproject hash to the repositroy"""  
    xcode_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xcodeVersion'), 'exclude': lambda f: f is None }})
    r"""Xcode version used to build. Available versions can be found in \\"/xcode_versions\\" API. Default is latest stable version, at the time when the configuration is set."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBodyToolsets:
    r"""The branch build configuration for each toolset"""
    
    android: Optional[BranchConfigurationsUpdateRequestBodyToolsetsAndroid] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('android'), 'exclude': lambda f: f is None }})
    r"""Build configuration for Android projects"""  
    javascript: Optional[BranchConfigurationsUpdateRequestBodyToolsetsJavascript] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('javascript'), 'exclude': lambda f: f is None }})
    r"""Build configuration when React Native, or other JavaScript tech, is part of the build steps"""  
    xamarin: Optional[BranchConfigurationsUpdateRequestBodyToolsetsXamarin] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xamarin'), 'exclude': lambda f: f is None }})
    r"""Build configuration for Xamarin projects"""  
    xcode: Optional[BranchConfigurationsUpdateRequestBodyToolsetsXcode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xcode'), 'exclude': lambda f: f is None }})
    r"""Build configuration when Xcode is part of the build steps"""  
    
class BranchConfigurationsUpdateRequestBodyTriggerEnum(str, Enum):
    CONTINOUS = 'continous'
    CONTINUOUS = 'continuous'
    MANUAL = 'manual'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdateRequestBody:
    r"""The branch build configuration"""
    
    artifact_versioning: Optional[BranchConfigurationsUpdateRequestBodyArtifactVersioning] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('artifactVersioning'), 'exclude': lambda f: f is None }})
    r"""The versioning configuration for artifacts built for this branch"""  
    badge_is_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('badgeIsEnabled'), 'exclude': lambda f: f is None }})  
    clone_from_branch: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cloneFromBranch'), 'exclude': lambda f: f is None }})
    r"""A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests."""  
    signed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('signed'), 'exclude': lambda f: f is None }})  
    tests_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('testsEnabled'), 'exclude': lambda f: f is None }})  
    toolsets: Optional[BranchConfigurationsUpdateRequestBodyToolsets] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('toolsets'), 'exclude': lambda f: f is None }})
    r"""The branch build configuration for each toolset"""  
    trigger: Optional[BranchConfigurationsUpdateRequestBodyTriggerEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trigger'), 'exclude': lambda f: f is None }})  
    

@dataclasses.dataclass
class BranchConfigurationsUpdateRequest:
    
    app_name: str = dataclasses.field(metadata={'path_param': { 'field_name': 'app_name', 'style': 'simple', 'explode': False }})
    r"""The name of the application"""  
    branch: str = dataclasses.field(metadata={'path_param': { 'field_name': 'branch', 'style': 'simple', 'explode': False }})
    r"""The branch name"""  
    owner_name: str = dataclasses.field(metadata={'path_param': { 'field_name': 'owner_name', 'style': 'simple', 'explode': False }})
    r"""The name of the owner"""  
    request_body: BranchConfigurationsUpdateRequestBody = dataclasses.field(metadata={'request': { 'media_type': 'application/json' }})
    r"""Parameters of the configuration"""  
    
class BranchConfigurationsUpdate200ApplicationJSONArtifactVersioningBuildNumberFormatEnum(str, Enum):
    BUILD_ID = 'buildId'
    TIMESTAMP = 'timestamp'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONArtifactVersioning:
    r"""The versioning configuration for artifacts built for this branch"""
    
    build_number_format: Optional[BranchConfigurationsUpdate200ApplicationJSONArtifactVersioningBuildNumberFormatEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('buildNumberFormat'), 'exclude': lambda f: f is None }})  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONToolsetsAndroid:
    r"""Build configuration for Android projects"""
    
    automatic_signing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('automaticSigning'), 'exclude': lambda f: f is None }})
    r"""Whether to apply automatic signing or not"""  
    build_variant: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('buildVariant'), 'exclude': lambda f: f is None }})
    r"""The Android build variant to build"""  
    gradle_wrapper_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gradleWrapperPath'), 'exclude': lambda f: f is None }})
    r"""Path to the Gradle wrapper script"""  
    is_root: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isRoot'), 'exclude': lambda f: f is None }})
    r"""Whether it is the root module or not"""  
    key_alias: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keyAlias'), 'exclude': lambda f: f is None }})
    r"""The key alias"""  
    key_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keyPassword'), 'exclude': lambda f: f is None }})
    r"""The key password"""  
    keystore_encoded: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keystoreEncoded'), 'exclude': lambda f: f is None }})
    r"""The keystore encoded value"""  
    keystore_filename: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keystoreFilename'), 'exclude': lambda f: f is None }})
    r"""The name of the keystore file"""  
    keystore_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keystorePassword'), 'exclude': lambda f: f is None }})
    r"""The password of the keystore"""  
    module: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('module'), 'exclude': lambda f: f is None }})
    r"""The Gradle module to build"""  
    run_lint: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runLint'), 'exclude': lambda f: f is None }})
    r"""Whether to run lint checks during the build (default)"""  
    run_tests: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runTests'), 'exclude': lambda f: f is None }})
    r"""Whether to run unit tests during the build (default)"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONToolsetsJavascript:
    r"""Build configuration when React Native, or other JavaScript tech, is part of the build steps"""
    
    package_json_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('packageJsonPath'), 'exclude': lambda f: f is None }})
    r"""Path to package.json file for the main project, e.g. \\"package.json\\" or \\"myapp/package.json\\" """  
    react_native_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('reactNativeVersion'), 'exclude': lambda f: f is None }})
    r"""Version of React Native from package.json files"""  
    run_tests: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('runTests'), 'exclude': lambda f: f is None }})
    r"""Whether to run Jest unit tests, via npm test, during the build"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONToolsetsXamarin:
    r"""Build configuration for Xamarin projects"""
    
    args: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('args'), 'exclude': lambda f: f is None }})  
    configuration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('configuration'), 'exclude': lambda f: f is None }})  
    is_sim_build: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isSimBuild'), 'exclude': lambda f: f is None }})  
    mono_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('monoVersion'), 'exclude': lambda f: f is None }})  
    p12_file: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('p12File'), 'exclude': lambda f: f is None }})  
    p12_pwd: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('p12Pwd'), 'exclude': lambda f: f is None }})  
    prov_profile: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provProfile'), 'exclude': lambda f: f is None }})  
    sdk_bundle: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sdkBundle'), 'exclude': lambda f: f is None }})  
    sln_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('slnPath'), 'exclude': lambda f: f is None }})  
    symlink: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('symlink'), 'exclude': lambda f: f is None }})
    r"""Symlink of the SDK Bundle and Mono installation.
    The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink is passed, the current stable Mono version will be configured for building.
    """  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONToolsetsXcodeAppExtensionProvisioningProfileFiles:
    r"""Provisioning profile fetch and store information"""
    
    file_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fileId'), 'exclude': lambda f: f is None }})
    r"""File id from secure file storage"""  
    file_name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('fileName'), 'exclude': lambda f: f is None }})
    r"""Name of uploaded provisioning profile"""  
    target_bundle_identifier: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targetBundleIdentifier'), 'exclude': lambda f: f is None }})
    r"""Target the provisioning profile is used to sign"""  
    upload_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('uploadId'), 'exclude': lambda f: f is None }})
    r"""Upload id to App Center File Upload Store"""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONToolsetsXcode:
    r"""Build configuration when Xcode is part of the build steps"""
    
    app_extension_provisioning_profile_files: Optional[list[BranchConfigurationsUpdate200ApplicationJSONToolsetsXcodeAppExtensionProvisioningProfileFiles]] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('appExtensionProvisioningProfileFiles'), 'exclude': lambda f: f is None }})  
    archive_configuration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('archiveConfiguration'), 'exclude': lambda f: f is None }})
    r"""The build configuration of the target to archive"""  
    automatic_signing: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('automaticSigning'), 'exclude': lambda f: f is None }})  
    cartfile_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cartfilePath'), 'exclude': lambda f: f is None }})
    r"""Path to Carthage file, if present"""  
    certificate_encoded: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateEncoded'), 'exclude': lambda f: f is None }})  
    certificate_file_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateFileId'), 'exclude': lambda f: f is None }})  
    certificate_filename: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateFilename'), 'exclude': lambda f: f is None }})  
    certificate_password: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificatePassword'), 'exclude': lambda f: f is None }})  
    certificate_upload_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('certificateUploadId'), 'exclude': lambda f: f is None }})  
    force_legacy_build_system: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('forceLegacyBuildSystem'), 'exclude': lambda f: f is None }})
    r"""Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting from workspace settings is used.
    By default new build system is used if workspace setting is not committed to the repository. Only used for iOS React Native app, with Xcode 10.
    """  
    podfile_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('podfilePath'), 'exclude': lambda f: f is None }})
    r"""Path to CococaPods file, if present"""  
    project_or_workspace_path: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('projectOrWorkspacePath'), 'exclude': lambda f: f is None }})
    r"""Xcode project/workspace path"""  
    provisioning_profile_encoded: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileEncoded'), 'exclude': lambda f: f is None }})  
    provisioning_profile_file_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileFileId'), 'exclude': lambda f: f is None }})  
    provisioning_profile_filename: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileFilename'), 'exclude': lambda f: f is None }})  
    provisioning_profile_upload_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('provisioningProfileUploadId'), 'exclude': lambda f: f is None }})  
    scheme: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('scheme'), 'exclude': lambda f: f is None }})  
    target_to_archive: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('targetToArchive'), 'exclude': lambda f: f is None }})
    r"""The target id of the selected scheme to archive"""  
    team_id: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('teamId'), 'exclude': lambda f: f is None }})  
    xcode_project_sha: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xcodeProjectSha'), 'exclude': lambda f: f is None }})
    r"""The selected pbxproject hash to the repositroy"""  
    xcode_version: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xcodeVersion'), 'exclude': lambda f: f is None }})
    r"""Xcode version used to build. Available versions can be found in \\"/xcode_versions\\" API. Default is latest stable version, at the time when the configuration is set."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSONToolsets:
    r"""The branch build configuration for each toolset"""
    
    android: Optional[BranchConfigurationsUpdate200ApplicationJSONToolsetsAndroid] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('android'), 'exclude': lambda f: f is None }})
    r"""Build configuration for Android projects"""  
    javascript: Optional[BranchConfigurationsUpdate200ApplicationJSONToolsetsJavascript] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('javascript'), 'exclude': lambda f: f is None }})
    r"""Build configuration when React Native, or other JavaScript tech, is part of the build steps"""  
    xamarin: Optional[BranchConfigurationsUpdate200ApplicationJSONToolsetsXamarin] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xamarin'), 'exclude': lambda f: f is None }})
    r"""Build configuration for Xamarin projects"""  
    xcode: Optional[BranchConfigurationsUpdate200ApplicationJSONToolsetsXcode] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('xcode'), 'exclude': lambda f: f is None }})
    r"""Build configuration when Xcode is part of the build steps"""  
    
class BranchConfigurationsUpdate200ApplicationJSONTriggerEnum(str, Enum):
    CONTINOUS = 'continous'
    CONTINUOUS = 'continuous'
    MANUAL = 'manual'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class BranchConfigurationsUpdate200ApplicationJSON:
    r"""The branch build configuration"""
    
    id: int = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('id') }})  
    artifact_versioning: Optional[BranchConfigurationsUpdate200ApplicationJSONArtifactVersioning] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('artifactVersioning'), 'exclude': lambda f: f is None }})
    r"""The versioning configuration for artifacts built for this branch"""  
    badge_is_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('badgeIsEnabled'), 'exclude': lambda f: f is None }})  
    clone_from_branch: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cloneFromBranch'), 'exclude': lambda f: f is None }})
    r"""A configured branch name to clone from. If provided, all other parameters will be ignored. Only supported in POST requests."""  
    signed: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('signed'), 'exclude': lambda f: f is None }})  
    tests_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('testsEnabled'), 'exclude': lambda f: f is None }})  
    toolsets: Optional[BranchConfigurationsUpdate200ApplicationJSONToolsets] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('toolsets'), 'exclude': lambda f: f is None }})
    r"""The branch build configuration for each toolset"""  
    trigger: Optional[BranchConfigurationsUpdate200ApplicationJSONTriggerEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('trigger'), 'exclude': lambda f: f is None }})  
    

@dataclasses.dataclass
class BranchConfigurationsUpdateResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    branch_configurations_update_200_application_json_object: Optional[BranchConfigurationsUpdate200ApplicationJSON] = dataclasses.field(default=None)
    r"""Success"""  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    