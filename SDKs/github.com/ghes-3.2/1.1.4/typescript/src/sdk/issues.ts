/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Interact with GitHub Issues.
 */
export class Issues {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Add assignees to an issue
   *
   * @remarks
   * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#add-assignees-to-an-issue} - API method documentation
   */
  issuesAddAssignees(
    req: operations.IssuesAddAssigneesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesAddAssigneesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesAddAssigneesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/assignees",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesAddAssigneesResponse =
        new operations.IssuesAddAssigneesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data, shared.Issue);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Add labels to an issue
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#add-labels-to-an-issue} - API method documentation
   */
  issuesAddLabels(
    req: operations.IssuesAddLabelsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesAddLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesAddLabelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/labels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesAddLabelsResponse =
        new operations.IssuesAddLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labels = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.labels = utils.objectToClass(
              httpRes?.data,
              shared.Label,
              resFieldDepth
            );
          }
          break;
        case [301, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Check if a user can be assigned
   *
   * @remarks
   * Checks if a user has permission to be assigned to an issue in this repository.
   *
   * If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
   *
   * Otherwise a `404` status code is returned.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#check-if-a-user-can-be-assigned} - API method documentation
   */
  issuesCheckUserCanBeAssigned(
    req: operations.IssuesCheckUserCanBeAssignedRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesCheckUserCanBeAssignedResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesCheckUserCanBeAssignedRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/assignees/{assignee}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesCheckUserCanBeAssignedResponse =
        new operations.IssuesCheckUserCanBeAssignedResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an issue
   *
   * @remarks
   * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
   *
   * This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.2/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.2/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.2/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#create-an-issue} - API method documentation
   */
  issuesCreate(
    req: operations.IssuesCreateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesCreateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesCreateResponse =
        new operations.IssuesCreateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data, shared.Issue);
          }
          break;
        case [403, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issuesCreate503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IssuesCreate503ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create an issue comment
   *
   * @remarks
   * This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.2/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.2/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.2/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#create-an-issue-comment} - API method documentation
   */
  issuesCreateComment(
    req: operations.IssuesCreateCommentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesCreateCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesCreateCommentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/comments",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesCreateCommentResponse =
        new operations.IssuesCreateCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComment = utils.objectToClass(
              httpRes?.data,
              shared.IssueComment
            );
          }
          break;
        case [403, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a label
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#create-a-label} - API method documentation
   */
  issuesCreateLabel(
    req: operations.IssuesCreateLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesCreateLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesCreateLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/labels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesCreateLabelResponse =
        new operations.IssuesCreateLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.label = utils.objectToClass(httpRes?.data, shared.Label);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a milestone
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#create-a-milestone} - API method documentation
   */
  issuesCreateMilestone(
    req: operations.IssuesCreateMilestoneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesCreateMilestoneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesCreateMilestoneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/milestones",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesCreateMilestoneResponse =
        new operations.IssuesCreateMilestoneResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 201:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.milestone = utils.objectToClass(
              httpRes?.data,
              shared.Milestone
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Delete an issue comment
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#delete-an-issue-comment} - API method documentation
   */
  issuesDeleteComment(
    req: operations.IssuesDeleteCommentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesDeleteCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesDeleteCommentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/comments/{comment_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesDeleteCommentResponse =
        new operations.IssuesDeleteCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a label
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#delete-a-label} - API method documentation
   */
  issuesDeleteLabel(
    req: operations.IssuesDeleteLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesDeleteLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesDeleteLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/labels/{name}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesDeleteLabelResponse =
        new operations.IssuesDeleteLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
      }

      return res;
    });
  }

  /**
   * Delete a milestone
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#delete-a-milestone} - API method documentation
   */
  issuesDeleteMilestone(
    req: operations.IssuesDeleteMilestoneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesDeleteMilestoneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesDeleteMilestoneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/milestones/{milestone_number}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesDeleteMilestoneResponse =
        new operations.IssuesDeleteMilestoneResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get an issue
   *
   * @remarks
   * The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.2/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
   * [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
   * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
   * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
   * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
   * to the [`issues`](https://docs.github.com/enterprise-server@3.2/webhooks/event-payloads/#issues) webhook.
   *
   * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.2/rest/reference/pulls#list-pull-requests)" endpoint.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#get-an-issue} - API method documentation
   */
  issuesGet(
    req: operations.IssuesGetRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesGetRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesGetResponse =
        new operations.IssuesGetResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data, shared.Issue);
          }
          break;
        case [301, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 304:
          break;
      }

      return res;
    });
  }

  /**
   * Get an issue comment
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#get-an-issue-comment} - API method documentation
   */
  issuesGetComment(
    req: operations.IssuesGetCommentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesGetCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesGetCommentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/comments/{comment_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesGetCommentResponse =
        new operations.IssuesGetCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComment = utils.objectToClass(
              httpRes?.data,
              shared.IssueComment
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get an issue event
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#get-an-issue-event} - API method documentation
   */
  issuesGetEvent(
    req: operations.IssuesGetEventRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesGetEventResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesGetEventRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/events/{event_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesGetEventResponse =
        new operations.IssuesGetEventResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueEvent = utils.objectToClass(
              httpRes?.data,
              shared.IssueEvent
            );
          }
          break;
        case [403, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a label
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#get-a-label} - API method documentation
   */
  issuesGetLabel(
    req: operations.IssuesGetLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesGetLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesGetLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/labels/{name}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesGetLabelResponse =
        new operations.IssuesGetLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.label = utils.objectToClass(httpRes?.data, shared.Label);
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a milestone
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#get-a-milestone} - API method documentation
   */
  issuesGetMilestone(
    req: operations.IssuesGetMilestoneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesGetMilestoneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesGetMilestoneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/milestones/{milestone_number}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesGetMilestoneResponse =
        new operations.IssuesGetMilestoneResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.milestone = utils.objectToClass(
              httpRes?.data,
              shared.Milestone
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List issues assigned to the authenticated user
   *
   * @remarks
   * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
   * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
   * necessarily assigned to you.
   *
   *
   * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.2/rest/reference/pulls#list-pull-requests)" endpoint.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-issues-assigned-to-the-authenticated-user} - API method documentation
   */
  issuesList(
    req: operations.IssuesListRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/issues";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListResponse =
        new operations.IssuesListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issues = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issues = utils.objectToClass(
              httpRes?.data,
              shared.Issue,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List assignees
   *
   * @remarks
   * Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-assignees} - API method documentation
   */
  issuesListAssignees(
    req: operations.IssuesListAssigneesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListAssigneesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListAssigneesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/assignees",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListAssigneesResponse =
        new operations.IssuesListAssigneesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.simpleUsers = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.simpleUsers = utils.objectToClass(
              httpRes?.data,
              shared.SimpleUser,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List issue comments
   *
   * @remarks
   * Issue Comments are ordered by ascending ID.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-issue-comments} - API method documentation
   */
  issuesListComments(
    req: operations.IssuesListCommentsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListCommentsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListCommentsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/comments",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListCommentsResponse =
        new operations.IssuesListCommentsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComments = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issueComments = utils.objectToClass(
              httpRes?.data,
              shared.IssueComment,
              resFieldDepth
            );
          }
          break;
        case [404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List issue comments for a repository
   *
   * @remarks
   * By default, Issue Comments are ordered by ascending ID.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-issue-comments-for-a-repository} - API method documentation
   */
  issuesListCommentsForRepo(
    req: operations.IssuesListCommentsForRepoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListCommentsForRepoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListCommentsForRepoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/comments",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListCommentsForRepoResponse =
        new operations.IssuesListCommentsForRepoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComments = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issueComments = utils.objectToClass(
              httpRes?.data,
              shared.IssueComment,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List issue events
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-issue-events} - API method documentation
   */
  issuesListEvents(
    req: operations.IssuesListEventsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/events",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListEventsResponse =
        new operations.IssuesListEventsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueEventForIssues = utils.objectToClass(httpRes?.data);
          }
          break;
        case httpRes?.status == 410:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List issue events for a repository
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-issue-events-for-a-repository} - API method documentation
   */
  issuesListEventsForRepo(
    req: operations.IssuesListEventsForRepoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListEventsForRepoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListEventsForRepoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/events",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListEventsForRepoResponse =
        new operations.IssuesListEventsForRepoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueEvents = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issueEvents = utils.objectToClass(
              httpRes?.data,
              shared.IssueEvent,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List timeline events for an issue
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-timeline-events-for-an-issue} - API method documentation
   */
  issuesListEventsForTimeline(
    req: operations.IssuesListEventsForTimelineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListEventsForTimelineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListEventsForTimelineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/timeline",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListEventsForTimelineResponse =
        new operations.IssuesListEventsForTimelineResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.timelineIssueEvents = utils.objectToClass(httpRes?.data);
          }
          break;
        case [404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List user account issues assigned to the authenticated user
   *
   * @remarks
   * List issues across owned and member repositories assigned to the authenticated user.
   *
   * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.2/rest/reference/pulls#list-pull-requests)" endpoint.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-user-account-issues-assigned-to-the-authenticated-user} - API method documentation
   */
  issuesListForAuthenticatedUser(
    req: operations.IssuesListForAuthenticatedUserRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListForAuthenticatedUserResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListForAuthenticatedUserRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/user/issues";

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListForAuthenticatedUserResponse =
        new operations.IssuesListForAuthenticatedUserResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issues = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issues = utils.objectToClass(
              httpRes?.data,
              shared.Issue,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 304:
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List organization issues assigned to the authenticated user
   *
   * @remarks
   * List issues in an organization assigned to the authenticated user.
   *
   * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.2/rest/reference/pulls#list-pull-requests)" endpoint.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-organization-issues-assigned-to-the-authenticated-user} - API method documentation
   */
  issuesListForOrg(
    req: operations.IssuesListForOrgRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListForOrgResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListForOrgRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/orgs/{org}/issues", req);

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListForOrgResponse =
        new operations.IssuesListForOrgResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issues = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issues = utils.objectToClass(
              httpRes?.data,
              shared.Issue,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List repository issues
   *
   * @remarks
   * List issues in a repository. Only open issues will be listed.
   *
   * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.2/rest/reference/pulls#list-pull-requests)" endpoint.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-repository-issues} - API method documentation
   */
  issuesListForRepo(
    req: operations.IssuesListForRepoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListForRepoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListForRepoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListForRepoResponse =
        new operations.IssuesListForRepoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issues = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.issues = utils.objectToClass(
              httpRes?.data,
              shared.Issue,
              resFieldDepth
            );
          }
          break;
        case [301, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List labels for issues in a milestone
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-labels-for-issues-in-a-milestone} - API method documentation
   */
  issuesListLabelsForMilestone(
    req: operations.IssuesListLabelsForMilestoneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListLabelsForMilestoneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListLabelsForMilestoneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/milestones/{milestone_number}/labels",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListLabelsForMilestoneResponse =
        new operations.IssuesListLabelsForMilestoneResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labels = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.labels = utils.objectToClass(
              httpRes?.data,
              shared.Label,
              resFieldDepth
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List labels for a repository
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-labels-for-a-repository} - API method documentation
   */
  issuesListLabelsForRepo(
    req: operations.IssuesListLabelsForRepoRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListLabelsForRepoResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListLabelsForRepoRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/labels",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListLabelsForRepoResponse =
        new operations.IssuesListLabelsForRepoResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labels = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.labels = utils.objectToClass(
              httpRes?.data,
              shared.Label,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List labels for an issue
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-labels-for-an-issue} - API method documentation
   */
  issuesListLabelsOnIssue(
    req: operations.IssuesListLabelsOnIssueRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListLabelsOnIssueResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListLabelsOnIssueRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/labels",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListLabelsOnIssueResponse =
        new operations.IssuesListLabelsOnIssueResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labels = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.labels = utils.objectToClass(
              httpRes?.data,
              shared.Label,
              resFieldDepth
            );
          }
          break;
        case [301, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * List milestones
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#list-milestones} - API method documentation
   */
  issuesListMilestones(
    req: operations.IssuesListMilestonesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesListMilestonesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesListMilestonesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/milestones",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesListMilestonesResponse =
        new operations.IssuesListMilestonesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
          headers: utils.getHeadersFromResponse(httpRes.headers),
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.milestones = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.milestones = utils.objectToClass(
              httpRes?.data,
              shared.Milestone,
              resFieldDepth
            );
          }
          break;
        case httpRes?.status == 404:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lock an issue
   *
   * @remarks
   * Users with push access can lock an issue or pull request's conversation.
   *
   * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.2/rest/overview/resources-in-the-rest-api#http-verbs)."
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#lock-an-issue} - API method documentation
   */
  issuesLock(
    req: operations.IssuesLockRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesLockResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesLockRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/lock",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesLockResponse =
        new operations.IssuesLockResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [403, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove all labels from an issue
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#remove-all-labels-from-an-issue} - API method documentation
   */
  issuesRemoveAllLabels(
    req: operations.IssuesRemoveAllLabelsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesRemoveAllLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesRemoveAllLabelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/labels",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesRemoveAllLabelsResponse =
        new operations.IssuesRemoveAllLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [301, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove assignees from an issue
   *
   * @remarks
   * Removes one or more assignees from an issue.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#remove-assignees-from-an-issue} - API method documentation
   */
  issuesRemoveAssignees(
    req: operations.IssuesRemoveAssigneesRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesRemoveAssigneesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesRemoveAssigneesRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/assignees",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "delete",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesRemoveAssigneesResponse =
        new operations.IssuesRemoveAssigneesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data, shared.Issue);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Remove a label from an issue
   *
   * @remarks
   * Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#remove-a-label-from-an-issue} - API method documentation
   */
  issuesRemoveLabel(
    req: operations.IssuesRemoveLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesRemoveLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesRemoveLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesRemoveLabelResponse =
        new operations.IssuesRemoveLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labels = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.labels = utils.objectToClass(
              httpRes?.data,
              shared.Label,
              resFieldDepth
            );
          }
          break;
        case [301, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Set labels for an issue
   *
   * @remarks
   * Removes any previous labels and sets the new labels for an issue.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#set-labels-for-an-issue} - API method documentation
   */
  issuesSetLabels(
    req: operations.IssuesSetLabelsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesSetLabelsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesSetLabelsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/labels",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "put",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesSetLabelsResponse =
        new operations.IssuesSetLabelsResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.labels = [];
            const resFieldDepth: number = utils.getResFieldDepth(res);
            res.labels = utils.objectToClass(
              httpRes?.data,
              shared.Label,
              resFieldDepth
            );
          }
          break;
        case [301, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Unlock an issue
   *
   * @remarks
   * Users with push access can unlock an issue's conversation.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#unlock-an-issue} - API method documentation
   */
  issuesUnlock(
    req: operations.IssuesUnlockRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesUnlockResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesUnlockRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}/lock",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesUnlockResponse =
        new operations.IssuesUnlockResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 204:
          break;
        case [403, 404].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an issue
   *
   * @remarks
   * Issue owners and users with push access can edit an issue.
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues/#update-an-issue} - API method documentation
   */
  issuesUpdate(
    req: operations.IssuesUpdateRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesUpdateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesUpdateRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/{issue_number}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesUpdateResponse =
        new operations.IssuesUpdateResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issue = utils.objectToClass(httpRes?.data, shared.Issue);
          }
          break;
        case [301, 403, 404, 410].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.basicError = utils.objectToClass(
              httpRes?.data,
              shared.BasicError
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
        case httpRes?.status == 503:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issuesUpdate503ApplicationJSONObject = utils.objectToClass(
              httpRes?.data,
              operations.IssuesUpdate503ApplicationJSON
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update an issue comment
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#update-an-issue-comment} - API method documentation
   */
  issuesUpdateComment(
    req: operations.IssuesUpdateCommentRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesUpdateCommentResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesUpdateCommentRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/issues/comments/{comment_id}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesUpdateCommentResponse =
        new operations.IssuesUpdateCommentResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.issueComment = utils.objectToClass(
              httpRes?.data,
              shared.IssueComment
            );
          }
          break;
        case httpRes?.status == 422:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.validationError = utils.objectToClass(
              httpRes?.data,
              shared.ValidationError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a label
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#update-a-label} - API method documentation
   */
  issuesUpdateLabel(
    req: operations.IssuesUpdateLabelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesUpdateLabelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesUpdateLabelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/labels/{name}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesUpdateLabelResponse =
        new operations.IssuesUpdateLabelResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.label = utils.objectToClass(httpRes?.data, shared.Label);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a milestone
   *
   * @see {@link https://docs.github.com/enterprise-server@3.2/rest/reference/issues#update-a-milestone} - API method documentation
   */
  issuesUpdateMilestone(
    req: operations.IssuesUpdateMilestoneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.IssuesUpdateMilestoneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.IssuesUpdateMilestoneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/repos/{owner}/{repo}/milestones/{milestone_number}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.IssuesUpdateMilestoneResponse =
        new operations.IssuesUpdateMilestoneResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.milestone = utils.objectToClass(
              httpRes?.data,
              shared.Milestone
            );
          }
          break;
      }

      return res;
    });
  }
}
