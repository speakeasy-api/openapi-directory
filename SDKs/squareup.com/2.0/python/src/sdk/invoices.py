"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Invoices:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def cancel_invoice(self, request: operations.CancelInvoiceRequest, security: operations.CancelInvoiceSecurity) -> operations.CancelInvoiceResponse:
        r"""CancelInvoice
        Cancels an invoice. The seller cannot collect payments for 
        the canceled invoice.
        
        You cannot cancel an invoice in the `DRAFT` state or in a terminal state: `PAID`, `REFUNDED`, `CANCELED`, or `FAILED`.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CancelInvoiceRequest, base_url, '/v2/invoices/{invoice_id}/cancel', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "cancel_invoice_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CancelInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CancelInvoiceResponse])
                res.cancel_invoice_response = out

        return res

    def create_invoice(self, request: shared.CreateInvoiceRequest, security: operations.CreateInvoiceSecurity) -> operations.CreateInvoiceResponse:
        r"""CreateInvoice
        Creates a draft [invoice](https://developer.squareup.com/reference/square_2021-08-18/objects/Invoice) 
        for an order created using the Orders API.
        
        A draft invoice remains in your account and no action is taken. 
        You must publish the invoice before Square can process it (send it to the customer's email address or charge the customerâ€™s card on file).
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/invoices'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreateInvoiceResponse])
                res.create_invoice_response = out

        return res

    def delete_invoice(self, request: operations.DeleteInvoiceRequest, security: operations.DeleteInvoiceSecurity) -> operations.DeleteInvoiceResponse:
        r"""DeleteInvoice
        Deletes the specified invoice. When an invoice is deleted, the 
        associated order status changes to CANCELED. You can only delete a draft 
        invoice (you cannot delete a published invoice, including one that is scheduled for processing).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteInvoiceRequest, base_url, '/v2/invoices/{invoice_id}', request)
        
        query_params = utils.get_query_params(operations.DeleteInvoiceRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('DELETE', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.DeleteInvoiceResponse])
                res.delete_invoice_response = out

        return res

    def get_invoice(self, request: operations.GetInvoiceRequest, security: operations.GetInvoiceSecurity) -> operations.GetInvoiceResponse:
        r"""GetInvoice
        Retrieves an invoice by invoice ID.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetInvoiceRequest, base_url, '/v2/invoices/{invoice_id}', request)
        
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GetInvoiceResponse])
                res.get_invoice_response = out

        return res

    def list_invoices(self, request: operations.ListInvoicesRequest, security: operations.ListInvoicesSecurity) -> operations.ListInvoicesResponse:
        r"""ListInvoices
        Returns a list of invoices for a given location. The response 
        is paginated. If truncated, the response includes a `cursor` that you    
        use in a subsequent request to retrieve the next set of invoices.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/invoices'
        
        query_params = utils.get_query_params(operations.ListInvoicesRequest, request)
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListInvoicesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ListInvoicesResponse])
                res.list_invoices_response = out

        return res

    def publish_invoice(self, request: operations.PublishInvoiceRequest, security: operations.PublishInvoiceSecurity) -> operations.PublishInvoiceResponse:
        r"""PublishInvoice
        Publishes the specified draft invoice. 
        
        After an invoice is published, Square 
        follows up based on the invoice configuration. For example, Square 
        sends the invoice to the customer's email address, charges the customer's card on file, or does 
        nothing. Square also makes the invoice available on a Square-hosted invoice page. 
        
        The invoice `status` also changes from `DRAFT` to a status 
        based on the invoice configuration. For example, the status changes to `UNPAID` if 
        Square emails the invoice or `PARTIALLY_PAID` if Square charge a card on file for a portion of the 
        invoice amount.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PublishInvoiceRequest, base_url, '/v2/invoices/{invoice_id}/publish', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "publish_invoice_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PublishInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.PublishInvoiceResponse])
                res.publish_invoice_response = out

        return res

    def search_invoices(self, request: shared.SearchInvoicesRequest, security: operations.SearchInvoicesSecurity) -> operations.SearchInvoicesResponse:
        r"""SearchInvoices
        Searches for invoices from a location specified in 
        the filter. You can optionally specify customers in the filter for whom to 
        retrieve invoices. In the current implementation, you can only specify one location and 
        optionally one customer.
        
        The response is paginated. If truncated, the response includes a `cursor` 
        that you use in a subsequent request to retrieve the next set of invoices.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v2/invoices/search'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchInvoicesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.SearchInvoicesResponse])
                res.search_invoices_response = out

        return res

    def update_invoice(self, request: operations.UpdateInvoiceRequest, security: operations.UpdateInvoiceSecurity) -> operations.UpdateInvoiceResponse:
        r"""UpdateInvoice
        Updates an invoice by modifying fields, clearing fields, or both. For most updates, you can use a sparse 
        `Invoice` object to add fields or change values and use the `fields_to_clear` field to specify fields to clear. 
        However, some restrictions apply. For example, you cannot change the `order_id` or `location_id` field and you 
        must provide the complete `custom_fields` list to update a custom field. Published invoices have additional restrictions.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateInvoiceRequest, base_url, '/v2/invoices/{invoice_id}', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_invoice_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = utils.configure_security_client(self._client, security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateInvoiceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UpdateInvoiceResponse])
                res.update_invoice_response = out

        return res

    