"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class AddressSearch:
    r"""Global address autocomplete, for search-as-you-type"""
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def address_autocomplete(self, request: operations.AddressAutocompleteRequest) -> operations.AddressAutocompleteResponse:
        r"""Find Address
        The address autocomplete API returns a list of address suggestions that match the query ordered by relevance.
        
        This API can be used to power realtime address finders, also known as address autofill or address autocomplete.
        
        Consider using our Address Autocomplete JavaScript libraries to add address lookup to a form in moments.
        
        ## Implementing Address Autocomplete
        
        Rapid address autocompletion using our Address Autocomplete API is a 2 step process.
        
        1. Retrieve partial address suggestions via `/autocomplete/addresses`
        2. Retrieve the entire address with the ID provided in the suggestion
        
        Step 2 will decrement your lookup balance.
        
        Please note, this API is not intended to be a free standalone resource.
        
        ## Filters
        
        You can strictly narrow your result by adding filters to your querystring. For instance, you can restrict to postcode `SW1A 2AA` by appending `postcode=sw1a2aa`.
        
        If a filter term is invalid, e.g. `postcode=SW1A2AAA`, then an empty result set is returned and no lookup is incurred.
        
        You can also scope using multiple terms for the same filter with a comma separated list of terms. E.g. Restrict results to E1, E2 and E3 outward codes: `postcode_outward=e1,e2,e3`. Multiple terms are `OR`'ed, i.e. the matching result sets are combined.
        
        All filters can accept multiple terms unless stated otherwise below.
        
        Filters can also be combined. E.g. Restrict results to small user organisations in the N postcode area: `su_organisation_indicator=Y&postcode_area=n`. Multiple filters are `AND`'ed, i.e. each additional filter narrows the result set.
        
        A maximum of **10** terms are allowed across all filters.
        
        ## Biases
        
        You can boost certain addresses results that match specific address criteria. All bias searches are prefixed with `bias_`.
        
        Biasing (unlike filtering) also allow unmatched addresses to appear with lower precedence.
        
        For instance, can boost addresses with postcode areas `SW` and `SE` by appending `bias_postcode_area=SW,SE`.
        
        No bias effect applies to bias terms that are invalid. e.g. `bias_postcode=SW1A2AAA`
        
        You may scope using multiple terms for the same bias with a comma separated list of terms. E.g. Restrict results to `E1`, `E2` and `E3` outward codes: <code>bias_postcode_outward=e1,e2,e3</code>.
        
        All biases can accept multiple terms unless stated otherwise below.
        
        A combined maximum of **5** terms are allowed across all biases.
        
        ## Suggestion Format
        
        The suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as-is.
        
        ## Rate Limiting
        
        You can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.
        
        | Header                  | Description                                                                            |
        | ----------------------- | -------------------------------------------------------------------------------------- |
        | `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |
        | `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |
        | `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |
        
        ## Pricing
        
        This API currently does not affect your balance. However, resolving a suggestion into a full address requires a paid request.
        
        Please note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/autocomplete/addresses'
        
        query_params = utils.get_query_params(operations.AddressAutocompleteRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.AddressAutocompleteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.AutocompleteResponse])
                res.autocomplete_response = out
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.BadRequestResponse])
                res.bad_request_response = out

        return res

    def resolve(self, request: operations.ResolveRequest) -> operations.ResolveResponse:
        r"""Resolve Address (GBR)
        Resolves an address autocompletion by its address ID.
        
        Resolved addresses (including global addresses) are returned in a UK format (up to 3 address lines) using UK nomenclature (like postcode and county).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ResolveRequest, base_url, '/autocomplete/addresses/{address}/gbr', request)
        
        query_params = utils.get_query_params(operations.ResolveRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ResolveResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GbrResolveAddressResponse])
                res.gbr_resolve_address_response = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def resolve_usa(self, request: operations.ResolveUsaRequest) -> operations.ResolveUsaResponse:
        r"""Resolve Address (USA)
        Resolves an address autocompletion by its address ID.
        
        Resolved addresses (including global addresses) are returned in a US format (up to 2 address lines) using US nomenclature (like zipcode, state and city).
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ResolveUsaRequest, base_url, '/autocomplete/addresses/{address}/usa', request)
        
        query_params = utils.get_query_params(operations.ResolveUsaRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ResolveUsaResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.UsaResolveAddressResponse])
                res.usa_resolve_address_response = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    