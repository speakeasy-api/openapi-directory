/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class Projects {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Adds an AD trust to a domain.
   */
  managedidentitiesProjectsLocationsGlobalDomainsAttachTrust(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:attachTrust",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "attachTrustRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsAttachTrustResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a Backup for a domain.
   */
  managedidentitiesProjectsLocationsGlobalDomainsBackupsCreate(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/backups", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "backupInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists Backup in a given project.
   */
  managedidentitiesProjectsLocationsGlobalDomainsBackupsList(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/backups", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsBackupsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listBackupsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListBackupsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a Microsoft AD domain.
   */
  managedidentitiesProjectsLocationsGlobalDomainsCreate(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/domains", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "domainInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Removes an AD trust.
   */
  managedidentitiesProjectsLocationsGlobalDomainsDetachTrust(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:detachTrust",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "detachTrustRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsDetachTrustResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Extend Schema for Domain
   */
  managedidentitiesProjectsLocationsGlobalDomainsExtendSchema(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{domain}:extendSchema",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "extendSchemaRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsExtendSchemaResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the domain ldaps settings.
   */
  managedidentitiesProjectsLocationsGlobalDomainsGetLdapssettings(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/ldapssettings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsGetLdapssettingsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.ldapsSettings = utils.objectToClass(
              httpRes?.data,
              shared.LDAPSSettings
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists domains in a project.
   */
  managedidentitiesProjectsLocationsGlobalDomainsList(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsListRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{parent}/domains", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsListResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listDomainsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListDomainsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the DNS conditional forwarder.
   */
  managedidentitiesProjectsLocationsGlobalDomainsReconfigureTrust(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:reconfigureTrust",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "reconfigureTrustRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsReconfigureTrustResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Resets a domain's administrator password.
   */
  managedidentitiesProjectsLocationsGlobalDomainsResetAdminPassword(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:resetAdminPassword",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsResetAdminPasswordResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.resetAdminPasswordResponse = utils.objectToClass(
              httpRes?.data,
              shared.ResetAdminPasswordResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * RestoreDomain restores domain backup mentioned in the RestoreDomainRequest
   */
  managedidentitiesProjectsLocationsGlobalDomainsRestore(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:restore", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "restoreDomainRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsRestoreResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists SqlIntegrations in a given domain.
   */
  managedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsList(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/sqlIntegrations",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsSqlIntegrationsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listSqlIntegrationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListSqlIntegrationsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Patches a single ldaps settings.
   */
  managedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettings(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}/ldapssettings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "ldapsSettingsInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsUpdateLdapssettingsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Validates a trust state, that the target domain is reachable, and that the target domain is able to accept incoming trust requests.
   */
  managedidentitiesProjectsLocationsGlobalDomainsValidateTrust(
    req: operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{name}:validateTrust",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "validateTrustRequestInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalDomainsValidateTrustResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
   */
  managedidentitiesProjectsLocationsGlobalOperationsCancel(
    req: operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}:cancel", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "requestBody",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalOperationsCancelResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.empty = utils.objectToClass(httpRes?.data);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Creates a Peering for Managed AD instance.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsCreate(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/peerings",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "peeringInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsCreateResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Deletes identified Peering.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsDelete(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsDeleteResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets details of a single Peering.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsGet(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.peering = utils.objectToClass(httpRes?.data, shared.Peering);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicy(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:getIamPolicy",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsGetIamPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists Peerings in a given project.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsList(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{parent}/peerings",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsListResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listPeeringsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListPeeringsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Updates the labels for specified Peering.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsPatch(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}", req);

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "peeringInput",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsPatchResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.operation = utils.objectToClass(
              httpRes?.data,
              shared.Operation
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicy(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicySecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:setIamPolicy",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "setIamPolicyRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicySecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsSetIamPolicyResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.policy = utils.objectToClass(httpRes?.data, shared.Policy);
          }
          break;
      }

      return res;
    });
  }

  /**
   * Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
   */
  managedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissions(
    req: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsRequest,
    security: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsRequest(
          req
        );
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/v1/{resource}:testIamPermissions",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "testIamPermissionsRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsSecurity(
          security
        );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };
    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsResponse =
        new operations.ManagedidentitiesProjectsLocationsGlobalPeeringsTestIamPermissionsResponse(
          {
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
          }
        );
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.testIamPermissionsResponse = utils.objectToClass(
              httpRes?.data,
              shared.TestIamPermissionsResponse
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Lists information about the supported locations for this service.
   */
  managedidentitiesProjectsLocationsList(
    req: operations.ManagedidentitiesProjectsLocationsListRequest,
    security: operations.ManagedidentitiesProjectsLocationsListSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.ManagedidentitiesProjectsLocationsListResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ManagedidentitiesProjectsLocationsListRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/v1/{name}/locations", req);
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.ManagedidentitiesProjectsLocationsListSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const queryParams: string = utils.serializeQueryParams(req);

    const r = client.request({
      url: url + queryParams,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.ManagedidentitiesProjectsLocationsListResponse =
        new operations.ManagedidentitiesProjectsLocationsListResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.listLocationsResponse = utils.objectToClass(
              httpRes?.data,
              shared.ListLocationsResponse
            );
          }
          break;
      }

      return res;
    });
  }
}
