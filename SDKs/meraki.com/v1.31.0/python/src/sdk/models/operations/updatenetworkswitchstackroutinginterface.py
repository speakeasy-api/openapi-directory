"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
import requests as requests_http
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Any, Optional


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkSwitchStackRoutingInterfaceRequestBodyIpv6:
    r"""The IPv6 settings of the interface."""
    
    address: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('address'), 'exclude': lambda f: f is None }})
    r"""The IPv6 address of the interface. Required if assignmentMode is included and set as 'static'. Must not be included if assignmentMode is 'eui-64'."""  
    assignment_mode: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('assignmentMode'), 'exclude': lambda f: f is None }})
    r"""The IPv6 assignment mode for the interface. Can be either 'eui-64' or 'static'."""  
    gateway: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gateway'), 'exclude': lambda f: f is None }})
    r"""The IPv6 default gateway of the interface. Required if prefix is defined and this is the first interface with IPv6 configured for the stack."""  
    prefix: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('prefix'), 'exclude': lambda f: f is None }})
    r"""The IPv6 prefix of the interface. Required if IPv6 object is included and interface does not already have ipv6.prefix configured"""  
    
class UpdateNetworkSwitchStackRoutingInterfaceRequestBodyMulticastRoutingEnum(str, Enum):
    r"""Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'."""
    IGMP_SNOOPING_QUERIER = 'IGMP snooping querier'
    DISABLED = 'disabled'
    ENABLED = 'enabled'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkSwitchStackRoutingInterfaceRequestBodyOspfSettings:
    r"""The OSPF routing settings of the interface."""
    
    area: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('area'), 'exclude': lambda f: f is None }})
    r"""The OSPF area to which this interface should belong. Can be either 'disabled' or the identifier of an existing OSPF area."""  
    cost: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('cost'), 'exclude': lambda f: f is None }})
    r"""The path cost for this interface. Defaults to 1, but can be increased up to 65535 to give lower priority."""  
    is_passive_enabled: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('isPassiveEnabled'), 'exclude': lambda f: f is None }})
    r"""When enabled, OSPF will not run on the interface, but the subnet will still be advertised."""  
    

@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class UpdateNetworkSwitchStackRoutingInterfaceRequestBody:
    
    default_gateway: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('defaultGateway'), 'exclude': lambda f: f is None }})
    r"""The next hop for any traffic that isn't going to a directly connected subnet or over a static route. This IP address must exist in a subnet with a routed interface."""  
    interface_ip: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('interfaceIp'), 'exclude': lambda f: f is None }})
    r"""The IP address this switch stack will use for layer 3 routing on this VLAN or subnet. This cannot be the same as the switch's management IP."""  
    ipv6: Optional[UpdateNetworkSwitchStackRoutingInterfaceRequestBodyIpv6] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ipv6'), 'exclude': lambda f: f is None }})
    r"""The IPv6 settings of the interface."""  
    multicast_routing: Optional[UpdateNetworkSwitchStackRoutingInterfaceRequestBodyMulticastRoutingEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('multicastRouting'), 'exclude': lambda f: f is None }})
    r"""Enable multicast support if, multicast routing between VLANs is required. Options are, 'disabled', 'enabled' or 'IGMP snooping querier'."""  
    name: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('name'), 'exclude': lambda f: f is None }})
    r"""A friendly name or description for the interface or VLAN."""  
    ospf_settings: Optional[UpdateNetworkSwitchStackRoutingInterfaceRequestBodyOspfSettings] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ospfSettings'), 'exclude': lambda f: f is None }})
    r"""The OSPF routing settings of the interface."""  
    subnet: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('subnet'), 'exclude': lambda f: f is None }})
    r"""The network that this routed interface is on, in CIDR notation (ex. 10.1.1.0/24)."""  
    vlan_id: Optional[int] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('vlanId'), 'exclude': lambda f: f is None }})
    r"""The VLAN this routed interface is on. VLAN must be between 1 and 4094."""  
    

@dataclasses.dataclass
class UpdateNetworkSwitchStackRoutingInterfaceRequest:
    
    interface_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'interfaceId', 'style': 'simple', 'explode': False }})  
    network_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'networkId', 'style': 'simple', 'explode': False }})  
    switch_stack_id: str = dataclasses.field(metadata={'path_param': { 'field_name': 'switchStackId', 'style': 'simple', 'explode': False }})  
    request_body: Optional[UpdateNetworkSwitchStackRoutingInterfaceRequestBody] = dataclasses.field(default=None, metadata={'request': { 'media_type': 'application/json' }})  
    

@dataclasses.dataclass
class UpdateNetworkSwitchStackRoutingInterfaceResponse:
    
    content_type: str = dataclasses.field()  
    status_code: int = dataclasses.field()  
    raw_response: Optional[requests_http.Response] = dataclasses.field(default=None)  
    update_network_switch_stack_routing_interface_200_application_json_object: Optional[dict[str, Any]] = dataclasses.field(default=None)
    r"""Successful operation"""  
    