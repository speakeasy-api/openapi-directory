/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * BestSellers - Fields related to the [Best sellers reports](https://support.google.com/merchants/answer/9488679).
 */
public class BestSellers {
    /**
     * Google product category ID to calculate the ranking for, represented in [Google's product taxonomy](https://support.google.com/merchants/answer/6324436). If a `WHERE` condition on `best_sellers.category_id` is not specified in the query, rankings for all top-level categories are returned.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("categoryId")
    public String categoryId;

    public BestSellers withCategoryId(String categoryId) {
        this.categoryId = categoryId;
        return this;
    }
    
    /**
     * Country where the ranking is calculated. A `WHERE` condition on `best_sellers.country_code` is required in the query.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("countryCode")
    public String countryCode;

    public BestSellers withCountryCode(String countryCode) {
        this.countryCode = countryCode;
        return this;
    }
    
    /**
     * Popularity rank in the previous week or month.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("previousRank")
    public String previousRank;

    public BestSellers withPreviousRank(String previousRank) {
        this.previousRank = previousRank;
        return this;
    }
    
    /**
     * Estimated demand in relation to the item with the highest popularity rank in the same category and country in the previous week or month.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("previousRelativeDemand")
    public BestSellersPreviousRelativeDemandEnum previousRelativeDemand;

    public BestSellers withPreviousRelativeDemand(BestSellersPreviousRelativeDemandEnum previousRelativeDemand) {
        this.previousRelativeDemand = previousRelativeDemand;
        return this;
    }
    
    /**
     * Popularity on Shopping ads and free listings, in the selected category and country, based on the estimated number of units sold.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("rank")
    public String rank;

    public BestSellers withRank(String rank) {
        this.rank = rank;
        return this;
    }
    
    /**
     * Estimated demand in relation to the item with the highest popularity rank in the same category and country.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("relativeDemand")
    public BestSellersRelativeDemandEnum relativeDemand;

    public BestSellers withRelativeDemand(BestSellersRelativeDemandEnum relativeDemand) {
        this.relativeDemand = relativeDemand;
        return this;
    }
    
    /**
     * Change in the estimated demand. Whether it rose, sank or remained flat.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("relativeDemandChange")
    public BestSellersRelativeDemandChangeEnum relativeDemandChange;

    public BestSellers withRelativeDemandChange(BestSellersRelativeDemandChangeEnum relativeDemandChange) {
        this.relativeDemandChange = relativeDemandChange;
        return this;
    }
    
    /**
     * Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following: * A full date, with non-zero year, month, and day values. * A month and day, with a zero year (for example, an anniversary). * A year on its own, with a zero month and a zero day. * A year and month, with a zero day (for example, a credit card expiration date). Related types: * google.type.TimeOfDay * google.type.DateTime * google.protobuf.Timestamp
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reportDate")
    public Date reportDate;

    public BestSellers withReportDate(Date reportDate) {
        this.reportDate = reportDate;
        return this;
    }
    
    /**
     * Granularity of the report. The ranking can be done over a week or a month timeframe. A `WHERE` condition on `best_sellers.report_granularity` is required in the query.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("reportGranularity")
    public BestSellersReportGranularityEnum reportGranularity;

    public BestSellers withReportGranularity(BestSellersReportGranularityEnum reportGranularity) {
        this.reportGranularity = reportGranularity;
        return this;
    }
    
    public BestSellers(){}
}
