"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Notifications:
    r"""Notifications are the actions taken to inform users or call third-party endpoints when a certain event happens. Typical actions include emails and callouts. Callouts typically refer to HTTP invocations, such as HTTP calls to REST services.
    
    **NOTE:** Notifications are processed asynchronously and may be delivered with a delay and out of order.
    
    Notifications are associated with Communication Profiles, which allow you to send specific event-driven notifications to targeted customers. Zuora provides the following Settings API to access the settings of Communication Profiles:
      * [Get all Communication Profiles](https://knowledgecenter.zuora.com/DC_Developers/BB_C_Settings_API/Settings_API_tutorials/Get_all_Communication_Profiles)
      * [Create a new Communication Profile](https://knowledgecenter.zuora.com/DC_Developers/BB_C_Settings_API/Settings_API_tutorials/Create_a_new_Communication_Profile)
      * [Modify a Communication Profile](https://knowledgecenter.zuora.com/DC_Developers/BB_C_Settings_API/Settings_API_tutorials/Modify_a_Communication_Profile)
      * [Get all Notifications under a particular Communication Profile](https://knowledgecenter.zuora.com/DC_Developers/BB_C_Settings_API/Settings_API_tutorials/Get_all_Notifications_under_a_particular_Communication_Profile)
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def delete_delete_email_template(self, request: operations.DELETEDELETEEmailTemplateRequest) -> operations.DELETEDELETEEmailTemplateResponse:
        r"""Delete an email template
        Deletes an email template.
        
        **Note**: This operation is only applicable to notifications for custom events.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DELETEDELETEEmailTemplateRequest, base_url, '/notifications/email-templates/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DELETEDELETEEmailTemplateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def delete_delete_notification_definition(self, request: operations.DELETEDELETENotificationDefinitionRequest) -> operations.DELETEDELETENotificationDefinitionResponse:
        r"""Delete a notification definition
        Deletes a notification definition.
        
        **Note**: This operation is only applicable to notifications for custom events.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DELETEDELETENotificationDefinitionRequest, base_url, '/notifications/notification-definitions/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DELETEDELETENotificationDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            res.headers = http_res.headers
            
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def delete_delete_notification_history_for_account(self, request: operations.DELETEDELETENotificationHistoryForAccountRequest) -> operations.DELETEDELETENotificationHistoryForAccountResponse:
        r"""Delete notification histories for an account
        Delete all notification histories for the given account. All email and callout notifications for this account will be deleted upon successful operation.
        
        **Note**: This operation is only available if you have the Notification and the Configurable Event features enabled.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/notifications/history'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.DELETEDELETENotificationHistoryForAccountRequest, request)
        
        client = self._client
        
        http_res = client.request('DELETE', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DELETEDELETENotificationHistoryForAccountResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 202:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NotificationsHistoryDeletionTaskResponse])
                res.notifications_history_deletion_task_response = out
        elif http_res.status_code == 400:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                res.delete_delete_notification_history_for_account_400_application_json_string = http_res.content
        elif http_res.status_code == 404:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_callout_history(self, request: operations.GETCalloutHistoryRequest) -> operations.GETCalloutHistoryResponse:
        r"""List callout notification histories
        Describes how to get a notification history for callouts.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/notification-history/callout'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETCalloutHistoryRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETCalloutHistoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETCalloutHistoryVOsType])
                res.get_callout_history_v_os_type = out

        return res

    def get_email_history(self, request: operations.GETEmailHistoryRequest) -> operations.GETEmailHistoryResponse:
        r"""List email notification histories
        Describes how to get a notification history for notification emails.
        
        
        ## Notes
        Request parameters and their values may be appended with a \"?\" following the HTTPS GET request.  Additional request parameter are separated by \"&\". 
        
        For example:
        
        `GET https://rest.zuora.com/v1/notification-history/email?startTime=2015-01-12T00:00:00&endTime=2015-01-15T00:00:00&failedOnly=false&eventCategory=1000&pageSize=1`
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/notification-history/email'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETEmailHistoryRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETEmailHistoryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETEmailHistoryVOsType])
                res.get_email_history_v_os_type = out

        return res

    def get_get_email_template(self, request: operations.GETGETEmailTemplateRequest) -> operations.GETGETEmailTemplateResponse:
        r"""Retrieve an email template
        Queries the email template of the specified ID.
        
        **Note**: This operation is only applicable to email templates for custom events.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GETGETEmailTemplateRequest, base_url, '/notifications/email-templates/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETGETEmailTemplateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETPublicEmailTemplateResponse])
                res.get_public_email_template_response = out
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_get_notification_definition(self, request: operations.GETGETNotificationDefinitionRequest) -> operations.GETGETNotificationDefinitionResponse:
        r"""Retrieve a notification definition
        Queries the notification definition of the given ID.
        
        **Note**: This operation is only applicable to notifications for custom events.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GETGETNotificationDefinitionRequest, base_url, '/notifications/notification-definitions/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETGETNotificationDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETPublicNotificationDefinitionResponse])
                res.get_public_notification_definition_response = out
        elif http_res.status_code in [404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_get_notification_history_deletion_task(self, request: operations.GETGETNotificationHistoryDeletionTaskRequest) -> operations.GETGETNotificationHistoryDeletionTaskResponse:
        r"""Retrieve a notification history deletion task
        Get the notification history deletion task by ID.
        
        **Note**: This operation is only available if you have the Notification and the Configurable Event features enabled.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GETGETNotificationHistoryDeletionTaskRequest, base_url, '/notifications/history/tasks/{id}', request)
        
        headers = utils.get_headers(request)
        
        client = self._client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETGETNotificationHistoryDeletionTaskResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NotificationsHistoryDeletionTaskResponse])
                res.notifications_history_deletion_task_response = out
        elif http_res.status_code == 404:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_query_email_templates(self, request: operations.GETQueryEmailTemplatesRequest) -> operations.GETQueryEmailTemplatesResponse:
        r"""List email templates
        Queries email templates.
        
        **Note**: This operation is only applicable to email templates for custom events.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/notifications/email-templates'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETQueryEmailTemplatesRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETQueryEmailTemplatesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GETQueryEmailTemplates200ApplicationJSON])
                res.get_query_email_templates_200_application_json_object = out
        elif http_res.status_code in [404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def get_query_notification_definitions(self, request: operations.GETQueryNotificationDefinitionsRequest) -> operations.GETQueryNotificationDefinitionsResponse:
        r"""List notification definitions
        Queries notification definitions with the specified filters.
        
        **Note**: This operation is only applicable to notifications for custom events.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/notifications/notification-definitions'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.GETQueryNotificationDefinitionsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GETQueryNotificationDefinitionsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.GETQueryNotificationDefinitions200ApplicationJSON])
                res.get_query_notification_definitions_200_application_json_object = out
        elif http_res.status_code in [404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def post_create_email_template(self, request: operations.POSTCreateEmailTemplateRequest) -> operations.POSTCreateEmailTemplateResponse:
        r"""Create an email template
        Creates an email template.
        
        **Note**: This operation is only applicable to email templates for custom events.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/notifications/email-templates'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "post_public_email_template_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTCreateEmailTemplateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETPublicEmailTemplateResponse])
                res.get_public_email_template_response = out
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def post_create_notification_definition(self, request: operations.POSTCreateNotificationDefinitionRequest) -> operations.POSTCreateNotificationDefinitionResponse:
        r"""Create a notification definition
        Creates a notification definition. If a filter rule is specified, it will be evaluated to
        see if the notification definition is qualified to handle the incoming events 
        during runtime. If the notification is qualified, it will send the email and
        invoke the callout if it has an email template or a callout. See a step-by-step guide for
        [creating a custom notification](https://www.zuora.com/developer/api-guides/#Callout-to-external-system-for-provisioning-or-entitlements)
        in [Zuora API Guides](https://www.zuora.com/developer/api-guides/).
        
        **Note**: This operation is only applicable to notifications for custom events.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/notifications/notification-definitions'
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "post_public_notification_definition_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.POSTCreateNotificationDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETPublicNotificationDefinitionResponse])
                res.get_public_notification_definition_response = out
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def put_update_email_template(self, request: operations.PUTUpdateEmailTemplateRequest) -> operations.PUTUpdateEmailTemplateResponse:
        r"""Update an email template
        Updates an email template.
        
        **Note**: This operation is only applicable to email templates for custom events.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PUTUpdateEmailTemplateRequest, base_url, '/notifications/email-templates/{id}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "put_public_email_template_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PUTUpdateEmailTemplateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETPublicEmailTemplateResponse])
                res.get_public_email_template_response = out
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    def put_update_notification_definition(self, request: operations.PUTUpdateNotificationDefinitionRequest) -> operations.PUTUpdateNotificationDefinitionResponse:
        r"""Update a notification definition
        Updates a notification definition.
        
        **Note**: This operation is only applicable to notifications for custom events.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.PUTUpdateNotificationDefinitionRequest, base_url, '/notifications/notification-definitions/{id}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "put_public_notification_definition_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.PUTUpdateNotificationDefinitionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.GETPublicNotificationDefinitionResponse])
                res.get_public_notification_definition_response = out
        elif http_res.status_code in [400, 404, 405, 415, 500]:
            res.headers = http_res.headers
            
            if utils.match_content_type(content_type, 'application/json; charset=utf-8'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ErrorResponse])
                res.error_response = out

        return res

    