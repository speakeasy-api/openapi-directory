// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum - Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
type UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum string

const (
	UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnumEightHundredAndTwo1x    UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum = "802.1x"
	UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnumHybridAuthentication    UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum = "Hybrid authentication"
	UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnumMacAuthenticationBypass UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum = "MAC authentication bypass"
)

func (e UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum) ToPointer() *UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum {
	return &e
}

func (e *UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "802.1x":
		fallthrough
	case "Hybrid authentication":
		fallthrough
	case "MAC authentication bypass":
		*e = UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum: %v", v)
	}
}

// UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum - Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
type UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum string

const (
	UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnumBoth    UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum = "both"
	UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnumInbound UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum = "inbound"
)

func (e UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum) ToPointer() *UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum {
	return &e
}

func (e *UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "both":
		fallthrough
	case "inbound":
		*e = UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum: %v", v)
	}
}

// UpdateNetworkSwitchAccessPolicyRequestBodyDot1x - 802.1x Settings
type UpdateNetworkSwitchAccessPolicyRequestBodyDot1x struct {
	// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
	ControlDirection *UpdateNetworkSwitchAccessPolicyRequestBodyDot1xControlDirectionEnum `json:"controlDirection,omitempty"`
}

// UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum - Choose the Host Mode for the access policy.
type UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum string

const (
	UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnumMultiAuth   UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Multi-Auth"
	UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnumMultiDomain UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Multi-Domain"
	UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnumMultiHost   UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Multi-Host"
	UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnumSingleHost  UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum = "Single-Host"
)

func (e UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum) ToPointer() *UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum {
	return &e
}

func (e *UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Multi-Auth":
		fallthrough
	case "Multi-Domain":
		fallthrough
	case "Multi-Host":
		fallthrough
	case "Single-Host":
		*e = UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum: %v", v)
	}
}

// UpdateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth - Critical auth settings for when authentication is rejected by the RADIUS server
type UpdateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth struct {
	// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	DataVlanID *int64 `json:"dataVlanId,omitempty"`
	// Enable to suspend port bounce when RADIUS servers are unreachable
	SuspendPortBounce *bool `json:"suspendPortBounce,omitempty"`
	// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	VoiceVlanID *int64 `json:"voiceVlanId,omitempty"`
}

// UpdateNetworkSwitchAccessPolicyRequestBodyRadius - Object for RADIUS Settings
type UpdateNetworkSwitchAccessPolicyRequestBodyRadius struct {
	// Critical auth settings for when authentication is rejected by the RADIUS server
	CriticalAuth *UpdateNetworkSwitchAccessPolicyRequestBodyRadiusCriticalAuth `json:"criticalAuth,omitempty"`
	// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	FailedAuthVlanID *int64 `json:"failedAuthVlanId,omitempty"`
	// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
	ReAuthenticationInterval *int64 `json:"reAuthenticationInterval,omitempty"`
}

type UpdateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers struct {
	// Public IP address of the RADIUS accounting server
	Host string `json:"host"`
	// UDP port that the RADIUS Accounting server listens on for access requests
	Port int64 `json:"port"`
	// RADIUS client shared secret
	Secret string `json:"secret"`
}

type UpdateNetworkSwitchAccessPolicyRequestBodyRadiusServers struct {
	// Public IP address of the RADIUS server
	Host string `json:"host"`
	// UDP port that the RADIUS server listens on for access requests
	Port int64 `json:"port"`
	// RADIUS client shared secret
	Secret string `json:"secret"`
}

type UpdateNetworkSwitchAccessPolicyRequestBody struct {
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *UpdateNetworkSwitchAccessPolicyRequestBodyAccessPolicyTypeEnum `json:"accessPolicyType,omitempty"`
	// 802.1x Settings
	Dot1x *UpdateNetworkSwitchAccessPolicyRequestBodyDot1x `json:"dot1x,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing *bool `json:"guestPortBouncing,omitempty"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanID *int64 `json:"guestVlanId,omitempty"`
	// Choose the Host Mode for the access policy.
	HostMode *UpdateNetworkSwitchAccessPolicyRequestBodyHostModeEnum `json:"hostMode,omitempty"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `json:"increaseAccessSpeed,omitempty"`
	// Name of the access policy
	Name *string `json:"name,omitempty"`
	// Object for RADIUS Settings
	Radius *UpdateNetworkSwitchAccessPolicyRequestBodyRadius `json:"radius,omitempty"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `json:"radiusAccountingEnabled,omitempty"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []UpdateNetworkSwitchAccessPolicyRequestBodyRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `json:"radiusCoaSupportEnabled,omitempty"`
	// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
	RadiusGroupAttribute *string `json:"radiusGroupAttribute,omitempty"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []UpdateNetworkSwitchAccessPolicyRequestBodyRadiusServers `json:"radiusServers,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `json:"radiusTestingEnabled,omitempty"`
	// Enable to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenEnabled *bool `json:"urlRedirectWalledGardenEnabled,omitempty"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenRanges []string `json:"urlRedirectWalledGardenRanges,omitempty"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `json:"voiceVlanClients,omitempty"`
}

type UpdateNetworkSwitchAccessPolicyRequest struct {
	RequestBody        *UpdateNetworkSwitchAccessPolicyRequestBody `request:"mediaType=application/json"`
	AccessPolicyNumber string                                      `pathParam:"style=simple,explode=false,name=accessPolicyNumber"`
	NetworkID          string                                      `pathParam:"style=simple,explode=false,name=networkId"`
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum - Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
type UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum string

const (
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnumEightHundredAndTwo1x    UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum = "802.1x"
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnumHybridAuthentication    UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum = "Hybrid authentication"
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnumMacAuthenticationBypass UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum = "MAC authentication bypass"
)

func (e UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum) ToPointer() *UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum {
	return &e
}

func (e *UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "802.1x":
		fallthrough
	case "Hybrid authentication":
		fallthrough
	case "MAC authentication bypass":
		*e = UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum: %v", v)
	}
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum - Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
type UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum string

const (
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnumBoth    UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum = "both"
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnumInbound UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum = "inbound"
)

func (e UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum) ToPointer() *UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum {
	return &e
}

func (e *UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "both":
		fallthrough
	case "inbound":
		*e = UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum: %v", v)
	}
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1x - 802.1x Settings
type UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1x struct {
	// Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
	ControlDirection *UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1xControlDirectionEnum `json:"controlDirection,omitempty"`
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum - Choose the Host Mode for the access policy.
type UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum string

const (
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumMultiAuth   UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Multi-Auth"
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumMultiDomain UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Multi-Domain"
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumMultiHost   UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Multi-Host"
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnumSingleHost  UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum = "Single-Host"
)

func (e UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum) ToPointer() *UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum {
	return &e
}

func (e *UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Multi-Auth":
		fallthrough
	case "Multi-Domain":
		fallthrough
	case "Multi-Host":
		fallthrough
	case "Single-Host":
		*e = UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum: %v", v)
	}
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth - Critical auth settings for when authentication is rejected by the RADIUS server
type UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth struct {
	// VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	DataVlanID *int64 `json:"dataVlanId,omitempty"`
	// Enable to suspend port bounce when RADIUS servers are unreachable
	SuspendPortBounce *bool `json:"suspendPortBounce,omitempty"`
	// VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	VoiceVlanID *int64 `json:"voiceVlanId,omitempty"`
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadius - Object for RADIUS Settings
type UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadius struct {
	// Critical auth settings for when authentication is rejected by the RADIUS server
	CriticalAuth *UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusCriticalAuth `json:"criticalAuth,omitempty"`
	// VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
	FailedAuthVlanID *int64 `json:"failedAuthVlanId,omitempty"`
	// Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
	ReAuthenticationInterval *int64 `json:"reAuthenticationInterval,omitempty"`
}

type UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers struct {
	// Public IP address of the RADIUS accounting server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS Accounting server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

type UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers struct {
	// Public IP address of the RADIUS server
	Host *string `json:"host,omitempty"`
	// UDP port that the RADIUS server listens on for access requests
	Port *int64 `json:"port,omitempty"`
}

// UpdateNetworkSwitchAccessPolicy200ApplicationJSON - Successful operation
type UpdateNetworkSwitchAccessPolicy200ApplicationJSON struct {
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *UpdateNetworkSwitchAccessPolicy200ApplicationJSONAccessPolicyTypeEnum `json:"accessPolicyType,omitempty"`
	// 802.1x Settings
	Dot1x *UpdateNetworkSwitchAccessPolicy200ApplicationJSONDot1x `json:"dot1x,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing *bool `json:"guestPortBouncing,omitempty"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanID *int64 `json:"guestVlanId,omitempty"`
	// Choose the Host Mode for the access policy.
	HostMode *UpdateNetworkSwitchAccessPolicy200ApplicationJSONHostModeEnum `json:"hostMode,omitempty"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `json:"increaseAccessSpeed,omitempty"`
	// Name of the access policy
	Name *string `json:"name,omitempty"`
	// Object for RADIUS Settings
	Radius *UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadius `json:"radius,omitempty"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `json:"radiusAccountingEnabled,omitempty"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusAccountingServers `json:"radiusAccountingServers,omitempty"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `json:"radiusCoaSupportEnabled,omitempty"`
	// Acceptable values are `""` for None, or `"11"` for Group Policies ACL
	RadiusGroupAttribute *string `json:"radiusGroupAttribute,omitempty"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []UpdateNetworkSwitchAccessPolicy200ApplicationJSONRadiusServers `json:"radiusServers,omitempty"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `json:"radiusTestingEnabled,omitempty"`
	// Enable to restrict access for clients to a response_objectific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenEnabled *bool `json:"urlRedirectWalledGardenEnabled,omitempty"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	URLRedirectWalledGardenRanges []string `json:"urlRedirectWalledGardenRanges,omitempty"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `json:"voiceVlanClients,omitempty"`
}

type UpdateNetworkSwitchAccessPolicyResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// Successful operation
	UpdateNetworkSwitchAccessPolicy200ApplicationJSONObject *UpdateNetworkSwitchAccessPolicy200ApplicationJSON
}
