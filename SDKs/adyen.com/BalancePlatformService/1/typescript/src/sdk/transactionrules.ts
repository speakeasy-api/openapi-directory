/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

export class TransactionRules {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Delete a transaction rule
   *
   * @remarks
   * Deletes a transaction rule.
   */
  deleteTransactionRulesTransactionRuleId(
    req: operations.DeleteTransactionRulesTransactionRuleIdRequest,
    security: operations.DeleteTransactionRulesTransactionRuleIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteTransactionRulesTransactionRuleIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteTransactionRulesTransactionRuleIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/transactionRules/{transactionRuleId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.DeleteTransactionRulesTransactionRuleIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "delete",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.DeleteTransactionRulesTransactionRuleIdResponse =
        new operations.DeleteTransactionRulesTransactionRuleIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transactionRule = utils.objectToClass(
              httpRes?.data,
              shared.TransactionRule
            );
          }
          break;
        case [400, 401, 403, 422, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.restServiceError = utils.objectToClass(
              httpRes?.data,
              shared.RestServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Get a transaction rule
   *
   * @remarks
   * Returns the details of a transaction rule.
   */
  getTransactionRulesTransactionRuleId(
    req: operations.GetTransactionRulesTransactionRuleIdRequest,
    security: operations.GetTransactionRulesTransactionRuleIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.GetTransactionRulesTransactionRuleIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.GetTransactionRulesTransactionRuleIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/transactionRules/{transactionRuleId}",
      req
    );
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.GetTransactionRulesTransactionRuleIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const r = client.request({
      url: url,
      method: "get",
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.GetTransactionRulesTransactionRuleIdResponse =
        new operations.GetTransactionRulesTransactionRuleIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transactionRuleResponse = utils.objectToClass(
              httpRes?.data,
              shared.TransactionRuleResponse
            );
          }
          break;
        case [400, 401, 403, 422, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.restServiceError = utils.objectToClass(
              httpRes?.data,
              shared.RestServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Update a transaction rule
   *
   * @remarks
   * Updates a transaction rule.
   *
   * * To update only the status of a transaction rule, send only the `status` parameter. All other parameters not provided in the request are left unchanged.
   *
   * * When updating any other parameter, you need to send all existing resource parameters. If you omit a parameter in the request, that parameter is removed from the resource.
   */
  patchTransactionRulesTransactionRuleId(
    req: operations.PatchTransactionRulesTransactionRuleIdRequest,
    security: operations.PatchTransactionRulesTransactionRuleIdSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PatchTransactionRulesTransactionRuleIdResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.PatchTransactionRulesTransactionRuleIdRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/transactionRules/{transactionRuleId}",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "transactionRuleInfo",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PatchTransactionRulesTransactionRuleIdSecurity(
        security
      );
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "patch",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PatchTransactionRulesTransactionRuleIdResponse =
        new operations.PatchTransactionRulesTransactionRuleIdResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transactionRule = utils.objectToClass(
              httpRes?.data,
              shared.TransactionRule
            );
          }
          break;
        case [400, 401, 403, 422, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.restServiceError = utils.objectToClass(
              httpRes?.data,
              shared.RestServiceError
            );
          }
          break;
      }

      return res;
    });
  }

  /**
   * Create a transaction rule
   *
   * @remarks
   * Creates a [transaction rule](https://docs.adyen.com/issuing/transaction-rules). When your user makes a transaction with their Adyen-issued card, the transaction is allowed or declined based on the conditions and outcome defined in the transaction rule. You can apply the transaction rule to several cards, such as all the cards in your platform, or to a specific card. For use cases, see [examples](https://docs.adyen.com/issuing/transaction-rules/examples).
   */
  postTransactionRules(
    req: shared.TransactionRuleInfo,
    security: operations.PostTransactionRulesSecurity,
    config?: AxiosRequestConfig
  ): Promise<operations.PostTransactionRulesResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.TransactionRuleInfo(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/transactionRules";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }
    if (!(security instanceof utils.SpeakeasyBase)) {
      security = new operations.PostTransactionRulesSecurity(security);
    }
    const client: AxiosInstance = utils.createSecurityClient(
      this._defaultClient,
      security
    );

    const headers = { ...reqBodyHeaders, ...config?.headers };

    const r = client.request({
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    return r.then((httpRes: AxiosResponse) => {
      const contentType: string = httpRes?.headers?.["content-type"] ?? "";

      if (httpRes?.status == null)
        throw new Error(`status code not found in response: ${httpRes}`);
      const res: operations.PostTransactionRulesResponse =
        new operations.PostTransactionRulesResponse({
          statusCode: httpRes.status,
          contentType: contentType,
          rawResponse: httpRes,
        });
      switch (true) {
        case httpRes?.status == 200:
          if (utils.matchContentType(contentType, `application/json`)) {
            res.transactionRule = utils.objectToClass(
              httpRes?.data,
              shared.TransactionRule
            );
          }
          break;
        case [400, 401, 403, 422, 500].includes(httpRes?.status):
          if (utils.matchContentType(contentType, `application/json`)) {
            res.restServiceError = utils.objectToClass(
              httpRes?.data,
              shared.RestServiceError
            );
          }
          break;
      }

      return res;
    });
  }
}
