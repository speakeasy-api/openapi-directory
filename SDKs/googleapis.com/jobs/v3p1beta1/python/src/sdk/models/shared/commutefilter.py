"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from ..shared import latlng as shared_latlng
from ..shared import timeofday as shared_timeofday
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class CommuteFilterCommuteMethodEnum(str, Enum):
    r"""Required. The method of transportation for which to calculate the commute time."""
    COMMUTE_METHOD_UNSPECIFIED = 'COMMUTE_METHOD_UNSPECIFIED'
    DRIVING = 'DRIVING'
    TRANSIT = 'TRANSIT'
    WALKING = 'WALKING'
    CYCLING = 'CYCLING'

class CommuteFilterRoadTrafficEnum(str, Enum):
    r"""Optional. Specifies the traffic density to use when calculating commute time."""
    ROAD_TRAFFIC_UNSPECIFIED = 'ROAD_TRAFFIC_UNSPECIFIED'
    TRAFFIC_FREE = 'TRAFFIC_FREE'
    BUSY_HOUR = 'BUSY_HOUR'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class CommuteFilter:
    r"""Input only. Parameters needed for commute search."""
    
    allow_imprecise_addresses: Optional[bool] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('allowImpreciseAddresses'), 'exclude': lambda f: f is None }})
    r"""Optional. If true, jobs without \\"precise\\" addresses (street level addresses or GPS coordinates) might also be returned. For city and coarser level addresses, text matching is used. If this field is set to false or is not specified, only jobs that include precise addresses are returned by Commute Search. Note: If `allow_imprecise_addresses` is set to true, Commute Search is not able to calculate accurate commute times to jobs with city level and coarser address information. Jobs with imprecise addresses will return a `travel_duration` time of 0 regardless of distance from the job seeker."""  
    commute_method: Optional[CommuteFilterCommuteMethodEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('commuteMethod'), 'exclude': lambda f: f is None }})
    r"""Required. The method of transportation for which to calculate the commute time."""  
    departure_time: Optional[shared_timeofday.TimeOfDay] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('departureTime'), 'exclude': lambda f: f is None }})
    r"""Represents a time of day. The date and time zone are either not significant or are specified elsewhere. An API may choose to allow leap seconds. Related types are google.type.Date and `google.protobuf.Timestamp`."""  
    road_traffic: Optional[CommuteFilterRoadTrafficEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('roadTraffic'), 'exclude': lambda f: f is None }})
    r"""Optional. Specifies the traffic density to use when calculating commute time."""  
    start_coordinates: Optional[shared_latlng.LatLng] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('startCoordinates'), 'exclude': lambda f: f is None }})
    r"""An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges."""  
    travel_duration: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('travelDuration'), 'exclude': lambda f: f is None }})
    r"""Required. The maximum travel time in seconds. The maximum allowed value is `3600s` (one hour). Format is `123s`."""  
    