"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from __future__ import annotations
import dataclasses
from dataclasses_json import Undefined, dataclass_json
from enum import Enum
from sdk import utils
from typing import Optional

class ComptageRequestComptageEnum(str, Enum):
    ONE = '1'

class ComptageRequestGmtZoneEnum(str, Enum):
    r"""Fuseau horaire de la date d'envoi"""
    PACIFIC_MIDWAY = 'Pacific/Midway'
    AMERICA_ADAK = 'America/Adak'
    ETC_GMT_PLUS_10 = 'Etc/GMT+10'
    PACIFIC_MARQUESAS = 'Pacific/Marquesas'
    PACIFIC_GAMBIER = 'Pacific/Gambier'
    AMERICA_ANCHORAGE = 'America/Anchorage'
    AMERICA_ENSENADA = 'America/Ensenada'
    ETC_GMT_PLUS_8 = 'Etc/GMT+8'
    AMERICA_LOS_ANGELES = 'America/Los_Angeles'
    AMERICA_DENVER = 'America/Denver'
    AMERICA_CHIHUAHUA = 'America/Chihuahua'
    AMERICA_DAWSON_CREEK = 'America/Dawson_Creek'
    AMERICA_BELIZE = 'America/Belize'
    AMERICA_CANCUN = 'America/Cancun'
    CHILE_EASTER_ISLAND = 'Chile/EasterIsland'
    AMERICA_CHICAGO = 'America/Chicago'
    AMERICA_NEW_YORK = 'America/New_York'
    AMERICA_HAVANA = 'America/Havana'
    AMERICA_BOGOTA = 'America/Bogota'
    AMERICA_CARACAS = 'America/Caracas'
    AMERICA_SANTIAGO = 'America/Santiago'
    AMERICA_LA_PAZ = 'America/La_Paz'
    ATLANTIC_STANLEY = 'Atlantic/Stanley'
    AMERICA_CAMPO_GRANDE = 'America/Campo_Grande'
    AMERICA_GOOSE_BAY = 'America/Goose_Bay'
    AMERICA_GLACE_BAY = 'America/Glace_Bay'
    AMERICA_ST_JOHNS = 'America/St_Johns'
    AMERICA_ARAGUAINA = 'America/Araguaina'
    AMERICA_MONTEVIDEO = 'America/Montevideo'
    AMERICA_MIQUELON = 'America/Miquelon'
    AMERICA_GODTHAB = 'America/Godthab'
    AMERICA_ARGENTINA_BUENOS_AIRES = 'America/Argentina/Buenos_Aires'
    AMERICA_SAO_PAULO = 'America/Sao_Paulo'
    AMERICA_NORONHA = 'America/Noronha'
    ATLANTIC_CAPE_VERDE = 'Atlantic/Cape_Verde'
    ATLANTIC_AZORES = 'Atlantic/Azores'
    EUROPE_BELFAST = 'Europe/Belfast'
    EUROPE_DUBLIN = 'Europe/Dublin'
    EUROPE_LISBON = 'Europe/Lisbon'
    EUROPE_LONDON = 'Europe/London'
    AFRICA_ABIDJAN = 'Africa/Abidjan'
    EUROPE_AMSTERDAM = 'Europe/Amsterdam'
    EUROPE_BELGRADE = 'Europe/Belgrade'
    EUROPE_BRUSSELS = 'Europe/Brussels'
    AFRICA_ALGIERS = 'Africa/Algiers'
    AFRICA_WINDHOEK = 'Africa/Windhoek'
    ASIA_BEIRUT = 'Asia/Beirut'
    AFRICA_CAIRO = 'Africa/Cairo'
    ASIA_GAZA = 'Asia/Gaza'
    AFRICA_BLANTYRE = 'Africa/Blantyre'
    ASIA_JERUSALEM = 'Asia/Jerusalem'
    EUROPE_MINSK = 'Europe/Minsk'
    ASIA_DAMASCUS = 'Asia/Damascus'
    EUROPE_MOSCOW = 'Europe/Moscow'
    AFRICA_ADDIS_ABABA = 'Africa/Addis_Ababa'
    ASIA_TEHRAN = 'Asia/Tehran'
    ASIA_DUBAI = 'Asia/Dubai'
    ASIA_YEREVAN = 'Asia/Yerevan'
    ASIA_KABUL = 'Asia/Kabul'
    ASIA_YEKATERINBURG = 'Asia/Yekaterinburg'
    ASIA_TASHKENT = 'Asia/Tashkent'
    ASIA_KOLKATA = 'Asia/Kolkata'
    ASIA_KATMANDU = 'Asia/Katmandu'
    ASIA_DHAKA = 'Asia/Dhaka'
    ASIA_NOVOSIBIRSK = 'Asia/Novosibirsk'
    ASIA_RANGOON = 'Asia/Rangoon'
    ASIA_BANGKOK = 'Asia/Bangkok'
    ASIA_KRASNOYARSK = 'Asia/Krasnoyarsk'
    ASIA_HONG_KONG = 'Asia/Hong_Kong'
    ASIA_IRKUTSK = 'Asia/Irkutsk'
    AUSTRALIA_PERTH = 'Australia/Perth'
    AUSTRALIA_EUCLA = 'Australia/Eucla'
    ASIA_TOKYO = 'Asia/Tokyo'
    ASIA_SEOUL = 'Asia/Seoul'
    ASIA_YAKUTSK = 'Asia/Yakutsk'
    AUSTRALIA_ADELAIDE = 'Australia/Adelaide'
    AUSTRALIA_DARWIN = 'Australia/Darwin'
    AUSTRALIA_BRISBANE = 'Australia/Brisbane'
    AUSTRALIA_HOBART = 'Australia/Hobart'
    ASIA_VLADIVOSTOK = 'Asia/Vladivostok'
    AUSTRALIA_LORD_HOWE = 'Australia/Lord_Howe'
    ETC_GMT_11 = 'Etc/GMT-11'
    ASIA_MAGADAN = 'Asia/Magadan'
    PACIFIC_NORFOLK = 'Pacific/Norfolk'
    ASIA_ANADYR = 'Asia/Anadyr'
    PACIFIC_AUCKLAND = 'Pacific/Auckland'
    ETC_GMT_12 = 'Etc/GMT-12'
    PACIFIC_CHATHAM = 'Pacific/Chatham'
    PACIFIC_TONGATAPU = 'Pacific/Tongatapu'
    PACIFIC_KIRITIMATI = 'Pacific/Kiritimati'

class ComptageRequestNumAzurEnum(str, Enum):
    ONE = '1'

class ComptageRequestSmslongEnum(str, Enum):
    r"""Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué
    de plusieurs SMS.
    Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918
    caractères par message.
    Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères.
    En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères
    du « STOP SMS ».
    Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" 
    """
    NINE_HUNDRED_AND_NINETY_NINE = '999'


@dataclass_json(undefined=Undefined.EXCLUDE)
@dataclasses.dataclass
class ComptageRequest:
    r"""sms request"""
    
    comptage: ComptageRequestComptageEnum = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('comptage') }})  
    keyid: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('keyid') }})
    r"""Clé API"""  
    num: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('num') }})
    r"""Numero de téléphone au format national (exemple 0680010203) ou international (example 33680010203)"""  
    sms: str = dataclasses.field(metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('sms') }})
    r"""Message à envoyer aux destinataires. Le message doit être encodé au format utf-8 et ne contenir que des caractères existant dans l'alphabet GSM. Il est également possible d'envoyer (à l'étranger uniquement) des SMS en UCS-2, cf paramètre ucs2 pour plus de détails."""  
    date_envoi: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('date_envoi'), 'exclude': lambda f: f is None }})
    r"""Date d'envoi au format YYYY-MM-DD hh:mm . Ce paramètre est optionnel, si il est omis l'envoi est réalisé immédiatement."""  
    emetteur: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('emetteur'), 'exclude': lambda f: f is None }})
    r"""- L'emetteur doit être une chaîne alphanumérique comprise entre 4 et 11 caractères.
    
    - Les caractères acceptés sont les chiffres entre 0 et 9, les lettres entre A et Z et l’espace.
    
    - Il ne peut pas comporter uniquement des chiffres. 
    
    - Pour la modification de l'émetteur et dans le cadre de campagnes commerciales, les opérateurs imposent contractuellement d'ajouter en fin de message le texte \"STOP XXXXX\". De ce fait, le message envoyé ne pourra excéder une longueur de 148 caractères au lieu des 160 caractères, le « STOP » étant rajouté automatiquement.
    """  
    gmt_zone: Optional[ComptageRequestGmtZoneEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('gmt_zone'), 'exclude': lambda f: f is None }})
    r"""Fuseau horaire de la date d'envoi"""  
    nostop: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('nostop'), 'exclude': lambda f: f is None }})
    r"""Si le message n’est pas à but commercial, vous pouvez faire une demande pour retirer l’obligation du STOP. Une fois votre demande validée par nos services, vous pourrez supprimer la mention STOP SMS en ajoutant nostop = \\"1\\" """  
    num_azur: Optional[ComptageRequestNumAzurEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('numAzur'), 'exclude': lambda f: f is None }})  
    smslong: Optional[ComptageRequestSmslongEnum] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('smslong'), 'exclude': lambda f: f is None }})
    r"""Le SMS long permet de dépasser la limite de 160 caractères en envoyant un message constitué
    de plusieurs SMS.
    Il est possible d’envoyer jusqu’à 6 SMS concaténés pour une longueur totale maximale de 918
    caractères par message.
    Pour des raisons technique, la limite par SMS concaténé étant de 153 caractères.
    En cas de modification de l’émetteur, il faut considérer l’ajout automatique de 12 caractères
    du « STOP SMS ».
    Pour envoyer un smslong, il faut ajouter le paramètre smslong aux appels. La valeur de SMS doit être le nombre maximum de sms concaténé autorisé.   Pour ne pas avoir ce message d’erreur et obtenir un calcul dynamique du nombre de SMS alors il faut renseigner smslong = \"999\" 
    """  
    tracker: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('tracker'), 'exclude': lambda f: f is None }})
    r"""Le tracker doit être une chaine alphanumérique de moins de 50 caractères. Ce tracker sera ensuite renvoyé en paramètre des urls pour les retours des accusés de réception."""  
    ucs2: Optional[str] = dataclasses.field(default=None, metadata={'dataclasses_json': { 'letter_case': utils.get_field_name('ucs2'), 'exclude': lambda f: f is None }})
    r"""Il est également possible d’envoyer des SMS en alphabet non latin (russe, chinois, arabe, etc) sur
    les numéros hors France métropolitaine.
    Pour ce faire, la requête devrait être encodée au format UTF-8 et contenir l’argument ucs2 = \"1\"
    Du fait de contraintes techniques, 1 SMS unique ne pourra pas dépasser 70 caractères (au lieu
    des 160 usuels) et dans le cas de SMS long, chaque sms ne pourra dépasser 67 caractères.
    """  
    