"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Line:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def line_arrivals(self, request: operations.LineArrivalsRequest) -> operations.LineArrivalsResponse:
        r"""Get the list of arrival predictions for given line ids based at the given stop"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineArrivalsRequest, base_url, '/Line/{ids}/Arrivals/{stopPointId}', request)
        
        query_params = utils.get_query_params(operations.LineArrivalsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineArrivalsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPrediction]])
                res.tfl_api_presentation_entities_predictions = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesPrediction]])
                res.tfl_api_presentation_entities_predictions = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_disruption(self, request: operations.LineDisruptionRequest) -> operations.LineDisruptionResponse:
        r"""Get disruptions for the given line ids"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineDisruptionRequest, base_url, '/Line/{ids}/Disruption', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineDisruptionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruption]])
                res.tfl_api_presentation_entities_disruptions = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruption]])
                res.tfl_api_presentation_entities_disruptions = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_disruption_by_mode(self, request: operations.LineDisruptionByModeRequest) -> operations.LineDisruptionByModeResponse:
        r"""Get disruptions for all lines of the given modes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineDisruptionByModeRequest, base_url, '/Line/Mode/{modes}/Disruption', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineDisruptionByModeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruption]])
                res.tfl_api_presentation_entities_disruptions = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesDisruption]])
                res.tfl_api_presentation_entities_disruptions = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_get(self, request: operations.LineGetRequest) -> operations.LineGetResponse:
        r"""Gets lines that match the specified line ids."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineGetRequest, base_url, '/Line/{ids}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineGetResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_get_by_mode(self, request: operations.LineGetByModeRequest) -> operations.LineGetByModeResponse:
        r"""Gets lines that serve the given modes."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineGetByModeRequest, base_url, '/Line/Mode/{modes}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineGetByModeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_line_routes_by_ids(self, request: operations.LineLineRoutesByIdsRequest) -> operations.LineLineRoutesByIdsResponse:
        r"""Get all valid routes for given line ids, including the name and id of the originating and terminating stops for each route."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineLineRoutesByIdsRequest, base_url, '/Line/{ids}/Route', request)
        
        query_params = utils.get_query_params(operations.LineLineRoutesByIdsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineLineRoutesByIdsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_meta_disruption_categories(self) -> operations.LineMetaDisruptionCategoriesResponse:
        r"""Gets a list of valid disruption categories"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Line/Meta/DisruptionCategories'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineMetaDisruptionCategoriesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.line_meta_disruption_categories_200_application_json_strings = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.line_meta_disruption_categories_200_text_json_strings = out

        return res

    def line_meta_modes(self) -> operations.LineMetaModesResponse:
        r"""Gets a list of valid modes"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Line/Meta/Modes'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineMetaModesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesMode]])
                res.tfl_api_presentation_entities_modes = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesMode]])
                res.tfl_api_presentation_entities_modes = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_meta_service_types(self) -> operations.LineMetaServiceTypesResponse:
        r"""Gets a list of valid ServiceTypes to filter on"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Line/Meta/ServiceTypes'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineMetaServiceTypesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.line_meta_service_types_200_application_json_strings = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[str]])
                res.line_meta_service_types_200_text_json_strings = out

        return res

    def line_meta_severity(self) -> operations.LineMetaSeverityResponse:
        r"""Gets a list of valid severity codes"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Line/Meta/Severity'
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineMetaSeverityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStatusSeverity]])
                res.tfl_api_presentation_entities_status_severities = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStatusSeverity]])
                res.tfl_api_presentation_entities_status_severities = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_route(self, request: operations.LineRouteRequest) -> operations.LineRouteResponse:
        r"""Get all valid routes for all lines, including the name and id of the originating and terminating stops for each route."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/Line/Route'
        
        query_params = utils.get_query_params(operations.LineRouteRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineRouteResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_route_by_mode(self, request: operations.LineRouteByModeRequest) -> operations.LineRouteByModeResponse:
        r"""Gets all lines and their valid routes for given modes, including the name and id of the originating and terminating stops for each route"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineRouteByModeRequest, base_url, '/Line/Mode/{modes}/Route', request)
        
        query_params = utils.get_query_params(operations.LineRouteByModeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineRouteByModeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_route_sequence(self, request: operations.LineRouteSequenceRequest) -> operations.LineRouteSequenceResponse:
        r"""Gets all valid routes for given line id, including the sequence of stops on each route."""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineRouteSequenceRequest, base_url, '/Line/{id}/Route/Sequence/{direction}', request)
        
        query_params = utils.get_query_params(operations.LineRouteSequenceRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineRouteSequenceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesRouteSequence])
                res.tfl_api_presentation_entities_route_sequence = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesRouteSequence])
                res.tfl_api_presentation_entities_route_sequence = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_search(self, request: operations.LineSearchRequest) -> operations.LineSearchResponse:
        r"""Search for lines or routes matching the query string"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineSearchRequest, base_url, '/Line/Search/{query}', request)
        
        query_params = utils.get_query_params(operations.LineSearchRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesRouteSearchResponse])
                res.tfl_api_presentation_entities_route_search_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesRouteSearchResponse])
                res.tfl_api_presentation_entities_route_search_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_status(self, request: operations.LineStatusRequest) -> operations.LineStatusResponse:
        r"""Gets the line status for given line ids during the provided dates e.g Minor Delays"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineStatusRequest, base_url, '/Line/{ids}/Status/{StartDate}/to/{EndDate}', request)
        
        query_params = utils.get_query_params(operations.LineStatusRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineStatusResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_status_by_ids(self, request: operations.LineStatusByIdsRequest) -> operations.LineStatusByIdsResponse:
        r"""Gets the line status of for given line ids e.g Minor Delays"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineStatusByIdsRequest, base_url, '/Line/{ids}/Status', request)
        
        query_params = utils.get_query_params(operations.LineStatusByIdsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineStatusByIdsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_status_by_mode(self, request: operations.LineStatusByModeRequest) -> operations.LineStatusByModeResponse:
        r"""Gets the line status of for all lines for the given modes"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineStatusByModeRequest, base_url, '/Line/Mode/{modes}/Status', request)
        
        query_params = utils.get_query_params(operations.LineStatusByModeRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineStatusByModeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_status_by_severity(self, request: operations.LineStatusBySeverityRequest) -> operations.LineStatusBySeverityResponse:
        r"""Gets the line status for all lines with a given severity
                    A list of valid severity codes can be obtained from a call to Line/Meta/Severity
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineStatusBySeverityRequest, base_url, '/Line/Status/{severity}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineStatusBySeverityResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesLine]])
                res.tfl_api_presentation_entities_lines = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_stop_points(self, request: operations.LineStopPointsRequest) -> operations.LineStopPointsResponse:
        r"""Gets a list of the stations that serve the given line id"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineStopPointsRequest, base_url, '/Line/{id}/StopPoints', request)
        
        query_params = utils.get_query_params(operations.LineStopPointsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineStopPointsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.TflAPIPresentationEntitiesStopPoint]])
                res.tfl_api_presentation_entities_stop_points = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_timetable(self, request: operations.LineTimetableRequest) -> operations.LineTimetableResponse:
        r"""Gets the timetable for a specified station on the give line"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineTimetableRequest, base_url, '/Line/{id}/Timetable/{fromStopPointId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineTimetableResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesTimetableResponse])
                res.tfl_api_presentation_entities_timetable_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesTimetableResponse])
                res.tfl_api_presentation_entities_timetable_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    def line_timetable_to(self, request: operations.LineTimetableToRequest) -> operations.LineTimetableToResponse:
        r"""Gets the timetable for a specified station on the give line with specified destination"""
        base_url = self._server_url
        
        url = utils.generate_url(operations.LineTimetableToRequest, base_url, '/Line/{id}/Timetable/{fromStopPointId}/to/{toStopPointId}', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.LineTimetableToResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesTimetableResponse])
                res.tfl_api_presentation_entities_timetable_response = out
            if utils.match_content_type(content_type, 'text/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.TflAPIPresentationEntitiesTimetableResponse])
                res.tfl_api_presentation_entities_timetable_response = out
            if utils.match_content_type(content_type, 'application/xml'):
                res.body = http_res.content
            if utils.match_content_type(content_type, 'text/xml'):
                res.body = http_res.content

        return res

    