"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations
from typing import Optional

class Search:
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def product_search(self, request: operations.ProductSearchRequest, server_url: Optional[str] = None) -> operations.ProductSearchResponse:
        r"""Search for Products
        Retrieves general information about the products related to the term searched. 
        This is the main search used by the store. The user can type anything to be searched.  
        
        For example, if they search for a \"decanter\", this is the URL: `https://{{accountName}}.{{environment}}.com.br/api/catalog_system/pub/products/search/decanter`. 
        
        Note that maybe the response can be HTTP 200 or 206, 206 means that it's a partial content response.
        
        If it is a 206 take a look at the Headers, will be an entry called resources. E.g.: resources → 0-9/19. This means that the response is showing items from 0 to 9, 10 items, but there were 19 items found. See more information at the paging route example.
        """
        base_url = operations.PRODUCT_SEARCH_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.ProductSearchRequest, base_url, '/api/catalog_system/pub/products/search/{search}', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ProductSearchResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ProductSearch200ApplicationJSON]])
                res.product_search_200_application_json_objects = out

        return res

    def product_search_filteredand_ordered(self, request: operations.ProductSearchFilteredandOrderedRequest, server_url: Optional[str] = None) -> operations.ProductSearchFilteredandOrderedResponse:
        r"""Search for Products with Filter, Order and Pagination
        Retrieves general information about the store products. This information can be filtered and ordered by a number of options. It also can be paginated, filtered and ordered. 
        
        ## Filters  
        
        - **Filter by full text** - `ft={searchWord}`  
        E.g.: `ft=television`
        
        - **Filter by category** - `fq=C:/{a}/{b}`  
        `{a}` and `{b}` are Category IDs   
        E.g.: `fq=C:/1000041/1000049/`
        
        - **Filter by brand** - `fq=B:/{a}/{b}`  
        `{a}` and `{b}` are Brand IDs
        E.g.: `fq=B:/189385/189387/`
        
        - **Filter by specification** - `fq=specificationFilter_{a}:{b}`  
        `{a}` is the specification ID
        `{b}` is the specification value
        E.g.: To filter products where the color is Blue, find the specification ID for color. Suppose it is 123, then the query will be: `fq=specificationFilter_123:Blue`
        
        - **Filter by price range** - `fq=P:[{a} TO {b}]`  
        `{a}`  is the minimum price \"from\"
        `{b}` is the highest price \"to\"  
        E.g.: `fq=P:[0 TO 20]` will search products between 0.00 and 20.00.  
        
        - **Filter by collection** - `fq=productClusterIds:{{productClusterId}}` 
        `productClusterId` is the same as `collectionId`  
        For more information about collections, read [Creating a product collection](https://help.vtex.com/en/tutorial/creating-a-product-collection).
        
        - **Filter by product ID** - `fq=productId:{{productId}}`
        
        - **Filter by SKU ID** - `fq=skuId:{{skuId}}`
        
        - **Filter by referenceId** - `fq=alternateIds_RefId:{{referenceId}}`
        
        - **Filter by EAN13** - `fq=alternateIds_Ean:{{ean13}}`
        
        - **Filter by availability at a specific sales channel** - `fq=isAvailablePerSalesChannel_{{sc}}:{{bool}}`  
        `{{sc}}` is the desired sales channel  
        `{{bool}}` is true ou false, 1 or 0.  
        E.g.: seaching available products for the sales channel 4 would be `fq=isAvailablePerSalesChannel_4:1`
        
        - **Filter by available at a specific seller** - `fq=sellerId:{{sellerId}}`
        The search does not include White Label Sellers.
        
        ## Pagination
        
        - **Initial item number** - `_from={{first}}`
        - **Final item number** - `_to={{last}}`
        
        >⚠️ This endpoint returns a maximum of 50 items per response, so the difference between `_from` and `_to` should not exceed this number. The result order is descending, from the highest product ID to the lowest.
        
        ## Sorting
        
        - **Price**  
        `O=OrderByPriceDESC`  
        `O=OrderByPriceASC`
        
        - **Top Selling Products**  
        `O=OrderByTopSaleDESC`
        
        - **Best Reviews**  
        `O=OrderByReviewRateDESC`
        
        - **Name**  
        `O=OrderByNameASC`  
        `O=OrderByNameDESC`
        
        - **Release Date**  
        `O=OrderByReleaseDateDESC`
        
        - **Best Discounts**  
        `O=OrderByBestDiscountDESC`
        
        - **Score**  
        `O=OrderByScoreDESC`
        """
        base_url = operations.PRODUCT_SEARCH_FILTEREDAND_ORDERED_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = base_url.removesuffix('/') + '/api/catalog_system/pub/products/search'
        
        headers = utils.get_headers(request)
        query_params = utils.get_query_params(operations.ProductSearchFilteredandOrderedRequest, request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ProductSearchFilteredandOrderedResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.ProductSearchFilteredandOrdered200ApplicationJSON]])
                res.product_search_filteredand_ordered_200_application_json_objects = out

        return res

    def searchbyproducturl(self, request: operations.SearchbyproducturlRequest, server_url: Optional[str] = None) -> operations.SearchbyproducturlResponse:
        r"""Search Product by Product URL
        Retrieves general information about the product of the URL you searched for.
        """
        base_url = operations.SEARCHBYPRODUCTURL_SERVERS[0]
        if server_url is not None:
            base_url = server_url
        
        url = utils.generate_url(operations.SearchbyproducturlRequest, base_url, '/api/catalog_system/pub/products/search/{product-text-link}/p', request)
        
        headers = utils.get_headers(request)
        
        client = self._security_client
        
        http_res = client.request('GET', url, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchbyproducturlResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[operations.Searchbyproducturl200ApplicationJSON]])
                res.searchbyproducturl_200_application_json_objects = out

        return res

    