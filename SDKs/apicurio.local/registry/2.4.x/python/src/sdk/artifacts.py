"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from . import utils
from sdk.models import operations, shared
from typing import Optional

class Artifacts:
    r"""The primary way to interact with the Apicurio Registry API is to add, update,
    or delete artifacts. This section includes all of these primary operations.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    def create_artifact_json(self, request: operations.CreateArtifactJSONRequest) -> operations.CreateArtifactJSONResponse:
        r"""Create artifact
        Creates a new artifact by posting the artifact content.  The body of the request should
        be the raw content of the artifact.  This is typically in JSON format for *most* of the 
        supported types, but may be in another format for a few (for example, `PROTOBUF`).
        
        The registry attempts to figure out what kind of artifact is being added from the
        following supported list:
        
        * Avro (`AVRO`)
        * Protobuf (`PROTOBUF`)
        * JSON Schema (`JSON`)
        * Kafka Connect (`KCONNECT`)
        * OpenAPI (`OPENAPI`)
        * AsyncAPI (`ASYNCAPI`)
        * GraphQL (`GRAPHQL`)
        * Web Services Description Language (`WSDL`)
        * XML Schema (`XSD`)
        
        Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType` 
        HTTP request header, or include a hint in the request's `Content-Type`.  For example:
        
        ```
        Content-Type: application/json; artifactType=AVRO
        ```
        
        An artifact is created using the content provided in the body of the request.  This
        content is created under a unique artifact ID that can be provided in the request
        using the `X-Registry-ArtifactId` request header.  If not provided in the request,
        the server generates a unique ID for the artifact.  It is typically recommended
        that callers provide the ID, because this is typically a meaningful identifier, 
        and for most use cases should be supplied by the caller.
        
        If an artifact with the provided artifact ID already exists, the default behavior
        is for the server to reject the content with a 409 error.  However, the caller can
        supply the `ifExists` query parameter to alter this default behavior. The `ifExists`
        query parameter can have one of the following values:
        
        * `FAIL` (*default*) - server rejects the content with a 409 error
        * `UPDATE` - server updates the existing artifact and returns the new metadata
        * `RETURN` - server does not create or add content to the server, but instead 
        returns the metadata for the existing artifact
        * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the 
        provided content if such a version exists, otherwise a new version is created
        
        This operation may fail for one of the following reasons:
        
        * An invalid `ArtifactType` was indicated (HTTP error `400`)
        * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`)
        * Provided content (request body) was empty (HTTP error `400`)
        * An artifact with the provided ID already exists (HTTP error `409`)
        * The content violates one of the configured global rules (HTTP error `409`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateArtifactJSONRequest, base_url, '/groups/{groupId}/artifacts', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "content_create_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.CreateArtifactJSONRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateArtifactJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactMetaData])
                res.artifact_meta_data = out
        elif http_res.status_code in [400, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RuleViolationError])
                res.rule_violation_error = out

        return res

    def create_artifact_raw(self, request: operations.CreateArtifactRawRequest) -> operations.CreateArtifactRawResponse:
        r"""Create artifact
        Creates a new artifact by posting the artifact content.  The body of the request should
        be the raw content of the artifact.  This is typically in JSON format for *most* of the 
        supported types, but may be in another format for a few (for example, `PROTOBUF`).
        
        The registry attempts to figure out what kind of artifact is being added from the
        following supported list:
        
        * Avro (`AVRO`)
        * Protobuf (`PROTOBUF`)
        * JSON Schema (`JSON`)
        * Kafka Connect (`KCONNECT`)
        * OpenAPI (`OPENAPI`)
        * AsyncAPI (`ASYNCAPI`)
        * GraphQL (`GRAPHQL`)
        * Web Services Description Language (`WSDL`)
        * XML Schema (`XSD`)
        
        Alternatively, you can specify the artifact type using the `X-Registry-ArtifactType` 
        HTTP request header, or include a hint in the request's `Content-Type`.  For example:
        
        ```
        Content-Type: application/json; artifactType=AVRO
        ```
        
        An artifact is created using the content provided in the body of the request.  This
        content is created under a unique artifact ID that can be provided in the request
        using the `X-Registry-ArtifactId` request header.  If not provided in the request,
        the server generates a unique ID for the artifact.  It is typically recommended
        that callers provide the ID, because this is typically a meaningful identifier, 
        and for most use cases should be supplied by the caller.
        
        If an artifact with the provided artifact ID already exists, the default behavior
        is for the server to reject the content with a 409 error.  However, the caller can
        supply the `ifExists` query parameter to alter this default behavior. The `ifExists`
        query parameter can have one of the following values:
        
        * `FAIL` (*default*) - server rejects the content with a 409 error
        * `UPDATE` - server updates the existing artifact and returns the new metadata
        * `RETURN` - server does not create or add content to the server, but instead 
        returns the metadata for the existing artifact
        * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the 
        provided content if such a version exists, otherwise a new version is created
        
        This operation may fail for one of the following reasons:
        
        * An invalid `ArtifactType` was indicated (HTTP error `400`)
        * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`)
        * Provided content (request body) was empty (HTTP error `400`)
        * An artifact with the provided ID already exists (HTTP error `409`)
        * The content violates one of the configured global rules (HTTP error `409`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.CreateArtifactRawRequest, base_url, '/groups/{groupId}/artifacts', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.CreateArtifactRawRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateArtifactRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactMetaData])
                res.artifact_meta_data = out
        elif http_res.status_code in [400, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.RuleViolationError])
                res.rule_violation_error = out

        return res

    def delete_artifact(self, request: operations.DeleteArtifactRequest) -> operations.DeleteArtifactResponse:
        r"""Delete artifact
        Deletes an artifact completely, resulting in all versions of the artifact also being
        deleted.  This may fail for one of the following reasons:
        
        * No artifact with the `artifactId` exists (HTTP error `404`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteArtifactRequest, base_url, '/groups/{groupId}/artifacts/{artifactId}', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteArtifactResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def delete_artifacts_in_group(self, request: operations.DeleteArtifactsInGroupRequest) -> operations.DeleteArtifactsInGroupResponse:
        r"""Delete artifacts in group
        Deletes all of the artifacts that exist in a given group.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.DeleteArtifactsInGroupRequest, base_url, '/groups/{groupId}/artifacts', request)
        
        
        client = self._client
        
        http_res = client.request('DELETE', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.DeleteArtifactsInGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_content_by_global_id(self, request: operations.GetContentByGlobalIDRequest) -> operations.GetContentByGlobalIDResponse:
        r"""Get artifact by global ID
        Gets the content for an artifact version in the registry using its globally unique
        identifier.
        
        This operation may fail for one of the following reasons:
        
        * No artifact version with this `globalId` exists (HTTP error `404`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContentByGlobalIDRequest, base_url, '/ids/globalIds/{globalId}', request)
        
        query_params = utils.get_query_params(operations.GetContentByGlobalIDRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContentByGlobalIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.file_content = http_res.content
        elif http_res.status_code in [404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_content_by_hash(self, request: operations.GetContentByHashRequest) -> operations.GetContentByHashResponse:
        r"""Get artifact content by SHA-256 hash
        Gets the content for an artifact version in the registry using the 
        SHA-256 hash of the content.  This content hash may be shared by multiple artifact
        versions in the case where the artifact versions have identical content.
        
        This operation may fail for one of the following reasons:
        
        * No content with this `contentHash` exists (HTTP error `404`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContentByHashRequest, base_url, '/ids/contentHashes/{contentHash}/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContentByHashResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.file_content = http_res.content
        elif http_res.status_code in [404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_content_by_id(self, request: operations.GetContentByIDRequest) -> operations.GetContentByIDResponse:
        r"""Get artifact content by ID
        Gets the content for an artifact version in the registry using the unique content
        identifier for that content.  This content ID may be shared by multiple artifact
        versions in the case where the artifact versions are identical.
        
        This operation may fail for one of the following reasons:
        
        * No content with this `contentId` exists (HTTP error `404`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetContentByIDRequest, base_url, '/ids/contentIds/{contentId}/', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetContentByIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.file_content = http_res.content
        elif http_res.status_code in [404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def get_latest_artifact(self, request: operations.GetLatestArtifactRequest) -> operations.GetLatestArtifactResponse:
        r"""Get latest artifact
        Returns the latest version of the artifact in its raw form.  The `Content-Type` of the
        response depends on the artifact type.  In most cases, this is `application/json`, but 
        for some types it may be different (for example, `PROTOBUF`).
        
        This operation may fail for one of the following reasons:
        
        * No artifact with this `artifactId` exists (HTTP error `404`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.GetLatestArtifactRequest, base_url, '/groups/{groupId}/artifacts/{artifactId}', request)
        
        query_params = utils.get_query_params(operations.GetLatestArtifactRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetLatestArtifactResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, '*/*'):
                res.file_content = http_res.content
        elif http_res.status_code in [404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def list_artifacts_in_group(self, request: operations.ListArtifactsInGroupRequest) -> operations.ListArtifactsInGroupResponse:
        r"""List artifacts in group
        Returns a list of all artifacts in the group.  This list is paged.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ListArtifactsInGroupRequest, base_url, '/groups/{groupId}/artifacts', request)
        
        query_params = utils.get_query_params(operations.ListArtifactsInGroupRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ListArtifactsInGroupResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactSearchResults])
                res.artifact_search_results = out
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def references_by_content_hash(self, request: operations.ReferencesByContentHashRequest) -> operations.ReferencesByContentHashResponse:
        r"""List artifact references by hash
        Returns a list containing all the artifact references using the artifact content hash.
        
        This operation may fail for one of the following reasons:
        
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReferencesByContentHashRequest, base_url, '/ids/contentHashes/{contentHash}/references', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReferencesByContentHashResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ArtifactReference]])
                res.artifact_references = out

        return res

    def references_by_content_id(self, request: operations.ReferencesByContentIDRequest) -> operations.ReferencesByContentIDResponse:
        r"""List artifact references by content ID
        Returns a list containing all the artifact references using the artifact content ID.
        
        This operation may fail for one of the following reasons:
        
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReferencesByContentIDRequest, base_url, '/ids/contentIds/{contentId}/references', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReferencesByContentIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ArtifactReference]])
                res.artifact_references = out

        return res

    def references_by_global_id(self, request: operations.ReferencesByGlobalIDRequest) -> operations.ReferencesByGlobalIDResponse:
        r"""List artifact references by global ID
        Returns a list containing all the artifact references using the artifact global ID.
        
        This operation may fail for one of the following reasons:
        
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.ReferencesByGlobalIDRequest, base_url, '/ids/globalIds/{globalId}/references', request)
        
        
        client = self._client
        
        http_res = client.request('GET', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.ReferencesByGlobalIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[list[shared.ArtifactReference]])
                res.artifact_references = out

        return res

    def search_artifacts(self, request: operations.SearchArtifactsRequest) -> operations.SearchArtifactsResponse:
        r"""Search for artifacts
        Returns a paginated list of all artifacts that match the provided filter criteria.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/search/artifacts'
        
        query_params = utils.get_query_params(operations.SearchArtifactsRequest, request)
        
        client = self._client
        
        http_res = client.request('GET', url, params=query_params)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchArtifactsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactSearchResults])
                res.artifact_search_results = out
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def search_artifacts_by_content(self, request: operations.SearchArtifactsByContentRequest) -> operations.SearchArtifactsByContentResponse:
        r"""Search for artifacts by content
        Returns a paginated list of all artifacts with at least one version that matches the
        posted content.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/search/artifacts'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        query_params = utils.get_query_params(operations.SearchArtifactsByContentRequest, request)
        
        client = self._client
        
        http_res = client.request('POST', url, params=query_params, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.SearchArtifactsByContentResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactSearchResults])
                res.artifact_search_results = out
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def update_artifact_state(self, request: operations.UpdateArtifactStateRequest) -> operations.UpdateArtifactStateResponse:
        r"""Update artifact state
        Updates the state of the artifact.  For example, you can use this to mark the latest
        version of an artifact as `DEPRECATED`.  The operation changes the state of the latest 
        version of the artifact.  If multiple versions exist, only the most recent is changed.
        
        This operation can fail for the following reasons:
        
        * No artifact with this `artifactId` exists (HTTP error `404`)
        * A server error occurred (HTTP error `500`)
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateArtifactStateRequest, base_url, '/groups/{groupId}/artifacts/{artifactId}/state', request)
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "update_state", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateArtifactStateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 204:
            pass
        elif http_res.status_code in [400, 404, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def update_artifact_json(self, request: operations.UpdateArtifactJSONRequest) -> operations.UpdateArtifactJSONResponse:
        r"""Update artifact
        Updates an artifact by uploading new content.  The body of the request can
        be the raw content of the artifact or a JSON object containing both the raw content and
        a set of references to other artifacts..  This is typically in JSON format for *most*
        of the supported types, but may be in another format for a few (for example, `PROTOBUF`).
        The type of the content should be compatible with the artifact's type (it would be
        an error to update an `AVRO` artifact with new `OPENAPI` content, for example).
        
        The update could fail for a number of reasons including:
        
        * Provided content (request body) was empty (HTTP error `400`)
        * No artifact with the `artifactId` exists (HTTP error `404`)
        * The new content violates one of the rules configured for the artifact (HTTP error `409`)
        * A server error occurred (HTTP error `500`)
        
        When successful, this creates a new version of the artifact, making it the most recent
        (and therefore official) version of the artifact.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateArtifactJSONRequest, base_url, '/groups/{groupId}/artifacts/{artifactId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "content_create_request", 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateArtifactJSONResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactMetaData])
                res.artifact_meta_data = out
        elif http_res.status_code in [404, 409, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    def update_artifact_raw(self, request: operations.UpdateArtifactRawRequest) -> operations.UpdateArtifactRawResponse:
        r"""Update artifact
        Updates an artifact by uploading new content.  The body of the request can
        be the raw content of the artifact or a JSON object containing both the raw content and
        a set of references to other artifacts..  This is typically in JSON format for *most*
        of the supported types, but may be in another format for a few (for example, `PROTOBUF`).
        The type of the content should be compatible with the artifact's type (it would be
        an error to update an `AVRO` artifact with new `OPENAPI` content, for example).
        
        The update could fail for a number of reasons including:
        
        * Provided content (request body) was empty (HTTP error `400`)
        * No artifact with the `artifactId` exists (HTTP error `404`)
        * The new content violates one of the rules configured for the artifact (HTTP error `409`)
        * A server error occurred (HTTP error `500`)
        
        When successful, this creates a new version of the artifact, making it the most recent
        (and therefore official) version of the artifact.
        """
        base_url = self._server_url
        
        url = utils.generate_url(operations.UpdateArtifactRawRequest, base_url, '/groups/{groupId}/artifacts/{artifactId}', request)
        
        headers = utils.get_headers(request)
        req_content_type, data, form = utils.serialize_request_body(request, "request_body", 'raw')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.UpdateArtifactRawResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ArtifactMetaData])
                res.artifact_meta_data = out
        elif http_res.status_code in [404, 409, 500]:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.Error])
                res.error = out

        return res

    