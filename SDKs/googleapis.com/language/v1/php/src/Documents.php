<?php

/**
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

declare(strict_types=1);

namespace OpenAPI\OpenAPI;

class Documents 
{

	// SDK private variables namespaced with _ to avoid conflicts with API models
	private \GuzzleHttp\ClientInterface $_defaultClient;
	private \GuzzleHttp\ClientInterface $_securityClient;
	private string $_serverUrl;
	private string $_language;
	private string $_sdkVersion;
	private string $_genVersion;	

	/**
	 * @param \GuzzleHttp\ClientInterface $defaultClient
	 * @param \GuzzleHttp\ClientInterface $securityClient
	 * @param string $serverUrl
	 * @param string $language
	 * @param string $sdkVersion
	 * @param string $genVersion
	 */
	public function __construct(\GuzzleHttp\ClientInterface $defaultClient, \GuzzleHttp\ClientInterface $securityClient, string $serverUrl, string $language, string $sdkVersion, string $genVersion)
	{
		$this->_defaultClient = $defaultClient;
		$this->_securityClient = $securityClient;
		$this->_serverUrl = $serverUrl;
		$this->_language = $language;
		$this->_sdkVersion = $sdkVersion;
		$this->_genVersion = $genVersion;
	}
	
    /**
     * Finds named entities (currently proper names and common nouns) in the text along with entity types, salience, mentions for each entity, and other properties.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesResponse
     */
	public function languageDocumentsAnalyzeEntities(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/documents:analyzeEntities');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "analyzeEntitiesRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitiesResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->analyzeEntitiesResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AnalyzeEntitiesResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Finds entities, similar to AnalyzeEntities in the text and analyzes sentiment associated with each entity and its mentions.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentResponse
     */
	public function languageDocumentsAnalyzeEntitySentiment(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/documents:analyzeEntitySentiment');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "analyzeEntitySentimentRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeEntitySentimentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->analyzeEntitySentimentResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AnalyzeEntitySentimentResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Analyzes the sentiment of the provided text.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentResponse
     */
	public function languageDocumentsAnalyzeSentiment(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/documents:analyzeSentiment');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "analyzeSentimentRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSentimentResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->analyzeSentimentResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AnalyzeSentimentResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Analyzes the syntax of the text and provides sentence boundaries and tokenization along with part of speech tags, dependency trees, and other properties.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxResponse
     */
	public function languageDocumentsAnalyzeSyntax(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/documents:analyzeSyntax');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "analyzeSyntaxRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnalyzeSyntaxResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->analyzeSyntaxResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AnalyzeSyntaxResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * A convenience method that provides all the features that analyzeSentiment, analyzeEntities, and analyzeSyntax provide in one call.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextResponse
     */
	public function languageDocumentsAnnotateText(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/documents:annotateText');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "annotateTextRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsAnnotateTextResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->annotateTextResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\AnnotateTextResponse', 'json');
            }
        }

        return $response;
    }
	
    /**
     * Classifies a document into categories.
     * 
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextRequest $request
     * @param \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextSecurity $security
     * @return \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextResponse
     */
	public function languageDocumentsClassifyText(
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextRequest $request,
        \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextSecurity $security,
    ): \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextResponse
    {
        $baseUrl = $this->_serverUrl;
        $url = Utils\Utils::generateUrl($baseUrl, '/v1/documents:classifyText');
        
        $options = ['http_errors' => false];
        $body = Utils\Utils::serializeRequestBody($request, "classifyTextRequest", "json");
        $options = array_merge_recursive($options, $body);
        $options = array_merge_recursive($options, Utils\Utils::getQueryParams(\OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextRequest::class, $request, null));
        
        $client = Utils\Utils::configureSecurityClient($this->_defaultClient, $security);
        $httpResponse = $client->request('POST', $url, $options);
        
        $contentType = $httpResponse->getHeader('Content-Type')[0] ?? '';

        $response = new \OpenAPI\OpenAPI\Models\Operations\LanguageDocumentsClassifyTextResponse();
        $response->statusCode = $httpResponse->getStatusCode();
        $response->contentType = $contentType;
        $response->rawResponse = $httpResponse;
        
        if ($httpResponse->getStatusCode() === 200) {
            if (Utils\Utils::matchContentType($contentType, 'application/json')) {
                $serializer = Utils\JSON::createSerializer();
                $response->classifyTextResponse = $serializer->deserialize((string)$httpResponse->getBody(), 'OpenAPI\OpenAPI\Models\Shared\ClassifyTextResponse', 'json');
            }
        }

        return $response;
    }
}